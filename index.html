<html lang="zh-CN">
	<head>
		<meta charset="UTF-8" />
		<!-- 响应式设计视口设置，禁止用户缩放 -->
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />

		<!-- PWA相关设置 -->
		<!-- 苹果设备主屏幕图标设置 -->
		<link rel="apple-touch-icon" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg" />
		<link rel="apple-touch-icon" sizes="152x152" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg" />
		<link rel="apple-touch-icon" sizes="180x180" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg" />
		<link rel="apple-touch-icon" sizes="167x167" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg" />

		<!-- PWA manifest文件链接 -->
		<link rel="manifest" href="manifest.json" />

		<!-- PWA全屏显示设置 -->
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<!-- 主屏幕应用标题 -->
		<meta name="apple-mobile-web-app-title" content="EPhone（兔k机版）" />

		<!-- 安卓浏览器兼容设置 -->
		<meta name="mobile-web-app-capable" content="yes" />

		<!-- 标准favicon图标 -->
		<link rel="icon" type="image/png" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg" />

		<title>EPhone（兔k机版）</title>

		<!-- 样式表和脚本引用 -->
		<link rel="stylesheet" href="style.css" />
		<script src="https://unpkg.com/dexie/dist/dexie.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
		<script src="https://phoebeboo.github.io/mewoooo/pp.js" defer></script>
		<script src="weibo.js" defer></script>
		<script src="game-hall.js" defer></script>
		<script src="forum.js" defer></script>
		<script src="lovers-space.js" defer></script>
		<script src="taobao.js" defer></script>
		<script src="https://cdn.jsdelivr.net/npm/darkreader@4.9.84/darkreader.min.js"></script>

		<!-- 自定义主题样式占位符 -->
		<style></style>
		<style id="custom-theme-style"></style>
	</head>
	<body>
		<div id="phone-screen">
			<!-- 顶部状态栏：显示时间和电池信息 -->
			<div id="status-bar">
				<span id="status-bar-time">12:00</span>
				<div id="status-bar-battery" class="battery-container">
					<span class="battery-text">--%</span>
					<div class="battery-icon">
						<div class="battery-level"></div>
					</div>
				</div>
			</div>

			<!-- 通知栏：显示消息通知 -->
			<div id="notification-bar">
				<img id="notification-avatar" src="" />
				<div id="notification-content">
					<div class="name"></div>
					<div class="message"></div>
				</div>
			</div>

			<!-- 悬浮歌词栏：显示当前播放音乐的歌词 -->
			<div id="floating-lyrics-bar">
				<span id="floating-lyric-text">♪</span>
				<div id="lyrics-settings-btn" style="cursor: pointer; display: flex; align-items: center; justify-content: center">
					<!-- 设置按钮图标 -->
					<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<circle cx="12" cy="12" r="3"></circle>
						<path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
					</svg>
				</div>
				<span class="close-btn">×</span>
			</div>

			<!-- 锁屏背景模糊层：用于锁屏时的背景效果 -->
			<div id="lock-screen-background-blur" style="display: none"></div>

			<!-- 主屏幕：包含滑动页面和应用图标 -->
			<div id="home-screen" class="screen active">
				<!-- 滑动容器：支持左右滑动切换页面 -->
				<div class="home-screen-slider">
					<!-- 第一页：主屏幕页面 -->
					<div class="home-page">
						<div id="main-content-area">
							<!-- 个人资料小组件 -->
							<div id="profile-widget">
								<img id="profile-banner-img" src="https://i.postimg.cc/k495F4W5/profile-banner.jpg" class="editable-image" />
								<!-- 头像容器：包含头像和头像框 -->
								<div class="profile-avatar-container">
									<img id="profile-avatar-img" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image" />
									<img id="profile-avatar-frame" class="weibo-avatar-frame" src="" style="display: none" />
								</div>
								<!-- 个人信息 -->
								<div class="profile-info">
									<p id="profile-username" class="editable-text">你的昵称</p>
									<p id="profile-sub-username" class="editable-text">@your_id</p>
									<p id="profile-bio" class="editable-text">点击这里编辑你的个性签名</p>
									<p id="profile-location" class="editable-text" data-placeholder="点击编辑地点">
										<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></svg><span>点击编辑地点</span>
									</p>
								</div>
							</div>
							<!-- 桌面布局 -->
							<div id="desktop-layout">
								<!-- 桌面小组件列 -->
								<div id="desktop-widget-column">
									<div class="custom-widget-container">
										<div id="widget-bubble-1" class="widget-bubble editable-text" contenteditable="true">点击编辑文字</div>
										<div class="widget-circle-uploader">
											<img id="widget-image-1" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image" title="点击更换图片" />
										</div>
										<div id="widget-subtext-1" class="widget-subtext editable-text" contenteditable="true">点击编辑文字</div>
									</div>
									<div class="custom-widget-container">
										<div id="widget-bubble-2" class="widget-bubble editable-text" contenteditable="true">点击编辑文字</div>
										<div class="widget-circle-uploader">
											<img id="widget-image-2" src="https://i.postimg.cc/k495F4W5/profile-banner.jpg" class="editable-image" title="点击更换图片" />
										</div>
										<div id="widget-subtext-2" class="widget-subtext editable-text" contenteditable="true">点击编辑文字</div>
									</div>
								</div>
								<!-- 应用图标容器 -->
								<div id="desktop-app-container">
									<div class="desktop-app-icon" onclick="showScreen('chat-list-screen')">
										<div class="icon-bg-desktop"><img id="icon-img-qq" src="https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg" alt="QQ" /></div>
										<span class="label">QQ</span>
									</div>
									<div class="desktop-app-icon" onclick="showScreen('world-book-screen')">
										<div class="icon-bg-desktop"><img id="icon-img-world-book" src="https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg" alt="世界书" /></div>
										<span class="label">世界书</span>
									</div>
									<div id="check-phone-btn" class="desktop-app-icon">
										<div class="icon-bg-desktop"><img id="icon-img-check-phone" src="https://i.postimg.cc/RVwpwr0r/IMG-8348.jpg" alt="查手机" /></div>
										<span class="label">查手机</span>
									</div>
									<div class="desktop-app-icon" id="weibo-app-icon">
										<div class="icon-bg-desktop"><img id="icon-img-weibo" src="https://i.postimg.cc/PqBY5wBq/weibo-icon.png" alt="微博" /></div>
										<span class="label">微博</span>
									</div>
								</div>
							</div>
						</div>
					</div>

					<!-- 第二页：自定义布局页面 -->
					<div class="home-page">
						<!-- 左侧小组件区域 -->
						<div id="second-page-left-widget" class="custom-widget-container">
							<div class="widget-circle-uploader">
								<img id="widget-image-3" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image" title="点击更换图片" />
							</div>
							<div id="second-page-bubble" class="widget-bubble editable-text" contenteditable="true">点击编辑文字</div>
							<!-- 新增的可编辑气泡容器 -->
							<div id="new-bubbles-container">
								<div id="flat-capsule-bubble" class="widget-bubble editable-text" contenteditable="true">可编辑</div>
								<div id="circular-bubble" class="widget-bubble editable-text" contenteditable="true">文字</div>
							</div>
						</div>
						<!-- 右上角应用图标区域 -->
						<div id="second-page-top-right-apps">
							<div class="desktop-app-icon" onclick="showScreen('forum-screen')">
								<div class="icon-bg-desktop"><img id="icon-img-forum" src="https://i.postimg.cc/pr0T3WfC/douban-icon.png" alt="圈子" /></div>
								<span class="label">圈子</span>
							</div>
							<div class="desktop-app-icon" id="lovers-space-app-icon">
								<div class="icon-bg-desktop"><img id="icon-img-lovers-space" src="https://i.postimg.cc/d1wZ39xW/lovers-space-icon.png" alt="情侣空间" /></div>
								<span class="label">情侣空间</span>
							</div>
							<div id="second-page-x-social-app" class="desktop-app-icon" onclick="showScreen('x-social-screen')">
								<div class="icon-bg-desktop"><img id="icon-img-x-social" src="https://i.postimg.cc/8P1H0vQ8/x-logo.png" alt="X社交" /></div>
								<span class="label">X社交</span>
							</div>
							<!-- 中心头像区域 -->
							<div id="center-avatar-wrapper">
								<div id="second-page-center-avatar" class="custom-widget-container">
									<div class="widget-circle-uploader">
										<img id="widget-image-4" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image" title="点击更换图片" />
									</div>
								</div>
								<div id="avatar-subtitle" class="editable-text">点击编辑文字</div>
								<!-- 四个角落的可编辑气泡 -->
								<div class="corner-bubble editable-text" id="bubble-top-left">左上角</div>
								<div class="corner-bubble editable-text" id="bubble-top-right">右上角</div>
								<div class="corner-bubble editable-text" id="bubble-bottom-left">左下角</div>
								<div class="corner-bubble editable-text" id="bubble-bottom-right">右下角</div>
							</div>
							<!-- 游戏大厅应用图标 -->
							<div style="position: absolute; top: 100px; right: 85px">
								<div class="desktop-app-icon" onclick="showScreen('game-hall-screen')">
									<div class="icon-bg-desktop">
										<img id="icon-img-game-hall" src="https://i.postimg.cc/P5gL5z2g/game-controller-icon.png" alt="游戏大厅" />
									</div>
									<span class="label">游戏大厅</span>
								</div>
							</div>
						</div>
						<!-- 新的自定义小组件 -->
						<div id="new-custom-widget">
							<div id="new-widget-header">
								<div id="widget-month-display"></div>
								<img id="new-widget-avatar" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image" />
							</div>
							<div id="new-widget-text-1" class="new-widget-text editable-text" contenteditable="true">可编辑文字</div>
							<div class="new-widget-divider"></div>
							<div id="new-widget-text-2" class="new-widget-text editable-text" contenteditable="true">可编辑文字</div>
							<div class="new-widget-divider"></div>
							<div id="new-widget-text-3" class="new-widget-text editable-text" contenteditable="true">可编辑文字</div>
						</div>
						<!-- 桃宝应用图标 -->
						<div style="position: absolute; bottom: 75px; left: 35px">
							<div class="desktop-app-icon" id="taobao-app-icon">
								<div class="icon-bg-desktop"><img id="icon-img-taobao" src="https://i.postimg.cc/k47tXg1j/taologo.png" alt="桃宝" /></div>
								<span class="label" style="color: white; text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5)">桃宝</span>
							</div>
						</div>
						<!-- 约会大作战应用图标 -->
						<div style="position: absolute; bottom: 75px; left: 120px">
							<div class="desktop-app-icon" id="date-a-live-app-icon">
								<div class="icon-bg-desktop"><img id="icon-img-date-a-live" src="https://i.postimg.cc/W36mYgP5/DAL-icon.jpg" alt="约会大作战" /></div>
								<span class="label" style="color: white; text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5)">约会大作战</span>
							</div>
						</div>
					</div>
				</div>

				<!-- 底部Dock栏：固定应用图标 -->
				<div id="desktop-dock">
					<div class="desktop-app-icon" onclick="showScreen('api-settings-screen')">
						<div class="icon-bg-desktop"><img id="icon-img-api-settings" src="https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg" alt="API设置" /></div>
						<span class="label">API设置</span>
					</div>
					<div class="desktop-app-icon" onclick="showScreen('font-settings-screen')">
						<div class="icon-bg-desktop"><img id="icon-img-font" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" alt="字体" /></div>
						<span class="label">字体</span>
					</div>
					<div class="desktop-app-icon" onclick="showScreen('wallpaper-screen')">
						<div class="icon-bg-desktop"><img id="icon-img-wallpaper" src="https://i.postimg.cc/T1j03pQr/IMG-6440.jpg" alt="外观设置" /></div>
						<span class="label">外观设置</span>
					</div>
				</div>

				<!-- 页面指示器：显示当前页面位置 -->
				<div class="pagination-dots">
					<span class="dot active"></span>
					<span class="dot"></span>
				</div>
			</div>

			<!-- 微博功能主界面 -->
			<div id="weibo-screen" class="screen">
				<!-- 微博页面容器，包含多个子页面 -->
				<div id="weibo-page-container">
					<!-- 页面1: 我的主页 -->
					<div id="weibo-my-profile-view" class="weibo-view active">
						<!-- 页面头部 -->
						<div class="header">
							<!-- 返回主页按钮 -->
							<span class="back-btn" onclick="showScreen('home-screen')">
								<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
									<path d="M15 18l-6-6 6-6" />
								</svg>
							</span>
							<span>我的主页</span>
							<!-- 头部操作按钮组 -->
							<div class="header-actions">
								<!-- 私信按钮 -->
								<span class="action-btn" id="weibo-my-dms-btn" title="我的私信">
									<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
										<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
										<polyline points="22,6 12,13 2,6"></polyline>
									</svg>
								</span>
								<!-- 编辑资料按钮 -->
								<span class="action-btn" id="edit-weibo-profile-btn" title="编辑资料">
									<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
										<path d="M12 20h9"></path>
										<path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
									</svg>
								</span>
								<!-- 发布微博按钮 -->
								<span class="action-btn" id="create-weibo-post-btn" style="font-size: 28px; font-weight: 300">+</span>
							</div>
						</div>
						<!-- 主页内容区域 -->
						<div id="weibo-profile-page">
							<div class="weibo-profile-header">
								<!-- 微博背景图片 -->
								<img id="weibo-background-img" src="https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg" class="weibo-background" />
								<!-- 用户头像容器 -->
								<div class="weibo-avatar-container">
									<img id="weibo-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" class="weibo-avatar" />
									<!-- 头像框（默认隐藏） -->
									<img id="weibo-avatar-frame" class="weibo-avatar-frame" src="" style="display: none" />
								</div>
								<!-- 用户昵称 -->
								<div class="weibo-nickname" id="weibo-nickname">你的昵称</div>
								<!-- 用户职业显示 -->
								<div id="weibo-user-profession-display">点击设置职业</div>
								<!-- 用户统计数据 -->
								<div class="weibo-stats">
									<div id="weibo-following-btn" class="weibo-stat-item">
										<span id="weibo-following-count" class="weibo-stat-number">0</span>
										<span class="weibo-stat-label">关注</span>
									</div>
									<div id="weibo-posts-item" class="weibo-stat-item">
										<span id="weibo-posts-count" class="weibo-stat-number">0</span>
										<span class="weibo-stat-label">微博</span>
									</div>
									<div id="weibo-fans-item" class="weibo-stat-item">
										<span id="weibo-fans-count" class="weibo-stat-number">0</span>
										<span class="weibo-stat-label">粉丝</span>
									</div>
								</div>
							</div>
							<!-- 用户微博列表 -->
							<div id="my-weibo-feed-list" style="padding: 15px; display: flex; flex-direction: column; gap: 15px">
								<!-- 微博内容将由JS动态生成 -->
							</div>
						</div>
					</div>

					<!-- 页面2: 关注的人 -->
					<div id="weibo-following-view" class="weibo-view">
						<div class="header">
							<span class="back-btn" onclick="showScreen('home-screen')">
								<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
									<path d="M15 18l-6-6 6-6" />
								</svg>
							</span>
							<span>关注的人</span>
							<!-- 清空关注列表按钮 -->
							<span class="action-btn" id="clear-following-feed-btn" style="font-size: 16px; font-weight: 500">清空</span>
						</div>
						<!-- 关注用户的微博列表 -->
						<div id="weibo-following-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 15px">
							<!-- 关注内容将由JS动态生成 -->
						</div>
					</div>

					<!-- 页面3: 热搜 -->
					<div id="weibo-hot-search-view" class="weibo-view">
						<div class="header">
							<span class="back-btn" onclick="showScreen('home-screen')">
								<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
									<path d="M15 18l-6-6 6-6" />
								</svg>
							</span>
							<span>热搜</span>
							<div class="header-actions">
								<!-- 生成热搜按钮 -->
								<span class="action-btn" id="generate-hot-search-btn" title="生成热搜">
									<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
										<circle cx="11" cy="11" r="8"></circle>
										<line x1="21" y1="21" x2="16.65" y2="16.65"></line>
									</svg>
								</span>
							</div>
						</div>
						<!-- 热搜列表 -->
						<div id="weibo-hot-search-list" style="flex-grow: 1; overflow-y: auto">
							<p style="text-align: center; color: #8a8a8a; margin-top: 50px">点击右上角放大镜生成热搜</p>
						</div>
					</div>

					<!-- 页面4: 广场 -->
					<div id="weibo-plaza-view" class="weibo-view">
						<div class="header">
							<span class="back-btn" onclick="showScreen('home-screen')">
								<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
									<path d="M15 18l-6-6 6-6" />
								</svg>
							</span>
							<span>广场</span>
							<div class="header-actions">
								<!-- 生成广场动态按钮 -->
								<span class="action-btn" id="generate-plaza-feed-btn" title="生成广场动态">
									<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
										<circle cx="11" cy="11" r="8"></circle>
										<line x1="21" y1="21" x2="16.65" y2="16.65"></line>
									</svg>
								</span>
							</div>
						</div>
						<!-- 广场动态列表 -->
						<div id="weibo-plaza-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 0">
							<p style="text-align: center; color: #8a8a8a; margin-top: 50px">点击右上角放大镜生成广场动态</p>
						</div>
					</div>

					<!-- 页面5: 热搜详情页 -->
					<div id="weibo-hottopic-feed-view" class="weibo-view">
						<div class="header">
							<!-- 返回按钮 -->
							<span class="back-btn" id="back-from-hottopic-btn">
								<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
									<path d="M15 18l-6-6 6-6" />
								</svg>
							</span>
							<!-- 热搜话题标题 -->
							<span id="weibo-hottopic-title">热搜话题</span>
							<div class="header-actions">
								<!-- 刷新热搜内容按钮 -->
								<span class="action-btn" id="refresh-hottopic-feed-btn" title="换一批">
									<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
										<polyline points="23 4 23 10 17 10"></polyline>
										<path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
									</svg>
								</span>
							</div>
						</div>
						<!-- 热搜话题内容列表 -->
						<div id="weibo-hottopic-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 0">
							<!-- 热搜内容将由JS动态生成 -->
						</div>
					</div>
				</div>

				<!-- 微博底部导航栏 -->
				<div id="weibo-bottom-nav">
					<div class="weibo-nav-item" data-view="weibo-hot-search-view">热搜</div>
					<div class="weibo-nav-item" data-view="weibo-plaza-view">广场</div>
					<div class="weibo-nav-item" data-view="weibo-following-view">关注的人</div>
					<div class="weibo-nav-item active" data-view="weibo-my-profile-view">我的微博</div>
				</div>
			</div>

			<!-- 世界书功能主界面 -->
			<div id="world-book-screen" class="screen">
				<div class="header">
					<!-- 返回主页按钮 -->
					<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
					<span>世界书</span>
					<!-- 头部操作按钮组 -->
					<div class="header-actions">
						<!-- 导入世界书按钮 -->
						<span class="action-btn" id="import-world-book-btn" title="导入世界书">
							<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
								<polyline points="17 8 12 3 7 8"></polyline>
								<line x1="12" y1="3" x2="12" y2="15"></line>
							</svg>
						</span>
						<!-- 管理分类按钮 -->
						<span class="action-btn" id="manage-world-book-categories-btn">管理分类</span>
						<!-- 添加世界书按钮 -->
						<span class="action-btn" id="add-world-book-btn">+</span>
					</div>
				</div>
				<!-- 世界书列表容器 -->
				<div id="world-book-list"></div>
			</div>

			<!-- 世界书编辑界面 -->
			<div id="world-book-editor-screen" class="screen">
				<div class="header">
					<!-- 返回按钮 -->
					<span class="back-btn" onclick="showScreen('world-book-screen')">‹</span>
					<!-- 页面标题 -->
					<span id="world-book-editor-title">编辑世界书</span>
					<!-- 保存按钮 -->
					<span class="save-btn" id="save-world-book-btn">保存</span>
				</div>
				<div class="form-container">
					<!-- 世界书名称输入 -->
					<div class="form-group">
						<label for="world-book-name-input">书名</label>
						<input type="text" id="world-book-name-input" placeholder="请输入世界书的名称..." />
					</div>
					<!-- 世界书分类选择 -->
					<div class="form-group">
						<label for="world-book-category-select">分类</label>
						<select id="world-book-category-select">
							<!-- 分类选项将由JS动态生成 -->
						</select>
					</div>
					<!-- 世界书内容编辑 -->
					<div class="form-group" style="height: 100%">
						<label for="world-book-content-input">内容</label>
						<textarea id="world-book-content-input" placeholder="在此处输入详细的世界观设定..."></textarea>
					</div>
				</div>
			</div>

			<!-- API设置界面 -->
			<div id="api-settings-screen" class="screen">
				<div class="header">
					<!-- 返回按钮 -->
					<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
					<span>API 设置</span>
					<!-- 占位符用于标题居中 -->
					<span style="width: 30px"></span>
				</div>
				<div class="form-container">
					<!-- 使用提示 -->
					<p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px">提示: 若要使用"发送图片"功能, 请务必选择支持Vision(视觉)的模型, 如<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px">gpt-4o</code>或 <code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px">gpt-4-vision-preview</code>。</p>

					<!-- API配置表单 -->
					<div class="form-group">
						<label for="proxy-url">反代地址 (不需要添加/v1噢~)</label>
						<input type="text" id="proxy-url" placeholder="例如: https://api.openai.com" />
					</div>
					<div class="form-group">
						<label for="api-key">密钥 (直连轮询用英文逗号隔开)</label>
						<input type="password" id="api-key" placeholder="sk-..." />
					</div>
					<div class="form-group">
						<label for="model-select">模型</label>
						<select id="model-select"></select>
					</div>

					<!-- API预设管理 -->
					<div class="form-group">
						<label>API 预设</label>
						<div class="bubble-preset-manager">
							<select id="api-preset-select" class="form-group select"></select>
							<button id="manage-api-presets-btn" class="action-btn">管理</button>
						</div>
					</div>

					<!-- 模型温度设置 -->
					<div class="form-group">
						<label for="temperature-slider">模型温度 (Temperature): <span id="temperature-value">0.8</span></label>
						<p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px; margin-bottom: 10px">数值越高，回复越随机、有创造性，但可能偏离人设。数值越低，回复越稳定、可预测。推荐值: 0.7 - 1.2</p>
						<input type="range" id="temperature-slider" min="0" max="2" step="0.1" value="0.8" style="width: 100%" />
					</div>

					<!-- 拉取模型按钮 -->
					<button class="form-button" id="fetch-models-btn">拉取模型</button>

					<!-- 后台角色活动设置分隔线 -->
					<hr style="margin: 20px 0; opacity: 0.3" />

					<!-- 后台活动总开关 -->
					<div class="form-group" style="display: flex; justify-content: space-between; align-items: center">
						<label for="background-activity-switch" style="margin-bottom: 0">
							启用后台角色活动 (总开关)
							<p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px">警告：开启后会显著增加API调用和费用！</p>
						</label>
						<label class="toggle-switch">
							<input type="checkbox" id="background-activity-switch" />
							<span class="slider"></span>
						</label>
					</div>

					<!-- 后台活动详细设置 (默认隐藏) -->
					<div id="background-activity-details" style="display: none">
						<!-- 活动检测间隔设置 -->
						<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px">
							<label for="background-interval-input" style="margin-bottom: 0">
								后台活动检测间隔 (秒)
								<p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px">建议值 60-300。值越大，费用越低，但角色反应越慢。</p>
							</label>
							<input type="number" id="background-interval-input" min="30" value="60" style="width: 80px; text-align: center" />
						</div>

						<!-- 角色选择与频率设置 -->
						<div class="form-group">
							<label>设置角色活动频率</label>
							<div id="background-activity-char-list" style="max-height: 150px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color)">
								<!-- 角色列表将由JS动态生成 -->
							</div>
							<div style="display: flex; gap: 10px; margin-top: 10px">
								<button id="bg-select-all-chars" class="form-button-secondary" style="flex: 1; margin: 0">全选</button>
								<button id="bg-deselect-all-chars" class="form-button-secondary" style="flex: 1; margin: 0">全不选</button>
							</div>
						</div>

						<!-- 角色活动频率设置 -->
						<div class="form-group">
							<label>为选中角色设置频率</label>
							<div style="display: flex; gap: 10px">
								<button class="form-button-secondary bg-freq-btn" data-freq="low" style="flex: 1; margin: 0; border-color: #28a745">低</button>
								<button class="form-button-secondary bg-freq-btn" data-freq="medium" style="flex: 1; margin: 0; border-color: #fd7e14">中</button>
								<button class="form-button-secondary bg-freq-btn" data-freq="high" style="flex: 1; margin: 0; border-color: #dc3545">高</button>
								<button class="form-button-secondary bg-freq-btn" data-freq="none" style="flex: 1; margin: 0; border-color: #aaa">关闭</button>
							</div>
							<p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 8px">频率越高，角色主动行为的概率越大，费用也越高。</p>
						</div>
					</div>

					<!-- AI被拉黑后冷静期设置 -->
					<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px">
						<label for="block-cooldown-input" style="margin-bottom: 0">
							AI被拉黑后冷静期 (小时)
							<p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px">被拉黑超过这个时间后，AI才有几率重新申请好友。</p>
						</label>
						<input type="number" id="block-cooldown-input" min="0.1" step="0.1" value="1" style="width: 80px; text-align: center" />
					</div>

					<!-- Minimax语音设置分隔线 -->
					<hr style="margin: 20px 0; opacity: 0.3" />

					<!-- Minimax语音功能提示 -->
					<p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px">以下是 Minimax 语音（TTS）的设置，用于AI发送语音消息。</p>

					<!-- Minimax Group ID设置 -->
					<div class="form-group">
						<label for="minimax-group-id">Minimax Group ID</label>
						<input type="text" id="minimax-group-id" placeholder="输入你的 Minimax Group ID" />
					</div>

					<!-- Minimax API Key设置 -->
					<div class="form-group">
						<label for="minimax-api-key">Minimax API Key</label>
						<input type="password" id="minimax-api-key" placeholder="输入你的 Minimax API Key" />
					</div>

					<!-- Minimax语音模型设置 -->
					<div class="form-group">
						<label for="minimax-speech-model-select">Minimax 语音模型 (TTS Model)</label>
						<select id="minimax-speech-model-select">
							<!-- 模型选项将由JS填充 -->
						</select>
					</div>

					<!-- 拉取语音模型按钮 -->
					<button class="form-button" id="fetch-minimax-speech-models-btn">拉取语音模型</button>

					<!-- NovelAI 图像生成系统配置 -->
					<hr style="margin: 20px 0; opacity: 0.3" />
					<div class="form-group" style="display: flex; justify-content: space-between; align-items: center">
						<label for="novelai-switch" style="margin-bottom: 0">
							启用 NovelAI 图像生成
							<!-- 功能说明和错误提示 -->
							<p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px">开启后可使用NovelAI官方API生成高质量动漫风格图像（必开🔮）</p>
							<p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px">1. 三击下载图片，下面可测试模型或关键词画师串</p>
							<p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px">2. 429是novel的访问频繁错误，等待几秒重新即可</p>
							<p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px">3. 403是多人共号限制，限制oplus免费出小图但可扣点数</p>
							<p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px">4. 403也会因为没开🔮报错，实在不行可更换出图尺寸</p>
							<p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px">5. 401是key没权限，检查key是否正确</p>
							<p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px">6. 生成失败:Failed to fetch是跨域限制，下方设置里换代理</p>
						</label>
						<!-- NovelAI功能开关 -->
						<label class="toggle-switch">
							<input type="checkbox" id="novelai-switch" />
							<span class="slider"></span>
						</label>
					</div>

					<!-- NovelAI详细配置区域 -->
					<div id="novelai-details" style="display: none">
						<div class="form-group">
							<label for="novelai-model" style="color: #333">NovelAI 模型</label>
							<!-- 模型选择下拉框 -->
							<select id="novelai-model" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; border-radius: 4px">
								<option value="nai-diffusion-4-curated-preview">NAI Diffusion V4.5 Curated (精选版无nsfw)</option>
								<option value="nai-diffusion-4-5-full">NAI Diffusion V4.5 Full（完整版含nsfw）</option>
								<option value="nai-diffusion-3">NAI Diffusion Anime V3（旧版）</option>
								<option value="nai-diffusion-furry-3">NAI Diffusion Furry V3（旧旧版）</option>
							</select>
							<p style="font-size: 12px; color: #666; margin-top: 5px">💡 必须有oplus订阅的apikey才可以使用！</p>
						</div>

						<div class="form-group">
							<label for="novelai-api-key" style="color: #333">NovelAI API Key</label>
							<!-- API密钥输入框 -->
							<div style="position: relative">
								<input type="password" id="novelai-api-key" placeholder="pst-xxxxxxxxxxxxxxxx" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding-right: 40px" />
								<span id="novelai-key-toggle" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; user-select: none; font-size: 18px">🧐</span>
							</div>
							<p style="font-size: 12px; color: #666; margin-top: 5px">💡 在 <a href="https://novelai.net" target="_blank" style="color: #007bff">NovelAI官网</a> 获取API Key</p>
						</div>

						<!-- 设置和测试按钮 -->
						<div style="display: flex; gap: 10px; margin-top: 15px">
							<button type="button" id="novelai-settings-btn" style="flex: 1; background-color: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer">生成设置</button>
							<button type="button" id="novelai-test-btn" style="flex: 1; background-color: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer">测试生成</button>
						</div>
					</div>

					<!-- 图片压缩质量设置 -->
					<hr style="margin: 20px 0; opacity: 0.3" />
					<div class="form-group">
						<label for="image-quality-slider">发送图片压缩质量 (0.1=高压缩, 1.0=不压缩): <span id="image-quality-value">0.7</span></label>
						<!-- 压缩质量说明 -->
						<p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px; margin-bottom: 10px">数值越低，图片压缩率越高，体积越小，但画质越差。此功能对所有上传的图片生效（如聊天发图、换头像、壁纸等）。推荐值: 0.5 - 0.8。</p>
						<!-- 压缩质量调节滑块 -->
						<input type="range" id="image-quality-slider" min="0.1" max="1.0" step="0.1" value="0.7" style="width: 100%" />
					</div>

					<!-- 图片压缩功能按钮 -->
					<button class="form-button form-button-secondary" id="compress-all-images-btn" style="margin-top: 10px; background-color: #ffc107; border-color: #ffaf00; color: #333">一键压缩全部现有图片</button>
					<!-- 图片数据大小显示 -->
					<p id="image-data-size-display" style="text-align: center; color: var(--text-secondary); margin-top: 5px">正在计算图片数据大小...</p>

					<!-- 保存设置按钮 -->
					<button class="form-button" id="save-api-settings-btn">保存设置</button>

					<!-- 数据管理功能区域 -->
					<hr style="margin: 20px 0; opacity: 0.3" />
					<button class="form-button form-button-secondary" id="clear-orphaned-data-btn" style="margin-top: 10px; border-color: #ff9966; color: #ff9966">🧹 清理失效数据</button>
					<button class="form-button" id="export-data-btn">导出数据</button>
					<!-- 流式导出按钮（适用于大数据） -->
					<button class="form-button form-button-secondary" id="export-data-stream-btn" style="margin-top: 10px">流式导出 (大数据专用)</button>
					<button class="form-button" id="import-btn">导入备份文件</button>
					<!-- 高级导入/导出功能按钮 -->
					<button class="form-button" id="advanced-transfer-btn" style="background-color: #6f42c1; margin-top: 10px">高级导入/导出</button>
					<!-- 隐藏的文件选择器 -->
					<input id="import-data-input" type="file" accept="application/json" hidden />
				</div>
			</div>

			<!-- 消息列表界面 -->
			<div id="chat-list-screen" class="screen">
				<!-- 主头部 -->
				<div class="header" id="main-chat-list-header">
					<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
					<span id="chat-list-title">消息</span>
					<!-- 头部操作按钮 -->
					<div class="header-actions">
						<!-- 创建群聊按钮 -->
						<span class="action-btn" id="add-group-chat-btn" title="创建群聊">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
								<path d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
								<path d="M21 21L19 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
								<path d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
								<path d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
							</svg>
						</span>
						<!-- 导入角色卡按钮 -->
						<span class="action-btn" id="import-character-card-btn" title="导入角色卡">
							<svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
								<polyline points="17 8 12 3 7 8"></polyline>
								<line x1="12" y1="3" x2="12" y2="15"></line>
							</svg>
						</span>
						<!-- 添加聊天按钮 -->
						<span class="action-btn" id="add-chat-btn">+</span>
					</div>
				</div>

				<!-- 消息列表视图 -->
				<div id="messages-view" class="chat-list-view active">
					<div id="chat-list">
						<!-- JS会在这里生成聊天列表 -->
					</div>
				</div>

				<!-- 动态界面视图 -->
				<div id="qzone-screen" class="chat-list-view">
					<div class="qzone-header">
						<span class="back-btn" id="qzone-back-btn">‹</span>
						<span>好友动态</span>
						<!-- 清空动态按钮 -->
						<div class="header-actions">
							<span class="action-btn" id="clear-qzone-posts-btn" title="清空动态">
								<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
								</svg>
							</span>
						</div>
					</div>
					<div class="qzone-content">
						<div class="qzone-profile-header">
							<!-- 背景图容器 -->
							<div id="qzone-banner-container" class="qzone-banner-container">
								<img id="qzone-banner-img" src="https://files.catbox.moe/r5heyt.gif" alt="背景" />
								<input type="file" id="qzone-banner-input" accept="image/*" hidden />
							</div>
							<!-- 用户信息 -->
							<div class="qzone-user-info">
								<div id="qzone-avatar-container" class="qzone-avatar-container">
									<img id="qzone-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" alt="头像" />
									<input type="file" id="qzone-avatar-input" accept="image/*" hidden />
								</div>
								<span id="qzone-nickname">{{user}}</span>
							</div>
						</div>
						<!-- 动作栏 -->
						<div class="qzone-actions-bar">
							<div class="action-item" id="create-shuoshuo-btn"><span>说说</span></div>
							<div class="action-item" id="create-post-btn"><span>动态</span></div>
							<div class="action-item" id="open-album-btn"><span>相册</span></div>
						</div>
						<div id="qzone-posts-list"></div>
					</div>
				</div>

				<!-- 收藏界面视图 -->
				<div id="favorites-view" class="chat-list-view">
					<div class="header">
						<span class="back-btn" id="favorites-back-btn">‹</span>
						<span>我的收藏</span>
						<!-- 编辑按钮 -->
						<span class="action-btn" id="favorites-edit-btn">编辑</span>
					</div>

					<!-- 搜索栏 -->
					<div class="search-bar-container">
						<input type="search" id="favorites-search-input" placeholder="搜索收藏的标题、内容或作者..." />
						<button id="favorites-search-clear-btn" class="search-clear-btn" style="display: none">×</button>
					</div>

					<div id="favorites-list" class="list-container">
						<!-- 收藏内容将由JS动态生成在这里 -->
					</div>

					<!-- 收藏页底部操作栏 -->
					<div id="favorites-action-bar" style="display: none">
						<button id="favorites-delete-selected-btn" class="action-bar-btn">删除 (0)</button>
					</div>
				</div>

				<!-- 回忆录界面视图 -->
				<div id="memories-view" class="chat-list-view">
					<div class="header">
						<span class="back-btn" id="memories-back-btn">‹</span>
						<span>我们的回忆</span>
						<!-- 添加倒计时按钮 -->
						<span class="action-btn" id="add-countdown-btn">+</span>
					</div>
					<div id="memories-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px">
						<!-- 回忆卡片将由JS动态生成在这里 -->
					</div>
				</div>

				<!-- 底部导航栏 -->
				<div id="chat-list-bottom-nav">
					<div class="nav-item active" data-view="messages-view">
						<span>消息</span>
					</div>
					<div class="nav-item" data-view="qzone-screen">
						<span>动态</span>
					</div>
					<div class="nav-item" data-view="memories-view">
						<span>回忆</span>
					</div>
					<div class="nav-item" data-view="favorites-view">
						<span>收藏</span>
					</div>
				</div>
			</div>

			<!-- 相册界面 -->
			<div id="album-screen" class="screen">
				<!-- 页面头部 -->
				<div class="header">
					<span class="back-btn" id="album-back-btn">‹</span>
					<span>我的相册</span>
					<!-- 创建相册按钮 -->
					<span class="action-btn" id="create-album-btn-page">+</span>
				</div>

				<!-- 相册内容区域 -->
				<div class="list-container">
					<div id="album-grid-page">
						<!-- 相册列表将由 JS 动态生成在这里 -->
					</div>
				</div>
			</div>

			<!-- 相册照片界面 -->
			<div id="album-photos-screen" class="screen">
				<!-- 页面头部 -->
				<div class="header">
					<span class="back-btn" id="album-photos-back-btn">‹</span>
					<span id="album-photos-title">相册名称</span>
					<!-- 上传照片按钮 -->
					<span class="action-btn" id="album-upload-photo-btn">上传</span>
				</div>

				<!-- 照片内容区域 -->
				<div class="list-container">
					<div id="photos-grid-page">
						<!-- 照片列表将由 JS 动态生成在这里 -->
					</div>

					<!-- 照片查看器模态框 -->
					<div id="photo-viewer-modal" class="modal">
						<!-- 关闭按钮 -->
						<button id="photo-viewer-close-btn">×</button>
						<!-- 上一张照片按钮 -->
						<button id="photo-viewer-prev-btn" class="nav-arrow">‹</button>
						<!-- 图片容器 -->
						<div class="photo-viewer-content">
							<img id="photo-viewer-image" src="" alt="全屏照片预览" />
						</div>
						<!-- 下一张照片按钮 -->
						<button id="photo-viewer-next-btn" class="nav-arrow">›</button>
					</div>
				</div>
			</div>

			<!-- 隐藏的照片上传输入框 -->
			<input type="file" id="album-photo-input" accept="image/*" multiple hidden />

			<!-- 聊天界面 -->
			<div id="chat-interface-screen" class="screen">
				<div class="header">
					<!-- 默认控件：包含标题、状态栏和常规按钮 -->
					<div class="default-controls">
						<span class="back-btn" id="back-to-list-btn">‹</span>

						<!-- 标题和状态的容器 -->
						<div id="chat-header-title-wrapper">
							<div id="chat-header-main-line">
								<span id="chat-header-title">聊天对象</span>
								<!-- 群公告按钮 -->
								<span id="group-announcement-btn" title="群公告">
									<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
										<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
										<line x1="7" y1="15" x2="17" y2="15"></line>
									</svg>
								</span>
							</div>
							<div id="chat-header-status">
								<span class="status-dot"></span>
								<span class="status-text">在线</span>
							</div>
						</div>

						<div class="header-actions">
							<!-- 心声按钮 -->
							<span class="action-btn" id="char-heart-btn" title="心声" style="display: none; cursor: pointer">
								<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#ff4d6d" stroke="#ffc3d0" stroke-width="1.5">
									<path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" />
								</svg>
							</span>
							<!-- 一起听按钮 -->
							<span class="action-btn" id="listen-together-btn" title="一起听"><img src="https://chatbotcos.weixin.qq.com/chatbot/30-openaiassets_63e04c67410237fa43bf6fcce542dbff_469401762321466866.png" alt="一起听" /></span>
							<!-- 聊天设置按钮 -->
							<span class="action-btn" id="chat-settings-btn" title="聊天设置"><img src="https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png" alt="设置" /></span>
						</div>
					</div>

					<!-- 多选模式控件 -->
					<div class="selection-controls">
						<span id="selection-cancel-btn">取消</span>
						<span id="selection-count"></span>
						<div class="header-actions">
							<span id="selection-favorite-btn" class="action-btn">收藏</span>
							<span id="selection-share-btn" class="action-btn">分享</span>
							<span id="selection-delete-btn" class="action-btn" style="color: #ff3b30">删除</span>
						</div>
					</div>
				</div>

				<!-- 聊天宠物容器 -->
				<div id="chat-pet-container" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: none; z-index: 10">
					<div id="chat-pet" style="display: none; position: absolute; cursor: grab; user-select: none; pointer-events: all; font-size: 80px; line-height: 1; text-align: center">
						<!-- 宠物会显示在这里 -->
					</div>
				</div>

				<!-- 聊天消息区域 -->
				<div id="chat-messages"><div id="typing-indicator">对方正在输入...</div></div>

				<!-- 输入区域 -->
				<div id="chat-input-area">
					<!-- 回复预览栏 -->
					<div id="reply-preview-bar">
						<div class="reply-preview-content">
							<div class="sender">回复 xxx:</div>
							<div class="text">被引用的消息内容...</div>
						</div>
						<span id="cancel-reply-btn">×</span>
					</div>

					<!-- 顶部聊天操作按钮 -->
					<div id="chat-input-actions-top">
						<!-- 表情面板按钮 -->
						<button id="open-sticker-panel-btn" class="chat-action-icon-btn action-button" title="表情面板">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
								<line x1="12" y1="5" x2="12" y2="19"></line>
								<line x1="5" y1="12" x2="19" y2="12"></line>
							</svg>
						</button>

						<!-- 重新生成回复按钮 -->
						<button id="reroll-btn" class="action-button" title="重新生成回复">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<polyline points="23 4 23 10 17 10"></polyline>
								<path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
							</svg>
						</button>

						<!-- 发送照片按钮 -->
						<button id="send-photo-btn" class="chat-action-icon-btn action-button" title="发送照片">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" />
								<circle cx="12" cy="13" r="4" />
							</svg>
						</button>

						<!-- 上传图片按钮 -->
						<button id="upload-image-btn" class="chat-action-icon-btn action-button" title="上传图片">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
								<path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
								<path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
								<path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
							</svg>
						</button>

						<!-- 转账按钮 -->
						<button id="transfer-btn" class="chat-action-icon-btn action-button" title="转账">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M7 4L12 12L17 4M12 12V20M8 10H16M8 13H16"></path>
							</svg>
						</button>

						<!-- 发送语音按钮 -->
						<button id="voice-message-btn" class="chat-action-icon-btn action-button" title="发送语音">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" />
								<path d="M19 10v2a7 7 0 0 1-14 0v-2" />
								<path d="M12 19v4" />
								<path d="M8 23h8" />
							</svg>
						</button>

						<!-- 发起外卖请求按钮 -->
						<button id="send-waimai-request-btn" class="chat-action-icon-btn action-button" title="发起外卖请求">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z" />
								<line x1="3" y1="6" x2="21" y2="6" />
								<path d="M16 10a4 4 0 0 1-8 0" />
							</svg>
						</button>

						<!-- 视频通话按钮 -->
						<button id="video-call-btn" class="chat-action-icon-btn action-button" title="视频通话">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<polygon points="23 7 16 12 23 17 23 7"></polygon>
								<rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
							</svg>
						</button>

						<!-- 群视频通话按钮 -->
						<button id="group-video-call-btn" class="chat-action-icon-btn action-button" title="群视频通话">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
								<circle cx="9" cy="7" r="4"></circle>
								<path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
								<path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
							</svg>
						</button>

						<!-- 发起投票按钮 -->
						<button id="send-poll-btn" class="chat-action-icon-btn action-button" title="发起投票">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M8 6h10" />
								<path d="M6 6h.01" />
								<path d="M8 12h10" />
								<path d="M6 12h.01" />
								<path d="M8 18h10" />
								<path d="M6 18h.01" />
							</svg>
						</button>

						<!-- 分享链接按钮 -->
						<button id="share-link-btn" class="chat-action-icon-btn action-button" title="分享链接">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path>
								<path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path>
							</svg>
						</button>

						<!-- 发送定位按钮 -->
						<button id="send-location-btn" class="chat-action-icon-btn action-button" title="发送定位">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
								<circle cx="12" cy="10" r="3"></circle>
							</svg>
						</button>

						<!-- 塔罗占卜按钮 -->
						<button id="open-tarot-btn" class="chat-action-icon-btn action-button" title="塔罗占卜">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
								<!-- 背景左侧卡牌 -->
								<path d="M7 6.5L4 7.5V17.5L7 16.5V6.5Z" stroke="currentColor" stroke-width="2.6" stroke-linejoin="round" />
								<!-- 背景右侧卡牌 -->
								<path d="M17 6.5L20 7.5V17.5L17 16.5V6.5Z" stroke="currentColor" stroke-width="2.6" stroke-linejoin="round" />
								<!-- 前方中心卡牌 -->
								<rect x="7" y="5" width="10" height="15" rx="1.5" stroke="currentColor" stroke-width="2.6" />
								<!-- 中心卡牌的星星 -->
								<path d="M12 9.5L13.12 11.79L15.61 12.17L13.8 13.92L14.24 16.4L12 15.2L9.76 16.4L10.2 13.92L8.39 12.17L10.88 11.79L12 9.5Z" fill="currentColor" />
							</svg>
						</button>

						<!-- 宠物按钮 -->
						<button id="pet-action-btn" class="chat-action-icon-btn action-button" title="我的宠物">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
								<!-- 主体轮廓: 耳朵不对称，营造歪头效果 -->
								<path d="M3.5 14.5C3.5 20.5 20.5 20.5 20.5 14.5C20.5 9 17.5 5.5 12.5 8.7C6.5 4.5 3.5 9 3.5 14.5Z" stroke="currentColor" stroke-width="2.6" stroke-linecap="round" stroke-linejoin="round" />
								<!-- 眼睛 -->
								<circle cx="8.5" cy="15" r="1.5" fill="currentColor" />
								<circle cx="15.5" cy="15" r="1.5" fill="currentColor" />
								<!-- 左边两根小胡须 -->
								<path d="M4.5 14.3L2.5 13.3" stroke="currentColor" stroke-width="2.6" stroke-linecap="round" />
								<path d="M4.5 15.7L2.5 16.7" stroke="currentColor" stroke-width="2.6" stroke-linecap="round" />
								<!-- 右边两根小胡须 -->
								<path d="M19.5 14.3L21.5 13.3" stroke="currentColor" stroke-width="2.6" stroke-linecap="round" />
								<path d="M19.5 15.7L21.5 16.7" stroke="currentColor" stroke-width="2.6" stroke-linecap="round" />
							</svg>
						</button>
					</div>

					<!-- 主输入行 -->
					<div id="chat-input-main-row">
						<textarea id="chat-input" rows="1" placeholder="输入消息..."></textarea>
						<div id="input-actions-wrapper">
							<button id="wait-reply-btn" title="等待回复"><img src="https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png" alt="等待回复" /></button>
							<button id="send-btn" class="action-button">发送</button>
						</div>
					</div>
				</div>

				<!-- 聊天锁定覆盖层 -->
				<div id="chat-lock-overlay">
					<div id="chat-lock-content"></div>
				</div>

				<!-- 表情包面板 -->
				<div id="sticker-panel">
					<div id="sticker-panel-header">
						<span class="panel-btn" id="close-sticker-panel-btn">取消</span>
						<span class="title">表情包</span>
						<!-- 表情包管理按钮 -->
						<div style="display: flex; gap: 10px">
							<span class="panel-btn" id="edit-user-stickers-btn">编辑</span>
							<span class="panel-btn" id="done-user-stickers-btn" style="display: none">完成</span>
							<span class="panel-btn" id="add-sticker-btn">添加</span>
							<span class="panel-btn" id="upload-sticker-btn">上传</span>
						</div>
					</div>
					<div id="sticker-grid"></div>
					<!-- 表情包分类标签 -->
					<div id="sticker-category-tabs">
						<!-- 分类胶囊将由JS动态生成在这里 -->
					</div>
					<!-- 表情包底部操作栏 -->
					<div id="sticker-panel-footer" style="display: none">
						<button id="move-selected-stickers-btn">移动到分类...</button>
						<button id="delete-selected-user-stickers-btn">删除已选 (0)</button>
					</div>
				</div>

				<!-- 隐藏的表情包上传输入框 -->
				<input type="file" id="sticker-upload-input" accept="image/*" style="display: none" multiple />
				<input type="file" id="image-upload-input" accept="image/*" style="display: none" />

				<!-- 音乐播放器 -->
				<div id="music-player-overlay">
					<div class="music-player-window">
						<!-- 顶部头像区域 -->
						<div id="music-avatars-container">
							<img id="music-char-avatar" src="" alt="角色头像" />
							<svg id="heartbeat-line" viewBox="0 0 80 30">
								<path class="heartbeat-path" d="M 5 15 Q 20 0 30 15 T 55 15 L 75 15"></path>
								<path class="heartbeat-heart" d="M 0 -2 a 2 2 0 0 1 4 0 v 2 a 2 2 0 0 1 -4 0 z"></path>
							</svg>
							<img id="music-user-avatar" src="" alt="用户头像" />
						</div>

						<!-- 一起听时长计数器 -->
						<div id="music-time-counter">已经一起听了0.0小时</div>

						<!-- 顶部操作按钮 -->
						<div class="music-player-top-actions">
							<div class="top-left-cluster">
								<button id="music-return-btn">‹</button>
								<button id="music-exit-btn">×</button>
							</div>
							<span id="music-playlist-btn">☰</span>
						</div>

						<!-- 封面和歌词显示区域 -->
						<div id="music-display-area">
							<img id="music-album-cover" src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png" alt="歌曲封面" />
							<div id="music-lyrics-container">
								<div id="music-lyrics-list">
									<div class="lyric-line">♪ 暂无歌词 ♪</div>
								</div>
							</div>
						</div>

						<!-- 歌曲信息 -->
						<div id="music-player-song-title">请添加歌曲</div>
						<div id="music-player-artist">...</div>

						<!-- 播放控制区 -->
						<div class="music-player-controls-wrapper">
							<div class="music-progress-bar-container">
								<div id="music-current-time" class="time-display">0:00</div>
								<div class="progress-bar">
									<div id="music-progress-fill" class="progress-bar-fill"></div>
								</div>
								<div id="music-total-time" class="time-display">0:00</div>
							</div>
							<div class="music-controls">
								<button id="music-prev-btn">◀</button>
								<button id="music-play-pause-btn" class="play-pause-btn">▶</button>
								<button id="music-next-btn">▶</button>
								<button id="music-mode-btn">顺序</button>
								<button id="toggle-lyrics-bar-btn" title="桌面歌词">悬浮</button>
							</div>
						</div>
					</div>
				</div>
			</div>

			<!-- 音乐播放列表面板 -->
			<div id="music-playlist-panel">
				<div class="playlist-header">
					<span class="panel-btn" id="close-playlist-btn">返回</span>
					<span>播放列表</span>
					<div>
						<!-- 清理失效歌曲按钮 -->
						<span class="panel-btn" id="delete-expired-songs-btn" title="清理失效的搜索歌曲">
							<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
								<path d="M3 6H5H21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
								<path d="M8 6V4C8 3.46957 8.21071 2.96086 8.58579 2.58579C8.96086 2.21071 9.46957 2 10 2H14C14.5304 2 15.0391 2.21071 15.4142 2.58579C15.7893 2.96086 16 3.46957 16 4V6M19 6V20C19 20.5304 18.7893 21.0391 18.4142 21.4142C18.0391 21.7893 17.5304 22 17 22H7C6.46957 22 5.96086 21.7893 5.58579 21.4142C5.21071 21.0391 5 20.5304 5 20V6H19Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
							</svg>
						</span>
						<!-- 添加歌曲按钮 -->
						<span class="panel-btn" id="add-song-local-btn">本地</span>
						<span class="panel-btn" id="add-song-url-btn">URL</span>
						<span class="panel-btn" id="add-song-search-btn">搜索</span>
					</div>
				</div>
				<!-- 播放列表内容 -->
				<div class="playlist-body" id="playlist-body"></div>
			</div>

			<!-- 隐藏的音频和歌词文件上传输入框 -->
			<input type="file" id="local-song-upload-input" accept="audio/*" multiple style="display: none" />
			<input type="file" id="lrc-upload-input" accept=".lrc" style="display: none" />
		</div>

		<!-- 外观设置界面 -->
		<div id="wallpaper-screen" class="screen">
			<div class="header">
				<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
				<span>外观设置</span>
				<span style="width: 30px"></span>
			</div>
			<div class="form-container">
				<!-- 锁屏设置区域 -->
				<div style="width: 100%; text-align: left; margin-bottom: 5px">
					<label style="font-weight: 500; color: var(--text-secondary)">锁屏设置</label>
				</div>
				<!-- 锁屏壁纸预览 -->
				<div id="lockscreen-wallpaper-preview" class="wallpaper-preview">点击下方上传</div>
				<!-- 上传锁屏壁纸按钮 -->
				<button class="form-button" onclick="document.getElementById('lockscreen-wallpaper-upload-input').click();">上传锁屏壁纸</button>
				<!-- 锁屏壁纸文件选择器 -->
				<input type="file" id="lockscreen-wallpaper-upload-input" accept="image/*" hidden />

				<!-- 锁屏密码设置 -->
				<div class="form-group" style="width: 100%; margin-top: 15px">
					<label for="password-set-input">锁屏密码 (留空则无密码)</label>
					<input type="text" id="password-set-input" placeholder="设置你的解锁密码" />
				</div>

				<hr style="width: 80%; opacity: 0.3; margin: 20px 0" />

				<!-- 主屏幕设置区域 -->
				<div style="width: 100%; text-align: left; margin-bottom: 5px">
					<label style="font-weight: 500; color: var(--text-secondary)">主屏幕设置</label>
				</div>
				<!-- 主屏幕壁纸预览 -->
				<div id="wallpaper-preview">点击下方上传</div>

				<!-- 锁屏界面开关 -->
				<div class="form-group">
					<label for="enable-lock-screen-toggle" class="toggle-switch-label">
						<span class="toggle-switch-text">启用锁屏界面</span>
						<input type="checkbox" id="enable-lock-screen-toggle" />
						<span class="toggle-switch-slider"></span>
					</label>
				</div>

				<!-- 状态栏显示开关 -->
				<div class="form-group">
					<label for="show-status-bar-toggle" class="toggle-switch-label">
						<span class="toggle-switch-text">显示状态栏</span>
						<input type="checkbox" id="show-status-bar-toggle" />
						<span class="toggle-switch-slider"></span>
					</label>
				</div>

				<!-- 夜间模式开关 -->
				<div class="form-group">
					<label for="dark-mode-toggle" class="toggle-switch-label">
						<span class="toggle-switch-text">夜间模式</span>
						<input type="checkbox" id="dark-mode-toggle" />
						<span class="toggle-switch-slider"></span>
					</label>
				</div>

				<!-- 上传壁纸按钮 -->
				<button class="form-button" onclick="document.getElementById('wallpaper-upload-input').click();">上传壁纸</button>
				<!-- 壁纸文件选择器 -->
				<input type="file" id="wallpaper-upload-input" accept="image/*" />

				<!-- 隐藏的夜间模式开关（旧版本兼容） -->
				<div class="form-group" style="display: none">
					<label for="theme-toggle-switch" style="margin-bottom: 0">夜间模式</label>
					<label class="toggle-switch">
						<input type="checkbox" id="theme-toggle-switch" />
						<span class="slider"></span>
					</label>
				</div>

				<!-- 手机美化(CSS)设置区域 -->
				<div style="width: 100%; text-align: left; margin-bottom: 15px">
					<label style="font-weight: 500; color: var(--text-secondary)">手机美化 (CSS)</label>
				</div>

				<!-- 主题选择和管理 -->
				<div class="form-group">
					<label for="theme-selector">选择已存方案</label>
					<div style="display: flex; gap: 10px">
						<select id="theme-selector" style="flex-grow: 1"></select>
						<button id="rename-theme-btn" class="form-button-secondary" style="margin: 0; padding: 0 10px">重命名</button>
						<button id="delete-theme-btn" class="form-button-secondary" style="margin: 0; padding: 0 10px; background-color: #ffdddd; color: #ff3b30">删除</button>
					</div>
				</div>

				<!-- CSS代码编辑区 -->
				<div class="form-group">
					<label for="theme-css-editor">美化代码编辑区</label>
					<textarea id="theme-css-editor" rows="10" style="font-family: monospace; font-size: 12px; resize: vertical" placeholder="在这里粘贴或编辑美化代码..."></textarea>
				</div>

				<!-- 主题操作按钮 -->
				<button id="apply-theme-btn" class="form-button">应用当前代码</button>
				<div style="display: flex; gap: 10px; margin-top: 10px">
					<button id="save-theme-btn" class="form-button-secondary" style="flex: 1">保存</button>
					<button id="save-as-new-theme-btn" class="form-button-secondary" style="flex: 1">另存</button>
				</div>
				<div style="display: flex; gap: 10px; margin-top: 10px">
					<button id="export-theme-btn" class="form-button-secondary" style="flex: 1">导出方案</button>
					<button id="import-theme-btn" class="form-button-secondary" style="flex: 1">导入方案</button>
					<input type="file" id="import-theme-input" accept=".json" hidden />
				</div>

				<!-- 主屏幕预设功能UI -->
				<div class="preset-manager-container">
					<div style="width: 100%; text-align: left; margin-bottom: 15px">
						<label style="font-weight: 500; color: var(--text-secondary)">主屏幕预设</label>
					</div>
					<div class="form-group">
						<select id="home-preset-selector" class="form-group select"></select>
						<div class="preset-manager-controls">
							<!-- 应用预设按钮 -->
							<button id="apply-home-preset-btn" class="preset-btn-capsule preset-btn-apply" disabled>应用</button>

							<!-- 预设管理按钮 -->
							<button id="save-home-preset-btn" class="preset-btn-capsule preset-btn-save">保存</button>
							<button id="update-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>更新</button>
							<button id="rename-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>重命名</button>
							<button id="import-home-preset-btn" class="preset-btn-capsule preset-btn-secondary">导入</button>
							<button id="export-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>导出</button>
							<button id="delete-home-preset-btn" class="preset-btn-capsule preset-btn-delete" disabled>删除</button>

							<input type="file" id="import-home-preset-input" accept=".json" hidden />
						</div>
					</div>
				</div>

				<!-- 主屏幕图标及小组件字体颜色设置 -->
				<hr style="width: 80%; opacity: 0.3; margin: 30px 0" />
				<div style="width: 100%; text-align: left; margin-bottom: 15px">
					<label style="font-weight: 500; color: var(--text-secondary)">主屏幕图标及小组件字体颜色</label>
				</div>
				<div class="form-group">
					<label for="home-icon-widget-text-color-picker">自定义字体颜色</label>
					<input type="color" id="home-icon-widget-text-color-picker" value="#FFFFFF" style="width: 100%; height: 40px; padding: 0; border-radius: 8px" />
				</div>

				<!-- 去除主屏幕字体阴影开关 -->
				<div class="form-group">
					<label for="remove-home-font-shadow-toggle" class="toggle-switch-label">
						<span class="toggle-switch-text">去除主屏幕字体阴影</span>
						<input type="checkbox" id="remove-home-font-shadow-toggle" />
						<span class="toggle-switch-slider"></span>
					</label>
				</div>

				<!-- App图标设置区域 -->
				<hr style="width: 80%; opacity: 0.3; margin: 30px 0" />
				<div style="width: 100%; text-align: left; margin-bottom: 15px">
					<label style="font-weight: 500; color: var(--text-secondary)">App 图标设置</label>
				</div>
				<div id="icon-settings-grid">
					<!-- 图标设置项将由JS动态生成在这里 -->
				</div>

				<!-- 主屏幕App名称设置 -->
				<hr style="width: 80%; opacity: 0.3; margin: 30px 0" />
				<div style="width: 100%; text-align: left; margin-bottom: 15px">
					<label style="font-weight: 500; color: var(--text-secondary)">主屏幕 App 名称</label>
				</div>
				<div id="icon-rename-grid" style="width: 100%; display: grid; grid-template-columns: 1fr 1fr; gap: 15px 20px">
					<!-- App 名称输入框将由JS动态生成在这里 -->
				</div>
				<button class="form-button form-button-secondary" id="reset-app-names-btn" style="margin-top: 15px">恢复默认App名字</button>

				<!-- 铃声设置 -->
				<hr style="width: 80%; opacity: 0.3; margin: 30px 0" />
				<div style="width: 100%; text-align: left; margin-bottom: 15px">
					<label style="font-weight: 500; color: var(--text-secondary)">铃声设置</label>
				</div>
				<div class="form-group" style="width: 100%">
					<label for="ringtone-url-input">来电铃声 URL (.mp3, .wav, etc.)</label>
					<input type="text" id="ringtone-url-input" placeholder="输入音频文件的网络链接..." />
				</div>
				<div class="form-group" style="width: 100%; margin-top: 15px">
					<label for="notification-sound-url-input">消息提示音 URL (.mp3, .wav, etc.)</label>
					<input type="text" id="notification-sound-url-input" placeholder="输入音频文件的网络链接..." />
				</div>

				<!-- 全局聊天背景设置 -->
				<hr style="width: 80%; opacity: 0.3; margin: 30px 0" />
				<div style="width: 100%; text-align: left; margin-bottom: 15px">
					<label style="font-weight: 500; color: var(--text-secondary)">全局聊天背景</label>
				</div>
				<div id="global-bg-preview" class="wallpaper-preview">点击下方上传</div>
				<button class="form-button" onclick="document.getElementById('global-bg-upload-input').click();">上传全局背景</button>
				<input type="file" id="global-bg-upload-input" accept="image/*" hidden />
				<button class="form-button form-button-secondary" id="remove-global-bg-btn" style="margin-top: 10px">移除全局背景</button>
				<button class="form-button form-button-secondary" id="clear-all-single-bgs-btn" style="margin-top: 10px; border-color: #ff3b30; color: #ff3b30">一键清空所有单人聊天背景</button>

				<!-- 保存外观设置按钮 -->
				<button class="form-button" id="save-wallpaper-btn" style="margin-top: 30px">保存所有外观设置</button>
			</div>
		</div>

		<!-- 浏览器/分享链接功能界面 -->
		<div id="browser-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="browser-back-btn">‹</span>
				<span id="browser-title"></span>
				<span style="width: 30px"></span>
			</div>
			<div id="browser-content" class="list-container">
				<!-- 文章内容将由JS动态生成在这里 -->
			</div>
		</div>

		<!-- 字体设置界面 -->
		<div id="font-settings-screen" class="screen">
			<div class="header">
				<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
				<span>字体预设</span>
				<span style="width: 30px"></span>
			</div>
			<div class="form-container" style="gap: 20px">
				<p style="font-size: 13px; color: #ff6b6b; background-color: rgba(255, 107, 107, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(255, 107, 107, 0.2); text-align: center; width: 100%; box-sizing: border-box">字体太大了导入本地字体会闪退！最好用url。</p>
				<!-- 字体预设容器 -->
				<div id="font-preset-container">
					<!-- 5个卡槽将由JavaScript动态生成在这里 -->
				</div>

				<!-- 全局字体预览区 -->
				<div class="form-group" style="width: 100%">
					<label>当前全局字体预览</label>
					<div id="font-preview">
						<p style="font-size: 20px; margin: 0 0 10px 0">你好世界 Hello World</p>
						<p style="margin: 0">这是全局字体预览效果，12345。</p>
					</div>
				</div>

				<button class="form-button form-button-secondary" id="reset-font-btn">恢复默认字体</button>
			</div>
		</div>

		<!-- 字体文件选择器 -->
		<input type="file" id="font-preset-local-upload" accept=".ttf,.otf,.woff,.woff2" style="display: none" />

		<!-- 查角色手机功能界面 -->

		<!-- 角色选择屏幕 -->
		<div id="character-selection-screen" class="screen">
			<div class="header">
				<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
				<span>选择要查看的手机</span>
				<span style="width: 30px"></span>
			</div>
			<div id="character-selection-list" class="list-container"></div>
		</div>

		<!-- 角色手机容器 -->
		<div id="character-phone-container" class="screen">
			<div class="character-phone-frame">
				<div class="character-phone-notch"></div>
				<div class="character-phone-inner-screen">
					<!-- 角色手机主界面 -->
					<div id="character-phone-screen" class="character-phone-page active">
						<div class="header character-phone-header">
							<span class="back-btn" data-target-screen="character-selection-screen">
								<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
							</span>
							<span id="character-phone-owner-name"></span>
							<div class="header-actions">
								<span class="action-btn" id="clear-character-data-btn" title="清空全部数据">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" /></svg>
								</span>
								<span class="action-btn" id="generate-character-data-btn" title="刷新全部数据">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
										<path d="M23 4v6h-6M1 20v-6h6" />
										<path d="M3.51 9a9 9 0 0114.85-3.36L20.5 10M3.5 14a9 9 0 0114.85 3.36L20.5 14" />
									</svg>
								</span>
							</div>
						</div>
						<!-- 桌面小组件 -->
						<div id="char-phone-widget-1" class="char-phone-widget">
							<img id="char-phone-widget-img-1" src="" />
						</div>
						<div id="char-phone-widget-2" class="char-phone-widget">
							<img id="char-phone-widget-img-2" src="" />
						</div>
						<div id="character-app-grid" class="app-grid-standard" style="padding-top: 60px"></div>
					</div>

					<!-- 角色手机聊天列表界面 -->
					<div id="character-chat-list-screen" class="character-phone-page">
						<div class="header character-phone-header">
							<span class="back-btn" data-target-page="character-phone-screen">
								<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
							</span>
							<span>消息</span>
							<div class="header-actions">
								<span class="action-btn" id="clear-npc-chats-btn" title="清空所有NPC聊天">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" /></svg>
								</span>
								<span class="action-btn" id="generate-chat-message-btn" title="生成新聊天">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z" /></svg>
								</span>
							</div>
						</div>
						<div id="character-chat-list" class="list-container" style="padding: 0"></div>
					</div>

					<!-- 角色手机具体聊天记录界面 -->
					<div id="character-chat-history-screen" class="character-phone-page">
						<div class="header character-phone-header">
							<span class="back-btn" data-target-page="character-chat-list-screen">
								<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
							</span>
							<span id="character-chat-with-name"></span>
						</div>
						<div id="character-chat-history-messages" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px; background-color: #e5ddd5"></div>
					</div>

					<!-- 角色手机购物车界面 -->
					<div id="character-shopping-cart-screen" class="character-phone-page">
						<div class="header character-phone-header">
							<span class="back-btn" data-target-page="character-phone-screen">
								<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
							</span>
							<span>购物车</span>
							<div class="header-actions">
								<span class="action-btn" id="clear-cart-items-btn" title="清空购物车">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" /></svg>
								</span>
								<span class="action-btn" id="generate-cart-item-btn" title="添加新商品">
									<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
										<line x1="12" y1="5" x2="12" y2="19"></line>
										<line x1="5" y1="12" x2="19" y2="12"></line>
									</svg>
								</span>
							</div>
						</div>
						<div id="character-shopping-cart-list" class="list-container"></div>
					</div>

					<!-- 角色手机备忘录界面 -->
					<div id="character-memos-screen" class="character-phone-page">
						<div class="header character-phone-header">
							<span class="back-btn" data-target-page="character-phone-screen">
								<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
							</span>
							<span>备忘录</span>
							<div class="header-actions">
								<span class="action-btn" id="clear-memos-btn" title="清空备忘录">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" /></svg>
								</span>
								<span class="action-btn" id="generate-memo-btn" title="写新备忘录">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z" /></svg>
								</span>
							</div>
						</div>
						<div id="character-memos-list" class="list-container"></div>
					</div>

					<!-- 角色手机浏览器界面 -->
					<div id="character-browser-screen" class="character-phone-page">
						<div class="header character-phone-header">
							<span class="back-btn" data-target-page="character-phone-screen">
								<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
							</span>
							<span>浏览器</span>
							<div class="header-actions">
								<span class="action-btn" id="clear-browser-history-btn" title="清空历史记录">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" /></svg>
								</span>
								<span class="action-btn" id="generate-browser-history-btn" title="生成新历史">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
										<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path>
										<path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path>
									</svg>
								</span>
							</div>
						</div>
						<div id="character-browser-list" class="list-container"></div>
					</div>

					<!-- 角色手机浏览器详情界面 -->
					<div id="character-browser-detail-screen" class="character-phone-page">
						<div class="header character-phone-header">
							<span class="back-btn" data-target-page="character-browser-screen">
								<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
							</span>
							<span id="character-browser-detail-title">搜索结果</span>
						</div>
						<div id="character-browser-detail-content" class="list-container" style="padding: 15px; line-height: 1.7"></div>
					</div>

					<!-- 角色手机相册界面 -->
					<div id="character-album-screen" class="character-phone-page">
						<div class="header character-phone-header">
							<span class="back-btn" data-target-page="character-phone-screen">
								<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
							</span>
							<span>相册</span>
							<div class="header-actions">
								<span class="action-btn" id="clear-album-photos-btn" title="清空相册">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" /></svg>
								</span>
								<span class="action-btn" id="generate-album-photo-btn" title="生成新照片">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
										<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
										<circle cx="8.5" cy="8.5" r="1.5"></circle>
										<polyline points="21 15 16 10 5 21"></polyline>
									</svg>
								</span>
							</div>
						</div>
						<div id="character-album-grid" class="list-container"></div>
					</div>

					<!-- 角色手机银行界面 -->
					<div id="character-bank-screen" class="character-phone-page">
						<div class="header character-phone-header">
							<span class="back-btn" data-target-page="character-phone-screen">
								<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
							</span>
							<span>钱包</span>
							<div class="header-actions">
								<span class="action-btn" id="clear-bank-transactions-btn" title="清空交易记录">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" /></svg>
								</span>
								<span class="action-btn" id="generate-bank-transaction-btn" title="生成新交易">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
										<line x1="12" y1="1" x2="12" y2="23"></line>
										<path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
									</svg>
								</span>
							</div>
						</div>
						<div id="character-bank-details" class="list-container"></div>
					</div>

					<!-- 角色手机行动轨迹界面 -->
					<div id="character-trajectory-screen" class="character-phone-page">
						<div class="header character-phone-header">
							<span class="back-btn" data-target-page="character-phone-screen">
								<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
							</span>
							<span>足迹</span>
							<div class="header-actions">
								<span class="action-btn" id="clear-trajectory-btn" title="清空足迹">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" /></svg>
								</span>
								<span class="action-btn" id="generate-trajectory-btn" title="生成新足迹">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
										<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
										<circle cx="12" cy="10" r="3"></circle>
									</svg>
								</span>
							</div>
						</div>
						<div id="character-trajectory-list" class="list-container"></div>
					</div>

					<!-- 角色手机APP使用记录界面 -->
					<div id="character-app-usage-screen" class="character-phone-page">
						<div class="header character-phone-header">
							<span class="back-btn" data-target-page="character-phone-screen">
								<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
							</span>
							<span>屏幕使用时间</span>
							<div class="header-actions">
								<span class="action-btn" id="clear-app-usage-btn" title="清空记录">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" /></svg>
								</span>
								<span class="action-btn" id="generate-app-usage-btn" title="生成新记录">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8v4l3 3m6-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0z"></path></svg>
								</span>
							</div>
						</div>
						<div id="character-app-usage-list" class="list-container"></div>
					</div>

					<!-- 角色手机日记界面 -->
					<div id="character-diary-screen" class="character-phone-page">
						<div class="header character-phone-header">
							<span class="back-btn" data-target-page="character-phone-screen">
								<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
							</span>
							<span>日记</span>
							<div class="header-actions">
								<span class="action-btn" id="clear-diary-entries-btn" title="清空日记">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" /></svg>
								</span>
								<span class="action-btn" id="generate-diary-entry-btn" title="写新日记">
									<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z" /></svg>
								</span>
							</div>
						</div>
						<div id="character-diary-list" class="list-container"></div>
					</div>

					<!-- 角色手机外观设置界面 -->
					<div id="character-phone-appearance-screen" class="character-phone-page">
						<div class="header character-phone-header">
							<span class="back-btn" data-target-page="character-phone-screen">
								<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
							</span>
							<span>外观设置</span>
							<span style="width: 30px"></span>
						</div>
						<!-- 外观设置表单容器 -->
						<div class="form-container" style="padding: 15px; gap: 25px">
							<!-- 手机壁纸设置区 -->
							<div>
								<label style="font-weight: 500; color: var(--text-secondary)">手机壁纸</label>
								<div id="char-phone-wallpaper-preview" class="wallpaper-preview" style="height: 240px; width: 135px; margin: 10px auto; border-radius: 12px">点击下方上传</div>
								<button id="upload-char-phone-wallpaper-btn" class="form-button">上传壁纸</button>
								<button id="remove-char-phone-wallpaper-btn" class="form-button form-button-secondary" style="margin-top: 10px">移除壁纸</button>
							</div>

							<!-- 分隔线 -->
							<hr style="width: 100%; opacity: 0.2" />

							<!-- App内壁纸设置区 -->
							<div>
								<label style="font-weight: 500; color: var(--text-secondary)">App 内壁纸</label>
								<div id="char-phone-app-wallpaper-preview" class="wallpaper-preview" style="height: 240px; width: 135px; margin: 10px auto; border-radius: 12px">点击下方上传</div>
								<button id="upload-char-phone-app-wallpaper-btn" class="form-button">上传 App 内壁纸</button>
								<button id="remove-char-phone-app-wallpaper-btn" class="form-button form-button-secondary" style="margin-top: 10px">移除 App 内壁纸</button>
							</div>

							<!-- 分隔线 -->
							<hr style="width: 100%; opacity: 0.2" />

							<!-- App图标设置区 -->
							<div>
								<label style="font-weight: 500; color: var(--text-secondary)">App 图标</label>
								<div id="char-phone-icon-settings-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-top: 15px; text-align: center">
									<!-- App图标设置将由JS动态生成在这里 -->
								</div>
							</div>

							<!-- 分隔线 -->
							<hr style="width: 100%; opacity: 0.2" />
							<!-- 桌面小组件设置区 -->
							<div>
								<label style="font-weight: 500; color: var(--text-secondary)">桌面小组件</label>
								<!-- 小组件1: 左上角 -->
								<div class="form-group" style="margin-top: 15px">
									<label>左上角小组件</label>
									<div class="avatar-upload">
										<img id="char-phone-widget-preview-1" class="wallpaper-preview" style="height: 100px; width: 100px; margin-bottom: 0" />
										<div style="display: flex; flex-direction: column; gap: 8px">
											<button class="form-button-secondary" id="upload-widget-1-btn" style="margin-top: 0">上传图片</button>
											<button class="form-button-secondary" id="remove-widget-1-btn" style="margin-top: 0; border-color: #ff3b30; color: #ff3b30">移除图片</button>
										</div>
									</div>
								</div>
								<!-- 小组件2: 右下角 -->
								<div class="form-group" style="margin-top: 15px">
									<label>右下角小组件</label>
									<div class="avatar-upload">
										<img id="char-phone-widget-preview-2" class="wallpaper-preview" style="height: 100px; width: 100px; margin-bottom: 0" />
										<div style="display: flex; flex-direction: column; gap: 8px">
											<button class="form-button-secondary" id="upload-widget-2-btn" style="margin-top: 0">上传图片</button>
											<button class="form-button-secondary" id="remove-widget-2-btn" style="margin-top: 0; border-color: #ff3b30; color: #ff3b30">移除图片</button>
										</div>
									</div>
								</div>
							</div>

							<!-- 分隔线 -->
							<hr style="width: 100%; opacity: 0.2; margin-top: 25px" />
							<!-- 外观预设管理区 -->
							<div class="preset-manager-container">
								<div style="width: 100%; text-align: left; margin-bottom: 15px">
									<label style="font-weight: 500; color: var(--text-secondary)">外观预设</label>
								</div>
								<div class="form-group">
									<!-- 预设选择器 -->
									<select id="char-phone-preset-selector" class="form-group select"></select>
									<div class="preset-manager-controls">
										<!-- 应用预设按钮 -->
										<button id="apply-char-phone-preset-btn" class="preset-btn-capsule preset-btn-apply" disabled>应用</button>

										<!-- 预设管理按钮组 -->
										<button id="save-char-phone-preset-btn" class="preset-btn-capsule preset-btn-save">保存</button>
										<button id="update-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>更新</button>
										<button id="rename-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>重命名</button>
										<button id="import-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary">导入</button>
										<button id="export-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>导出</button>
										<button id="delete-char-phone-preset-btn" class="preset-btn-capsule preset-btn-delete" disabled>删除</button>

										<!-- 导入预设文件选择器 -->
										<input type="file" id="import-char-phone-preset-input" accept=".json" hidden />
									</div>
								</div>
							</div>
						</div>
					</div>

					<!-- 隐藏的文件选择器，用于处理上传 -->
					<input type="file" id="char-phone-wallpaper-upload-input" accept="image/*" hidden />
					<input type="file" id="char-phone-icon-upload-input" accept="image/*" hidden />

					<!-- 小组件图片上传文件选择器 -->
					<input type="file" id="char-phone-widget-1-upload-input" accept="image/*" hidden />
					<input type="file" id="char-phone-widget-2-upload-input" accept="image/*" hidden />
					<input type="file" id="char-phone-app-wallpaper-upload-input" accept="image/*" hidden />
				</div>
			</div>
		</div>

		<!-- 加载动画遮罩层 -->
		<div id="generation-overlay" class="modal" style="background-color: rgba(0, 0, 0, 0.6); z-index: 2000">
			<div style="text-align: center; color: white">
				<div id="loading-spinner" style="width: 40px; height: 40px; border: 4px solid rgba(255, 255, 255, 0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px"></div>
				<p>正在同步Ta的手机数据...</p>
				<p style="font-size: 12px; opacity: 0.7">（这可能需要一些时间，并会消耗API额度）</p>
			</div>
		</div>

		<!-- 选择联系人以创建群聊的屏幕 -->
		<div id="contact-picker-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="cancel-contact-picker-btn">取消</span>
				<span>选择联系人</span>
				<span class="save-btn" id="confirm-contact-picker-btn">完成(0)</span>
			</div>
			<div class="list-container" id="contact-picker-list">
				<!-- 联系人列表将由JS动态生成 -->
			</div>
		</div>

		<!-- 群成员管理屏幕 -->
		<div id="member-management-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="back-from-member-management">‹</span>
				<span>群成员管理</span>
				<span style="width: 30px"></span>
			</div>
			<div class="list-container" id="member-management-list">
				<!-- 现有成员列表会在这里动态生成 -->
			</div>
			<div id="member-management-actions">
				<button id="add-existing-contact-btn">从好友列表添加</button>
				<button id="create-new-member-btn">创建群内新成员</button>
				<button id="ai-generate-members-btn">✨ AI 生成成员</button>
			</div>
		</div>

		<!-- 微博用户人设与职业设置模态框 -->
		<div id="weibo-user-settings-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 80%">
				<div class="modal-header">
					<span>我的微博设定</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label>预设方案</label>
						<div class="bubble-preset-manager">
							<!-- 复用现有样式 -->
							<select id="weibo-user-preset-select" class="form-group select"></select>
							<button id="manage-weibo-user-presets-btn" class="action-btn">管理</button>
						</div>
					</div>
					<div class="form-group">
						<label for="weibo-user-profession-modal-input">职业 (显示在昵称下方)</label>
						<input type="text" id="weibo-user-profession-modal-input" placeholder="例如：职业电竞选手、美妆博主" />
					</div>
					<div class="form-group">
						<label for="weibo-user-persona-modal-input">隐藏人设 (仅供AI生成评论时参考)</label>
						<textarea id="weibo-user-persona-modal-input" rows="4" placeholder="例如：性格高冷，少与粉丝互动，只回复赞助商的评论。"></textarea>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-weibo-user-settings-btn">取消</button>
					<button class="save" id="save-weibo-user-settings-btn">保存</button>
				</div>
			</div>
		</div>

		<!-- 微博手动操作的弹窗 -->
		<div id="weibo-action-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 80%">
				<div class="modal-header">
					<span id="weibo-action-modal-title">执行操作</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label for="weibo-action-actor-select">选择操作者 (Actor)</label>
						<select id="weibo-action-actor-select" class="form-group select"></select>
					</div>
					<div class="form-group">
						<label>选择操作类型</label>
						<!-- 操作类型选择 -->
						<div id="weibo-action-type-select" style="text-align: left">
							<label><input type="radio" name="weibo_action_type" value="post" checked /> 发布一条新微博</label>
							<label><input type="radio" name="weibo_action_type" value="comment_plaza" /> 评论广场最新微博</label>
							<label><input type="radio" name="weibo_action_type" value="comment_user" /> 评论用户最新微博</label>
						</div>
					</div>
					<div class="form-group">
						<label for="weibo-action-prompt-input">关于... (可选, 简要提示)</label>
						<textarea id="weibo-action-prompt-input" rows="2" placeholder="例如：今天比赛赢了很开心 or 回应最近的热搜"></textarea>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-weibo-action-btn">取消</button>
					<button class="save" id="confirm-weibo-action-btn">执行</button>
				</div>
			</div>
		</div>

		<!-- 表情包管理屏幕 -->
		<div id="char-sticker-manager-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="back-from-sticker-manager">‹</span>
				<span id="sticker-manager-title">表情包管理</span>
				<!-- 编辑/完成按钮 -->
				<div class="header-actions">
					<span class="action-btn" id="edit-char-stickers-btn">编辑</span>
					<span class="action-btn" id="done-char-stickers-btn" style="display: none">完成</span>
				</div>
			</div>
			<input type="file" id="char-sticker-upload-input" accept="image/*" style="display: none" multiple />
			<div class="modal-body" style="padding: 0; display: flex; flex-direction: column; flex-grow: 1">
				<!-- 页签切换 -->
				<div class="frame-tabs">
					<div id="sticker-tab-exclusive" class="frame-tab active">专属表情</div>
					<div id="sticker-tab-common" class="frame-tab">通用表情</div>
				</div>

				<!-- 专属表情内容区 -->
				<div id="sticker-content-exclusive" class="frame-content active">
					<div class="sticker-panel-header" style="justify-content: flex-end">
						<div style="display: flex; gap: 10px">
							<span class="panel-btn" id="add-exclusive-sticker-btn">批量添加</span>
							<span class="panel-btn" id="upload-exclusive-sticker-btn">本地上传</span>
						</div>
					</div>
					<div id="exclusive-sticker-grid" class="sticker-grid"></div>
				</div>

				<!-- 通用表情内容区 -->
				<div id="sticker-content-common" class="frame-content">
					<div class="sticker-panel-header" style="justify-content: flex-end">
						<div style="display: flex; gap: 10px">
							<span class="panel-btn" id="add-common-sticker-btn">批量添加</span>
							<span class="panel-btn" id="upload-common-sticker-btn">本地上传</span>
						</div>
					</div>
					<div id="common-sticker-grid" class="sticker-grid"></div>
				</div>
			</div>
			<!-- 批量删除操作栏 -->
			<div id="char-sticker-footer" style="display: none">
				<button id="delete-selected-char-stickers-btn">删除已选 (0)</button>
			</div>
		</div>

		<!-- 来电请求模态框 -->
		<div id="incoming-call-modal" class="modal">
			<div class="incoming-call-content">
				<img id="caller-avatar" class="caller-avatar" src="" />
				<div id="caller-name" class="caller-name"></div>
				<div class="caller-text">邀请你视频通话</div>
				<div class="incoming-call-actions">
					<div class="action-button-wrapper">
						<button id="decline-call-btn" class="call-action-btn decline"></button>
						<span>拒绝</span>
					</div>
					<div class="action-button-wrapper">
						<button id="accept-call-btn" class="call-action-btn accept"></button>
						<span>接听</span>
					</div>
				</div>
			</div>
		</div>

		<!-- BGM搜索结果的弹窗 -->
		<div id="music-search-results-modal" class="modal">
			<div class="modal-content" style="height: 70%">
				<div class="modal-header">
					<span>搜索结果</span>
				</div>
				<div class="modal-body" id="search-results-list" style="padding: 0">
					<!-- 搜索结果将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-music-search-btn" style="width: 100%">取消</button>
				</div>
			</div>
		</div>

		<!-- 视频通话界面 -->
		<div id="video-call-screen" class="screen">
			<div id="visual-call-interface" style="display: none">
				<div class="video-background">
					<div id="video-main-view" class="video-container">
						<img src="" alt="主视频画面" />
					</div>
					<div id="video-pip-view" class="video-container pip">
						<img src="" alt="小窗视频画面" />
					</div>
				</div>

				<!-- 顶部状态栏 -->
				<div class="video-call-top-bar">
					<span id="visual-call-timer">00:00</span>
				</div>

				<!-- 聊天气泡显示区域 -->
				<div id="video-call-messages-visual" class="video-call-main">
					<!-- 聊天气泡会由JS动态生成在这里 -->
				</div>

				<!-- 视频通话控制按钮 -->
				<div class="video-call-controls">
					<button id="reroll-call-btn" class="control-btn reroll-btn" title="重新生成"></button>
					<button id="user-speak-btn-visual" class="control-btn speak-btn" title="发言"></button>
					<button id="switch-camera-btn" class="control-btn switch-camera-btn" title="切换镜头"></button>
					<button id="hang-up-btn-visual" class="control-btn hangup-btn"></button>
				</div>
			</div>

			<!-- 纯文字语音通话界面 -->
			<div id="text-call-interface" style="display: none">
				<div class="video-call-top-bar">
					<span id="call-timer">00:00</span>
				</div>
				<div class="video-call-avatar-area">
					<div id="participant-avatars-grid">
						<!-- JS会在这里动态生成头像 -->
					</div>
				</div>
				<div id="video-call-main" class="video-call-main">
					<!-- 对话内容会动态生成在这里 -->
				</div>
				<div class="video-call-controls">
					<!-- 重roll按钮 -->
					<button id="reroll-call-btn-text" class="control-btn reroll-btn" title="重新生成"></button>
					<button id="user-speak-btn" class="control-btn speak-btn"></button>
					<button id="hang-up-btn" class="control-btn hangup-btn"></button>
					<button id="join-call-btn" class="control-btn join-btn" style="display: none"></button>
				</div>
			</div>
		</div>

		<!-- 正在呼叫界面 -->
		<div id="outgoing-call-screen" class="screen">
			<div class="outgoing-call-content">
				<img id="outgoing-call-avatar" class="caller-avatar" src="" />
				<div id="outgoing-call-name" class="caller-name"></div>
				<div class="caller-text">正在呼叫...</div>
				<div class="outgoing-call-actions">
					<button id="cancel-call-btn" class="call-action-btn decline"></button>
					<span>取消</span>
				</div>
			</div>
		</div>

		<!-- 通话记录页面 -->
		<div id="call-history-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="call-history-back-btn">‹</span>
				<span id="call-history-title">通话记录</span>
				<span style="width: 30px"></span>
			</div>
			<div id="call-history-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px">
				<!-- 通话记录卡片将由JS动态生成在这里 -->
			</div>
		</div>

		<!-- 聊天记录搜索界面 -->
		<div id="chat-search-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="search-back-btn">‹</span>
				<span>查找聊天记录</span>
				<span style="width: 30px"></span>
			</div>
			<div class="form-container" style="padding-bottom: 0">
				<!-- 搜索条件输入区 -->
				<div class="form-group">
					<label for="keyword-search-input">关键词</label>
					<input type="text" id="keyword-search-input" placeholder="输入要查找的关键词..." />
				</div>
				<div class="form-group">
					<label for="sender-search-select">人物</label>
					<select id="sender-search-select">
						<!-- 选项将由JS动态生成 -->
					</select>
				</div>
				<div class="form-group">
					<label for="date-search-input">日期</label>
					<input type="date" id="date-search-input" />
				</div>
				<button class="form-button" id="perform-search-btn">开始查找</button>

				<!-- 搜索结果显示区 -->
				<div id="chat-search-results-list" class="list-container" style="margin-top: 15px; padding: 0">
					<!-- 搜索结果将由JS动态生成在这里 -->
				</div>
			</div>
		</div>

		<!-- 锁屏界面 -->
		<div id="lock-screen" class="screen">
			<div id="lock-clock-container">
				<div id="lock-main-time">12:00</div>
				<div id="lock-main-date">星期一, 1月1日</div>
			</div>
			<div id="unlock-hint">向上轻扫以解锁</div>
		</div>

		<!-- 密码输入模态框 -->
		<div id="password-modal-overlay" class="modal">
			<div class="password-modal-content">
				<p>请输入密码</p>
				<input type="password" id="password-input-field" maxlength="20" />
				<div class="password-actions">
					<button id="password-cancel-btn">取消</button>
					<button id="password-confirm-btn">进入</button>
				</div>
			</div>
		</div>

		<!-- 情侣空间界面 -->
		<div id="lovers-space-screen" class="screen">
			<!-- 头部 -->
			<div id="ls-header">
				<div class="ls-header-overlay"></div>
				<div class="ls-header-top-bar">
					<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
					<span id="ls-char-name"></span>
					<div class="header-actions">
						<span class="action-btn" id="ls-settings-btn" title="空间设置">
							<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<circle cx="12" cy="12" r="3"></circle>
								<path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
							</svg>
						</span>
						<span class="action-btn" id="ls-change-bg-btn" title="更换背景">
							<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
								<circle cx="8.5" cy="8.5" r="1.5"></circle>
								<polyline points="21 15 16 10 5 21"></polyline>
							</svg>
						</span>
						<span class="action-btn" id="ls-switch-char-btn">切换</span>
					</div>
				</div>
				<div class="ls-avatar-and-counter-wrapper">
					<div class="ls-header-avatars">
						<img id="ls-user-avatar" src="" />
						<span class="heart-icon">❤</span>
						<img id="ls-char-avatar" src="" />
					</div>
					<div id="ls-days-counter"></div>
				</div>
			</div>

			<!-- 导航标签栏 -->
			<div id="ls-tab-bar">
				<div class="ls-tab-item active" data-view="ls-moments-view" title="说说">
					<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
				</div>
				<div class="ls-tab-item" data-view="ls-album-view" title="相册">
					<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
						<circle cx="8.5" cy="8.5" r="1.5"></circle>
						<polyline points="21 15 16 10 5 21"></polyline>
					</svg>
				</div>
				<div class="ls-tab-item" data-view="ls-letters-view" title="情书">
					<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
						<polyline points="22,6 12,13 2,6"></polyline>
					</svg>
				</div>
				<div class="ls-tab-item" data-view="ls-shares-view" title="分享">
					<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<circle cx="18" cy="5" r="3"></circle>
						<circle cx="6" cy="12" r="3"></circle>
						<circle cx="18" cy="19" r="3"></circle>
						<line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
						<line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
					</svg>
				</div>
				<div class="ls-tab-item" data-view="ls-questions-view" title="提问">
					<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
						<circle cx="12" cy="12" r="10"></circle>
						<line x1="12" y1="17" x2="12.01" y2="17"></line>
					</svg>
				</div>
				<div class="ls-tab-item" data-view="ls-diary-view" title="日记">
					<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
						<path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
					</svg>
				</div>
				<div class="ls-tab-item" data-view="ls-pomodoro-view" title="番茄钟">
					<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<circle cx="12" cy="12" r="10"></circle>
						<polyline points="12 6 12 12 16 14"></polyline>
					</svg>
				</div>
				<div class="ls-tab-item" data-view="ls-activity-view" title="今日足迹">
					<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
						<line x1="16" y1="2" x2="16" y2="6"></line>
						<line x1="8" y1="2" x2="8" y2="6"></line>
						<line x1="3" y1="10" x2="21" y2="10"></line>
					</svg>
				</div>
			</div>

			<!-- 内容显示区域 -->
			<div id="ls-content-area">
				<div id="ls-moments-view" class="ls-view active">
					<div id="ls-moments-list"></div>
					<button id="ls-add-moment-btn" class="ls-fab-btn">
						<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
							<line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round" />
							<line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round" />
						</svg>
					</button>
				</div>
				<div id="ls-album-view" class="ls-view">
					<div id="ls-album-list"></div>
					<button id="ls-add-album-btn" class="ls-fab-btn">
						<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
							<line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round" />
							<line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round" />
						</svg>
					</button>
				</div>

				<div id="ls-letters-view" class="ls-view">
					<div id="ls-letters-list"></div>
					<button id="ls-add-letter-btn" class="ls-fab-btn">
						<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
							<line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round" />
							<line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round" />
						</svg>
					</button>
				</div>

				<div id="ls-shares-view" class="ls-view"><div id="ls-shares-list"></div></div>
				<div id="ls-questions-view" class="ls-view">
					<div id="ls-questions-list"></div>
					<button id="ls-add-question-btn" class="ls-fab-btn">
						<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
							<line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round" />
							<line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round" />
						</svg>
					</button>
				</div>

				<!-- 日记视图 -->
				<div id="ls-diary-view" class="ls-view">
					<!-- 日历和心情罐子的内容将由JS动态生成在这里 -->
				</div>

				<!-- 番茄钟视图 -->
				<div id="ls-pomodoro-view" class="ls-view">
					<!-- 番茄钟主页，显示历史记录和开始按钮 -->
					<div id="ls-pomodoro-home">
						<div id="ls-pomodoro-start-btn-container">
							<div id="ls-pomodoro-start-icon">＋</div>
							<p>开启新的专注时光</p>
						</div>
						<div id="ls-pomodoro-history-list">
							<!-- 历史记录会由JS生成在这里 -->
						</div>
					</div>
					<!-- 正在计时的界面，默认隐藏 -->
					<div id="ls-pomodoro-timer-active" style="display: none">
						<div class="pomodoro-char-avatar-container">
							<img id="pomodoro-char-avatar" src="" />
							<div id="pomodoro-char-log"></div>
						</div>
						<div class="pomodoro-timer-display">
							<div id="pomodoro-current-task"></div>
							<div id="pomodoro-time">25:00</div>
						</div>
						<button id="pomodoro-end-btn">结束专注</button>
					</div>
				</div>

				<div id="ls-activity-view" class="ls-view">
					<!-- 今日足迹的内容将由JS动态生成在这里 -->
				</div>
			</div>
		</div>

		<!-- 聊天设置模态框 -->
		<div id="chat-settings-modal" class="modal">
			<div class="modal-content">
				<div class="modal-header"><span>聊天设置</span></div>
				<div class="modal-body">
					<div class="form-group" id="chat-name-group"><label for="chat-name-input">备注名 / 群名</label><input type="text" id="chat-name-input" /></div>

					<!-- 好友分组设置 -->
					<div class="form-group" id="assign-group-section" style="display: none">
						<!-- 默认隐藏，只对单聊显示 -->
						<label for="assign-group-select">好友分组</label>
						<div style="display: flex; align-items: center; gap: 10px">
							<select id="assign-group-select" style="flex-grow: 1">
								<!-- 分组选项将由JS动态生成 -->
							</select>
							<button id="manage-groups-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px">管理分组</button>
						</div>
					</div>

					<div class="form-group" id="my-group-nickname-group"><label for="my-group-nickname-input">我的群昵称</label><input type="text" id="my-group-nickname-input" /></div>
					<div class="form-group" id="group-avatar-group">
						<label>群头像</label>
						<div class="avatar-upload"><img id="group-avatar-preview" /><button onclick="document.getElementById('group-avatar-input').click()">上传群头像</button><input type="file" id="group-avatar-input" accept="image/*" /></div>
					</div>
					<div class="form-group" id="world-book-link-group">
						<label>关联世界书 (可多选)</label>
						<div class="custom-multiselect">
							<div class="select-box">
								<span class="selected-options-text">-- 点击选择 --</span>
								<span class="arrow-down">▼</span>
							</div>
							<div id="world-book-checkboxes-container" class="checkboxes-container"></div>
						</div>
					</div>

					<!-- 记忆互通设置 -->
					<div class="form-group" id="memory-link-group">
						<label>记忆互通 (选择要链接的聊天)</label>

						<!-- 复用世界书的多选框样式 -->
						<div class="custom-multiselect" id="memory-link-multiselect">
							<div class="select-box">
								<span class="selected-options-text">-- 点击选择 --</span>
								<span class="arrow-down">▼</span>
							</div>
							<div id="memory-link-checkboxes-container" class="checkboxes-container">
								<!-- 聊天选项将由JS动态生成在这里 -->
							</div>
						</div>

						<!-- 记忆条数设置 -->
						<div class="form-group" style="margin-top: 10px">
							<label for="link-memory-depth-input" style="font-weight: normal; color: var(--text-secondary); font-size: 13px">互通记忆条数 (AI会看到对方最近的几条消息)</label>
							<input type="number" id="link-memory-depth-input" value="5" min="1" max="20" style="padding: 8px" />
						</div>
					</div>

					<!-- 线下模式设置 -->
					<hr style="opacity: 0.2; margin: 20px 0" />

					<div class="form-group" id="offline-mode-section">
						<label for="offline-mode-toggle" class="toggle-switch-label">
							<span class="toggle-switch-text">
								开启线下模式
								<p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px">开启后，AI将默认你们在线下见面，并以大段叙事的方式进行回应。</p>
							</span>
							<input type="checkbox" id="offline-mode-toggle" />
							<span class="toggle-switch-slider"></span>
						</label>
					</div>

					<!-- 线下模式详细设置 -->
					<div id="offline-mode-details" style="display: none; padding-left: 10px; border-left: 3px solid var(--accent-color); margin-top: 15px">
						<div class="form-group">
							<label>线下模式预设</label>
							<div class="bubble-preset-manager">
								<select id="offline-preset-select" class="form-group select"></select>
								<button id="manage-offline-presets-btn" class="action-btn">管理</button>
							</div>
						</div>

						<div class="form-group">
							<label for="offline-prompt-input">自定义提示词 (Prompt)</label>
							<textarea id="offline-prompt-input" rows="4" placeholder="例如：你正在一家安静的咖啡馆里和用户约会..."></textarea>
						</div>

						<div class="form-group">
							<label for="offline-style-input">自定义文风 (Style)</label>
							<textarea id="offline-style-input" rows="3" placeholder="例如：请使用第三人称，详细描写角色的动作、神态和心理活动..."></textarea>
						</div>

						<div class="form-group">
							<label for="offline-word-count-input">期望回复字数</label>
							<input type="number" id="offline-word-count-input" value="300" min="50" step="50" />
						</div>
					</div>

					<!-- 聊天总结设置 -->
					<hr style="opacity: 0.2; margin: 20px 0" />

					<div class="form-group">
						<label for="summary-toggle" class="toggle-switch-label">
							<span class="toggle-switch-text">
								开启聊天总结
								<p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px">开启后，AI会在对话达到一定长度时自动或手动进行总结，作为长期记忆。</p>
							</span>
							<input type="checkbox" id="summary-toggle" />
							<span class="toggle-switch-slider"></span>
						</label>
					</div>

					<div id="summary-details-container" style="display: none; padding-left: 10px; border-left: 3px solid var(--accent-color); margin-top: 15px">
						<div class="form-group">
							<label>总结模式</label>
							<div style="display: flex; gap: 20px">
								<label><input type="radio" name="summary-mode" value="auto" checked /> 自动总结</label>
								<label><input type="radio" name="summary-mode" value="manual" /> 手动总结</label>
							</div>
						</div>
						<div class="form-group">
							<label for="summary-count-input">触发消息条数</label>
							<input type="number" id="summary-count-input" value="20" min="5" />
						</div>
						<div class="form-group">
							<label for="summary-prompt-input">总结提示词 (Prompt)</label>
							<textarea id="summary-prompt-input" rows="4"></textarea>
						</div>
						<button id="view-summaries-btn" class="form-button form-button-secondary" style="margin-top: 10px">查看和管理总结</button>
						<button id="manual-summary-btn" class="form-button form-button-secondary" style="margin-top: 10px">立即手动总结</button>
					</div>

					<!-- 聊天统计信息 -->
					<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px">
						<label style="margin-bottom: 0">当前总聊天条数</label>
						<span id="total-message-count-display" style="color: var(--text-secondary); font-weight: 500">--</span>
					</div>

					<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px">
						<label style="margin-bottom: 0">
							上下文Token数
							<p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px">(提示词 + 上下文记忆)</p>
						</label>
						<span id="context-token-count-display" style="color: var(--text-secondary); font-weight: 500">--</span>
					</div>

					<div class="form-group" id="ai-persona-group"><label for="ai-persona">对方人设 (AI Persona)</label><textarea id="ai-persona" rows="3"></textarea></div>

					<!-- 角色表情包管理 -->
					<div class="form-group" id="char-sticker-group">
						<button id="manage-char-stickers-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 5px">管理角色表情包</button>
					</div>

					<!-- NPC库管理 -->
					<div class="form-group" id="npc-library-group">
						<button id="manage-npcs-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 5px">管理NPC库</button>
					</div>

					<!-- Minimax语音ID设置 -->
					<div class="form-group" id="minimax-voice-id-group">
						<label for="minimax-voice-id-input">Minimax 语音ID</label>
						<input type="text" id="minimax-voice-id-input" placeholder="例如：male-01" />
					</div>

					<!-- 微博人设与职业设置 -->
					<div id="weibo-settings-for-user" style="display: none">
						<hr style="opacity: 0.2; margin: 20px 0" />
						<div class="form-group">
							<label>我的微博设定</label>
							<div class="bubble-preset-manager">
								<select id="weibo-persona-preset-select" class="form-group select"></select>
								<button id="manage-weibo-presets-btn" class="action-btn">管理</button>
							</div>
						</div>
						<div class="form-group">
							<label for="weibo-user-profession-input">职业 (显示在昵称下方)</label>
							<input type="text" id="weibo-user-profession-input" placeholder="例如：职业电竞选手、美妆博主" />
						</div>
						<div class="form-group">
							<label for="weibo-user-persona-input">隐藏人设 (仅供AI参考)</label>
							<textarea id="weibo-user-persona-input" rows="3" placeholder="例如：性格高冷，少与粉丝互动，只回复赞助商的评论。"></textarea>
						</div>
					</div>

					<!-- 微博职业和指令设置 -->
					<div class="form-group" id="weibo-profession-group">
						<label for="weibo-profession-input">微博职业</label>
						<input type="text" id="weibo-profession-input" placeholder="例如：职业电竞选手、美妆博主、演员..." />
					</div>
					<div class="form-group" id="weibo-instruction-group">
						<label for="weibo-instruction-input">微博指令 (AI发微博/评论时将严格遵守)</label>
						<textarea id="weibo-instruction-input" rows="3" placeholder="例如：多发日常训练和比赛的内容，性格高冷，少与粉丝互动，只回复赞助商的评论。"></textarea>
					</div>

					<!-- 实时时间感知设置 -->
					<hr style="opacity: 0.2; margin: 20px 0" />
					<div class="form-group">
						<label for="time-perception-toggle" class="toggle-switch-label">
							<span class="toggle-switch-text">启用实时时间感知</span>
							<input type="checkbox" id="time-perception-toggle" checked />
							<span class="toggle-switch-slider"></span>
						</label>
					</div>
					<div id="custom-time-container" class="form-group" style="display: none">
						<label for="custom-time-input">自定义时间</label>
						<input type="datetime-local" id="custom-time-input" style="width: 95%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-color)" />
					</div>

					<div class="form-group" id="ai-avatar-group">
						<label>对方头像</label>

						<!-- 视频通话界面设置 -->
						<div class="form-group" id="video-call-settings-group">
							<hr style="opacity: 0.2; margin: 20px 0" />
							<label>视频通话界面设置</label>

							<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px">
								<span>启用可视化界面</span>
								<label class="toggle-switch">
									<input type="checkbox" id="visual-video-call-switch" />
									<span class="slider"></span>
								</label>
							</div>

							<div id="video-call-image-uploads" style="display: none">
								<div class="form-group">
									<label>对方的视频画面</label>
									<div class="avatar-upload">
										<img id="char-video-image-preview" style="border-radius: 8px; width: 80px; height: 142px" />
										<button onclick="document.getElementById('char-video-image-input').click()">上传图片</button>
										<input type="file" id="char-video-image-input" accept="image/*" hidden />
									</div>
								</div>
								<div class="form-group">
									<label>我的视频画面</label>
									<div class="avatar-upload">
										<img id="user-video-image-preview" style="border-radius: 8px; width: 80px; height: 142px" />
										<button onclick="document.getElementById('user-video-image-input').click()">上传图片</button>
										<input type="file" id="user-video-image-input" accept="image/*" hidden />
									</div>
								</div>
							</div>
						</div>

						<div class="avatar-upload">
							<img id="ai-avatar-preview" />
							<button onclick="document.getElementById('ai-avatar-input').click()">上传对方头像</button>
							<button class="change-frame-btn" data-type="ai">更换头像框</button>
							<button id="manage-ai-avatar-library-btn">管理头像库</button>
							<input type="file" id="ai-avatar-input" accept="image/*" />
						</div>
					</div>

					<!-- 情侣头像设置 -->
					<div class="form-group" id="couple-avatar-group">
						<label for="couple-avatar-toggle" class="toggle-switch-label">
							<span class="toggle-switch-text">情侣头像开关</span>
							<input type="checkbox" id="couple-avatar-toggle" />
							<span class="toggle-switch-slider"></span>
						</label>
						<div id="couple-avatar-desc-container" style="display: none; margin-top: 10px">
							<label for="couple-avatar-description" style="font-size: 13px; color: var(--text-secondary)">情侣头像描述 (可选)</label>
							<input type="text" id="couple-avatar-description" placeholder="例如：一只小猫在看月亮" />
						</div>
					</div>

					<div class="form-group" id="my-persona-group"><label for="my-persona">我的人设 (My Persona)</label><textarea id="my-persona" rows="3"></textarea></div>
					<div class="form-group" id="my-avatar-group">
						<label>我的头像</label>
						<div class="avatar-upload"><img id="my-avatar-preview" /><button onclick="document.getElementById('my-avatar-input').click()">上传我的头像</button> <button class="change-frame-btn" data-type="my">更换头像框</button> <button id="open-persona-library-btn">预设</button><input type="file" id="my-avatar-input" accept="image/*" /></div>
					</div>
					<div class="form-group" id="group-members-group">
						<label>群成员人设</label>
						<div id="group-members-settings"></div>

						<button id="manage-members-btn" class="form-button form-button-secondary" style="margin-top: 15px">管理群成员</button>
					</div>

					<!-- 群聊后台活动设置 -->
					<div class="form-group" id="group-background-activity-group" style="display: none">
						<hr style="opacity: 0.2; margin: 20px 0" />
						<label class="toggle-switch-label">
							<span class="toggle-switch-text">
								群聊后台实时活动
								<p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px">警告：开启后会增加API调用和费用！</p>
							</span>
							<input type="checkbox" id="group-background-activity-switch" />
							<span class="toggle-switch-slider"></span>
						</label>

						<div id="group-background-interval-settings" style="display: none; margin-top: 15px">
							<div style="display: flex; justify-content: space-between; align-items: center">
								<label for="group-background-interval-input" style="margin-bottom: 0">
									活动间隔期 (秒)
									<p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px">建议值 120-600。值越大，费用越低，但群内互动越慢。</p>
								</label>
								<input type="number" id="group-background-interval-input" min="60" value="120" style="width: 80px; text-align: center" />
							</div>
						</div>
					</div>

					<!-- 火花设置 -->
					<div class="form-group" id="streak-settings-section">
						<label for="streak-enabled-toggle" class="toggle-switch-label">
							<span class="toggle-switch-text">
								开启续火花
								<p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px">开启后，每天和Ta互动即可延续火花。</p>
							</span>
							<input type="checkbox" id="streak-enabled-toggle" />
							<span class="toggle-switch-slider"></span>
						</label>

						<button id="open-intimacy-panel-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 10px; display: none">🏅</button>

						<div id="streak-details-container" style="display: none; margin-top: 15px; padding-left: 10px; border-left: 3px solid var(--accent-color)">
							<div class="form-group">
								<label for="streak-initial-days-input">初始火花天数</label>
								<input type="number" id="streak-initial-days-input" value="0" min="0" />
							</div>
							<div class="form-group">
								<label for="streak-extinguish-threshold-select">火花熄灭规则</label>
								<select id="streak-extinguish-threshold-select">
									<option value="1">1天不联系则熄灭</option>
									<option value="3">3天不联系则熄灭</option>
									<option value="7">7天不联系则熄灭</option>
									<option value="-1">永不熄灭 🔥</option>
								</select>
							</div>
							<div class="form-group">
								<label for="streak-lit-icon-url">点亮的火花图片 URL (可选)</label>
								<input type="text" id="streak-lit-icon-url" placeholder="留空则默认显示🔥" />
							</div>
							<div class="form-group">
								<label for="streak-extinguished-icon-url">熄灭的火花图片 URL (可选)</label>
								<input type="text" id="streak-extinguished-icon-url" placeholder="留空则默认显示🧊" />
							</div>
							<div class="form-group">
								<label for="streak-font-color-picker">天数字体颜色 (可选)</label>
								<input type="color" id="streak-font-color-picker" value="#ff6f00" style="width: 100%; height: 40px" />
							</div>
						</div>
					</div>

					<div class="form-group"><label for="max-memory">上下文记忆条数</label><input type="number" id="max-memory" value="10" /></div>
					<div class="form-group">
						<label>聊天气泡主题 <button id="reset-theme-btn" type="button">重置</button></label>
						<div class="theme-selector">
							<label><input type="radio" name="theme-select" value="default" id="theme-default" /> 默认</label><label><input type="radio" name="theme-select" value="pink_blue" /> 粉蓝</label><label><input type="radio" name="theme-select" value="blue_white" /> 蓝白</label><label><input type="radio" name="theme-select" value="purple_yellow" /> 紫黄</label><label><input type="radio" name="theme-select" value="black_white" /> 黑白</label><label><input type="radio" name="theme-select" value="yellow_white" /> 黄白</label><label><input type="radio" name="theme-select" value="red_black" /> 红黑</label><label><input type="radio" name="theme-select" value="blue_yellow" /> 蓝黄</label><label><input type="radio" name="theme-select" value="pink_yellow" /> 粉黄</label><label><input type="radio" name="theme-select" value="pink_purple" /> 粉紫</label><label><input type="radio" name="theme-select" value="gray_white" /> 灰白</label><label><input type="radio" name="theme-select" value="blue_green" /> 蓝绿</label><label><input type="radio" name="theme-select" value="pink_white" /> 粉白</label><label><input type="radio" name="theme-select" value="pink_black" /> 粉黑</label><label><input type="radio" name="theme-select" value="pink_green" /> 粉绿</label><label><input type="radio" name="theme-select" value="green_black" /> 绿黑</label>
						</div>
					</div>

					<!-- 聊天字体大小设置 -->
					<div class="form-group">
						<label for="font-size-slider">聊天字体大小 <span id="font-size-value">13px</span></label>
						<input type="range" id="font-size-slider" min="12" max="20" step="1" value="13" style="width: 100%; margin-top: 8px" />
					</div>

					<!-- 气泡样式预设 -->
					<div class="form-group">
						<label>气泡样式预设</label>
						<div class="bubble-preset-manager">
							<select id="bubble-style-preset-select" class="form-group select"></select>
							<button id="manage-bubble-presets-btn" class="action-btn">管理</button>
						</div>
						<div style="display: flex; gap: 10px; margin-top: 10px">
							<button id="export-bubble-preset-btn" class="form-button form-button-secondary" style="flex: 1; margin: 0">导出气泡</button>
							<button id="import-bubble-preset-btn" class="form-button form-button-secondary" style="flex: 1; margin: 0">导入气泡</button>
						</div>
						<input type="file" id="import-bubble-preset-input" accept=".json" style="display: none" />
					</div>

					<!-- 自定义气泡样式 -->
					<div class="form-group">
						<label for="custom-css-input">
							自定义气泡样式 (CSS)
							<button id="reset-custom-css-btn" type="button" style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px">重置</button>
						</label>
						<textarea
							id="custom-css-input"
							rows="5"
							style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 12px; resize: vertical"
							placeholder="/* 示例：为“我”的气泡添加渐变背景和阴影 */
                                        .message-bubble.user .content {
                                            background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
                                            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
                                            border-radius: 15px 4px 15px 15px;
                                        }"
						></textarea>
					</div>

					<!-- 实时预览 -->
					<div class="form-group">
						<label>实时预览</label>
						<div id="settings-preview-area">
							<!-- JS会在这里生成预览内容 -->
						</div>
					</div>

					<!-- 聊天背景设置 -->
					<div class="form-group">
						<label>聊天背景</label>
						<div class="bg-upload-container">
							<button type="button" class="form-button-secondary" style="width: auto; padding: 8px 12px; margin-top: 0" onclick="document.getElementById('bg-input').click()">上传背景图</button>
							<button type="button" id="remove-bg-btn">移除背景</button>
						</div>
						<img id="bg-preview" class="bg-preview-img" />
						<input type="file" id="bg-input" accept="image/*" style="display: none" />
					</div>

					<!-- NAI出图设置（单聊显示） -->
					<div class="form-group" id="nai-character-settings-group" style="display: none">
						<hr style="opacity: 0.2; margin: 20px 0" />
						<label style="font-weight: 600; color: var(--accent-color)">NAI出图设置</label>
						<p style="font-size: 12px; color: #666; margin-top: 5px">为当前角色配置专属的NovelAI出图提示词</p>

						<div style="margin-top: 15px">
							<label style="font-weight: 500; color: #333">提示词来源</label>
							<div style="display: flex; gap: 15px; margin-top: 10px">
								<label style="display: flex; align-items: center; cursor: pointer">
									<input type="radio" name="nai-prompt-source" value="system" checked style="width: auto; margin-right: 8px" />
									<span>使用系统设置</span>
								</label>
								<label style="display: flex; align-items: center; cursor: pointer">
									<input type="radio" name="nai-prompt-source" value="character" style="width: auto; margin-right: 8px" />
									<span>使用当前角色配置</span>
								</label>
							</div>
						</div>

						<button id="character-nai-prompts-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 15px">配置角色专属提示词</button>
					</div>

					<div class="form-group" id="group-nai-settings-group" style="display: none">
						<hr style="opacity: 0.2; margin: 20px 0" />
						<label style="font-weight: 600; color: var(--accent-color)">NAI出图设置</label>
						<p style="font-size: 12px; color: #666; margin-top: 5px">为当前角色配置专属的NovelAI出图提示词</p>

						<div style="margin-top: 15px">
							<label style="font-weight: 500; color: #333">提示词来源</label>
							<div style="display: flex; gap: 15px; margin-top: 10px">
								<label style="display: flex; align-items: center; cursor: pointer">
									<input type="radio" name="group-nai-prompt-source" value="system" checked style="width: auto; margin-right: 8px" />
									<span>使用系统设置</span>
								</label>
								<label style="display: flex; align-items: center; cursor: pointer">
									<input type="radio" name="group-nai-prompt-source" value="character" style="width: auto; margin-right: 8px" />
									<span>使用当前角色配置</span>
								</label>
							</div>
						</div>

						<button id="group-character-nai-prompts-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 15px">配置角色专属提示词</button>
					</div>

					<!-- 记录管理区 -->
					<div class="form-group" style="display: flex; gap: 10px">
						<button class="form-button form-button-secondary" id="import-chat-history-btn" style="flex: 1; margin: 0">导入聊天记录</button>
						<button class="form-button form-button-secondary" id="export-chat-history-btn" style="flex: 1; margin: 0">导出聊天记录</button>
					</div>
					<input type="file" id="import-chat-history-input" accept="application/json" style="display: none" />
					<button class="form-button form-button-secondary" id="search-chat-btn">查找聊天记录</button>
					<button class="form-button form-button-secondary" id="clear-chat-btn">清空聊天记录</button>
					<button class="form-button form-button-secondary" id="block-chat-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30">拉黑对方</button>
				</div>
				<div class="modal-footer"><button class="cancel" id="cancel-chat-settings-btn">取消</button><button class="save" id="save-chat-settings-btn">保存</button></div>
			</div>
		</div>

		<!-- 我的人设库模态框 -->
		<div id="persona-library-modal" class="modal">
			<div class="modal-content">
				<div class="modal-header"><span>我的人设库</span><button id="add-persona-preset-btn" class="action-button">添加</button></div>
				<div class="modal-body"><div id="persona-library-grid"></div></div>
				<div class="modal-footer"><button class="cancel" id="close-persona-library-btn">关闭</button></div>
			</div>
		</div>

		<!-- 人设编辑器模态框 -->
		<div id="persona-editor-modal" class="modal">
			<div class="modal-content">
				<div class="modal-header">
					<span id="persona-editor-title">添加人设预设</span>
				</div>
				<div class="modal-body">
					<!-- NPC名字输入框 -->
					<div class="form-group" id="npc-editor-name-group">
						<label for="npc-editor-name-input">NPC 名字</label>
						<input type="text" id="npc-editor-name-input" />
					</div>
					<div class="form-group">
						<label>头像</label>
						<div class="avatar-upload">
							<img id="preset-avatar-preview" />
							<button onclick="document.getElementById('preset-avatar-input').click()">上传头像</button>
							<!-- 更换头像框按钮 -->
							<button id="persona-editor-change-frame-btn" class="change-frame-btn" data-type="member">更换头像框</button>
							<input type="file" id="preset-avatar-input" accept="image/*" />
						</div>
					</div>
					<div class="form-group">
						<label for="preset-persona-input">人设</label>
						<textarea id="preset-persona-input" rows="4" placeholder="在此输入这个人设的详细设定..."></textarea>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-persona-editor-btn">取消</button>
					<button class="save" id="save-persona-preset-btn">保存</button>
				</div>
			</div>
		</div>

		<!-- 群成员设置模态框 -->
		<div id="member-settings-modal" class="modal">
			<div class="modal-content">
				<div class="modal-header"><span>编辑群成员</span></div>
				<div class="modal-body">
					<div class="form-group"><label for="member-name-input">名字</label><input type="text" id="member-name-input" /></div>
					<div class="form-group"><label for="member-persona-input">人设</label><textarea id="member-persona-input" rows="4"></textarea></div>
					<!-- 头像上传区域 -->
					<div class="form-group">
						<label>头像</label>
						<div class="avatar-upload">
							<img id="member-avatar-preview" />
							<button onclick="document.getElementById('member-avatar-input').click()">上传头像</button>
							<!-- 更换头像框按钮 -->
							<button id="member-editor-change-frame-btn" class="change-frame-btn">更换头像框</button>
							<input type="file" id="member-avatar-input" accept="image/*" hidden />
						</div>
					</div>
				</div>
				<div class="modal-footer"><button class="cancel" id="cancel-member-settings-btn">取消</button><button class="save" id="save-member-settings-btn">保存</button></div>
			</div>
		</div>

		<!-- 自定义模态框 -->
		<div id="custom-modal-overlay">
			<div id="custom-modal">
				<div class="custom-modal-header" id="custom-modal-title"></div>
				<div class="custom-modal-body" id="custom-modal-body"></div>
				<div class="custom-modal-footer">
					<button id="custom-modal-cancel">取消</button>
					<button id="custom-modal-confirm" class="confirm-btn">确定</button>
				</div>
			</div>
		</div>

		<!-- 预设操作模态框 -->
		<div id="preset-actions-modal" class="modal">
			<div id="custom-modal" style="width: 250px">
				<div class="custom-modal-footer">
					<button id="preset-action-edit">编辑预设</button>
					<button id="preset-action-delete" class="btn-danger">删除预设</button>
					<button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0">取消</button>
				</div>
			</div>
		</div>

		<!-- 转账模态框 -->
		<div id="transfer-modal">
			<div class="transfer-content">
				<div class="transfer-header">给Ta一个惊喜！</div>
				<div class="transfer-input-group">
					<label for="transfer-amount">转账金额</label>
					<input type="number" id="transfer-amount" placeholder="0.00" min="0" max="9999999999999" step="0.01" />
				</div>
				<div class="transfer-input-group">
					<label for="transfer-note">备注 (可选)</label>
					<input type="text" id="transfer-note" placeholder="留下你的小心思~" maxlength="20" />
				</div>
				<div class="transfer-actions">
					<button id="transfer-cancel-btn">取消</button>
					<button id="transfer-confirm-btn">确认转账</button>
				</div>
			</div>
		</div>

		<!-- 电池警告模态框 -->
		<div id="battery-alert-modal">
			<div class="battery-alert-content">
				<img id="battery-alert-image" src="" />
				<p id="battery-alert-text"></p>
			</div>
		</div>

		<!-- 音频播放器 -->
		<audio id="audio-player" style="display: none"></audio>
		<!-- TTS音频播放器 -->
		<audio id="tts-audio-player" style="display: none"></audio>
		<audio id="ringtone-player" loop></audio>
		<audio id="notification-sound-player" preload="auto"></audio>

		<!-- 发布动态模态框 -->
		<div id="create-post-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 90%">
				<div class="modal-header">
					<span id="create-post-modal-title">发布动态</span>
					<!-- 使用ID方便JS修改标题 -->
				</div>
				<div class="modal-body">
					<!-- 公开文字输入区 -->
					<div class="form-group">
						<textarea id="post-public-text" rows="3" placeholder="分享新鲜事..."></textarea>
					</div>

					<!-- 模式切换开关 -->
					<div class="post-mode-switcher">
						<button id="switch-to-image-mode" class="mode-btn active">上传图片</button>
						<button id="switch-to-text-image-mode" class="mode-btn">使用文字图</button>
					</div>

					<!-- 图片模式区域 -->
					<div id="image-mode-content" class="post-mode-content active">
						<div class="form-group">
							<div id="post-image-preview-container" class="post-image-preview-container">
								<img id="post-image-preview" src="" alt="图片预览" />
								<button id="post-remove-image-btn">×</button>
							</div>
							<div class="post-image-upload-options">
								<button id="post-upload-local-btn" class="form-button-secondary">本地上传</button>
								<button id="post-use-url-btn" class="form-button-secondary">网络URL</button>
								<input type="file" id="post-local-image-input" accept="image/*" hidden />
							</div>
						</div>
						<!-- 给AI看的图片描述，在微博模式下会隐藏 -->
						<div id="post-image-desc-group" class="form-group" style="display: none">
							<label>图片描述 (必填，给AI看)</label>
							<input type="text" id="post-image-description" placeholder="简单描述图片内容，帮助AI理解" />
						</div>
					</div>

					<!-- 文字图模式区域 -->
					<div id="text-image-mode-content" class="post-mode-content">
						<div class="form-group">
							<label>文字图 (给AI理解用的描述，点击图片后可见)</label>
							<textarea id="post-hidden-text" rows="4" placeholder="在这里写下图片描述..."></textarea>
						</div>
					</div>

					<!-- 可见范围设置 -->
					<div class="form-group" id="post-visibility-group">
						<label>可见范围</label>
						<div style="display: flex; gap: 20px; margin-bottom: 10px">
							<label><input type="radio" name="visibility" value="all" checked /> 所有人可见</label>
							<label><input type="radio" name="visibility" value="groups" /> 仅分组可见</label>
						</div>
						<div id="post-visibility-groups" style="display: none; max-height: 120px; overflow-y: auto; background-color: #f0f2f5; padding: 10px; border-radius: 8px">
							<!-- 分组的多选框会由JS动态生成在这里 -->
						</div>
					</div>

					<!-- 允许角色看见评论区开关 -->
					<div class="form-group" id="post-comments-toggle-group" style="margin-top: 15px">
						<label for="post-comments-toggle" class="toggle-switch-label">
							<span class="toggle-switch-text">允许角色看见评论区</span>
							<input type="checkbox" id="post-comments-toggle" checked />
							<span class="toggle-switch-slider"></span>
						</label>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-create-post-btn">取消</button>
					<button class="save" id="confirm-create-post-btn">发布</button>
				</div>
			</div>
		</div>

		<!-- NovelAI 生成设置弹窗 -->
		<div id="novelai-settings-modal" class="modal" style="display: none">
			<div class="modal-content" style="max-width: 600px; width: 90%; max-height: 85vh; overflow-y: auto">
				<div class="modal-header">
					<span>NovelAI 生成设置</span>
					<span class="close" id="close-novelai-settings" style="cursor: pointer; float: right; font-size: 28px; font-weight: bold">&times;</span>
				</div>
				<div class="modal-body" style="padding: 20px">
					<div class="form-group">
						<label style="color: #333">图像尺寸（oplus可无限出小图）</label>
						<select id="nai-resolution" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px">
							<optgroup label="小">
								<option value="512x768">纵向 (512x768)</option>
								<option value="768x512">横向 (768x512)</option>
								<option value="640x640">正方形 (640x640)</option>
							</optgroup>
							<optgroup label="正常">
								<option value="832x1216">竖图 (832x1216)</option>
								<option value="1216x832">横图 (1216x832)</option>
								<option value="1024x1024" selected>方图 (1024x1024)</option>
							</optgroup>
							<optgroup label="壁纸">
								<option value="1088x1920">纵向 (1088x1920)</option>
								<option value="1920x1088">风景 (1920x1088)</option>
							</optgroup>
						</select>
						<small style="color: #666">建议使用官方支持的标准尺寸以获得最佳效果</small>
					</div>

					<div class="form-group">
						<label style="color: #333">采样步数 (Steps)</label>
						<input type="number" id="nai-steps" value="28" min="1" max="50" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px" />
						<small style="color: #666">推荐值: 28 (值越高质量越好但耗时越长)</small>
					</div>

					<div class="form-group">
						<label style="color: #333">提示词相关性 (CFG Scale)</label>
						<input type="number" id="nai-cfg-scale" value="5" min="1" max="20" step="0.5" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px" />
						<small style="color: #666">推荐值: 5 (控制图像与提示词的相关程度)</small>
					</div>

					<div class="form-group">
						<label style="color: #333">采样器 (Sampler)</label>
						<select id="nai-sampler" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px">
							<option value="k_euler">Euler</option>
							<option value="k_euler_ancestral" selected>Euler Ancestral</option>
							<option value="k_dpmpp_2s_ancestral">DPM++ 2S Ancestral</option>
							<option value="k_dpmpp_2m">DPM++ 2M</option>
							<option value="k_dpmpp_sde">DPM++ SDE</option>
							<option value="ddim">DDIM</option>
						</select>
					</div>

					<div class="form-group">
						<label style="color: #333">随机种子 (Seed)</label>
						<input type="number" id="nai-seed" value="-1" min="-1" max="9999999999" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px" />
						<small style="color: #666">-1 表示随机，固定种子可复现相同图像</small>
					</div>

					<div class="form-group">
						<label style="color: #333">负面提示词预设 (UC Preset)</label>
						<select id="nai-uc-preset" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px">
							<option value="0">Preset 0 - Heavy</option>
							<option value="1" selected>Preset 1 - Light</option>
							<option value="2">Preset 2 - Human Focus</option>
							<option value="3">Preset 3 - None</option>
						</select>
					</div>

					<div class="form-group">
						<label style="color: #333">质量标签</label>
						<div style="display: flex; align-items: center; gap: 10px">
							<input type="checkbox" id="nai-quality-toggle" checked style="width: auto" />
							<span style="color: #666; font-size: 14px">自动添加质量提升标签</span>
						</div>
					</div>

					<div class="form-group">
						<label style="color: #333">SMEA (提升细节)</label>
						<div style="display: flex; align-items: center; gap: 10px">
							<input type="checkbox" id="nai-smea" checked style="width: auto" />
							<span style="color: #666; font-size: 14px">启用SMEA增强</span>
						</div>
					</div>

					<div class="form-group">
						<label style="color: #333">SMEA DYN (动态优化)</label>
						<div style="display: flex; align-items: center; gap: 10px">
							<input type="checkbox" id="nai-smea-dyn" style="width: auto" />
							<span style="color: #666; font-size: 14px">启用动态SMEA</span>
						</div>
					</div>

					<div class="form-group">
						<label style="color: #333">默认正面提示词</label>
						<textarea id="nai-default-positive" rows="3" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px; resize: vertical" placeholder="masterpiece, best quality, 1girl, beautiful...">masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style</textarea>
						<small style="color: #666">此提示词将在生成时自动使用（如果测试弹窗中未填写）</small>
					</div>

					<div class="form-group">
						<label style="color: #333">默认负面提示词</label>
						<textarea id="nai-default-negative" rows="3" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px; resize: vertical" placeholder="lowres, bad anatomy, bad hands, text, error...">lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry</textarea>
					</div>

					<div class="form-group" style="border-top: 1px solid #ddd; padding-top: 15px; margin-top: 15px">
						<label style="color: #333">🌐 CORS 代理设置</label>
						<select id="nai-cors-proxy" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px">
							<option value="">❌ 直连（无代理）</option>
							<option value="https://corsproxy.io/?" selected>✅ corsproxy.io（推荐）</option>
							<option value="https://api.allorigins.win/raw?url=">allorigins.win</option>
							<option value="https://cors-anywhere.herokuapp.com/">cors-anywhere（需激活）</option>
							<option value="custom">🔧 自定义代理</option>
						</select>
						<small style="color: #e74c3c; display: block; margin-top: 8px"> ⚠️ 本地运行会遇到CORS跨域问题，需使用代理。推荐使用 corsproxy.io </small>
					</div>

					<div id="nai-custom-proxy-group" class="form-group" style="display: none">
						<label style="color: #333">自定义代理地址</label>
						<input type="text" id="nai-custom-proxy-url" placeholder="https://your-proxy.com/?" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px" />
						<small style="color: #666">代理URL应以 / 或 ? 结尾，例如：https://proxy.com/?</small>
					</div>
				</div>
				<div class="modal-footer">
					<button id="reset-nai-settings-btn" class="form-button form-button-secondary" style="margin-right: 10px">恢复默认</button>
					<button id="save-nai-settings-btn" class="form-button form-button-secondary">保存设置</button>
				</div>
			</div>
		</div>

		<!-- NovelAI 测试生成弹窗 -->
		<div id="novelai-test-modal" class="modal" style="display: none">
			<div class="modal-content" style="max-width: 700px; width: 90%; max-height: 90vh; overflow-y: auto">
				<div class="modal-header">
					<span>🖼️ NovelAI 测试生成</span>
					<span class="close" id="close-novelai-test" style="cursor: pointer; float: right; font-size: 28px; font-weight: bold">&times;</span>
				</div>
				<div class="modal-body" style="padding: 20px">
					<div class="form-group">
						<label style="color: #333">正面提示词（此处提示词仅用于该弹窗测试）</label>
						<textarea id="nai-test-prompt" rows="4" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical" placeholder="1girl, solo, long hair, blue eyes, smile...">1girl, solo, long hair, blue eyes, smile, outdoors, cherry blossoms, spring</textarea>
					</div>

					<div class="form-group">
						<label style="color: #333">负面提示词（可选，留空使用默认）</label>
						<textarea id="nai-test-negative" rows="3" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical" placeholder="留空将使用设置中的默认负面提示词"></textarea>
					</div>

					<div style="text-align: center; margin: 20px 0">
						<button id="nai-generate-btn" style="background-color: #007bff; color: white; border: none; padding: 12px 30px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold">生成图像</button>
					</div>

					<div id="nai-test-status" style="text-align: center; color: #666; margin: 15px 0; display: none">正在生成中，请稍候...</div>

					<div id="nai-test-result" style="display: none; margin-top: 20px">
						<div style="font-weight: bold; color: #333; margin-bottom: 10px">生成结果：</div>
						<div style="text-align: center; background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef">
							<img id="nai-result-image" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1)" />
						</div>
						<div style="margin-top: 10px; text-align: center">
							<button id="nai-download-btn" class="form-button-secondary" style="margin: 0">下载图像</button>
						</div>
					</div>

					<div id="nai-test-error" style="display: none; margin-top: 15px; padding: 12px; background: #f8d7da; color: #721c24; border-radius: 6px; border: 1px solid #f5c6cb"></div>
				</div>
				<div class="modal-footer">
					<button id="close-nai-test-btn" class="form-button">关闭</button>
				</div>
			</div>
		</div>

		<!-- 角色专属NAI出图设置弹窗 -->
		<div id="character-nai-prompts-modal" class="modal" style="display: none">
			<div class="modal-content">
				<div class="modal-header">
					<span>角色专属NAI提示词配置</span>
					<span class="close" id="close-character-nai-prompts" style="cursor: pointer; float: right; font-size: 28px; font-weight: bold">&times;</span>
				</div>
				<div class="modal-body">
					<p style="font-size: 13px; color: #666; margin-bottom: 20px; background-color: #f0f8ff; padding: 12px; border-radius: 6px; border-left: 3px solid #007bff">💡 这里配置的提示词仅用于当前角色的NAI出图，不影响其他角色或系统设置</p>

					<div class="form-group">
						<label for="character-nai-positive" style="color: #333; font-weight: 600"> 正面提示词 (Positive Prompt) </label>
						<textarea id="character-nai-positive" rows="4" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical; font-size: 13px" placeholder="例如: masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style"></textarea>
						<small style="display: block; color: #666; font-size: 12px; margin-top: 5px"> 描述你希望生成的图像风格，可填入画师串 </small>
					</div>

					<div class="form-group">
						<label for="character-nai-negative" style="color: #333; font-weight: 600"> 负面提示词 (Negative Prompt) </label>
						<textarea id="character-nai-negative" rows="4" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical; font-size: 13px" placeholder="例如: lowres, bad anatomy, bad hands, text, error, missing fingers"></textarea>
						<small style="display: block; color: #666; font-size: 12px; margin-top: 5px"> 描述你希望避免的元素 </small>
					</div>
				</div>
				<div class="modal-footer">
					<button id="reset-character-nai-prompts-btn" class="form-button form-button-secondary" style="margin-right: 10px">清空配置</button>
					<button id="save-character-nai-prompts-btn" class="form-button form-button-secondary">保存</button>
				</div>
			</div>
		</div>

		<!-- 管理好友分组模态框 -->
		<div id="group-management-modal" class="modal">
			<div class="modal-content" style="height: 60%">
				<div class="modal-header">
					<span>管理好友分组</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label>新建分组</label>
						<div style="display: flex; gap: 10px">
							<input type="text" id="new-group-name-input" placeholder="输入分组名..." style="flex-grow: 1" />
							<button id="add-new-group-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px">添加</button>
						</div>
					</div>
					<hr style="opacity: 0.2" />
					<div id="existing-groups-list" style="display: flex; flex-direction: column; gap: 10px">
						<!-- 分组列表将由JS动态生成 -->
					</div>
				</div>
				<div class="modal-footer">
					<button class="save" id="close-group-manager-btn" style="width: 100%">完成</button>
				</div>
			</div>
		</div>

		<!-- 消息操作模态框 -->
		<div id="message-actions-modal" class="modal">
			<div id="custom-modal" style="width: 250px">
				<div class="custom-modal-footer">
					<!-- 消息操作按钮 -->
					<button id="edit-message-btn">编辑消息</button>
					<button id="copy-message-btn">复制文本</button>
					<button id="recall-message-btn">撤回</button>
					<button id="quote-message-btn">引用</button>
					<button id="select-message-btn">进入多选</button>
					<!-- 取消按钮 -->
					<button id="cancel-message-action-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0">取消</button>
				</div>
			</div>
		</div>

		<!-- 动态操作模态框 -->
		<div id="post-actions-modal" class="modal">
			<div id="custom-modal" style="width: 250px">
				<div class="custom-modal-footer">
					<button id="edit-post-btn">编辑动态</button>
					<button id="copy-post-btn">复制内容</button>
					<button id="cancel-post-action-btn">取消</button>
				</div>
			</div>
		</div>

		<!-- 可视化消息编辑器模态框 -->
		<div id="message-editor-modal" class="modal">
			<div class="modal-content" style="height: 75%">
				<div class="modal-header">
					<span>编辑与拆分消息</span>
				</div>
				<div class="modal-body" id="message-editor-body">
					<!-- 编辑器容器，JS会在这里动态生成文本框 -->
					<div id="message-editor-container"></div>
					<!-- 添加新消息的按钮 -->
					<button id="add-message-editor-block-btn" class="form-button form-button-secondary" style="margin-top: 15px">[+] 添加下一条消息</button>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-advanced-editor-btn">取消</button>
					<button class="save" id="save-advanced-editor-btn">保存更改</button>
				</div>
			</div>
		</div>

		<!-- 外卖请求模态框 -->
		<div id="waimai-request-modal" class="modal">
			<div class="modal-content" style="width: 290px">
				<div class="modal-header">
					<span>发起外卖代付</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label for="waimai-product-info">商品信息</label>
						<input type="text" id="waimai-product-info" placeholder="例如：一杯杨枝甘露" />
					</div>
					<div class="form-group">
						<label for="waimai-amount">代付金额 (元)</label>
						<input type="number" id="waimai-amount" placeholder="例如：21" min="0" step="0.01" />
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="waimai-cancel-btn">取消</button>
					<button class="save" id="waimai-confirm-btn">发起请求</button>
				</div>
			</div>
		</div>

		<!-- 新建约定/倒计时模态框 -->
		<div id="create-countdown-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span>新建约定</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label for="countdown-title-input">约定标题</label>
						<input type="text" id="countdown-title-input" placeholder="例如：我的生日" />
					</div>
					<div class="form-group">
						<label for="countdown-date-input">约定日期与时间</label>
						<input type="datetime-local" id="countdown-date-input" style="width: 95%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-color)" />
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-create-countdown-btn">取消</button>
					<button class="save" id="confirm-create-countdown-btn">保存约定</button>
				</div>
			</div>
		</div>

		<!-- 发红包模态框 -->
		<div id="red-packet-modal" class="modal">
			<div class="modal-content" style="width: 300px; height: auto">
				<div class="modal-header">
					<span>发红包</span>
				</div>
				<div class="modal-body" style="padding: 0">
					<!-- 页签切换 -->
					<div class="frame-tabs">
						<div id="rp-tab-group" class="frame-tab active">拼手气红包</div>
						<div id="rp-tab-direct" class="frame-tab">专属红包</div>
					</div>

					<!-- 拼手气红包内容区 -->
					<div id="rp-content-group" class="frame-content" style="padding: 20px 15px">
						<div class="form-group">
							<label>总金额 (元)</label>
							<input type="number" id="rp-group-amount" placeholder="0.00" />
						</div>
						<div class="form-group">
							<label>红包个数</label>
							<input type="number" id="rp-group-count" placeholder="填写红包个数" />
						</div>
						<div class="form-group">
							<label>祝福语</label>
							<input type="text" id="rp-group-greeting" placeholder="恭喜发财，大吉大利！" />
						</div>
						<p id="rp-group-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0">¥ 0.00</p>
						<button id="send-group-packet-btn" class="form-button">塞钱进红包</button>
					</div>

					<!-- 专属红包内容区 -->
					<div id="rp-content-direct" class="frame-content" style="display: none; padding: 20px 15px">
						<div class="form-group">
							<label>发送给</label>
							<select id="rp-direct-receiver"></select>
						</div>
						<div class="form-group">
							<label>金额 (元)</label>
							<input type="number" id="rp-direct-amount" placeholder="0.00" />
						</div>
						<div class="form-group">
							<label>祝福语</label>
							<input type="text" id="rp-direct-greeting" placeholder="恭喜发财，大吉大利！" />
						</div>
						<p id="rp-direct-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0">¥ 0.00</p>
						<button id="send-direct-packet-btn" class="form-button">塞钱进红包</button>
					</div>
				</div>
				<div class="modal-footer" style="justify-content: center">
					<button class="cancel" id="cancel-red-packet-btn" style="width: 100%">取消</button>
				</div>
			</div>
		</div>

		<!-- 红包详情模态框 -->
		<div id="red-packet-details-modal" class="modal">
			<div class="modal-content" style="width: 280px; height: auto; background-color: #f7f7f7">
				<div class="modal-header" style="background-color: #f96259; color: white; border-bottom: none; padding-bottom: 5px">
					<div style="text-align: center; width: 100%">
						<div id="rp-details-sender" style="font-size: 16px"></div>
						<div style="font-size: 13px; opacity: 0.8">的红包</div>
					</div>
				</div>
				<div class="modal-body" style="padding: 15px">
					<p id="rp-details-greeting" style="text-align: center; font-size: 20px; color: #333; margin: 0 0 20px 0"></p>
					<div id="rp-details-my-amount" style="text-align: center; display: none; margin-bottom: 20px">
						<span style="font-size: 40px; font-weight: bold; color: #e44d44">0.00</span>
						<span style="font-size: 18px; color: #e44d44">元</span>
					</div>
					<div id="rp-details-summary" style="font-size: 13px; color: #8a8a8a; border-top: 1px solid #e0e0e0; padding-top: 10px"></div>
					<div id="rp-details-list" style="max-height: 150px; overflow-y: auto; margin-top: 10px">
						<!-- 领取详情将由JS动态生成在这里 -->
					</div>
				</div>
				<div class="modal-footer">
					<button class="save" id="close-rp-details-btn" style="width: 100%">关闭</button>
				</div>
			</div>
		</div>

		<!-- 创建投票模态框 -->
		<div id="create-poll-modal" class="modal">
			<div class="modal-content" style="width: 300px; height: auto">
				<div class="modal-header">
					<span>发起投票</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label for="poll-question-input">投票问题</label>
						<textarea id="poll-question-input" rows="2" placeholder="例如：今晚我们看什么电影？"></textarea>
					</div>
					<div class="form-group">
						<label>投票选项 (至少2项)</label>
						<div id="poll-options-container" style="display: flex; flex-direction: column; gap: 8px">
							<!-- 投票选项将由JS动态生成在这里 -->
						</div>
						<button id="add-poll-option-btn" class="form-button form-button-secondary" style="margin-top: 12px">+ 添加选项</button>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-create-poll-btn">取消</button>
					<button class="save" id="confirm-create-poll-btn">发起投票</button>
				</div>
			</div>
		</div>

		<!-- AI头像库管理模态框 -->
		<div id="ai-avatar-library-modal" class="modal">
			<div class="modal-content" style="height: 70%">
				<div class="modal-header">
					<span id="ai-avatar-library-title">对方的头像库</span>
					<button id="add-ai-avatar-btn" class="action-button">添加</button>
				</div>
				<div class="modal-body" style="padding: 15px">
					<div id="ai-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px">
						<!-- 头像库内容将由JS动态生成 -->
					</div>
				</div>
				<div class="modal-footer">
					<button class="save" id="close-ai-avatar-library-btn" style="width: 100%">关闭</button>
				</div>
			</div>
		</div>

		<!-- 用户分享链接模态框 -->
		<div id="share-link-modal" class="modal">
			<div class="modal-content" style="width: 300px; height: auto">
				<div class="modal-header">
					<span>分享链接</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label for="link-title-input">标题</label>
						<input type="text" id="link-title-input" placeholder="输入文章或链接的标题" />
					</div>
					<div class="form-group">
						<label for="link-description-input">摘要 (可选)</label>
						<textarea id="link-description-input" rows="2" placeholder="简单描述一下链接内容"></textarea>
					</div>
					<div class="form-group">
						<label for="link-source-input">来源名称 (可选)</label>
						<input type="text" id="link-source-input" placeholder="例如：知乎日报、B站" />
					</div>
					<div class="form-group">
						<label for="link-content-input">完整内容 (可选，用于浏览器内显示)</label>
						<textarea id="link-content-input" rows="4" placeholder="粘贴或输入完整的文章内容"></textarea>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-share-link-btn">取消</button>
					<button class="save" id="confirm-share-link-btn">分享</button>
				</div>
			</div>
		</div>

		<!-- 精致版转账操作弹窗 -->
		<div id="transfer-actions-modal" class="modal">
			<div class="transfer-actions-content">
				<div class="transfer-actions-header">请选择操作</div>
				<div class="transfer-actions-body">
					<p>你收到了来自 <strong id="transfer-sender-name"></strong> 的一笔转账。</p>
				</div>
				<div class="transfer-actions-footer">
					<button id="transfer-action-decline" class="action-btn decline">残忍拒绝</button>
					<button id="transfer-action-accept" class="action-btn accept">开心收下</button>
				</div>
				<button id="transfer-action-cancel" class="cancel-btn">×</button>
			</div>
		</div>

		<!-- 通话记录详情模态框 -->
		<div id="call-transcript-modal" class="modal">
			<div class="modal-content" style="height: 70%">
				<div class="modal-header">
					<span id="transcript-modal-title">通话详情</span>
				</div>
				<div class="modal-body" id="transcript-modal-body" style="background-color: #f0f2f5">
					<!-- 通话文字记录将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button class="cancel" id="delete-transcript-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30">删除记录</button>
					<button class="save" id="close-transcript-modal-btn" style="width: 100%">关闭</button>
				</div>
			</div>
		</div>

		<!-- 分享目标选择器模态框 -->
		<div id="share-target-modal" class="modal">
			<div class="modal-content" style="height: 70%">
				<div class="modal-header">
					<span id="share-target-modal-title">分享到...</span>
				</div>
				<div class="modal-body" id="share-target-list" style="padding: 0">
					<!-- 聊天列表将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-share-target-btn">取消</button>
					<button class="save" id="confirm-share-target-btn">确认分享</button>
				</div>
			</div>
		</div>

		<!-- 分享记录查看器模态框 -->
		<div id="shared-history-viewer-modal" class="modal">
			<div class="modal-content" style="height: 80%">
				<div class="modal-header">
					<span id="shared-history-viewer-title">聊天记录</span>
				</div>
				<div class="modal-body" id="shared-history-viewer-content" style="background-color: #f0f2f5">
					<!-- 分享的聊天记录气泡将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button class="save" id="close-shared-history-viewer-btn" style="width: 100%">关闭</button>
				</div>
			</div>
		</div>

		<!-- 世界书分类管理模态框 -->
		<div id="world-book-category-manager-modal" class="modal">
			<div class="modal-content" style="height: 60%">
				<div class="modal-header">
					<span>管理世界书分类</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label>新建分类</label>
						<div style="display: flex; gap: 10px">
							<input type="text" id="new-category-name-input" placeholder="输入分类名..." style="flex-grow: 1" />
							<button id="add-new-category-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px">添加</button>
						</div>
					</div>
					<hr style="opacity: 0.2" />
					<div id="existing-categories-list" style="display: flex; flex-direction: column; gap: 10px">
						<!-- 分类列表将由JS动态生成 -->
					</div>
				</div>
				<div class="modal-footer">
					<button class="save" id="close-category-manager-btn" style="width: 100%">完成</button>
				</div>
			</div>
		</div>

		<!-- 角色专属NPC库管理界面 -->
		<div id="npc-management-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="back-from-npc-management">‹</span>
				<span id="npc-management-title">NPC 库管理</span>
				<span class="action-btn" id="add-new-npc-btn">+</span>
			</div>
			<div class="list-container" id="npc-management-list">
				<!-- NPC列表将由JS动态生成在这里 -->
			</div>
		</div>

		<!-- 论坛主屏幕 (显示所有小组) -->
		<div id="forum-screen" class="screen">
			<div class="header">
				<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
				<span>圈子</span>
				<div class="header-actions">
					<!-- 筛选按钮 -->
					<span class="action-btn filter-btn" id="forum-filter-btn" title="筛选">
						<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>
					</span>
					<span class="action-btn" id="create-group-btn" style="font-size: 28px; font-weight: 300">+</span>
				</div>
			</div>
			<div id="forum-group-list" class="list-container" style="padding: 15px; display: grid; grid-template-columns: 1fr 1fr; gap: 15px; align-content: start">
				<!-- 小组列表将由JS动态生成在这里 -->
			</div>
		</div>

		<!-- 小组屏幕 -->
		<div id="group-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="back-to-forum-list">‹</span>
				<span id="group-screen-title">小组名称</span>
				<div class="header-actions">
					<!-- 筛选按钮 -->
					<span class="action-btn filter-btn" id="group-filter-btn" title="筛选">
						<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>
					</span>
					<!-- 生成内容按钮 -->
					<span class="action-btn" id="generate-group-content-btn" title="生成内容">
						<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
					</span>
					<span class="action-btn" id="create-forum-post-btn" style="font-size: 28px; font-weight: 300">+</span>
				</div>
			</div>
			<!-- CP偏好设置栏 -->
			<div id="fanfic-preference-bar" style="display: none; padding: 10px 15px; background-color: #f0f2f5; border-bottom: 1px solid var(--border-color); flex-shrink: 0">
				<div class="form-group" style="margin: 0">
					<label style="font-size: 14px; margin-bottom: 5px">选择CP偏好</label>
					<div style="display: flex; align-items: center; gap: 10px">
						<select id="fanfic-char1-select" style="flex: 1"></select>
						<span>&</span>
						<select id="fanfic-char2-select" style="flex: 1"></select>
						<button id="trigger-fanfic-generation-btn" class="form-button" style="margin: 0; padding: 10px 15px; width: auto">生成</button>
					</div>
				</div>
				<!-- 世界观偏好输入框 -->
				<div class="form-group" style="margin-top: 10px; margin-bottom: 0">
					<label for="fanfic-worldview-input" style="font-size: 14px; margin-bottom: 5px">世界观偏好 (可选)</label>
					<input type="text" id="fanfic-worldview-input" placeholder="例如：ABO、哨向、现代大学AU..." />
				</div>
			</div>

			<div id="group-post-list" class="list-container" style="padding-top: 0">
				<!-- 帖子列表将由JS动态生成在这里 -->
			</div>
		</div>

		<!-- 单个帖子页面 (显示帖子内容和评论) -->
		<div id="post-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="back-to-group-screen">‹</span>
				<span>帖子详情</span>
				<div class="header-actions">
					<span class="action-btn" id="repost-to-chat-btn">转载</span>
				</div>
			</div>
			<div id="post-detail-content" class="list-container" style="padding: 20px">
				<!-- 帖子和评论将由JS动态生成在这里 -->
			</div>
			<!-- 帖子页的评论输入框 -->
			<div id="post-comment-input-area" class="chat-input-area" style="visibility: visible">
				<div class="chat-input-main-row">
					<textarea id="post-comment-input" rows="1" placeholder="发布你的评论..."></textarea>
					<button id="send-post-comment-btn" class="action-button">发送</button>
				</div>
			</div>
		</div>

		<!-- 圈子分类筛选弹窗 -->
		<div id="forum-filter-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 60%">
				<div class="modal-header">
					<span>按分类筛选</span>
				</div>
				<div class="modal-body">
					<div id="forum-filter-category-list">
						<!-- 分类标签将由JS动态生成在这里 -->
					</div>
				</div>
				<div class="modal-footer" style="justify-content: space-between">
					<button class="cancel" id="reset-forum-filter-btn" style="width: 30%">重置</button>
					<button class="cancel" id="cancel-forum-filter-btn" style="width: 30%">取消</button>
					<button class="save" id="apply-forum-filter-btn" style="width: 30%">应用</button>
				</div>
			</div>
		</div>

		<!-- 自定义头像框管理模态框 -->
		<div id="custom-frame-manager-modal" class="modal">
			<div class="modal-content" style="height: 70%">
				<div class="modal-header">
					<span>管理我的头像框</span>
					<button id="upload-custom-frame-btn" class="action-button">上传</button>
				</div>
				<div class="modal-body" style="padding: 15px">
					<div id="custom-frame-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px">
						<!-- 自定义头像框将由JS动态生成在这里 -->
					</div>
				</div>
				<div class="modal-footer">
					<button class="save" id="close-frame-manager-btn" style="width: 100%">关闭</button>
				</div>
			</div>
		</div>
		<input type="file" id="custom-frame-upload-input" accept="image/png, image/gif" hidden multiple />

		<!-- 头像框选择模态框 -->
		<div id="avatar-frame-modal" class="modal">
			<div class="modal-content" style="height: 70%">
				<div class="modal-header">
					<span>选择头像框</span>
					<!-- 管理按钮 -->
					<button id="manage-custom-frames-btn" class="action-button">管理</button>
				</div>
				<div class="modal-body" style="padding: 15px">
					<!-- 头像框网格 -->
					<div id="avatar-frame-grid" class="frame-grid">
						<!-- 头像框选项（包括"无"和自定义的）会在这里生成 -->
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-frame-settings-btn">取消</button>
					<button class="save" id="save-frame-settings-btn">保存</button>
				</div>
			</div>
		</div>

		<!-- 发送定位与轨迹模态框 -->
		<div id="send-location-modal" class="modal">
			<div class="modal-content" style="width: 300px; height: auto; max-height: 80%">
				<div class="modal-header">
					<span>发送定位与轨迹</span>
				</div>
				<div class="modal-body" style="padding-bottom: 5px">
					<!-- 核心信息 -->
					<div class="form-group">
						<label for="user-location-input">我的位置 (起点)</label>
						<input type="text" id="user-location-input" placeholder="例如：市中心的咖啡馆" />
					</div>
					<div class="form-group">
						<label for="ai-location-input">Ta的位置 (终点)</label>
						<input type="text" id="ai-location-input" placeholder="例如：海边的灯塔" />
					</div>
					<div class="form-group">
						<label for="distance-input">相距</label>
						<input type="text" id="distance-input" placeholder="例如：约5公里 (必填)" />
					</div>

					<hr style="opacity: 0.2" />

					<!-- 行动轨迹输入区 -->
					<div class="form-group">
						<label>行动轨迹 (可选，按顺序填写)</label>
						<div id="trajectory-points-container" style="display: flex; flex-direction: column; gap: 8px">
							<!-- JS会在这里动态添加输入框 -->
						</div>
						<button id="add-trajectory-point-btn" class="form-button form-button-secondary" style="margin-top: 12px">+ 添加途经点</button>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="location-cancel-btn">取消</button>
					<button class="save" id="location-confirm-btn">发送</button>
				</div>
			</div>
		</div>

		<!-- 悬浮歌词栏设置模态框 -->
		<div id="lyrics-settings-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span>悬浮歌词设置</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label for="lyrics-font-size-slider">字体大小: <span id="lyrics-font-size-value">14px</span></label>
						<input type="range" id="lyrics-font-size-slider" min="12" max="24" value="14" style="width: 100%" />
					</div>
					<div class="form-group">
						<label for="lyrics-bg-opacity-slider">背景不透明度: <span id="lyrics-bg-opacity-value">0%</span></label>
						<input type="range" id="lyrics-bg-opacity-slider" min="0" max="100" value="0" style="width: 100%" />
					</div>
					<div class="form-group">
						<label for="lyrics-font-color-picker">字体颜色</label>
						<input type="color" id="lyrics-font-color-picker" value="#FFFFFF" style="width: 100%; height: 40px" />
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="reset-lyrics-settings-btn">恢复默认</button>
					<button class="save" id="close-lyrics-settings-btn">完成</button>
				</div>
			</div>
		</div>

		<!-- 音乐搜索源选择模态框 -->
		<div id="music-source-selector-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span>选择搜索源</span>
				</div>
				<div class="modal-body" style="text-align: left; padding: 20px">
					<label style="display: block; margin-bottom: 15px; cursor: pointer"> <input type="radio" name="search-source" value="all" checked /> 全部来源 (网易云 + QQ音乐) </label>
					<label style="display: block; margin-bottom: 15px; cursor: pointer"> <input type="radio" name="search-source" value="netease" /> 仅网易云音乐 </label>
					<label style="display: block; cursor: pointer"> <input type="radio" name="search-source" value="tencent" /> 仅QQ音乐 </label>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-source-select-btn">取消</button>
					<button class="save" id="confirm-source-select-btn">开始搜索</button>
				</div>
			</div>
		</div>

		<!-- 微博关注列表弹窗 -->
		<div id="weibo-following-modal" class="modal">
			<div class="modal-content" style="height: 60%">
				<div class="modal-header">
					<span>关注列表</span>
				</div>
				<div class="modal-body" style="padding: 0">
					<!-- 关注列表容器 -->
					<div id="weibo-following-list-container">
						<!-- 关注列表将由JS动态生成在这里 -->
					</div>
				</div>
				<div class="modal-footer">
					<button class="save" id="close-following-list-btn" style="width: 100%">关闭</button>
				</div>
			</div>
		</div>

		<!-- 塔罗牌占卜主模态框 -->
		<div id="tarot-divination-modal" class="modal">
			<div class="modal-content" style="height: 85%; width: 95%">
				<!-- 占卜设置界面 -->
				<div id="tarot-setup-view">
					<div class="modal-header">
						<span>塔罗牌占卜</span>
						<div>
							<span id="tarot-history-btn" class="action-btn" style="font-size: 16px">历史</span>
							<span id="close-tarot-modal-btn" class="action-btn" style="font-size: 16px">关闭</span>
						</div>
					</div>
					<div class="modal-body">
						<div class="form-group">
							<label for="tarot-question-input">您的问题或关注点</label>
							<textarea id="tarot-question-input" rows="2" placeholder="例如：我近期的桃花运如何？"></textarea>
						</div>
						<div class="form-group">
							<label for="tarot-spread-select">选择牌阵</label>
							<select id="tarot-spread-select">
								<option value="single">单张牌 - 快速指引</option>
								<option value="three_past_present_future">三张牌 - 过去/现在/未来</option>
								<option value="three_situation_challenge_advice">三张牌 - 情境/挑战/建议</option>
								<option value="celtic_cross">凯尔特十字 - 深度分析 (10张牌)</option>
							</select>
						</div>
						<div class="form-group">
							<label>牌面方向</label>
							<div style="display: flex; gap: 20px">
								<label><input type="radio" name="tarot-orientation" value="upright" checked /> 仅正位</label>
								<label><input type="radio" name="tarot-orientation" value="reversed" /> 包含逆位</label>
							</div>
						</div>
						<button id="draw-tarot-cards-btn" class="form-button" style="margin-top: 20px">洗牌并抽牌</button>
					</div>
				</div>

				<!-- 占卜结果界面 (默认隐藏) -->
				<div id="tarot-result-view" style="display: none; height: 100%; display: flex; flex-direction: column">
					<div class="modal-header">
						<span id="back-to-tarot-setup-btn" class="action-btn" style="font-size: 16px">返回</span>
						<span>占卜结果</span>
					</div>
					<div class="modal-body" id="tarot-result-display">
						<!-- 结果将由JS动态生成在这里 -->
					</div>
					<div class="modal-footer">
						<button id="send-tarot-result-btn" class="save" style="width: 100%">发给塔罗师解读</button>
					</div>
				</div>

				<!-- 历史记录界面 (默认隐藏) -->
				<div id="tarot-history-view" style="display: none; height: 100%; display: flex; flex-direction: column">
					<div class="modal-header">
						<span id="back-to-tarot-main-btn" class="action-btn" style="font-size: 16px">返回</span>
						<span>占卜历史</span>
					</div>
					<div class="modal-body" id="tarot-history-list">
						<!-- 历史记录将由JS动态生成在这里 -->
					</div>
				</div>
			</div>
		</div>

		<!-- 情侣空间功能HTML代码 -->

		<!-- 切换角色的弹窗 -->
		<div id="ls-char-selector-modal" class="modal">
			<div class="modal-content" style="height: 60%">
				<div class="modal-header">
					<span>选择空间</span>
				</div>
				<div class="modal-body" id="ls-char-selector-list" style="padding: 0">
					<!-- 角色列表会由JS动态生成 -->
				</div>
				<div class="modal-footer">
					<button class="cancel" id="ls-cancel-switch-char-btn" style="width: 100%">取消</button>
				</div>
			</div>
		</div>

		<!-- 发布说说的弹窗 -->
		<div id="ls-create-moment-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span>想对Ta说...</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<textarea id="ls-moment-content-input" rows="5" placeholder="在这里写下你们的私密话语..."></textarea>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="ls-cancel-moment-btn">取消</button>
					<button class="save" id="ls-confirm-moment-btn">发布</button>
				</div>
			</div>
		</div>

		<!-- 创建相册/上传照片的弹窗 -->
		<div id="ls-create-album-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<!-- 标题 -->
					<span id="ls-album-modal-title">上传照片</span>
				</div>
				<div class="modal-body">
					<!-- 模式切换开关 -->
					<div class="post-mode-switcher">
						<button id="ls-switch-to-image-mode" class="mode-btn active">上传图片</button>
						<button id="ls-switch-to-text-image-mode" class="mode-btn">使用文字图</button>
					</div>

					<!-- 模式1: 上传图片 -->
					<div id="ls-image-mode-content" class="post-mode-content active">
						<div class="form-group">
							<label>选择照片 (仅限单张)</label>
							<div id="ls-photo-preview-container"></div>
							<button class="form-button form-button-secondary" id="ls-select-photos-btn">选择照片</button>
							<!-- 照片选择输入框 -->
							<input type="file" id="ls-photo-input" accept="image/*" hidden />
						</div>
						<div class="form-group">
							<label>图片描述 (必填)</label>
							<textarea id="ls-photo-desc-input" rows="3" placeholder="为这张照片写下注脚..."></textarea>
						</div>
					</div>

					<!-- 模式2: 使用文字图 -->
					<div id="ls-text-image-mode-content" class="post-mode-content" style="display: none">
						<div class="form-group">
							<label>文字图描述 (必填)</label>
							<textarea id="ls-text-image-desc-input" rows="5" placeholder="在这里写下你的心情或故事..."></textarea>
						</div>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="ls-cancel-album-btn">取消</button>
					<button class="save" id="ls-confirm-album-btn">确认上传</button>
				</div>
			</div>
		</div>

		<!-- 情侣空间-写情书/回信的弹窗 -->
		<div id="ls-create-letter-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span id="ls-letter-modal-title">给Ta写一封信</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label for="ls-letter-recipient-input">收信人</label>
						<!-- 收信人输入框 -->
						<input type="text" id="ls-letter-recipient-input" disabled />
					</div>
					<div class="form-group">
						<label for="ls-letter-content-input">情书内容</label>
						<textarea id="ls-letter-content-input" rows="8" placeholder="在这里写下你的心意..."></textarea>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="ls-cancel-letter-btn">取消</button>
					<button class="save" id="ls-confirm-letter-btn">寄出</button>
				</div>
			</div>
		</div>

		<!-- 情侣空间-情书查看器 -->
		<div id="ls-letter-viewer-modal" class="modal">
			<div class="ls-letter-viewer-content">
				<!-- 头部：收信人信息 -->
				<div class="letter-viewer-header">
					<img id="ls-viewer-recipient-avatar" class="meta-avatar" />
					<div class="recipient-info">
						<div class="label">To my dear:</div>
						<div id="ls-viewer-recipient-name" class="name"></div>
					</div>
				</div>
				<!-- 中间：信件正文 -->
				<div id="ls-viewer-body" class="letter-viewer-body">
					<!-- JS会在这里填充信件内容 -->
				</div>
				<!-- 底部：发信人信息和操作按钮 -->
				<div class="letter-viewer-footer">
					<div class="sender-info">
						<div id="ls-viewer-sender-name"></div>
						<div id="ls-viewer-timestamp" class="timestamp"></div>
					</div>
					<div class="letter-actions">
						<button id="ls-close-letter-viewer-btn">关闭</button>
						<button id="ls-reply-letter-btn" class="primary">回信</button>
					</div>
				</div>
			</div>
		</div>

		<!-- 情侣空间设置弹窗 -->
		<div id="ls-settings-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span>情侣空间设置</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label for="ls-start-date-input">我们在一起的第一天</label>
						<input type="date" id="ls-start-date-input" style="width: 100%; padding: 10px; box-sizing: border-box" />
					</div>

					<hr style="opacity: 0.2; margin: 20px 0" />
					<div class="form-group">
						<label>危险操作</label>
						<div style="display: flex; gap: 10px">
							<button id="ls-cancel-space-btn" class="form-button form-button-secondary" style="background-color: #ffe5e5; color: #ff3b30; border-color: #ffc2d1; flex: 1; margin: 0">取消空间</button>
							<button id="ls-disconnect-space-btn" class="form-button form-button-secondary" style="background-color: #ff3b30; color: white; border-color: #ff3b30; flex: 1; margin: 0">解除关系</button>
						</div>
						<p style="font-size: 12px; color: #8a8a8a; margin-top: 8px">
							<strong>取消空间</strong>: 将空间变为未启用状态，但保留所有数据。不会通知对方。<br />
							<strong>解除关系</strong>: 同样会取消空间，但会通知对方关系已解除，对方会对此发表意见。
						</p>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="ls-settings-cancel-btn">取消</button>
					<button class="save" id="ls-settings-save-btn">保存</button>
				</div>
			</div>
		</div>

		<!-- 情侣空间-提问弹窗 -->
		<div id="ls-ask-question-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span>发起一个提问</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<textarea id="ls-question-content-input" rows="5" placeholder="向Ta提个问题吧..."></textarea>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="ls-cancel-ask-btn">取消</button>
					<button class="save" id="ls-confirm-ask-btn">向Ta提问</button>
				</div>
			</div>
		</div>

		<!-- 情侣空间-回答弹窗 -->
		<div id="ls-answer-question-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span>回答Ta的问题</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label>问题：</label>
						<p id="ls-answer-question-text" style="background-color: #f0f2f5; padding: 10px; border-radius: 8px"></p>
					</div>
					<div class="form-group">
						<label for="ls-answer-content-input">你的回答：</label>
						<textarea id="ls-answer-content-input" rows="5" placeholder="认真回答哦..."></textarea>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="ls-cancel-answer-btn">取消</button>
					<button class="save" id="ls-confirm-answer-btn">确认回答</button>
				</div>
			</div>
		</div>

		<!-- 情侣空间专属音乐播放器 -->

		<!-- 播放器专属的音频引擎 -->
		<audio id="ls-audio-player" style="display: none"></audio>

		<!-- 播放器的主窗口界面 -->
		<div id="ls-music-player-overlay" class="modal">
			<div class="music-player-window">
				<!-- 封面和歌词的切换容器 -->
				<div id="ls-display-area" style="width: 192px; height: 192px; margin-bottom: 20px; cursor: pointer">
					<!-- 歌曲封面 -->
					<img id="ls-album-cover" src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png" alt="歌曲封面" style="width: 100%; height: 100%; border-radius: 12px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2)" />

					<!-- 歌词容器 -->
					<div id="ls-lyrics-container" style="display: none; width: 100%; height: 100%; overflow: hidden; text-align: center; color: #333; font-weight: 500">
						<div id="ls-lyrics-list" style="transition: transform 0.5s ease">
							<!-- 歌词会显示在这里 -->
						</div>
					</div>
				</div>

				<!-- 歌曲信息 -->
				<div id="ls-song-title" style="font-size: 18px; font-weight: 600">暂无歌曲</div>
				<div id="ls-artist" style="font-size: 14px; color: #666; margin-bottom: 15px">...</div>

				<!-- 进度条 -->
				<div class="music-progress-bar-container" style="width: 100%">
					<div id="ls-current-time" class="time-display">0:00</div>
					<div class="progress-bar" id="ls-progress-bar">
						<div id="ls-progress-fill" class="progress-bar-fill"></div>
					</div>
					<div id="ls-total-time" class="time-display">0:00</div>
				</div>

				<!-- 控制按钮 -->
				<div class="music-controls" style="margin-bottom: 15px">
					<button id="ls-prev-btn">◀</button>
					<button id="ls-play-pause-btn" class="play-pause-btn">▶</button>
					<button id="ls-next-btn">▶</button>
				</div>

				<!-- 底部操作按钮 -->
				<div class="music-bottom-actions" style="width: 100%">
					<button id="ls-playlist-btn" style="background-color: rgba(0, 123, 255, 0.1); color: var(--accent-color); margin-right: 5px">播放列表</button>
					<button id="ls-close-player-btn" style="background-color: rgba(0, 0, 0, 0.05); color: #333; margin-left: 5px">关闭</button>
				</div>
			</div>
		</div>

		<!-- 播放列表的侧滑面板 -->
		<div id="ls-music-playlist-panel" class="music-playlist-panel">
			<div class="playlist-header">
				<span class="panel-btn" id="ls-close-playlist-btn">返回</span>
				<span>播放列表</span>
				<span class="panel-btn" id="ls-clear-playlist-btn" style="color: #ff3b30">清空</span>
			</div>
			<div class="playlist-body" id="ls-playlist-body">
				<!-- 播放列表内容会在这里生成 -->
			</div>
		</div>

		<!-- 情侣番茄钟-设置弹窗 -->
		<div id="ls-pomodoro-setup-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span>新的专注时光</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label for="pomodoro-task-input">专注任务</label>
						<input type="text" id="pomodoro-task-input" placeholder="例如：学习JS、完成工作报告" />
					</div>
					<div class="form-group">
						<label for="pomodoro-duration-input">专注时长 (分钟)</label>
						<input type="number" id="pomodoro-duration-input" value="25" min="1" />
					</div>
					<div class="form-group">
						<label>计时模式</label>
						<div style="display: flex; gap: 20px">
							<label><input type="radio" name="pomodoro-mode" value="countdown" checked /> 倒计时</label>
							<label><input type="radio" name="pomodoro-mode" value="countup" /> 正计时</label>
						</div>
					</div>
					<div class="form-group">
						<label for="pomodoro-talk-interval-input">角色鼓励间隔 (分钟, 0为不自动鼓励)</label>
						<input type="number" id="pomodoro-talk-interval-input" value="5" min="0" />
					</div>
					<!-- 番茄钟背景设置 -->
					<div class="form-group">
						<label>自定义背景 (可选)</label>
						<div style="display: flex; gap: 10px; align-items: center">
							<input type="text" id="pomodoro-bg-url-input" placeholder="粘贴图片URL" style="flex-grow: 1" />
							<button id="pomodoro-bg-local-upload-btn" class="form-button-secondary" style="margin: 0; padding: 12px; width: auto">本地上传</button>
						</div>
						<input type="file" id="pomodoro-bg-file-input" accept="image/*" hidden />
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="pomodoro-cancel-setup-btn">取消</button>
					<button class="save" id="pomodoro-confirm-setup-btn">开始专注</button>
				</div>
			</div>
		</div>

		<!-- 情侣番茄钟-历史详情弹窗 -->
		<div id="ls-pomodoro-history-viewer-modal" class="modal">
			<div class="modal-content" style="height: 70%">
				<div class="modal-header">
					<span id="pomodoro-history-viewer-title">专注记录</span>
				</div>
				<div class="modal-body" id="pomodoro-history-viewer-content">
					<!-- 聊天记录会由JS生成在这里 -->
				</div>
				<div class="modal-footer">
					<button class="save" id="pomodoro-close-history-viewer-btn" style="width: 100%">关闭</button>
				</div>
			</div>
		</div>

		<!-- 小组编辑器弹窗 (用于修改小组信息和世界观) -->
		<div id="forum-group-editor-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 80%">
				<div class="modal-header">
					<span>编辑小组信息</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label for="group-editor-name-input">小组名称</label>
						<input type="text" id="group-editor-name-input" />
					</div>
					<div class="form-group">
						<label for="group-editor-desc-input">小组简介</label>
						<input type="text" id="group-editor-desc-input" />
					</div>
					<div class="form-group">
						<label for="group-editor-icon-input">小组图标 (Emoji)</label>
						<input type="text" id="group-editor-icon-input" maxlength="2" />
					</div>
					<div class="form-group">
						<label for="group-editor-categories-input">小组分类 (用#号分隔, 例如: #科幻 #未来)</label>
						<input type="text" id="group-editor-categories-input" placeholder="例如: #科幻 #未来" />
					</div>
					<div class="form-group">
						<label for="group-editor-worldview-input">小组世界观 (供AI生成内容时参考)</label>
						<textarea id="group-editor-worldview-input" rows="5" placeholder="详细描述这个小组独特的背景设定..."></textarea>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-group-editor-btn">取消</button>
					<button class="save" id="save-group-editor-btn">保存</button>
				</div>
			</div>
		</div>

		<!-- 分类管理弹窗 -->
		<div id="forum-category-manager-modal" class="modal">
			<div class="modal-content" style="height: 60%">
				<div class="modal-header">
					<span>管理圈子分类</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label>新建分类</label>
						<div style="display: flex; gap: 10px">
							<input type="text" id="new-forum-category-name-input" placeholder="输入分类名，无需带'#'..." style="flex-grow: 1" />
							<button id="add-new-forum-category-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px">添加</button>
						</div>
					</div>
					<hr style="opacity: 0.2" />
					<div id="existing-forum-categories-list" style="display: flex; flex-direction: column; gap: 10px">
						<!-- 分类列表将由JS动态生成 -->
					</div>
				</div>
				<div class="modal-footer">
					<button class="save" id="close-forum-category-manager-btn" style="width: 100%">完成</button>
				</div>
			</div>
		</div>

		<!-- 游戏大厅的主界面 -->
		<div id="game-hall-screen" class="screen">
			<div class="header">
				<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
				<span>游戏大厅</span>
				<span style="width: 30px"></span>
				<!-- 占位符 -->
			</div>
			<div class="list-container" style="padding: 20px">
				<p style="text-align: center; color: var(--text-secondary)">选择一个游戏开始吧！</p>
				<div id="game-hall-grid">
					<!-- 游戏列表将显示在这里 -->
					<div class="game-card" data-game="werewolf">
						<div class="game-icon">🐺</div>
						<div class="game-info">
							<div class="game-title">狼人杀</div>
							<div class="game-desc">逻辑与谎言的对决</div>
						</div>
					</div>
					<div class="game-card" data-game="sea-turtle-soup">
						<div class="game-icon">🐢</div>
						<div class="game-info">
							<div class="game-title">海龟汤</div>
							<div class="game-desc">揭开情景的真相</div>
						</div>
					</div>
					<div class="game-card" data-game="script-kill">
						<div class="game-icon">📜</div>
						<div class="game-info">
							<div class="game-title">剧本杀</div>
							<div class="game-desc">扮演角色，探寻谜案</div>
						</div>
					</div>
					<div class="game-card" data-game="guess-what">
						<div class="game-icon">🗣️</div>
						<div class="game-info">
							<div class="game-title">你说我猜</div>
							<div class="game-desc">考验默契的时候到了</div>
						</div>
					</div>
					<div class="game-card" data-game="ludo">
						<div class="game-icon">🎲</div>
						<div class="game-info">
							<div class="game-title">心动飞行棋</div>
							<div class="game-desc">和Ta来一场只属于你们的冒险</div>
						</div>
					</div>
					<div class="game-card" data-game="undercover">
						<div class="game-icon">🕵️</div>
						<div class="game-info">
							<div class="game-title">谁是卧底</div>
							<div class="game-desc">语言的伪装，逻辑的陷阱</div>
						</div>
					</div>
					<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); font-size: 14px; margin-top: 20px">更多游戏正在火速开发中...</p>
				</div>
			</div>
		</div>

		<!-- 狼人杀游戏设置屏幕 -->
		<div id="werewolf-setup-screen" class="screen">
			<div class="header">
				<span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
				<span>狼人杀 - 游戏设置</span>
			</div>
			<div class="form-container">
				<div class="form-group">
					<label for="werewolf-player-count">选择游戏人数</label>
					<select id="werewolf-player-count">
						<option value="6">6人局 (2狼, 2民, 预言家, 守卫)</option>
						<option value="9">9人局 (3狼, 3民, 预言家, 女巫, 猎人)</option>
						<option value="12">12人局 (4狼, 4民, 预言家, 女巫, 猎人, 白痴)</option>
					</select>
				</div>
				<div class="form-group">
					<label>邀请玩家 (你已自动加入)</label>
					<div id="werewolf-player-selection" class="list-container" style="height: 300px; border: 1px solid var(--border-color); border-radius: 8px">
						<!-- 玩家选择列表将由JS动态生成 -->
					</div>
				</div>
				<button id="start-werewolf-game-btn" class="form-button">开始游戏</button>
			</div>
		</div>

		<!-- 狼人杀游戏主界面 -->
		<div id="werewolf-game-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="exit-werewolf-game-btn">‹ 退出</span>
				<span id="werewolf-game-title">狼人杀</span>
				<span class="action-btn" id="werewolf-my-role-btn">我的身份</span>
			</div>
			<!-- 游戏主内容区 -->
			<div id="werewolf-game-content">
				<!-- 玩家座位区 -->
				<div id="werewolf-players-grid">
					<!-- 玩家头像和状态将由JS动态生成 -->
				</div>
				<!-- 游戏日志/信息区 -->
				<div id="werewolf-log-container">
					<div id="werewolf-game-log">
						<!-- 游戏过程信息会显示在这里 -->
					</div>
				</div>
				<!-- 玩家操作区 -->
				<div id="werewolf-action-area">
					<!-- 玩家的按钮会根据游戏阶段显示在这里 -->
				</div>
			</div>
		</div>

		<!-- 狼人杀游戏结算卡片 -->
		<div id="werewolf-summary-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 80%">
				<div class="modal-header">
					<span>游戏结算</span>
				</div>
				<div class="modal-body" id="werewolf-summary-content" style="white-space: pre-wrap; line-height: 1.7">
					<!-- 结算内容将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button class="cancel" id="repost-summary-btn">发送复盘到聊天</button>
					<button class="save" id="back-to-hall-btn">返回大厅</button>
				</div>
			</div>
		</div>

		<!-- 狼人杀复盘发送目标选择器 -->
		<div id="werewolf-target-picker-modal" class="modal">
			<div class="modal-content" style="height: 60%">
				<div class="modal-header">
					<span>选择要发送的玩家</span>
				</div>
				<div class="modal-body" id="werewolf-target-list" style="padding: 0">
					<!-- 玩家列表将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button id="wt-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0">全选</button>
					<button id="wt-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0">全不选</button>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="wt-cancel-btn">取消</button>
					<button class="save" id="wt-confirm-btn">确认发送</button>
				</div>
			</div>
		</div>

		<!-- 海龟汤游戏主界面 -->
		<div id="sea-turtle-soup-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="exit-sts-game-btn">‹ 退出</span>
				<span>海龟汤</span>
				<span class="action-btn" id="reveal-sts-answer-btn">揭晓答案</span>
			</div>
			<div id="sts-game-content" style="display: flex; flex-direction: column; height: 100%; overflow: hidden; padding: 10px; box-sizing: border-box">
				<!-- 玩家座位区 -->
				<div id="sts-players-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); gap: 10px; padding: 10px; flex-shrink: 0">
					<!-- 玩家头像和状态将由JS动态生成 -->
				</div>
				<!-- 游戏日志/信息区 -->
				<div id="sts-log-container" style="flex-grow: 1; background-color: rgba(0, 0, 0, 0.05); border-radius: 10px; padding: 10px; overflow-y: auto; margin: 10px 0; min-height: 0">
					<div id="sts-game-log">
						<!-- 游戏过程信息会显示在这里 -->
					</div>
				</div>
				<!-- 玩家操作输入区 -->
				<div id="sts-action-area" class="chat-input-area" style="visibility: visible">
					<div class="chat-input-main-row">
						<textarea id="sts-question-input" rows="1" placeholder="输入问题或答案..."></textarea>
						<!-- 新增"猜答案"按钮 -->
						<button id="guess-sts-answer-btn" class="action-button" style="background-color: #ff9800">猜答案</button>
						<button id="send-sts-question-btn" class="action-button">提问</button>
					</div>
				</div>
			</div>
		</div>

		<!-- 海龟汤游戏设置模态框 -->
		<div id="sea-turtle-soup-setup-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 85%">
				<div class="modal-header">
					<span>海龟汤 - 游戏设置</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label>邀请玩家 (你已自动加入)</label>
						<div id="sts-player-selection" class="list-container" style="height: 200px; border: 1px solid var(--border-color); border-radius: 8px">
							<!-- 玩家选择列表将由JS动态生成 -->
						</div>
					</div>
					<div class="form-group">
						<label>谁来出题？</label>
						<select id="sts-riddle-provider-select">
							<option value="user">我来出题</option>
							<option value="random_ai">随机一位AI</option>
						</select>
					</div>
					<!-- 用户出题的输入区 (默认隐藏) -->
					<div id="sts-user-riddle-input-area" style="display: none">
						<div class="form-group">
							<label for="sts-user-riddle-surface">谜面</label>
							<textarea id="sts-user-riddle-surface" rows="2" placeholder="例如：一个男人走进酒吧，要了一杯水..."></textarea>
						</div>
						<div class="form-group">
							<label for="sts-user-riddle-answer">谜底 (完整故事)</label>
							<textarea id="sts-user-riddle-answer" rows="4" placeholder="例如：男人在打嗝，他想喝水止嗝..."></textarea>
						</div>
					</div>
					<!-- AI出题的输入区 (默认隐藏) -->
					<div id="sts-ai-riddle-input-area" style="display: none">
						<div class="form-group">
							<label for="sts-ai-riddle-type">谜题类型 (可选)</label>
							<input type="text" id="sts-ai-riddle-type" placeholder="例如：恐怖、温情、脑洞、经典" />
						</div>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-sts-setup-btn">取消</button>
					<button class="save" id="start-sts-game-btn">开始游戏</button>
				</div>
			</div>
		</div>

		<!-- 海龟汤游戏结算卡片 -->
		<div id="sts-summary-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 80%">
				<div class="modal-header">
					<span>游戏结算</span>
				</div>
				<div class="modal-body" id="sts-summary-content" style="white-space: pre-wrap; line-height: 1.7">
					<!-- 结算内容将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button class="cancel" id="share-sts-summary-btn">分享复盘</button>
					<button class="save" id="back-to-hall-from-sts-btn">返回大厅</button>
				</div>
			</div>
		</div>

		<!-- 海龟汤复盘发送目标选择器 -->
		<div id="sts-share-target-modal" class="modal">
			<div class="modal-content" style="height: 60%">
				<div class="modal-header">
					<span>选择要分享的玩家</span>
				</div>
				<div class="modal-body" id="sts-share-target-list" style="padding: 0">
					<!-- 玩家列表将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button id="sts-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0">全选</button>
					<button id="sts-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0">全不选</button>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="sts-cancel-share-btn">取消</button>
					<button class="save" id="sts-confirm-share-btn">确认分享</button>
				</div>
			</div>
		</div>

		<!-- 剧本杀游戏设置屏幕 -->
		<div id="script-kill-setup-screen" class="screen">
			<div class="header">
				<span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
				<span>剧本杀 - 游戏设置</span>
			</div>
			<div class="form-container">
				<div class="form-group">
					<label>选择剧本</label>
					<div style="display: flex; gap: 10px">
						<select id="script-kill-script-select" style="flex-grow: 1"></select>
						<button id="manage-custom-scripts-btn" class="form-button-secondary" style="margin-top: 0; padding: 0 15px">管理</button>
					</div>
				</div>
				<div class="form-group">
					<label>邀请玩家 (你已自动加入)</label>
					<div id="script-kill-player-selection" class="list-container" style="height: 300px; border: 1px solid var(--border-color); border-radius: 8px">
						<!-- 玩家选择列表将由JS动态生成 -->
					</div>
				</div>
				<div class="form-group">
					<label class="toggle-switch-label">
						<span class="toggle-switch-text">自由选择角色 (关闭则随机分配)</span>
						<input type="checkbox" id="script-kill-free-choice-toggle" />
						<span class="toggle-switch-slider"></span>
					</label>
				</div>
				<button id="start-script-kill-game-btn" class="form-button">开始游戏</button>
			</div>
		</div>

		<!-- 剧本杀游戏主界面 -->
		<div id="script-kill-game-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="exit-script-kill-game-btn">‹ 退出</span>
				<span id="script-kill-game-title">剧本杀</span>
				<div class="header-actions">
					<span class="action-btn" id="script-kill-my-role-btn">我的角色</span>
					<span class="action-btn" id="script-kill-all-evidence-btn">公共线索</span>
				</div>
			</div>
			<div id="script-kill-game-content">
				<div id="script-kill-players-grid">
					<!-- 玩家头像和状态将由JS动态生成 -->
				</div>
				<div id="script-kill-log-container">
					<div id="script-kill-game-log">
						<!-- 游戏过程信息会显示在这里 -->
					</div>
				</div>
				<div id="script-kill-action-area">
					<!-- 玩家的按钮会根据游戏阶段显示在这里 -->
				</div>
			</div>
		</div>

		<!-- 剧本杀自定义剧本管理模态框 -->
		<div id="script-kill-manager-modal" class="modal">
			<div class="modal-content" style="height: 70%">
				<div class="modal-header">
					<span>管理自定义剧本</span>
					<div class="header-actions">
						<!-- AI生成剧本按钮 -->
						<button id="open-sk-ai-generator-btn" class="action-button" style="font-size: 14px">AI生成</button>
						<button id="add-new-script-btn" class="action-button">添加</button>
					</div>
				</div>

				<div class="modal-body" id="custom-scripts-list" style="padding: 0">
					<!-- 自定义剧本列表将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button class="save" id="close-script-manager-btn" style="width: 100%">完成</button>
				</div>
			</div>
		</div>

		<!-- 剧本编辑器主弹窗 (可视化版) -->
		<div id="script-kill-editor-modal" class="modal">
			<div class="modal-content" style="height: 90%">
				<div class="modal-header">
					<span id="script-editor-title">剧本编辑器</span>
				</div>
				<div class="modal-body" style="display: flex; flex-direction: column; gap: 15px">
					<!-- 基础信息 -->
					<div class="form-group">
						<label for="script-name-input">剧本名称</label>
						<input type="text" id="script-name-input" />
					</div>
					<div class="form-group">
						<label for="script-background-input">故事背景</label>
						<textarea id="script-background-input" rows="3"></textarea>
					</div>

					<hr style="opacity: 0.2" />

					<!-- 角色设定区 -->
					<div>
						<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px">
							<label style="margin: 0; font-weight: 600">角色设定</label>
							<button id="sk-add-role-btn" class="form-button-secondary" style="margin: 0; padding: 5px 15px">+ 添加角色</button>
						</div>
						<div id="sk-roles-container" class="sk-item-container">
							<!-- 角色卡片将由JS动态生成在这里 -->
						</div>
					</div>

					<!-- 线索卡区 -->
					<div>
						<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px">
							<label style="margin: 0; font-weight: 600">线索卡</label>
							<button id="sk-add-clue-btn" class="form-button-secondary" style="margin: 0; padding: 5px 15px">+ 添加线索</button>
						</div>
						<div id="sk-clues-container" class="sk-item-container">
							<!-- 线索卡片将由JS动态生成在这里 -->
						</div>
					</div>

					<!-- 最终真相互动 -->
					<div class="form-group">
						<label for="sk-truth-input">最终真相</label>
						<textarea id="sk-truth-input" rows="3"></textarea>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-script-editor-btn">取消</button>
					<button class="save" id="save-script-btn">保存剧本</button>
				</div>
			</div>
		</div>

		<!-- 用于编辑单个角色/线索的子弹窗 -->
		<div id="sk-item-editor-modal" class="modal" style="z-index: 1003">
			<div class="modal-content" style="height: auto; max-height: 85%">
				<div class="modal-header">
					<span id="sk-item-editor-title"></span>
				</div>
				<div class="modal-body">
					<!-- 角色编辑字段 (默认隐藏) -->
					<div id="sk-role-editor-fields" style="display: none">
						<div class="form-group">
							<label for="sk-role-name-input">角色名称</label>
							<input type="text" id="sk-role-name-input" />
						</div>
						<div class="form-group">
							<label for="sk-role-desc-input">角色介绍</label>
							<textarea id="sk-role-desc-input" rows="3"></textarea>
						</div>
						<div class="form-group">
							<label for="sk-role-storyline-input">故事线 (案发时间段的详细行动轨迹)</label>
							<textarea id="sk-role-storyline-input" rows="5"></textarea>
						</div>
						<div class="form-group">
							<label for="sk-role-tasks-input">秘密任务</label>
							<textarea id="sk-role-tasks-input" rows="2"></textarea>
						</div>
						<div class="form-group">
							<label class="toggle-switch-label">
								<span class="toggle-switch-text">是凶手</span>
								<input type="checkbox" id="sk-role-killer-toggle" />
								<span class="toggle-switch-slider"></span>
							</label>
						</div>
					</div>
					<!-- 线索编辑字段 (默认隐藏) -->
					<div id="sk-clue-editor-fields" style="display: none">
						<div class="form-group">
							<label for="sk-clue-owner-select">线索归属</label>
							<select id="sk-clue-owner-select">
								<!-- 选项将由JS动态生成 -->
							</select>
						</div>
						<div class="form-group">
							<label for="sk-clue-desc-input">线索描述</label>
							<textarea id="sk-clue-desc-input" rows="4"></textarea>
						</div>
						<div class="form-group">
							<label class="toggle-switch-label">
								<span class="toggle-switch-text">是关键线索</span>
								<input type="checkbox" id="sk-clue-key-toggle" />
								<span class="toggle-switch-slider"></span>
							</label>
						</div>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="sk-item-editor-cancel-btn">取消</button>
					<button class="save" id="sk-item-editor-save-btn">保存</button>
				</div>
			</div>
		</div>

		<!-- 角色身份卡模态框 -->
		<div id="script-kill-role-modal" class="modal">
			<div class="modal-content" style="height: 70%">
				<div class="modal-header">
					<span id="sk-role-name">你的角色</span>
				</div>
				<div class="modal-body" id="sk-role-details" style="white-space: pre-wrap; line-height: 1.7">
					<!-- 角色介绍、任务等将显示在这里 -->
				</div>
				<div class="modal-footer">
					<button class="save" id="close-sk-role-modal-btn" style="width: 100%">我已了解</button>
				</div>
			</div>
		</div>

		<!-- 个人线索板模态框 -->
		<div id="script-kill-evidence-modal" class="modal">
			<div class="modal-content" style="height: 70%">
				<div class="modal-header">
					<span>我的线索板</span>
				</div>
				<div class="modal-body" id="sk-evidence-list" style="padding: 10px; display: flex; flex-direction: column; gap: 10px">
					<!-- 搜到的线索卡片会显示在这里 -->
				</div>
				<div class="modal-footer">
					<button class="save" id="close-sk-evidence-modal-btn" style="width: 100%">关闭</button>
				</div>
			</div>
		</div>

		<!-- 投票模态框 -->
		<div id="script-kill-vote-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 70%">
				<div class="modal-header">
					<span id="sk-vote-title">最终投票</span>
				</div>
				<div class="modal-body" id="sk-vote-options-list" style="text-align: left; padding: 20px">
					<!-- 投票选项将由JS动态生成 -->
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-sk-vote-btn">取消</button>
					<button class="save" id="confirm-sk-vote-btn">确认投票</button>
				</div>
			</div>
		</div>

		<!-- 剧本杀游戏结算卡片 -->
		<div id="script-kill-summary-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 80%">
				<div class="modal-header">
					<span>游戏结算</span>
				</div>
				<div class="modal-body" id="script-kill-summary-content" style="white-space: pre-wrap; line-height: 1.7">
					<!-- 结算内容将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button class="cancel" id="repost-sk-summary-btn">转发复盘到单聊</button>
					<button class="save" id="back-to-hall-from-sk-btn">返回大厅</button>
				</div>
			</div>
		</div>

		<!-- 剧本杀复盘发送目标选择器 -->
		<div id="script-kill-target-picker-modal" class="modal">
			<div class="modal-content" style="height: 60%">
				<div class="modal-header">
					<span>选择要转发的玩家</span>
				</div>
				<div class="modal-body" id="script-kill-target-list" style="padding: 0">
					<!-- 玩家列表将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button id="sk-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0">全选</button>
					<button id="sk-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0">全不选</button>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="sk-cancel-share-btn">取消</button>
					<button class="save" id="sk-confirm-share-btn">确认转发</button>
				</div>
			</div>
		</div>

		<!-- AI剧本生成器的弹窗 -->
		<div id="sk-ai-generator-modal" class="modal">
			<div class="modal-content" style="height: 90%">
				<div class="modal-header">
					<span>AI 剧本生成器</span>
				</div>
				<div class="modal-body" style="display: flex; flex-direction: column; gap: 15px">
					<div class="form-group">
						<label for="sk-ai-elements-input">核心要素 (用逗号分隔)</label>
						<input type="text" id="sk-ai-elements-input" placeholder="例如：现代, 谋杀, 暴风雪山庄, 遗产" />
					</div>

					<!-- 玩家人数输入框 -->
					<div class="form-group">
						<label for="sk-ai-player-count-input">玩家人数 (包含凶手, 建议4-8人)</label>
						<input type="number" id="sk-ai-player-count-input" value="5" min="3" max="12" style="width: 100%; box-sizing: border-box; padding: 10px; border-radius: 6px; border: 1px solid var(--border-color)" />
					</div>

					<div class="form-group">
						<label for="sk-ai-summary-input">剧情梗概 (可选)</label>
						<textarea id="sk-ai-summary-input" rows="4" placeholder="可以写一个简单的故事大纲，帮助AI更好地理解你的想法..."></textarea>
					</div>
					<button id="sk-trigger-ai-generation-btn" class="form-button">开始生成</button>

					<hr style="opacity: 0.2; margin: 5px 0" />

					<div class="form-group" style="flex-grow: 1; min-height: 0; display: flex; flex-direction: column">
						<label>AI 生成结果预览</label>
						<div id="sk-ai-result-preview" style="flex-grow: 1; overflow-y: auto; background: #f0f2f5; padding: 10px; border-radius: 8px; white-space: pre-wrap; line-height: 1.6; color: #555">点击"开始生成"后，结果将显示在这里...</div>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="sk-ai-generator-cancel-btn">关闭</button>
					<!-- 这个保存按钮初始是禁用的，生成成功后才会激活 -->
					<button class="save" id="sk-ai-generator-save-btn" disabled>保存剧本</button>
				</div>
			</div>
		</div>

		<!-- "你说我猜"游戏设置屏幕 -->
		<div id="guess-what-setup-screen" class="screen">
			<div class="header">
				<span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
				<span>你说我猜 - 游戏设置</span>
			</div>
			<div class="form-container">
				<div class="form-group">
					<label>邀请一位玩伴</label>
					<div id="guess-what-player-selection" class="list-container" style="height: 200px; border: 1px solid var(--border-color); border-radius: 8px">
						<!-- 玩家选择列表将由JS动态生成 -->
					</div>
				</div>
				<div class="form-group">
					<label>选择游戏模式</label>
					<div style="display: flex; gap: 20px">
						<label><input type="radio" name="guess_what_mode" value="ai_guesses" checked /> 我出题，AI猜</label>
						<label><input type="radio" name="guess_what_mode" value="user_guesses" /> AI出题，我猜</label>
					</div>
				</div>
				<!-- "我出题"模式下的输入框 -->
				<div class="form-group" id="user-word-input-container">
					<label for="guess-what-user-word">请输入你要出的词</label>
					<input type="text" id="guess-what-user-word" placeholder="例如：苹果、流浪地球..." />
				</div>
				<button id="start-guess-what-game-btn" class="form-button">开始游戏</button>
			</div>
		</div>

		<!-- "你说我猜"游戏主界面 -->
		<div id="guess-what-game-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="exit-guess-what-game-btn">‹ 退出</span>
				<span id="guess-what-game-title">你说我猜</span>
				<span class="action-btn" id="give-up-guess-what-btn">放弃</span>
			</div>
			<!-- 游戏主内容区 -->
			<div id="guess-what-game-content" style="display: flex; flex-direction: column; height: 100%; overflow: hidden; padding: 10px; box-sizing: border-box">
				<!-- 游戏日志/信息区 -->
				<div id="guess-what-log-container" style="flex-grow: 1; background-color: rgba(0, 0, 0, 0.05); border-radius: 10px; padding: 10px; overflow-y: auto; margin: 10px 0; min-height: 0">
					<div id="guess-what-game-log">
						<!-- 游戏过程信息会显示在这里 -->
					</div>
				</div>
				<!-- 玩家操作区 -->
				<div id="guess-what-action-area" class="chat-input-area" style="visibility: visible">
					<div class="chat-input-main-row">
						<textarea id="guess-what-user-input" rows="1" placeholder="输入提示或猜测..."></textarea>
						<button id="send-guess-what-input-btn" class="action-button">发送</button>
					</div>
				</div>
			</div>
		</div>

		<!-- "你说我猜"游戏结算卡片 -->
		<div id="guess-what-summary-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 80%">
				<div class="modal-header">
					<span>游戏结算</span>
				</div>
				<div class="modal-body" id="guess-what-summary-content" style="white-space: pre-wrap; line-height: 1.7">
					<!-- 结算内容将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button class="cancel" id="forward-guess-what-summary-btn">转发给Ta</button>
					<button class="save" id="close-guess-what-summary-btn">返回大厅</button>
				</div>
			</div>
		</div>

		<!-- 飞行棋游戏设置屏幕 -->
		<div id="ludo-setup-screen" class="screen">
			<div class="header">
				<span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
				<span>心动飞行棋 - 游戏设置</span>
			</div>
			<div class="form-container">
				<div class="form-group">
					<label>选择一位玩伴</label>
					<!-- 邀请列表，我们会用JS来填充 -->
					<div id="ludo-player-selection" class="list-container" style="height: 200px; border: 1px solid var(--border-color); border-radius: 8px"></div>
				</div>
				<!-- 选择问题库 -->
				<div class="form-group">
					<label>选择问题库</label>
					<div style="display: flex; align-items: center; gap: 10px">
						<select id="ludo-question-bank-select" style="flex-grow: 1"></select>
						<button id="manage-ludo-question-banks-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px; width: auto">管理题库</button>
					</div>
				</div>

				<button id="start-ludo-game-btn" class="form-button">开始游戏</button>
			</div>
		</div>

		<!-- 飞行棋游戏主界面 -->
		<div id="ludo-game-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="exit-ludo-game-btn">‹ 退出</span>
				<span>心动飞行棋</span>
				<!-- 重新开始游戏按钮 -->
				<span class="action-btn" id="restart-ludo-game-btn" title="重新开始">
					<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<polyline points="23 4 23 10 17 10"></polyline>
						<path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
					</svg>
				</span>
			</div>
			<!-- 游戏主内容区 -->
			<div id="ludo-game-content">
				<!-- 棋盘区域 -->
				<div id="ludo-board-container">
					<div id="ludo-board">
						<!-- 棋盘格子将由JS动态生成 -->
					</div>
					<!-- 玩家棋子 -->
					<div id="ludo-user-piece" class="ludo-piece user"></div>
					<div id="ludo-char-piece" class="ludo-piece char"></div>
				</div>

				<!-- 游戏日志区域 -->
				<div id="ludo-log-container">
					<div id="ludo-game-log">
						<!-- 游戏过程信息会显示在这里 -->
					</div>
				</div>

				<!-- 玩家操作区 -->
				<div id="ludo-action-area">
					<!-- 用户的按钮会根据游戏阶段显示在这里 -->
				</div>
			</div>
		</div>

		<!-- 微博私信列表页面 -->
		<div id="weibo-dm-list-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="back-from-dm-list">‹</span>
				<span id="weibo-dm-list-title">粉丝私信</span>
				<div class="header-actions">
					<!-- 继续生成私信按钮 -->
					<span class="action-btn" id="generate-more-dms-btn" title="继续生成私信">
						<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
					</span>

					<!-- 清空全部私信按钮 -->
					<span class="action-btn" id="clear-all-dms-btn" title="清空全部私信">
						<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
							<path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" />
						</svg>
					</span>
				</div>
			</div>
			<div id="weibo-dm-list" class="list-container" style="padding: 0">
				<!-- 私信列表将由JS动态生成 -->
			</div>
		</div>

		<!-- 微博私信详情页面 -->
		<div id="weibo-dm-detail-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="back-from-dm-detail">‹</span>
				<span id="weibo-dm-detail-title"></span>
				<span style="width: 30px"></span>
				<!-- 占位符 -->
			</div>
			<div id="weibo-dm-messages" class="list-container" style="display: flex; flex-direction: column; gap: 15px; padding: 15px; background-color: #f0f2f5">
				<!-- 聊天气泡将由JS动态生成 -->
			</div>
		</div>

		<!-- 桃宝主界面 -->
		<div id="taobao-screen" class="screen">
			<div class="header">
				<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
				<span>桃宝</span>
				<div class="header-actions">
					<span class="action-btn" id="clear-taobao-products-btn" style="font-size: 16px; font-weight: 500">清空</span>
					<span class="action-btn" id="add-product-btn" title="添加商品">+</span>
				</div>
			</div>

			<!-- 顶部页签导航 (已加入"饿了么") -->
			<div class="taobao-tabs">
				<button class="taobao-tab active" data-view="products-view">首页</button>
				<!-- 饿了么页签 -->
				<button class="taobao-tab" data-view="eleme-view">饿了么</button>
				<button class="taobao-tab" data-view="cart-view">购物车<span id="cart-item-count-badge" style="display: none">0</span></button>
				<button class="taobao-tab" data-view="orders-view">我的订单</button>
				<button class="taobao-tab" data-view="my-view">我的</button>
			</div>

			<!-- 页面内容容器 -->
			<div class="taobao-content">
				<!-- "首页"视图 -->
				<div id="products-view" class="taobao-view active">
					<div class="taobao-search-bar">
						<input type="search" id="product-search-input" placeholder="搜一搜，让AI为你创造好物！" />
						<button id="product-search-btn">搜索</button>
					</div>
					<div id="product-category-tabs"></div>
					<div id="product-grid" class="product-grid"></div>
				</div>

				<!-- "饿了么"内容视图 -->
				<div id="eleme-view" class="taobao-view">
					<div class="taobao-search-bar">
						<!-- 搜索组 -->
						<div class="eleme-search-group">
							<input type="search" id="eleme-search-input" placeholder="想吃点什么？让AI帮你找！" />
							<button id="eleme-search-btn">搜索</button>
						</div>

						<!-- 功能组 -->
						<div class="eleme-actions-group">
							<button id="eleme-add-manual-btn" class="header-actions" title="手动添加美食">+</button>
							<button id="eleme-generate-ai-btn" class="header-actions" title="AI生成美食">✨</button>
							<button id="eleme-clear-all-btn" class="header-btn">🗑️</button>
						</div>
					</div>
					<div id="eleme-grid" class="product-grid">
						<!-- 美食列表将由JS动态生成在这里 -->
					</div>
				</div>

				<!-- "购物车"视图 -->
				<div id="cart-view" class="taobao-view">
					<div id="cart-item-list"></div>
					<div id="cart-checkout-bar" style="display: none">
						<div class="total-price">合计: <span id="cart-total-price">¥ 0.00</span></div>
						<div style="display: flex; gap: 10px">
							<button id="share-cart-to-char-btn">分享给Ta代付</button>
							<button id="buy-for-char-btn">为Ta购买</button>
							<button id="checkout-btn">结算(0)</button>
						</div>
					</div>
				</div>

				<!-- "我的订单"视图 -->
				<div id="orders-view" class="taobao-view">
					<div id="order-list" class="order-list"></div>
				</div>

				<!-- "我的"视图 -->
				<div id="my-view" class="taobao-view">
					<div id="user-balance-container">
						<p>我的余额</p>
						<h2 id="user-balance-display">¥ 0.00</h2>
						<button id="top-up-btn" class="form-button">给钱包充点钱</button>
					</div>
					<div id="balance-details-list" class="order-list" style="padding: 0 15px"></div>
				</div>
			</div>
		</div>

		<!-- 商品详情弹窗 -->
		<div id="product-detail-modal" class="modal">
			<div class="modal-content">
				<div class="modal-header">
					<span>商品详情</span>
				</div>
				<div class="modal-body" id="product-detail-body">
					<!-- 详情内容将由JS动态生成 -->
				</div>
				<!-- 商品评价区域 -->
				<div id="product-reviews-section">
					<h3>宝贝评价</h3>
					<div id="product-reviews-list">
						<!-- 评价内容会由JS动态生成在这里 -->
					</div>
					<button id="generate-reviews-btn" class="form-button form-button-secondary">✨ AI生成评价</button>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="close-product-detail-btn">关闭</button>
					<button class="save" id="detail-add-to-cart-btn">加入购物车</button>
				</div>
			</div>
		</div>

		<!-- 添加商品的方式选择弹窗 -->
		<div id="add-product-choice-modal" class="modal">
			<div id="custom-modal" style="width: 250px">
				<div class="custom-modal-header">选择添加方式</div>
				<div class="custom-modal-footer">
					<button id="add-product-manual-btn">手动添加</button>
					<button id="add-product-link-btn">识别链接</button>
					<button id="add-product-ai-btn">AI生成</button>
					<button id="cancel-add-choice-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0">取消</button>
				</div>
			</div>
		</div>

		<!-- 手动添加/编辑商品弹窗 -->
		<div id="product-editor-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span id="product-editor-title">添加新商品</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label for="product-name-input">商品名称</label>
						<input type="text" id="product-name-input" />
					</div>
					<div class="form-group">
						<label for="product-price-input">价格 (元)</label>
						<input type="number" id="product-price-input" />
					</div>
					<div class="form-group">
						<label for="product-image-input">图片 URL</label>
						<input type="text" id="product-image-input" />
					</div>
					<div class="form-group">
						<label for="product-category-input">分类 (选填)</label>
						<input type="text" id="product-category-input" placeholder="例如：衣服, 零食..." />
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-product-editor-btn">取消</button>
					<button class="save" id="save-product-btn">保存</button>
				</div>
			</div>
		</div>

		<!-- 识别链接弹窗 -->
		<div id="add-from-link-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span>粘贴分享文案</span>
				</div>
				<div class="modal-body">
					<textarea id="link-paste-area" rows="6" placeholder="请在这里粘贴完整的淘宝或拼多多分享文案..."></textarea>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-link-paste-btn">取消</button>
					<button class="save" id="confirm-link-paste-btn">识别</button>
				</div>
			</div>
		</div>

		<!-- 物流详情页面 -->
		<div id="logistics-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="logistics-back-btn">‹</span>
				<span>物流详情</span>
				<span style="width: 30px"></span>
				<!-- 占位符，让标题居中 -->
			</div>
			<div id="logistics-content-area" class="list-container">
				<!-- 物流信息将由JS动态生成在这里 -->
			</div>
		</div>

		<!-- "谁是卧底"游戏设置屏幕 -->
		<div id="undercover-setup-screen" class="screen">
			<div class="header">
				<span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
				<span>谁是卧底 - 游戏设置</span>
			</div>
			<div class="form-container">
				<div class="form-group">
					<label>邀请模式</label>
					<div style="display: flex; gap: 20px">
						<label style="cursor: pointer"><input type="radio" name="undercover_invite_mode" value="manual" checked /> 手动邀请</label>
						<label style="cursor: pointer"><input type="radio" name="undercover_invite_mode" value="random" /> 随机邀请</label>
					</div>
				</div>

				<!-- 随机邀请的选项 -->
				<div id="undercover-random-invite-options" style="display: none">
					<div class="form-group">
						<label for="undercover-random-player-count">你想邀请几位AI/NPC？ (不含你自己)</label>
						<input type="number" id="undercover-random-player-count" min="2" max="15" value="5" style="width: 100%; box-sizing: border-box; padding: 10px" />
					</div>
				</div>

				<!-- 手动邀请的选项 -->
				<div id="undercover-manual-invite-options">
					<div class="form-group">
						<label>请勾选要邀请的玩家</label>
						<div id="undercover-player-selection" class="list-container" style="height: 350px; border: 1px solid var(--border-color); border-radius: 8px">
							<!-- 玩家选择列表将由JS动态生成 -->
						</div>
					</div>
				</div>

				<button id="start-undercover-game-btn" class="form-button">开始游戏</button>
				<p style="text-align: center; color: var(--text-secondary); font-size: 13px; margin-top: 15px">
					游戏最少需要3人。<br />
					3-5人局：1卧底<br />
					6-8人局：1卧底, 1白板<br />
					9人及以上：2卧底, 1白板
				</p>
			</div>
		</div>

		<!-- "谁是卧底"游戏主界面 -->
		<div id="undercover-game-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="exit-undercover-game-btn">‹ 退出</span>
				<span id="undercover-game-title">谁是卧底</span>
				<span class="action-btn" id="undercover-my-word-btn">我的词语</span>
			</div>
			<!-- 游戏主内容区 -->
			<div id="undercover-game-content" style="display: flex; flex-direction: column; height: 100%; overflow: hidden; padding: 10px; box-sizing: border-box">
				<!-- 玩家座位区 -->
				<div id="undercover-players-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); gap: 15px; padding: 10px; flex-shrink: 0">
					<!-- 玩家头像和状态将由JS动态生成 -->
				</div>
				<!-- 游戏日志/信息区 -->
				<div id="undercover-log-container" style="flex-grow: 1; background-color: rgba(0, 0, 0, 0.05); border-radius: 10px; padding: 10px; overflow-y: auto; margin: 10px 0; min-height: 0">
					<div id="undercover-game-log">
						<!-- 游戏过程信息会显示在这里 -->
					</div>
				</div>
				<!-- 玩家操作区 -->
				<div id="undercover-action-area" style="flex-shrink: 0; padding: 10px; display: flex; justify-content: center; align-items: center; gap: 15px; min-height: 50px">
					<!-- 玩家的按钮会根据游戏阶段显示在这里 -->
				</div>
			</div>
		</div>

		<!-- "谁是卧底"游戏结算弹窗 -->
		<div id="undercover-summary-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 80%">
				<div class="modal-header">
					<span>游戏结算</span>
				</div>
				<div class="modal-body" id="undercover-summary-content" style="white-space: pre-wrap; line-height: 1.7">
					<!-- 结算内容将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<!-- 分享复盘按钮 -->
					<button class="cancel" id="repost-undercover-summary-btn">分享复盘到单聊</button>
					<button class="save" id="back-to-hall-from-undercover-btn">返回大厅</button>
				</div>
			</div>
		</div>

		<!-- User私信列表页面 -->
		<div id="user-dm-list-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="back-from-user-dm-list">‹</span>
				<span>我的私信</span>
				<div class="header-actions">
					<!-- 生成新私信按钮 -->
					<span class="action-btn" id="generate-new-user-dms-btn" title="生成新私信">
						<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
					</span>
					<!-- 清空所有私信按钮 -->
					<span class="action-btn" id="clear-all-user-dms-btn" title="清空所有私信">
						<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" /></svg>
					</span>
				</div>
			</div>
			<div id="user-dm-list-container" class="list-container" style="padding: 0">
				<!-- 私信列表将由JS动态生成在这里 -->
			</div>
		</div>

		<!-- User私信详情页面 (与粉丝聊天) -->
		<div id="user-dm-detail-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="back-from-user-dm-detail">‹</span>
				<span id="user-dm-detail-title"></span>
				<!-- 粉丝名字 -->
				<span style="width: 30px"></span>
				<!-- 占位符 -->
			</div>
			<div id="user-dm-messages-container" class="list-container" style="display: flex; flex-direction: column; gap: 15px; padding: 15px; background-color: #f0f2f5">
				<!-- 聊天气泡将由JS动态生成在这里 -->
			</div>
			<!-- 聊天输入框 -->
			<div id="user-dm-input-area" class="chat-input-area">
				<div class="chat-input-main-row">
					<textarea id="user-dm-input" rows="1" placeholder="和粉丝聊点什么..."></textarea>
					<!-- 操作按钮容器 -->
					<div id="input-actions-wrapper">
						<!-- 触发AI回应按钮 -->
						<button id="user-dm-trigger-ai-btn" class="action-button chat-action-icon-btn" title="让对方先说">
							<svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
							</svg>
						</button>
						<!-- 重新生成回复按钮 -->
						<button id="user-dm-reroll-btn" class="action-button chat-action-icon-btn" title="重新生成回复">
							<svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<polyline points="23 4 23 10 17 10"></polyline>
								<path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
							</svg>
						</button>
						<!-- 发送按钮 -->
						<button id="user-dm-send-btn" class="action-button">发送</button>
					</div>
				</div>
			</div>
		</div>

		<!-- 角色微博主页屏幕 -->
		<div id="weibo-char-profile-screen" class="screen">
			<!-- 头部，包含返回按钮和角色名字 -->
			<div class="header">
				<span class="back-btn" id="back-from-char-profile">‹</span>
				<span id="weibo-char-profile-title">角色主页</span>
				<div class="header-actions">
					<!-- 编辑角色资料按钮 -->
					<span class="action-btn" id="edit-char-weibo-profile-btn" title="编辑角色资料">
						<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
							<path d="M12 20h9"></path>
							<path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
						</svg>
					</span>
				</div>
			</div>
			<!-- 角色主页的内容区 -->
			<div id="weibo-char-profile-page" class="weibo-profile-page">
				<!-- 复用个人主页的滚动样式 -->
				<div class="weibo-profile-header">
					<img id="weibo-char-background-img" src="https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg" class="weibo-background" />
					<div class="weibo-avatar-container">
						<img id="weibo-char-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" class="weibo-avatar" />
						<img id="weibo-char-avatar-frame" class="weibo-avatar-frame" src="" style="display: none" />
					</div>
					<div class="weibo-nickname" id="weibo-char-nickname">角色昵称</div>
					<div id="weibo-char-profession-display">角色职业</div>
					<!-- 角色统计数据 -->
					<div class="weibo-stats">
						<div id="weibo-char-following-item" class="weibo-stat-item" style="cursor: pointer">
							<span id="weibo-char-following-count" class="weibo-stat-number">0</span>
							<span class="weibo-stat-label">关注</span>
						</div>
						<div id="weibo-char-posts-item" class="weibo-stat-item">
							<span id="weibo-char-posts-count" class="weibo-stat-number">0</span>
							<span class="weibo-stat-label">微博</span>
						</div>
						<div id="weibo-char-fans-item" class="weibo-stat-item" style="cursor: pointer">
							<span id="weibo-char-fans-count" class="weibo-stat-number">0</span>
							<span class="weibo-stat-label">粉丝</span>
						</div>
					</div>
				</div>
				<div id="char-weibo-feed-list" style="padding: 15px; display: flex; flex-direction: column; gap: 15px">
					<!-- 角色的微博列表将由JS动态生成在这里 -->
				</div>
			</div>
		</div>

		<!-- 角色微博资料编辑弹窗 -->
		<div id="char-weibo-editor-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span>编辑角色微博资料</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label>微博头像</label>
						<div class="avatar-upload">
							<img id="char-weibo-editor-avatar-preview" />
							<button onclick="document.getElementById('char-weibo-editor-avatar-input').click()">上传头像</button>
							<button class="change-frame-btn" data-type="char-weibo">更换头像框</button>
							<input type="file" id="char-weibo-editor-avatar-input" accept="image/*" hidden />
						</div>
					</div>
					<div class="form-group">
						<label for="char-weibo-editor-nickname-input">微博昵称</label>
						<input type="text" id="char-weibo-editor-nickname-input" />
					</div>
					<div class="form-group">
						<label>微博背景</label>
						<div class="avatar-upload">
							<img id="char-weibo-editor-bg-preview" style="width: 120px; height: 67.5px; border-radius: 8px" />
							<button onclick="document.getElementById('char-weibo-editor-bg-input').click()">上传背景</button>
							<input type="file" id="char-weibo-editor-bg-input" accept="image/*" hidden />
						</div>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-char-weibo-editor-btn">取消</button>
					<button class="save" id="save-char-weibo-editor-btn">保存</button>
				</div>
			</div>
		</div>

		<!-- 约会大作战主界面 -->
		<div id="date-a-live-screen" class="screen">
			<div class="header">
				<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
				<span>约会大作战</span>
				<div class="header-actions">
					<!-- 创建新场景按钮 -->
					<span class="action-btn" id="create-dating-scene-btn" title="创建新场景">
						<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
							<line x1="12" y1="5" x2="12" y2="19"></line>
							<line x1="5" y1="12" x2="19" y2="12"></line>
						</svg>
					</span>

					<span class="action-btn" id="dating-history-btn" title="历史约会">
						<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
							<path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
							<polyline points="3 3 3 8 8 8" />
							<path d="M12 6V12L16 14" />
						</svg>
					</span>
					<span class="action-btn" id="refresh-dating-scene-btn" title="刷新场景">
						<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
							<polyline points="23 4 23 10 17 10"></polyline>
							<path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
						</svg>
					</span>
				</div>
			</div>
			<div id="dating-scene-content" class="list-container">
				<!-- 约会场景卡片将由JS动态生成在这里 -->
			</div>
		</div>

		<!-- 宠物功能模态框 -->
		<div id="pet-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 85%">
				<div class="modal-header">
					<span id="pet-modal-title">我的宠物</span>
				</div>
				<div class="modal-body">
					<!-- 宠物信息预览区 -->
					<div id="pet-preview-area" style="text-align: center; margin-bottom: 20px">
						<div id="pet-preview-display" style="font-size: 60px; line-height: 1; margin-bottom: 10px; cursor: pointer" title="点击更换图片"></div>
						<strong id="pet-preview-name" style="font-size: 18px"></strong>
						<p id="pet-preview-type" style="font-size: 14px; color: var(--text-secondary); margin: 5px 0"></p>
					</div>

					<!-- 宠物数值显示区 -->
					<div id="pet-stats-area" style="display: none">
						<div id="pet-hunger-bar" class="stat-bar-container">
							<span class="stat-label">饱食度</span>
							<div class="stat-bar"><div class="stat-bar-fill">100%</div></div>
						</div>
						<div id="pet-happiness-bar" class="stat-bar-container">
							<span class="stat-label">心情值</span>
							<div class="stat-bar"><div class="stat-bar-fill">100%</div></div>
						</div>
						<div id="pet-intimacy-user-bar" class="stat-bar-container">
							<span class="stat-label">对你的亲密度</span>
							<div class="stat-bar"><div class="stat-bar-fill">50%</div></div>
						</div>
						<div id="pet-intimacy-char-bar" class="stat-bar-container">
							<span class="stat-label">对Ta的亲密度</span>
							<div class="stat-bar"><div class="stat-bar-fill">50%</div></div>
						</div>
					</div>

					<!-- 互动按钮区 -->
					<div id="pet-interaction-area" style="display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color)">
						<button class="form-button-secondary" data-action="feed">喂食</button>
						<button class="form-button-secondary" data-action="play">玩耍</button>
						<button class="form-button-secondary" data-action="touch">抚摸</button>
						<button class="form-button-secondary" data-action="chat">对话</button>
					</div>

					<!-- 设置区 -->
					<div class="form-group">
						<label for="pet-type-input">种类 (自由填写)</label>
						<input type="text" id="pet-type-input" placeholder="例如: 小猫, 仓鼠, 太阳花..." />
					</div>
					<div class="form-group">
						<label for="pet-name-input">昵称</label>
						<input type="text" id="pet-name-input" placeholder="给它起个名字吧" />
					</div>
					<div class="form-group">
						<label for="pet-image-input">初始样子 (Emoji 或 图片URL)</label>
						<input type="text" id="pet-image-input" placeholder="输入一个 Emoji 比如 🐈 或图片链接" />
					</div>
					<!-- 宠物人设输入框 -->
					<div class="form-group">
						<label for="pet-persona-input">宠物人设与背景</label>
						<textarea id="pet-persona-input" rows="3" placeholder="描述一下它的性格和故事，AI会根据这个来扮演它。"></textarea>
					</div>
					<div class="form-group">
						<label class="toggle-switch-label">
							<span>在聊天界面显示</span>
							<input type="checkbox" id="pet-display-toggle" />
							<span class="toggle-switch-slider"></span>
						</label>
					</div>
					<div id="pet-position-controls" style="display: none">
						<div class="form-group">
							<label for="pet-size-slider">大小: <span id="pet-size-value">100px</span></label>
							<input type="range" id="pet-size-slider" min="30" max="200" value="100" style="width: 100%" />
						</div>
					</div>
				</div>
				<div class="modal-footer">
					<!-- 放生宠物按钮 -->
					<button class="cancel" id="pet-abandon-btn" style="background-color: #ffdde5; color: #ff3b30; border-color: #ffc2d1">放生宠物</button>
					<button class="cancel" id="pet-modal-cancel-btn">取消</button>
					<button class="save" id="pet-modal-save-btn">保存</button>
				</div>
			</div>
		</div>
		<input type="file" id="pet-custom-image-input" accept="image/*" style="display: none" />

		<!-- 宠物聊天模态框 -->
		<div id="pet-chat-modal" class="modal">
			<div class="modal-content" style="height: 80%">
				<div class="modal-header">
					<span id="pet-chat-title">和宠物的对话</span>
				</div>
				<div id="pet-chat-messages" class="modal-body" style="background-color: #f0f2f5; display: flex; flex-direction: column; gap: 15px">
					<!-- 宠物聊天记录将显示在这里 -->
				</div>
				<!-- 复用主聊天输入框的样式 -->
				<div id="pet-chat-input-area" class="chat-input-area" style="border-top: 1px solid var(--border-color)">
					<div class="chat-input-main-row">
						<textarea id="pet-chat-input" rows="1" placeholder="和它说点什么..."></textarea>
						<button id="send-to-pet-btn" class="action-button">发送</button>
					</div>
				</div>
			</div>
		</div>

		<!-- 微博专用的角色选择弹窗 -->
		<div id="weibo-char-selector-modal" class="modal">
			<div class="modal-content" style="height: 70%">
				<div class="modal-header">
					<span>选择生成内容的主角</span>
				</div>
				<div class="modal-body" id="weibo-char-selector-list" style="padding: 0; overflow-y: auto">
					<!-- 角色列表将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer" style="justify-content: space-between">
					<button id="weibo-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0">全选</button>
					<button id="weibo-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0">全不选</button>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="weibo-cancel-char-select-btn">取消</button>
					<button class="save" id="weibo-confirm-char-select-btn">确认</button>
				</div>
			</div>
		</div>

		<!-- 情侣空间-情绪日记编辑弹窗 -->
		<div id="ls-diary-editor-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 80%">
				<div class="modal-header">
					<span id="ls-diary-editor-title">记录今天的心情</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label>选择一个表情代表今天的心情</label>
						<div id="ls-emoji-selector" style="display: flex; flex-wrap: wrap; gap: 10px; font-size: 24px; cursor: pointer; justify-content: center; padding: 10px 0">
							<!-- Emoji将由JS生成 -->
						</div>
					</div>
					<div class="form-group">
						<label for="ls-diary-content-input">写下你的日记</label>
						<textarea id="ls-diary-content-input" rows="6" placeholder="今天发生了什么特别的事吗..."></textarea>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="ls-cancel-diary-btn">取消</button>
					<button class="save" id="ls-save-diary-btn">保存日记</button>
				</div>
			</div>
		</div>

		<!-- 情侣空间-日记查看弹窗 -->
		<div id="ls-diary-viewer-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 80%">
				<div class="modal-header">
					<span id="ls-diary-viewer-title">查看日记</span>
				</div>
				<div id="ls-diary-viewer-body" class="modal-body" style="display: flex; flex-direction: column; gap: 20px">
					<!-- 日记内容将由JS动态生成 -->
				</div>
				<div class="modal-footer">
					<button class="save" id="ls-close-diary-viewer-btn" style="width: 100%">关闭</button>
				</div>
			</div>
		</div>

		<!-- 情侣空间 - 每日足迹日历弹窗 -->
		<div id="ls-activity-calendar-modal" class="modal">
			<div class="modal-content" style="max-width: 380px">
				<div class="modal-header">
					<span id="ls-activity-calendar-title">💕 足迹日历 💕</span>
				</div>
				<div class="modal-body" id="ls-activity-calendar-body">
					<!-- 日历内容会由JavaScript动态生成在这里 -->
				</div>
			</div>
		</div>

		<!-- 聊天总结查看弹窗 -->
		<div id="summary-viewer-modal" class="modal">
			<div class="modal-content" style="height: 80%">
				<div class="modal-header">
					<span id="summary-viewer-title">聊天总结</span>
				</div>
				<div class="modal-body" id="summary-list" style="padding: 15px">
					<!-- 总结列表将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer" style="display: flex; gap: 10px">
					<!-- 全部精简按钮 -->
					<button class="form-button-secondary" id="concise-all-summaries-btn" style="flex: 1; margin: 0">全部精简</button>
					<button class="save" id="close-summary-viewer-btn" style="flex: 1; margin: 0">关闭</button>
				</div>
			</div>
		</div>

		<!-- AI生成商品结果/选择弹窗 -->
		<div id="ai-generated-products-modal" class="modal">
			<div class="modal-content" style="height: 80%">
				<div class="modal-header">
					<span id="ai-products-modal-title">AI为你生成了以下宝贝</span>
				</div>
				<div class="modal-body" style="padding: 15px">
					<div id="ai-product-results-grid" class="product-grid">
						<!-- AI生成的商品会显示在这里 -->
					</div>
				</div>
				<div class="modal-footer">
					<button class="save" id="close-ai-products-modal-btn" style="width: 100%">完成</button>
				</div>
			</div>
		</div>

		<!-- 飞行棋问题库管理模态框 -->
		<div id="ludo-qbank-manager-modal" class="modal">
			<div class="modal-content" style="height: 70%">
				<div class="modal-header">
					<span>管理问题库</span>
					<!-- 问题库操作按钮 -->
					<div class="header-actions">
						<span class="action-btn" id="import-ludo-qbank-btn" title="导入题库">
							<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
								<polyline points="17 8 12 3 7 8"></polyline>
								<line x1="12" y1="3" x2="12" y2="15"></line>
							</svg>
						</span>
						<span class="action-btn" id="add-ludo-qbank-btn" style="font-size: 16px">新建</span>
					</div>
				</div>
				<div class="modal-body" id="ludo-qbank-list" style="padding: 0">
					<!-- 问题库列表将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button class="save" id="close-qbank-manager-btn" style="width: 100%">完成</button>
				</div>
			</div>
		</div>

		<!-- 飞行棋问题编辑器模态框 -->
		<div id="ludo-question-editor-modal" class="modal">
			<div class="modal-content" style="height: 80%">
				<div class="modal-header">
					<span class="back-btn" id="back-to-qbank-manager-btn">‹</span>
					<span id="ludo-question-editor-title">编辑问题</span>
					<span class="action-btn" id="add-ludo-question-btn" style="font-size: 28px; font-weight: 300">+</span>
				</div>
				<div class="modal-body" id="ludo-question-list" style="padding: 10px">
					<!-- 问题列表将由JS动态生成在这里 -->
				</div>
			</div>
		</div>

		<!-- 飞行棋单个问题编辑器模态框 -->
		<div id="ludo-single-question-editor-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span id="ludo-single-question-title">编辑问题</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label for="ludo-question-text-input">问题内容</label>
						<textarea id="ludo-question-text-input" rows="4"></textarea>
					</div>
					<div class="form-group">
						<label>问题类型</label>
						<div style="display: flex; gap: 20px">
							<label><input type="radio" name="ludo_question_type" value="both_answer" checked /> 共同回答</label>
							<label><input type="radio" name="ludo_question_type" value="single_answer" /> 一人回答,一人评价</label>
						</div>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-single-question-btn">取消</button>
					<button class="save" id="save-single-question-btn">保存</button>
				</div>
			</div>
		</div>

		<!-- 飞行棋游戏结算模态框 -->
		<div id="ludo-summary-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 80%">
				<div class="modal-header">
					<span>游戏结算</span>
				</div>
				<div class="modal-body" id="ludo-summary-content" style="text-align: left; line-height: 1.7">
					<!-- 结算内容将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button class="cancel" id="share-ludo-summary-btn">分享给Ta</button>
					<button class="save" id="back-to-hall-from-ludo-btn">返回大厅</button>
				</div>
			</div>
		</div>

		<!-- 谁是卧底游戏结算模态框 -->
		<div id="undercover-summary-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 80%">
				<div class="modal-header">
					<span>游戏结算</span>
				</div>
				<div class="modal-body" id="undercover-summary-content" style="white-space: pre-wrap; line-height: 1.7">
					<!-- 结算内容将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<!-- 分享复盘按钮 -->
					<button class="cancel" id="repost-undercover-summary-btn">分享复盘到单聊</button>
					<button class="save" id="back-to-hall-from-undercover-btn">返回大厅</button>
				</div>
			</div>
		</div>

		<!-- 谁是卧底复盘发送目标选择器 -->
		<div id="undercover-target-picker-modal" class="modal">
			<div class="modal-content" style="height: 60%">
				<div class="modal-header">
					<span>选择要发送的玩家</span>
				</div>
				<div class="modal-body" id="undercover-target-list" style="padding: 0">
					<!-- 玩家列表将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button id="uc-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0">全选</button>
					<button id="uc-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0">全不选</button>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="uc-cancel-share-btn">取消</button>
					<button class="save" id="uc-confirm-share-btn">确认发送</button>
				</div>
			</div>
		</div>

		<!-- 群公告模态框 -->
		<div id="group-announcement-modal" class="modal">
			<div class="modal-content">
				<div class="modal-header">
					<span>群公告</span>
				</div>
				<div class="modal-body" id="announcement-content-area">
					<!-- 公告内容将显示在这里 -->
				</div>
				<div class="modal-footer" id="announcement-footer">
					<!-- 按钮将由JS动态生成 -->
				</div>
			</div>
		</div>

		<!-- 心声面板样式编辑器弹窗 -->
		<div id="inner-voice-editor-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span>编辑心声面板样式</span>
				</div>
				<div class="modal-body">
					<!-- 卡片背景颜色 -->
					<div class="form-group">
						<label for="iv-card-bg-color">卡片背景颜色</label>
						<input type="color" id="iv-card-bg-color" value="#FFFFFF" style="width: 100%; height: 40px" />
					</div>
					<!-- 卡片透明度 -->
					<div class="form-group">
						<label for="iv-opacity-slider">卡片背景透明度: <span id="iv-opacity-value">70%</span></label>
						<input type="range" id="iv-opacity-slider" min="0" max="1" step="0.05" value="0.7" style="width: 100%" />
					</div>
					<hr style="opacity: 0.2" />
					<!-- 四个标签的背景色 -->
					<div class="form-group">
						<label for="iv-color-clothing">"服装"标签背景色</label>
						<input type="color" id="iv-color-clothing" value="#f0a1a8" style="width: 100%; height: 40px" />
					</div>
					<div class="form-group">
						<label for="iv-color-behavior">"行为"标签背景色</label>
						<input type="color" id="iv-color-behavior" value="#81c784" style="width: 100%; height: 40px" />
					</div>
					<div class="form-group">
						<label for="iv-color-thoughts">"心声"标签背景色</label>
						<input type="color" id="iv-color-thoughts" value="#64b5f6" style="width: 100%; height: 40px" />
					</div>
					<div class="form-group">
						<label for="iv-color-naughty">"坏心思"标签背景色</label>
						<input type="color" id="iv-color-naughty" value="#ba68c8" style="width: 100%; height: 40px" />
					</div>
					<hr style="opacity: 0.2; margin: 20px 0" />
					<div class="form-group">
						<label for="iv-icon-color">图标颜色</label>
						<input type="color" id="iv-icon-color" value="#ff8a80" style="width: 100%; height: 40px" />
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="iv-editor-cancel-btn">取消</button>
					<button class="save" id="iv-editor-save-btn">保存</button>
				</div>
			</div>
		</div>

		<!-- AI生成群成员模态框 -->
		<div id="ai-generate-members-modal" class="modal">
			<div class="modal-content" style="height: auto">
				<div class="modal-header">
					<span>AI 生成群成员</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label for="ai-member-count-input">生成人数 (1-20)</label>
						<input type="number" id="ai-member-count-input" value="3" min="1" max="20" />
					</div>
					<div class="form-group">
						<label for="ai-member-prompt-input">要求 (可选，AI会参考)</label>
						<textarea id="ai-member-prompt-input" rows="4" placeholder="例如：一群喜欢户外探险的大学生，性格各异..."></textarea>
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-ai-generate-members-btn">取消</button>
					<button class="save" id="confirm-ai-generate-members-btn">开始生成</button>
				</div>
			</div>
		</div>

		<!-- 约会邀请与支付模态框 -->
		<div id="dating-payment-modal" class="modal">
			<div class="modal-content" style="width: 300px; height: auto">
				<div class="modal-header">
					<span id="dating-modal-title">发起约会邀请</span>
				</div>
				<div class="modal-body" style="text-align: center">
					<p>你选择的约会是：</p>
					<h3 id="dating-modal-scene-name" style="color: var(--accent-color); margin: 10px 0"></h3>
					<p id="dating-modal-scene-cost" style="font-weight: bold"></p>
					<hr style="opacity: 0.2; margin: 20px 0" />
					<p>由谁来买单呢？</p>
					<div id="dating-payment-options" style="display: flex; flex-direction: column; gap: 10px">
						<!-- 支付选项按钮将由JS动态生成 -->
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="dating-cancel-btn" style="width: 100%">下次再说</button>
				</div>
			</div>
		</div>

		<!-- 约会角色选择弹窗 -->
		<div id="dating-char-selector-modal" class="modal">
			<div class="modal-content" style="height: 60%">
				<div class="modal-header">
					<span>选择约会对象</span>
				</div>
				<div class="modal-body" id="dating-char-selector-list" style="padding: 0">
					<!-- 角色列表将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button class="cancel" id="dating-cancel-char-select-btn" style="width: 100%">取消</button>
				</div>
			</div>
		</div>

		<!-- 约会游戏主界面 -->
		<div id="dating-game-screen" class="screen">
			<!-- 动态背景图 (最底层) -->
			<div id="dating-game-background"></div>

			<!-- 角色立绘容器 (中间层) -->
			<div id="dating-game-sprite-container">
				<img id="dating-game-sprite" src="" />
			</div>

			<!-- UI覆盖层 (最顶层, 包含头部/文本框/选项) -->
			<div class="dating-game-ui-overlay">
				<div class="header">
					<span class="back-btn" id="end-date-btn">
						<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
					</span>

					<span id="dating-game-char-name"></span>
					<div class="header-actions">
						<!-- 约会数值显示 -->
						<div id="dating-values-container">
							<div id="romance-value" class="value-display">
								<!-- 我们会用JS在这里生成5个粉色心形 -->
							</div>
							<div id="lust-value" class="value-display">
								<!-- 我们会用JS在这里生成5个黄色心形 -->
							</div>
						</div>

						<span class="action-btn" id="dating-game-settings-btn" title="场景设置">
							<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<circle cx="12" cy="12" r="3"></circle>
								<path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
							</svg>
						</span>
						<span class="action-btn" id="dating-game-reroll-btn" title="重Roll回应">
							<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<polyline points="23 4 23 10 17 10"></polyline>
								<path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
							</svg>
						</span>
					</div>
				</div>

				<!-- 底部文本框 -->
				<div class="dating-game-textbox">
					<p id="dating-game-text-content">约会即将开始...</p>
				</div>
				<div id="dating-completion-bar-container">
					<div id="dating-completion-bar-fill"></div>
					<span id="dating-completion-text">0%</span>
				</div>
				<!-- 玩家操作区 -->
				<div id="dating-game-choices" class="dating-game-choices">
					<!-- 选项按钮将由JS动态生成在这里 -->
				</div>
			</div>
		</div>

		<!-- 借钱对象选择弹窗 -->
		<div id="borrow-money-modal" class="modal">
			<div class="modal-content" style="height: 60%">
				<div class="modal-header">
					<span>向谁借钱？</span>
				</div>
				<div class="modal-body" id="borrow-money-char-list" style="padding: 0; overflow-y: auto">
					<!-- 借钱对象列表将由JS动态生成在这里 -->
				</div>
				<div class="modal-footer">
					<button class="cancel" id="borrow-money-cancel-btn" style="width: 100%">取消</button>
				</div>
			</div>
		</div>

		<!-- 约会场景设置模态框 -->
		<div id="dating-game-settings-modal" class="modal">
			<div class="modal-content">
				<div class="modal-header">
					<span>约会场景设置</span>
				</div>
				<div class="modal-body">
					<!-- 预设管理 -->
					<div class="form-group">
						<label>预设方案</label>
						<div class="bubble-preset-manager">
							<select id="dating-preset-select" class="form-group select"></select>
							<button id="manage-dating-presets-btn" class="action-btn">管理</button>
						</div>
					</div>

					<hr style="opacity: 0.2" />

					<!-- 立绘组选择器 -->
					<div class="form-group">
						<label>选择角色立绘组</label>
						<div class="bubble-preset-manager">
							<select id="dating-sprite-group-select" class="form-group select">
								<option value="">-- 不使用立绘 --</option>
								<!-- 立绘组将由JS动态填充 -->
							</select>
							<button id="manage-sprite-groups-btn" class="action-btn">管理立绘组</button>
						</div>
					</div>

					<hr style="opacity: 0.2" />

					<!-- 核心设置 -->
					<div class="form-group">
						<label for="dating-prompt-input">场景/角色提示词 (Prompt)</label>
						<textarea id="dating-prompt-input" rows="4" placeholder="例如：你是一个傲娇但内心温柔的少女，在海边对用户的表白感到不知所措..."></textarea>
					</div>
					<div class="form-group">
						<label for="dating-style-input">文风 (Style)</label>
						<textarea id="dating-style-input" rows="3" placeholder="例如：请使用细腻的心理描写和优美的风景描写..."></textarea>
					</div>
					<div class="form-group">
						<label>约会背景图</label>
						<div class="bg-upload-container">
							<button class="form-button-secondary" onclick="document.getElementById('dating-bg-upload-input').click()" style="margin-top: 0">上传图片</button>
							<input type="text" id="dating-bg-url-input" placeholder="或粘贴网络图片URL" style="flex-grow: 1" />
						</div>
						<input type="file" id="dating-bg-upload-input" accept="image/*" hidden />
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-dating-settings-btn">取消</button>
					<button class="save" id="save-dating-settings-btn">应用并保存</button>
				</div>
			</div>
		</div>

		<!-- 立绘组管理弹窗 -->
		<div id="sprite-group-manager-modal" class="modal">
			<div class="modal-content" style="height: 60%">
				<div class="modal-header">
					<span>管理立绘组</span>
					<span class="action-btn" id="create-new-sprite-group-btn" style="font-size: 16px">新建</span>
				</div>
				<div class="modal-body" id="sprite-group-list-container" style="padding: 0">
					<!-- 立绘组列表将由JS动态生成 -->
				</div>
				<div class="modal-footer">
					<button class="save" id="close-sprite-group-manager-btn" style="width: 100%">完成</button>
				</div>
			</div>
		</div>

		<!-- 立绘组编辑器弹窗 -->
		<div id="sprite-editor-modal" class="modal">
			<div class="modal-content" style="height: 90%">
				<div class="modal-header">
					<span id="sprite-editor-title">编辑立绘组</span>
				</div>
				<div class="modal-body" id="sprite-editor-body">
					<div class="form-group">
						<label for="sprite-group-name-input">立绘组名称</label>
						<input type="text" id="sprite-group-name-input" placeholder="例如：日常、战斗、害羞..." />
					</div>
					<hr style="opacity: 0.2" />
					<label>立绘列表</label>
					<div id="sprite-list-editor" style="display: flex; flex-direction: column; gap: 15px; margin-top: 10px">
						<!-- 单个立绘的编辑卡片将由JS动态生成 -->
					</div>
					<button id="add-new-sprite-btn" class="form-button form-button-secondary" style="margin-top: 20px">+ 添加一个新立绘</button>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-sprite-editor-btn">取消</button>
					<button class="save" id="save-sprite-editor-btn">保存立绘组</button>
				</div>
			</div>
		</div>

		<!-- 约会结算卡片 -->
		<div id="dating-summary-overlay" class="modal">
			<div class="dating-summary-card">
				<div class="dating-summary-card-inner">
					<!-- 卡片正面 -->
					<div class="card-front">
						<img id="summary-card-avatar" src="" alt="角色头像" />
						<h2 id="summary-card-rating"></h2>
						<p class="summary-card-tip">点击卡片查看完整约会记录</p>
						<div class="summary-card-actions">
							<button id="summary-share-btn">分享给Ta</button>
							<button id="summary-close-btn">关闭</button>
						</div>
					</div>
					<!-- 卡片背面 -->
					<div class="card-back">
						<div class="card-back-header">
							<span>完整约会记录</span>
							<button id="summary-flip-back-btn">返回</button>
						</div>
						<div id="summary-card-history" class="card-back-content">
							<!-- 约会历史记录将由JS动态生成在这里 -->
						</div>
					</div>
				</div>
			</div>
		</div>

		<!-- 约会结算卡片分享功能文件上传 -->
		<input type="file" id="dating-summary-image-upload" accept="image/*" hidden />

		<!-- 约会历史记录界面 -->
		<div id="dating-history-screen" class="screen">
			<div class="header">
				<span class="back-btn" id="dating-history-back-btn">‹</span>
				<span>历史约会</span>
				<span style="width: 30px"></span>
				<!-- 占位符，保持标题居中 -->
			</div>
			<div id="dating-history-list" class="list-container">
				<!-- 历史约会卡片将由JS动态生成在这里 -->
			</div>
		</div>

		<!-- 创建约会场景模态框 -->
		<div id="create-dating-scene-modal" class="modal">
			<div class="modal-content" style="width: 300px; height: auto">
				<div class="modal-header">
					<span>创建约会场景</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label for="scene-name-input">场景名称</label>
						<input type="text" id="scene-name-input" placeholder="例如：月光下的海滩漫步" />
					</div>
					<div class="form-group">
						<label for="scene-image-url-input">图片 URL (可选)</label>
						<input type="text" id="scene-image-url-input" placeholder="留空则由AI根据场景名生成图片..." />
					</div>
					<div class="form-group">
						<label for="scene-cost-input">花费 (金币)</label>
						<input type="number" id="scene-cost-input" placeholder="例如：520" />
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-create-scene-btn">取消</button>
					<button class="save" id="save-custom-scene-btn">保存</button>
				</div>
			</div>
		</div>

		<!-- 表情分类管理模态框 -->
		<div id="sticker-category-modal" class="modal">
			<div class="modal-content" style="height: auto; max-height: 70%">
				<div class="modal-header">
					<span>移动表情到分类</span>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label>选择一个现有分类</label>
						<div id="sticker-category-list" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px; padding: 5px">
							<!-- 分类列表将由JS动态生成 -->
						</div>
					</div>
					<p style="text-align: center; color: var(--text-secondary); margin: 10px 0">或</p>
					<div class="form-group">
						<label for="new-sticker-category-input">创建一个新分类</label>
						<input type="text" id="new-sticker-category-input" placeholder="输入新分类的名称..." />
					</div>
				</div>
				<div class="modal-footer">
					<button class="cancel" id="cancel-sticker-category-btn">取消</button>
					<button class="save" id="confirm-sticker-category-btn">确认移动</button>
				</div>
			</div>
		</div>

		<!-- 高级导入/导出模态框 -->
		<div id="advanced-transfer-modal" class="modal">
			<div class="modal-content">
				<div class="modal-header">
					<span>高级导入 / 导出</span>
				</div>
				<div class="modal-body">
					<h4>选择要导出的内容</h4>

					<!-- App 数据导出区 -->
					<div class="form-group">
						<label>全局App数据 (多选)</label>
						<div id="export-apps-list" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: 8px">
							<!-- App 多选框将由JS动态生成在这里 -->
						</div>
					</div>

					<!-- 角色数据导出区 -->
					<div class="form-group">
						<label style="display: flex; justify-content: space-between; align-items: center">
							<span>角色数据 (多选,qq动态什么的)</span>
							<label style="font-size: 13px; font-weight: normal; cursor: pointer"> <input type="checkbox" id="select-all-characters-checkbox" style="vertical-align: middle; margin-right: 4px" /> 全选/全不选 </label>
						</label>
						<div id="export-characters-list" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: 8px">
							<!-- 角色多选框将由JS动态生成在这里 -->
						</div>
					</div>
					<button id="export-selected-data-btn" class="form-button">导出选中项</button>

					<hr style="margin: 20px 0" />

					<h4>兼容性操作</h4>
					<p style="font-size: 13px; color: #666">从其他版本导入数据，或将数据导出为兼容格式。</p>

					<!-- 兼容330格式导入按钮 -->
					<button id="import-from-330-btn" class="form-button" style="background-color: #28a745; margin-bottom: 10px">📥 兼容330格式导入</button>

					<button id="export-for-330-btn" class="form-button" style="background-color: #6f42c1">🚀 兼容330数据导出</button>

					<hr style="margin: 20px 0" />

					<h4>导入补充数据</h4>
					<p style="font-size: 13px; color: #666">导入将以【补充和覆盖】的方式进行，不会删除您现有的其他数据。这可以用来合并数据或恢复单个角色的备份。</p>
					<button id="import-chunked-data-btn" class="form-button form-button-secondary">选择文件并导入</button>
					<input id="import-chunked-data-input" type="file" accept="application/json" hidden />
				</div>
				<div class="modal-footer">
					<button class="cancel" id="close-advanced-transfer-btn">关闭</button>
				</div>
			</div>
		</div>

		<!-- 兼容330格式导入文件选择器 -->
		<input id="import-from-330-input" type="file" accept="application/json" hidden />

		<!-- 亲密关系面板 -->
		<div id="intimacy-panel" class="modal">
			<div class="modal-content">
				<div class="modal-header">
					<span>亲密关系</span>
					<span id="close-intimacy-panel" class="close-btn" style="cursor: pointer">&times;</span>
				</div>
				<div class="modal-body" id="intimacy-panel-body">
					<div id="intimacy-display">
						<p>当前亲密值</p>
						<h2 id="intimacy-score-display">--</h2>
					</div>
					<div id="intimacy-details">
						<div class="detail-item">
							<span>🔥 火花天数</span>
							<span id="intimacy-streak-days">-- 天</span>
						</div>
						<div class="detail-item">
							<span>💬 今日消息</span>
							<span id="intimacy-today-msgs">-- 条</span>
						</div>
						<div class="detail-item">
							<span>📈 累计消息</span>
							<span id="intimacy-total-msgs">-- 条</span>
						</div>
					</div>
					<div id="intimacy-symbol-unlocks">
						<h3>亲密徽章</h3>
						<div id="symbol-list-container">
							<!-- JS会在这里生成所有可解锁的徽章 -->
						</div>
					</div>
					<div id="intimacy-records">
						<h3>解锁记录</h3>
						<div id="unlocked-symbols-record">
							<!-- JS会在这里生成已解锁徽章的记录 -->
							<p>暂无记录</p>
						</div>
					</div>
				</div>
			</div>
		</div>

		<!-- 心声主面板 -->
		<div id="inner-voice-modal" class="modal">
			<div id="inner-voice-main-panel" class="modal-content" style="width: 90%; max-width: 340px; height: auto; max-height: 80%; background-color: #fffafb; border: 1px solid #ffe4e1">
				<div class="modal-header" style="border-bottom: 1px solid #ffe4e1; padding: 12px 15px; display: flex; justify-content: space-between; align-items: center">
					<span id="close-inner-voice-modal" style="cursor: pointer; font-size: 24px">×</span>

					<div style="display: flex; align-items: center; gap: 15px">
						<span id="inner-voice-edit-btn" style="cursor: pointer" title="编辑心声面板">
							<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M12 20h9"></path>
								<path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
							</svg>
						</span>
						<span id="change-inner-voice-bg-btn" style="cursor: pointer" title="更换背景">
							<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
								<circle cx="8.5" cy="8.5" r="1.5"></circle>
								<polyline points="21 15 16 10 5 21"></polyline>
							</svg>
						</span>
						<span id="inner-voice-history-btn" style="cursor: pointer">
							<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<circle cx="12" cy="12" r="10"></circle>
								<polyline points="12 6 12 12 16 14"></polyline>
							</svg>
						</span>
					</div>
				</div>

				<div class="modal-body" style="padding: 15px">
					<!-- 角色头像 -->
					<div id="inner-voice-avatar-wrapper">
						<img id="inner-voice-avatar" src="" />
						<!-- 角色头像框 -->
						<img id="inner-voice-avatar-frame" src="" style="display: none" />
					</div>

					<!-- 角色名字 -->
					<div id="inner-voice-char-info">
						<div id="inner-voice-char-name"></div>
					</div>

					<!-- 领养人信息（头像+名字）-->
					<div id="inner-voice-adopter-info">
						<img id="inner-voice-adopter-avatar" src="" />
						<span id="inner-voice-adopter-name"></span>
					</div>

					<!-- 心声内容 -->
					<div id="inner-voice-content-area" style="display: flex; flex-direction: column; gap: 15px">
						<div>
							<strong style="color: #e57373">服装:</strong>
							<p id="inner-voice-clothing" style="margin: 5px 0 0 0; line-height: 1.6; color: #555"></p>
						</div>
						<div>
							<strong style="color: #81c784">行为:</strong>
							<p id="inner-voice-behavior" style="margin: 5px 0 0 0; line-height: 1.6; color: #555"></p>
						</div>
						<div>
							<strong style="color: #64b5f6">心声:</strong>
							<p id="inner-voice-thoughts" style="margin: 5px 0 0 0; line-height: 1.6; color: #555"></p>
						</div>
						<div>
							<strong style="color: #ba68c8">坏心思:</strong>
							<p id="inner-voice-naughty-thoughts" style="margin: 5px 0 0 0; line-height: 1.6; color: #555"></p>
						</div>
					</div>
				</div>
			</div>

			<!-- 历史记录面板 -->
			<div id="inner-voice-history-panel" class="modal-content" style="width: 90%; max-width: 340px; height: 80%; background-color: #f5f5f5; display: none; flex-direction: column">
				<div class="modal-header" style="border-bottom: 1px solid #ddd; justify-content: space-between">
					<span id="back-from-history-btn" style="cursor: pointer; font-size: 16px; font-weight: 600; color: var(--accent-color)">返回</span>
					<span>历史心声</span>
					<span id="clear-all-history-btn" style="cursor: pointer; font-size: 14px; color: #ff3b30">全部清空</span>
				</div>
				<div class="modal-body" id="inner-voice-history-list" style="padding: 0">
					<!-- 历史记录会由JS动态生成在这里 -->
				</div>
			</div>
		</div>

		<script>
			// 塔罗牌数据定义，包含每张牌的正位和逆位含义
			const TAROT_DECK = [
				{ name: "愚人", upright: "开始, 天真, 自发性, 自由精神", reversed: "天真, 鲁莽, 承担风险" },
				{ name: "魔术师", upright: "显化, 足智多谋, 力量, 灵感行动", reversed: "操纵, 计划不周, 未被利用的天赋" },
				{ name: "女祭司", upright: "直觉, 神圣女性, 潜意识, 神秘", reversed: "秘密, 脱离直觉, 压抑的感情" },
				{ name: "皇后", upright: "生育, 女性气质, 美丽, 自然, 丰富", reversed: "创造力受阻, 依赖他人" },
				{ name: "皇帝", upright: "权威, 父亲形象, 结构, 稳固控制", reversed: "控制欲, 僵化, 缺乏纪律" },
				{ name: "教皇", upright: "精神智慧, 宗教信仰, 传统, 制度", reversed: "个人信仰, 挑战传统, 墨守成规" },
				{ name: "恋人", upright: "爱, 和谐, 关系, 价值观对齐, 选择", reversed: "不和谐, 失衡, 价值观错位" },
				{ name: "战车", upright: "控制, 意志力, 胜利, 断言, 决心", reversed: "缺乏控制和方向, 侵略性" },
				{ name: "力量", upright: "力量, 勇气, 同情, 专注, 耐心", reversed: "内在力量, 自我怀疑, 精力不足" },
				{ name: "隐士", upright: "灵魂探索, 内省, 孤独, 内在引导", reversed: "孤立, 孤独, 退缩" },
				{ name: "命运之轮", upright: "好运, 因果报应, 生命周期, 转折点", reversed: "坏运气, 抵抗改变, 打破循环" },
				{ name: "正义", upright: "正义, 公平, 真理, 因果, 法律", reversed: "不公平, 缺乏责任感, 不诚实" },
				{ name: "倒吊人", upright: "暂停, 限制, 放手, 牺牲, 新视角", reversed: "拖延, 毫无意义的牺牲, 停滞" },
				{ name: "死神", upright: "结束, 改变, 转变, 过渡", reversed: "抵抗改变, 无法前进, 停滞" },
				{ name: "节制", upright: "平衡, 适度, 耐心, 目标", reversed: "失衡, 过度, 重新调整" },
				{ name: "恶魔", upright: "束缚, 成瘾, 消极, 唯物主义", reversed: "挣脱束缚, 释放, 恢复控制" },
				{ name: "高塔", upright: "突变, 剧变, 混乱, 启示, 觉醒", reversed: "避免灾难, 害怕改变" },
				{ name: "星星", upright: "希望, 信念, 目标, 更新, 灵性", reversed: "缺乏信念, 绝望, 不专注" },
				{ name: "月亮", upright: "幻觉, 恐惧, 焦虑, 潜意识, 直觉", reversed: "释放恐惧, 压抑的情感, 内心困惑" },
				{ name: "太阳", upright: "积极, 乐趣, 温暖, 成功, 活力", reversed: "内心幼稚, 过于乐观, 沮丧" },
				{ name: "审判", upright: "审判, 重生, 内心召唤, 赦免", reversed: "自我怀疑, 无视召唤" },
				{ name: "世界", upright: "完成, 整合, 成就, 旅行", reversed: "寻求个人结束, 走捷径, 拖延" },
				{ name: "权杖ACE", upright: "灵感, 新机会, 成长, 潜力", reversed: "缺乏动力, 错过机会, 拖延" },
				{ name: "权杖二", upright: "未来规划, 进步, 决策, 离开家", reversed: "恐惧未知, 缺乏规划, 害怕改变" },
				{ name: "权杖三", upright: "扩张, 成长, 远见, 海外机会", reversed: "计划受挫, 缺乏远见, 延误" },
				{ name: "权杖四", upright: "庆祝, 和谐, 婚姻, 回家, 稳定", reversed: "不和谐, 过渡, 缺乏支持" },
				{ name: "权杖五", upright: "冲突, 分歧, 竞争, 紧张", reversed: "冲突避免, 尊重差异" },
				{ name: "权杖六", upright: "成功, 公众认可, 胜利, 进步", reversed: "自负, 缺乏认可, 惩罚" },
				{ name: "权杖七", upright: "挑战, 竞争, 保护, 坚持", reversed: "放弃, 不知所措, 过度保护" },
				{ name: "权杖八", upright: "速度, 行动, 空中旅行, 运动, 快速决策", reversed: "延误, 挫折, 抵制改变" },
				{ name: "权杖九", upright: "韧性, 勇气, 坚持, 界限", reversed: "内心挣扎, 偏执, 防御性" },
				{ name: "权杖十", upright: "负担, 责任, 努力工作, 压力", reversed: "卸下负担, 委派, 释放" },
				{ name: "权杖侍从", upright: "灵感, 想法, 发现, 自由精神", reversed: "不切实际的想法, 拖延, 创造力受阻" },
				{ name: "权杖骑士", upright: "能量, 激情, 欲望, 行动, 冒险", reversed: "愤怒, 冲动, 鲁莽" },
				{ name: "权杖王后", upright: "勇气, 自信, 独立, 社交蝴蝶", reversed: "自我尊重, 自信, 内向" },
				{ name: "权杖国王", upright: "天生的领袖, 远见, 企业家, 荣誉", reversed: "冲动, 仓促, 无情的" },
				{ name: "圣杯ACE", upright: "爱, 新关系, 同情, 创造力", reversed: "自我爱, 直觉, 压抑的情感" },
				{ name: "圣杯二", upright: "统一的爱, 伙伴关系, 相互吸引", reversed: "分手, 不和谐, 不信任" },
				{ name: "圣杯三", upright: "庆祝, 友谊, 创造力, 合作", reversed: "独立, 独处, '三人行'" },
				{ name: "圣杯四", upright: "沉思, 断开连接, 冷漠, 重新评估", reversed: "退缩, 孤僻, 错过机会" },
				{ name: "圣杯五", upright: "遗憾, 失败, 失望, 悲观主义", reversed: "个人挫折, 自我宽恕, 前进" },
				{ name: "圣杯六", upright: "重温过去, 童年记忆, 天真, 喜悦", reversed: "活在过去, 不愿原谅, 缺乏玩乐" },
				{ name: "圣杯七", upright: "机会, 选择, 幻想, 幻觉", reversed: "一致性, 幻想, 过多选择" },
				{ name: "圣杯八", upright: "失望, 放弃, 退缩, 逃避主义", reversed: "尝试新事物, 冷漠, 恐惧改变" },
				{ name: "圣杯九", upright: "满足, 满意, 感激, 愿望成真", reversed: "不满足, 唯物主义, 不满" },
				{ name: "圣杯十", upright: "神圣的爱, 和谐关系, 家庭, 一致性", reversed: "脱节, 对齐错误, 挣扎的关系" },
				{ name: "圣杯侍从", upright: "创意机会, 直觉信息, 好奇心", reversed: "新的想法, 怀疑, 创造力受阻" },
				{ name: "圣杯骑士", upright: "创造力, 浪漫, 魅力, 想象力", reversed: "不切实际, 嫉妒, 情绪波动" },
				{ name: "圣杯王后", upright: "富有同情心, 关怀, 直觉, 平静", reversed: "内在感受, 自我照顾, 自爱, 共情" },
				{ name: "圣杯国王", upright: "情绪平衡, 同情, 外交", reversed: "自我同情, 内在真理, 情绪不稳定" },
				{ name: "宝剑ACE", upright: "突破, 新想法, 头脑清晰, 成功", reversed: "内心清晰, 重新思考一个想法, 混乱" },
				{ name: "宝剑二", upright: "艰难的选择, 未知的后果, 僵局", reversed: "优柔寡断, 困惑, 信息过载" },
				{ name: "宝剑三", upright: "心碎, 悲伤, 拒绝, 分离", reversed: "释放痛苦, 乐观, 宽恕" },
				{ name: "宝剑四", upright: "休息, 放松, 沉思, 恢复", reversed: "精疲力尽, 倦怠, 停滞" },
				{ name: "宝剑五", upright: "冲突, 分歧, 竞争, 失败", reversed: "和解, 过去的原谅" },
				{ name: "宝剑六", upright: "过渡, 改变, 仪式, 放下", reversed: "个人过渡, 抵抗改变, 未完成的事" },
				{ name: "宝剑七", upright: "背叛, 欺骗, 走捷径, 鬼祟", reversed: "冒名顶替综合症, 欺骗, 守秘" },
				{ name: "宝剑八", upright: "负面想法, 自我强加的限制, 监禁", reversed: "自我限制的信念, 释放, 思想开放" },
				{ name: "宝剑九", upright: "焦虑, 担忧, 恐惧, 抑郁, 噩梦", reversed: "内心挣扎, 深度恐惧, 释放忧虑" },
				{ name: "宝剑十", upright: "痛苦的结局, 深度创伤, 背叛, 损失", reversed: "恢复, 抵抗结局, 无法放手" },
				{ name: "宝剑侍从", upright: "新想法, 好奇心, 追求真理", reversed: "自言自语, 全能选手, 仓促" },
				{ name: "宝剑骑士", upright: "雄心勃勃, 行动导向, 追求目标", reversed: "不安, 冲动, 倦怠" },
				{ name: "宝剑王后", upright: "独立的, 无偏见的判断, 清晰的界限", reversed: "过于情绪化, 轻易受影响, 刻薄" },
				{ name: "宝剑国王", upright: "精神清晰, 智慧, 权威, 真理", reversed: "安静的力量, 内在真理, 滥用权力" },
				{ name: "星币ACE", upright: "显化, 新的财务机会, 繁荣", reversed: "机会丧失, 缺乏规划和远见" },
				{ name: "星币二", upright: "多任务, 适应性, 时间管理", reversed: "重新调整优先级, 过度投入" },
				{ name: "星币三", upright: "团队合作, 合作, 学习, 实施", reversed: "不和谐, 团队内部冲突, 计划不周" },
				{ name: "星币四", upright: "节约, 安全, 保守, 稀缺心态", reversed: "过度消费, 贪婪, 自我保护" },
				{ name: "星币五", upright: "财务损失, 贫困, 孤立, 忧虑", reversed: "从财务损失中恢复, 精神贫困" },
				{ name: "星币六", upright: "给予, 接受, 分享财富, 慷慨", reversed: "自私, 债务, 单方面给予" },
				{ name: "星币七", upright: "长期眼光, 可持续的结果, 投资", reversed: "缺乏长期眼光, 成功受限" },
				{ name: "星币八", upright: "学徒, 重复, 掌握, 技能发展", reversed: "自我发展, 完美主义, 部署不当" },
				{ name: "星币九", upright: "丰富, 奢华, 自给自足, 财务独立", reversed: "自我价值, 过度投资于工作" },
				{ name: "星币十", upright: "财富, 财务安全, 家庭, 遗产", reversed: "财务失败, 负担, 遗产丧失" },
				{ name: "星币侍从", upright: "显化, 财务机会, 技能发展", reversed: "缺乏进步, 拖延, 学会新技能" },
				{ name: "星币骑士", upright: "努力工作, 生产力, 日常, 保守", reversed: "自我纪律, 无聊, 感觉'卡住'" },
				{ name: "星币王后", upright: "养育, 务实, 财务安全, 工作与家庭的平衡", reversed: "财务独立, 自我照顾, 工作与家庭的不平衡" },
				{ name: "星币国王", upright: "财富, 商业, 领导力, 安全, 纪律", reversed: "财务不称职, 过时, 固执" },
			];

			// 内置剧本库，包含多个推理游戏剧本
			const BUILT_IN_SCRIPTS = [
				{
					id: "built_in_1",
					name: "办公室疑云",
					storyBackground: "深夜，顶级互联网公司“比特无限”灯火通明。以苛刻闻名的项目总监王强，被发现死在自己的座位上，死因为药物中毒。警方初步锁定了当晚还在公司的五位嫌疑人，每个人似乎都与死者有着千丝万缕的联系。在这座欲望与代码交织的钢铁森林里，谁的秘密被永远埋葬，谁的双手沾染了罪恶？",
					roles: [
						{
							name: "李思",
							description: "公司新晋的天才程序员，技术过硬，但性格内向，不善言辞。",
							storyline: `今天是项目上线的最后期限，我被王总监逼着加班到深夜。\n**晚上8:00**：王总监把我叫进他办公室，因为一个微不足道的bug对我破口大骂，甚至撕掉了我的绩效评估报告，说我“不合格”。我气得浑身发抖，和他大吵了一架，然后摔门而出。\n**晚上8:30**：我回到工位，越想越气，打开电脑写了一封辞职信，但还没发送。\n**晚上9:00**：我起身去茶水间倒水，路过总监办公室时，看到人事主管陈静端着一杯咖啡走了进去。我当时没太在意。\n**晚上9:30**：我有点饿，点了一份外卖。等外卖的时候，我看到设计师孙伟鬼鬼祟祟地从茶水间的方向走出来，手里好像攥着什么东西。\n**晚上10:00**：外卖到了，我吃完外卖继续改bug，直到被发现尸体的惊叫声打断。`,
							tasks: "1. 隐藏你与王强总监发生过激烈争吵，并被他评为“不合格”的事实。\n2. 你的首要目标是自保，找到证据证明你离开后另有其人进入过办公室。\n3. 你怀疑陈静和孙伟，尝试找出他们的可疑之处。",
							isKiller: false,
						},
						{
							name: "赵娜",
							description: "公司的市场部经理，能力出众，是典型的职场女强人，野心勃勃。",
							storyline: `今晚本不需要我加班，但我为了准备一个重要的竞标方案，主动留了下来。\n**晚上7:30**：我在自己的办公室整理资料，无意中发现了王强挪用项目公款的证据。我立刻起草了一封匿名举报邮件，准备发给总部。\n**晚上8:10**：我听到隔壁总监办公室传来激烈的争吵声，好像是李思在和王强吵架。\n**晚上8:45**：我需要一些数据，就去找王强签字。进他办公室时，他正在喝咖啡，脸色很差。我把文件给他，他很不耐烦地签了字。我注意到他桌上放着一瓶没贴标签的药瓶。\n**晚上9:15**：我回到自己办公室，思考着举报邮件的事情。我担心这会影响公司声誉，最终还是没有发送。\n**晚上10:15**：我准备下班，路过总监办公室时，发现门虚掩着，里面很安静。我没有进去看，直接离开了公司。`,
							tasks: "1. 你的首要任务是找出真凶，洗清自己的嫌疑，确保公司丑闻不被曝光，以免影响你的职业前途。\n2. 隐藏你发现王强挪用公款并准备举报他的事实。\n3. 你看到他桌上的药瓶，这是一个重要线索，你需要引导大家注意到这一点。",
							isKiller: false,
						},
						{
							name: "孙伟",
							description: "公司的资深UI设计师，也是王强的老部下，表面对他毕恭毕敬。",
							storyline: `我恨透了王强！他克扣了我们团队辛辛苦苦做完的项目奖金，自己却拿了大头。\n**晚上9:00**：我借口加班，实际上是想潜入王强的办公室，找到他克扣奖金的证据。我看到陈静端着咖啡进去后不久就出来了。\n**晚上9:20**：我确认王强办公室没人注意，就偷偷溜了进去。我看到他趴在桌上睡着了，旁边是那杯几乎没喝的咖啡。我在他抽屉里翻找，果然找到了一份内部奖金分配表，证实了他中饱私囊。我用手机拍了下来。\n**晚上9:30**：我拿着证据悄悄离开办公室，准备去茶水间处理一下。这时迎面撞上了去倒水的李思，我吓了一跳，赶紧把手机藏进口袋里。\n**晚上10:00后**：我一直在自己的工位上，盘算着怎么利用这个证据让他身败名裂。`,
							tasks: "1. 隐藏你曾潜入总监办公室并偷拍证据的事实。\n2. 王强死了对你有利，你需要引导大家怀疑其他有动机的人，比如与他争吵的李思。\n3. 保护好你手机里的照片证据，这是你的护身符。",
							isKiller: false,
						},
						{
							name: "陈静",
							description: "公司的人事主管，外表温柔体贴，善于处理人际关系。",
							storyline: `我曾是王强秘密的情人，他承诺过会和妻子离婚娶我。但最近，我发现他为了攀附一个富家女，准备抛弃我。更让我恐惧的是，他手机里存着我们大量的私密照片和视频，如果曝光，我的职业生涯就全毁了。\n**晚上8:45**：我知道王强有喝咖啡的习惯。我提前准备了强效安眠药，磨成粉末，藏在身上。\n**晚上9:00**：我以关心他为由，为他冲了一杯咖啡，并将安眠药全部倒了进去，然后端进了他的办公室。他当时正在处理文件，没有怀疑，喝了一大口。\n**晚上9:10**：我借口离开，在外面观察。不一会儿，就看到他趴在桌上睡着了。\n**晚上9:20**：我返回办公室，想找到他的手机删除资料。但我怎么也找不到他的手机。此时我发现他已经没了呼吸，我吓坏了，慌乱中，我不小心将他桌上的一条项链（他准备送给那个富家女的）碰掉，掉进了我的手提包里。\n**晚上9:40**：我惊慌失措地逃离了办公室，回到自己的工位假装加班，心乱如麻。`,
							tasks: `【你的核心任务】\n请隐藏你为了销毁证据而失手用安眠药毒杀王强的事实。你是本案的唯一真凶。\n\n【你的行动指南】\n1. 嫁祸他人。你可以利用你看到的、听到的信息，将嫌疑引向李思或孙伟。\n2. 你包里的项链是定时炸弹，想办法合理解释它的来历，或者神不知鬼不觉地处理掉它。\n3. 你的目标是误导所有人，让他们投出错误的凶手。`,
							isKiller: true,
						},
						{
							name: "周毅",
							description: "公司大楼的夜班保安，看起来忠厚老实，但观察力敏锐。",
							storyline: `作为保安，我负责大楼夜间的安全巡逻。\n**晚上8:10**：我巡逻到18楼，听到总监办公室里有激烈的争吵声，好像是那个叫李思的程序员，我没敢靠近。\n**晚上9:00**：我看到人事主管陈静端着杯咖啡进了总监办公室，几分钟后就出来了，看起来有点紧张。\n**晚上9:20**：我看到UI设计师孙伟，像做贼一样溜进了总监办公室。\n**晚上9:40**：我又看到陈静从总监办公室出来，这次她脸色惨白，脚步匆忙，好像丢了魂一样。我觉得很奇怪，但没敢多问。\n**晚上10:30**：我进行例行检查，发现总监办公室的门没关，进去一看，发现王总监已经……我立刻报了警。`,
							tasks: "1. 你是本案最重要的目击证人，你的任务是诚实、准确地向大家提供你看到的时间线索。\n2. 你觉得陈静的行为最可疑，你需要重点观察她，并向大家说明你的怀疑。\n3. 找出对公司最有利的真相，避免事件扩大化。",
							isKiller: false,
						},
					],
					clues: [
						{ owner: "李思", description: "一张被揉成一团、丢在垃圾桶里的绩效评估报告，上面有王强龙飞凤舞的签名和“不合格，建议辞退”的批注。" },
						{ owner: "赵娜", description: "你的电脑里有一封未发送的邮件，收件人是集团总部纪检委，标题是“关于比特无限项目总监王强涉嫌严重职务侵占的实名举报”。" },
						{ owner: "孙伟", description: "你的手机相册里有一张照片，内容是一份内部奖金分配表，表格显示项目总奖金的70%都流向了王强的个人账户。" },
						{ owner: "陈静", description: "在你的手提包夹层里，发现了一条价值不菲的钻石项链，包装盒还在，但没有贺卡。", isKey: true },
						{ owner: "周毅", description: "一份保安巡逻日志，清晰地记录了你在不同时间点看到不同人进出总监办公室的情况。" },
						{ owner: "公共", description: "在茶水间垃圾桶里发现一个空的安眠药药瓶，上面的标签被撕掉了。" },
						{ owner: "公共", description: "在死者办公桌下发现一部手机，但不是死者常用的那部，手机已经没电了。" },
					],
					truth: "凶手是人事主管陈静。她与总监王强有私情，但王强近期为了利益想和她分手并娶一位富家女。当晚，陈静在王强的咖啡里下了过量安眠药，想让他睡着后偷走他手机里存有的两人亲密照片。但由于药量过大，王强意外死亡。陈静在慌乱中没找到手机，反而不小心将王强准备送给富家女的项链碰进了自己的包里。",
				},
				// --- 【全新剧本1：深海遗书】 ---
				{
					id: "built_in_2",
					name: "深海遗书",
					storyBackground: "在与世隔绝的“回响岛”上，著名的海洋学家李博士被发现死在自己反锁的书房中，桌上放着一封打印的遗书，死因为氰化物中毒。一场突如其来的风暴切断了岛上与外界的所有联系，将剩下的四个人困在了这座孤岛上：李博士的得意门生、一位竞争对手、一位沉默寡言的技术员，以及一位不请自来的记者。",
					roles: [
						{
							name: "高远",
							description: "李博士的学生，才华横溢但野心勃勃。",
							storyline: `我一直觉得老师窃取了我的研究成果。今晚，我本想和他摊牌。\n**晚上7:00**：我和老师在实验室大吵一架，他承认参考了我的数据，但拒绝公开承认。我愤怒地离开。\n**晚上8:00**：我回到宿舍，越想越气。我利用权限，远程删除了部分对他有利、对我不利的核心实验数据，想让他无法发布论文。\n**晚上9:00**：我去食堂吃饭，看到技术员陈默在调试监控设备，他看起来心事重重。\n**晚上9:45**：我看到记者张莱在李博士书房门口徘徊，似乎想进去但又不敢。`,
							tasks: "1. 隐藏你和老师的学术纠纷以及你删除数据的行为。\n2. 你认为自己的前途受到了威胁，必须找到真凶来洗清嫌疑。\n3. 引导大家怀疑其他有动机的人。",
							isKiller: false,
						},
						{
							name: "林雪",
							description: "另一位海洋学家，与李博士是长期的竞争对手。",
							storyline: `我和李博士在竞争一个重要的国际科研基金。我知道他这次的研究有重大突破。\n**晚上7:30**：我去找李博士，希望他能分享一些数据，被他无情拒绝了。我们不欢而散。\n**晚上8:30**：我在自己的房间里整理资料，听到外面有奇怪的电流声，好像是停电了一瞬间又恢复了。\n**晚上9:10**：我口渴去厨房倒水，看到高远神色慌张地从机房的方向出来。\n**晚上10:00**：我经过书房时，闻到一股淡淡的杏仁味（氰化物的典型气味），但我当时以为是实验室的化学品味道，没有在意。`,
							tasks: "1. 李博士的死对你的基金申请有利，这是你的嫌疑点，你需要撇清关系。\n2. 隐藏你曾私下找他索要数据被拒的事实。\n3. 你闻到的杏仁味是关键线索，需要让大家知道。",
							isKiller: false,
						},
						{
							name: "陈默",
							description: "研究站的技术员，性格内向，暗恋着李博士。",
							storyline: `我深爱着李博士，但她似乎对我毫不在意。我掌管着整个研究站的设备和监控。\n**晚上8:30**：我接到高远的请求，他让我“不小心”让监控系统断电一分钟。我虽然觉得奇怪，但因为他答应帮我向李博士说好话，我还是照做了。\n**晚上9:00**：我看到李博士把自己锁在书房里，神情悲伤。我很难过，但不敢打扰。\n**晚上9:20**：我看到记者张莱试图撬书房的门锁，被我发现后他慌忙走开了。\n**晚上10:30**：我越想越不对劲，用备用钥匙打开了书房的门，发现了博士的尸体。`,
							tasks: "1. 隐藏你曾受高远指使，人为制造监控断电的事实。\n2. 你有备用钥匙，这让你有重大嫌疑，你需要找到合理的解释。\n3. 你怀疑记者张莱有不轨行为。",
							isKiller: false,
						},
						{
							name: "张莱",
							description: "一位追踪学术丑闻的记者，秘密登岛。",
							storyline: `我收到线报，称李博士的研究涉嫌造假，我是来调查真相的。今晚是最好的机会。\n**晚上9:00**：我绕到李博士书房的窗外，看到她正在电脑前打字，似乎在写着什么重要的东西。我用长焦相机拍下了几张模糊的照片。\n**晚上9:20**：我尝试从正门进入书房，想找她当面对质，但门被反锁了。我试图用铁丝开锁，结果被技术员陈默撞见了，我只好假装路过离开。\n**晚上9:50**：我回到自己的住处，放大相机里的照片，发现她打字的内容似乎是一封遗书，但内容很奇怪，好像在暗示什么。我还拍到她桌上有一个遥控器一样的东西。`,
							tasks: "1. 隐藏你记者的身份和你登岛的真实目的。\n2. 你拍到的照片是关键证据，但直接拿出来会暴露你自己。你需要巧妙地引导大家发现遗书和遥控器的问题。\n3. 你是外来者，嫌疑最大，必须尽快找到凶手。",
							isKiller: true,
						},
					],
					clues: [
						{ owner: "高远", description: "你的电脑回收站里有一份未发送的邮件，内容是向竞争对手的公司投递简历，并附言可以提供“比特无限”的核心代码。" },
						{ owner: "林雪", description: "在你的抽屉里，发现了一瓶标签被撕掉的化学试剂，经过检验，是无毒的营养液。" },
						{ owner: "陈默", description: "一张工作日志，上面写着“20:30-20:31，18楼东区服务器意外重启，原因排查中”。" },
						{ owner: "张莱", description: "你的相机里有多张照片，其中一张清晰地拍到死者电脑屏幕上的遗书内容，另一张模糊地拍到了桌上的一个小型遥控装置。", isKey: true },
						{ owner: "公共", description: "死者手边的咖啡杯里检测出高浓度的氰化物，但奇怪的是，咖啡基本没喝。" },
						{ owner: "公共", description: "书房的通风口内侧，发现一个被改装过的、连接着小型雾化喷嘴的遥控香薰机，里面残留有氰化物液体。" },
						{ owner: "公共", description: "死者的电脑浏览器历史显示，她在死前最后一个访问的页面是她已故丈夫的纪念网站。" },
					],
					truth: "凶手是记者张莱。他并非想杀死李博士，而是想制造混乱以窃取学术造假的证据。他提前在书房的通风口安装了遥控毒气装置，计划在采访时如果李博士不配合，就少量释放让她昏迷。但他没想到，当晚李博士因为思念亡夫而情绪低落，正在写一封真的遗书。张莱在窗外看到遗书，误以为时机已到，便按下了遥控器，导致李博士吸入过量毒气身亡。他之后尝试进入房间取回装置未果。",
				},
				// --- 【全新剧本2：古堡魅影】 ---
				{
					id: "built_in_3",
					name: "古堡魅影",
					storyBackground: "在浓雾笼罩的偏远古堡里，富有而古怪的伯爵被发现死在反锁的书房中，胸口插着一把古董拆信刀。猛烈的暴风雨切断了城堡与外界的唯一桥梁，所有人都被困于此：伯爵年轻貌美的妻子、与他素有嫌隙的侄子、负债累累的私人医生，以及一位被请来进行降神会的女巫。",
					roles: [
						{
							name: "安娜",
							description: "伯爵的年轻妻子，被外界传言是为了财产才嫁给年迈的伯爵。",
							storyline: `我受够了这段没有爱情的婚姻。我爱上了侄子爱德华，我们计划私奔。\n**晚上8:00**：我和爱德华在花园秘密会面，商量私奔的细节。我告诉他，我找到了一条可以通往书房的密道。\n**晚上9:00**：伯爵把我叫到书房，再次因为我购买奢侈品的事与我争吵，并威胁要修改遗嘱，剥夺我的继承权。我愤怒地离开。\n**晚上9:30**：我回到房间，收拾好我的珠宝准备离开。此时我听到楼下传来一声女人的尖叫，但很快就消失了。\n**晚上10:00**：我从房间的密道入口进入，想去书房偷走遗嘱。当我从书房的壁炉后走出来时，发现伯爵已经倒在血泊里。我吓坏了，立刻原路返回，不敢声张。`,
							tasks: "1. 隐藏你和爱德华的私情以及私奔计划。\n2. 隐藏你曾通过密道进入案发现场的事实。\n3. 你认为凶手是其他人，需要尽快找到证据洗脱嫌疑。",
							isKiller: false,
						},
						{
							name: "爱德华",
							description: "伯爵的侄子，放荡不羁，是城堡的法定继承人，但与伯爵关系恶劣。",
							storyline: `我急需用钱，但老家伙一分钱都不肯给我。我今晚准备偷点东西去卖。\n**晚上8:00**：我和安娜在花园见面，她告诉我一条通往书房的密道，这正合我意。\n**晚上8:30**：我看到医生马丁行色匆匆地进了伯爵的书房。\n**晚上9:10**：我准备通过安娜告诉我的密道进入书房，但在密道口听到了里面有奇怪的响动，我害怕被发现，就退了回来。\n**晚上9:40**：我在走廊里遇到了女巫罗兰女士，她警告我今晚城堡会有血光之灾，让我不要乱走动。她的眼神很奇怪，让我不寒而栗。`,
							tasks: "1. 隐藏你计划偷窃以及知道密道的事实。\n2. 伯爵死了，你是最大受益人，你的嫌疑最大。你需要将嫌疑转移到他人身上，比如医生或行为诡异的女巫。\n3. 你需要找到对你有利的证据。",
							isKiller: false,
						},
						{
							name: "马丁医生",
							description: "伯爵的私人医生，医术高明，但深陷赌博债务。",
							storyline: `我欠了伯爵一大笔钱，他拿走了我的行医执照作为抵押，并威胁如果我还不上钱，就让我身败名裂。\n**晚上8:30**：我去找伯爵，恳求他再宽限我一段时间。他不仅拒绝了，还羞辱了我一番。我绝望地离开。\n**晚上9:00**：我回到我的房间，准备了一些强效镇定剂，我计划让他睡着，然后偷回我的行医执照。\n**晚上9:20**：我再次来到书房门口，却听到里面安娜和伯爵在激烈争吵。我只好暂时放弃计划，躲在附近观察。\n**晚上9:40后**：我看到安娜气冲冲地离开后，就再也没人进出过书房。我因为害怕一直没敢动手，直到尸体被发现。`,
							tasks: "1. 隐藏你欠下巨额赌债并被伯爵威胁的事实。\n2. 隐藏你准备了镇定剂并计划偷东西的意图。\n3. 你是最后一个见到伯爵的人之一，你需要证明你离开后还有作案时间。",
							isKiller: false,
						},
						{
							name: "罗兰女士",
							description: "著名的灵媒、女巫，被伯爵请来进行降神会，与城堡的“幽灵”对话。",
							storyline: `我是个骗子。伯爵发现了我的秘密，并以此敲诈我，让我免费为他“服务”。\n**晚上9:10**：伯爵把我叫到书房，再次威胁我，说如果今晚的降神会不能让他满意，就要揭穿我的一切。我感到前所未有的恐惧。\n**晚上9:30**：我借口准备仪式，独自留在书房。伯爵背对着我，在欣赏一幅画。我看到桌上有一把锋利的拆信刀，一时冲动，拿起刀从背后刺向了他。他当场倒下。我发出一声短促的尖叫，但立刻捂住了嘴。\n**晚上9:35**：我慌乱地将书房门从内反锁，然后从墙角的书架后面启动了密道（这是我之前偷偷发现的），逃离了现场。在密道中，我的一片蕾丝袖口被挂掉了。\n**晚上9:40**：我从密道出来，遇到了爱德华，我故作神秘地警告他有血光之灾，以掩饰我的慌张。`,
							tasks: "1. 你是真凶！你的任务是隐藏一切，将罪行嫁祸给他人。\n2. 利用你“女巫”的身份，编造一些鬼神之说来混淆视听。\n3. 爱德华和安娜都知道密道，这是嫁祸他们的好机会。马丁医生有强烈的动机，也可以加以利用。",
							isKiller: true,
						},
					],
					clues: [
						{ owner: "安娜", description: "你的珠宝盒里有一张单程的火车票，目的地是巴黎，时间是明天一早。" },
						{ owner: "爱德华", description: "你的口袋里有一张当票，上面是一枚属于伯爵家族的古董怀表。" },
						{ owner: "马丁医生", description: "你的药箱里有一瓶几乎满装的强效镇定剂，以及一张伯爵写的、要求你一周内还清10万英镑欠款的字条。" },
						{ owner: "罗兰女士", description: "你的长裙袖口处有一块明显的撕裂痕迹，似乎是被什么东西挂坏的。", isKey: true },
						{ owner: "公共", description: "在书房壁炉后面发现一个隐蔽的按钮，按下后，旁边的一整面书架会旋转打开，露出一条通往楼上走廊的密道。" },
						{ owner: "公共", description: "在密道的地板上，发现了一小片黑色的蕾丝布料。" },
						{ owner: "公共", description: "伯爵的书桌上摊开着一本关于“灵媒与欺诈”的书，其中一页用红笔圈出了“罗兰女士”的名字。" },
					],
					truth: "凶手是女巫罗兰女士。伯爵发现了她是个骗子并以此敲诈她。当晚，伯爵再次威胁她，罗兰在恐惧和愤怒之下，用拆信刀从背后杀害了伯主。她知道城堡的密道，于是反锁房门，通过密道逃离，伪造了密室杀人案。但慌乱中，她的一片蕾f丝袖口挂在了密道里，成为了关键证据。",
				},
			];

			/**
			 * 从一个已领完的红包中找出"手气王"(获得金额最多的人)
			 * @param {object} packet - 已领完的红包消息对象
			 * @returns {object|null} - 返回手气王的信息 { name, amount }，或 null
			 */
			function findLuckyKing(packet) {
				const claimedBy = packet.claimedBy || {};
				const claimedEntries = Object.entries(claimedBy);

				// 如果红包是"拼手气"类型，并且有超过1个人领取
				if (packet.packetType === "lucky" && claimedEntries.length > 1) {
					let luckyKing = { name: "", amount: -1 };
					claimedEntries.forEach(([name, amount]) => {
						if (amount > luckyKing.amount) {
							luckyKing = { name, amount };
						}
					});
					return luckyKing;
				}
				return null; // 如果不满足条件，则没有手气王
			}

			// 应用状态管理对象
			let state = {
				chats: {},
				activeChatId: null,
				globalSettings: {},
				apiConfig: {},
				userStickers: [],
				worldBooks: [],
				personaPresets: [],
				qzoneSettings: {},
				activeAlbumId: null,
			};

			// 约会游戏状态管理对象
			let datingGameState = {
				isActive: false,
				scene: null,
				characterId: null,
				storyHistory: [],
				romance: 0,
				lust: 0,
				currentStoryText: "",
				currentSentenceIndex: -1,
				sentences: [],
				isSwitchingSentence: false,
				isNsfwMode: false,
				completion: 0,
			};

			// 用于暂存当前约会游戏结算卡片的数据
			let currentDatingSummary = null;

			// Gemini API基础URL
			const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models";

			/**
			 * 从逗号分隔的字符串中随机选择一个值
			 * @param {string} str - 可能包含逗号分隔的多个值的字符串
			 * @returns {string} - 随机选择的单个值
			 */
			function getRandomValue(str) {
				// 检查字符串是否包含逗号
				if (str.includes(",")) {
					// 用逗号分隔字符串并移除多余空格
					const arr = str.split(",").map((item) => item.trim());
					// 生成随机索引 (0 到 arr.length-1)
					const randomIndex = Math.floor(Math.random() * arr.length);
					// 返回随机元素
					return arr[randomIndex];
				}
				// 没有逗号则直接返回原字符串
				return str;
			}

			/**
			 * 处理图片消息，提取Base64数据和MIME类型
			 * @param {object} text - 文本内容对象
			 * @param {object} content - 图片内容对象
			 * @returns {array} - 包含文本描述和图片数据的数组
			 */
			function isImage(text, content) {
				let currentImageData = content.image_url.url;
				// 提取Base64数据（去掉前缀）
				const base64Data = currentImageData.split(",")[1];
				// 根据图片类型获取MIME类型
				const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
				return [
					{ text: `${text.text}用户向你发送了一张图片` },
					{
						inline_data: {
							mime_type: mimeType,
							data: base64Data,
						},
					},
				];
			}

			/**
			 * 从文本中提取时间戳和JSON数组数据
			 * @param {string} text - 包含时间戳和JSON数据的文本
			 * @returns {array|string} - 解析成功返回[时间戳部分, JSON数据]，失败返回原文本
			 */
			function extractArray(text) {
				// 正则表达式模式：匹配开头的时间戳部分和后续的JSON数组
				const pattern = /^\(Timestamp: (\d+)\)(.*)$/s;
				const match = text.match(pattern);

				if (match) {
					const timestampPart = `(Timestamp: ${match[1]}) `;
					const jsonPart = match[2].trim();

					try {
						// 尝试解析JSON部分
						const parsedJson = JSON.parse(jsonPart);
						// 验证解析结果是否为数组
						if (Array.isArray(parsedJson)) {
							return [timestampPart, parsedJson[0]];
						}
					} catch (error) {
						// 解析失败，返回原始文本
					}
				}

				// 不匹配格式或解析失败时返回原值
				return text;
			}

			/**
			 * 转换聊天数据格式
			 * @param {object} item - 聊天消息项
			 * @returns {array} - 转换后的消息数组
			 */
			function transformChatData(item) {
				let type = {
					send_and_recall: "撤回了消息",
					update_status: "更新了状态",
					change_music: "切换了歌曲",
					create_memory: "记录了回忆",
					create_countdown: "创建了约定/倒计时",
					text: "发送了文本",
					sticker: "发送了表情",
					ai_image: "发送了图片",
					voice_message: "发送了语音",
					transfer: "发起了转账",
					waimai_request: "发起了外卖请求",
					waimai_response: {
						paid: "回应了外卖-同意",
						rejected: "回应了外卖-拒绝",
					},
					video_call_request: "发起了视频通话",
					video_call_response: {
						accept: "回应了视频通话-接受",
						reject: "回应了视频通话-拒绝",
					},
					qzone_post: {
						shuoshuo: "发布了说说",
						text_image: "发布了文字图",
					},
					qzone_comment: "评论了动态",
					qzone_like: "点赞了动态",
					pat_user: "拍一拍了用户",
					block_user: "拉黑了用户",
					friend_request_response: "回应了好友申请",
					change_avatar: "更换了头像",
					share_link: "分享了链接",
					accept_transfer: "回应了转账-接受",
					decline_transfer: "回应了转账-拒绝/退款",
					quote_reply: "引用了回复",
					text: "",
				};
				let res = extractArray(item.content);

				if (Array.isArray(res)) {
					let obj = res[1];
					let itemType = obj.type;
					let time = res[0];
					let text = type[itemType];
					if (text) {
						if (itemType === "sticker") {
							return [{ text: `${time}[${text}] 含义是:${obj.meaning}` }];
						} else if (itemType === "send_and_recall") {
							return [{ text: `${time}[${text}] ${obj.content}` }];
						} else if (itemType === "update_status") {
							return [{ text: `${time}[${text}] ${obj.status_text}(${obj.is_busy ? "忙碌/离开" : "空闲"})` }];
						} else if (itemType === "change_music") {
							return [{ text: `${time}[${text}] ${obj.change_music}, 歌名是:${obj.song_name}` }];
						} else if (itemType === "create_memory") {
							return [{ text: `${time}[${text}] ${obj.description}` }];
						} else if (itemType === "create_countdown") {
							return [{ text: `${time}[${text}] ${obj.title}(${obj.date})` }];
						} else if (itemType === "ai_image") {
							return [{ text: `${time}[${text}] 图片描述是:${obj.description}` }];
						} else if (itemType === "voice_message") {
							return [{ text: `${time}[${text}] ${obj.content}` }];
						} else if (itemType === "transfer") {
							return [{ text: `${time}[${text}] 金额是:${obj.amount} 备注是:${obj.amount}` }];
						} else if (itemType === "waimai_request") {
							return [{ text: `${time}[${text}] 金额是:${obj.amount} 商品是:${obj.productInfo}` }];
						} else if (itemType === "waimai_response") {
							return [{ text: `${time}[${text[obj.status]}] ${obj.status === "paid" ? "同意" : "拒绝"}` }];
						} else if (itemType === "video_call_request") {
							return [{ text: `${time}[${text}]` }];
						}
					} else if (itemType === "video_call_request") {
						return [{ text: `${time}[${text[obj.decision]}] ${obj.decision === "accept" ? "同意" : "拒绝"}` }];
					} else if (itemType === "qzone_post") {
						return [{ text: `${time}[${text[obj.postType]}] ${obj.postType === "shuoshuo" ? `${obj.content}` : `图片描述是:${obj.hiddenContent} ${obj.publicText ? `文案是: ${obj.publicText}` : ""}`}` }];
					} else if (itemType === "qzone_comment") {
						return [{ text: `${time}[${text}] 评论的id是: ${obj.postId} 评论的内容是: ${obj.commentText}` }];
					} else if (itemType === "qzone_like") {
						return [{ text: `${time}[${text}] 点赞的id是: ${obj.postId}` }];
					} else if (itemType === "pat_user") {
						return [{ text: `${time}[${text}] ${obj.suffix ? obj.suffix : ""}` }];
					} else if (itemType === "block_user") {
						return [{ text: `${time}[${text}]` }];
					} else if (itemType === "friend_request_response") {
						return [{ text: `${time}[${text}] 结果是:${obj.decision === "accept" ? "同意" : "拒绝"}` }];
					} else if (itemType === "change_avatar") {
						return [{ text: `${time}[${text}] 头像名是:${obj.name}` }];
					} else if (itemType === "share_link") {
						return [{ text: `${time}[${text}] 文章标题是:${obj.title}  文章摘要是:${obj.description} 来源网站名是:${obj.source_name} 文章正文是:${obj.content}` }];
					} else if (itemType === "accept_transfer") {
						return [{ text: `${time}[${text}]` }];
					} else if (itemType === "accept_transfer") {
						return [{ text: `${time}[${text}]` }];
					} else if (itemType === "quote_reply") {
						return [{ text: `${time}[${text}] 引用的内容是:${obj.reply_content}` }];
					} else if (itemType === "text") {
						return [{ text: `${time}${obj.content}` }];
					}
				}

				// (例如，它是一个数组，或者一个AI返回的、我们不认识的JSON对象)
				if (typeof res !== "string") {
					// 我们就强制使用最原始、最安全的 item.content 字符串
					res = item.content;
				}

				return [{ text: res }];
			}

			/**
			 * 构造Gemini API请求数据
			 * @param {string} model - 模型名称
			 * @param {string} apiKey - API密钥
			 * @param {string} systemInstruction - 系统指令
			 * @param {array} messagesForDecision - 消息历史
			 * @param {boolean} isGemini - 是否为Gemini模型
			 * @param {number} temperature - 温度参数
			 * @returns {object|undefined} - 构造的请求数据对象或undefined
			 */
			function toGeminiRequestData(model, apiKey, systemInstruction, messagesForDecision, isGemini, temperature) {
				if (!isGemini) {
					return undefined;
				}

				// 角色类型映射，将'system'角色也映射为'user'
				let roleType = {
					user: "user",
					assistant: "model",
					system: "user", // 将system角色映射为user角色
				};

				return {
					url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`,
					data: {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
						},
						body: JSON.stringify({
							contents: messagesForDecision.map((item) => {
								// 检查消息是否包含图片
								let includesImages = false;
								if (Array.isArray(item.content)) {
									includesImages = item.content.some((sub) => {
										return sub.type === "image_url" && sub.image_url.url;
									});
								}
								return {
									role: roleType[item.role], // 现在 'system' 会被正确转换为 'user'
									parts: includesImages ? isImage(item.content[0], item.content[1]) : transformChatData(item),
								};
							}),
							generationConfig: {
								temperature: parseFloat(temperature) || 0.8,
							},
							systemInstruction: {
								parts: [
									{
										text: systemInstruction,
									},
								],
							},
						}),
					},
				};
			}

			document.addEventListener("DOMContentLoaded", () => {
				// ===================================================================
				// 1. 所有变量和常量定义
				// ===================================================================
				// 宠物数值衰减相关的全局变量和常量
				const PET_DECAY_INTERVAL = 60 * 60 * 1000; // 每60分钟衰减一次
				const PET_DECAY_AMOUNT = {
					// 每次衰减的数值
					hunger: 5,
					happiness: 3,
				};
				let petDecayTimer = null; // 用于管理衰减计时器的全局变量
				// 角色手机的App列表
				const CHAR_PHONE_APPS = [
					{ id: "chat", name: "微信", screen: "character-chat-list-screen", svg: `<svg viewBox="0 0 24 24" fill="#4CAF50"><path d="M12 2C6.48 2 2 6.48 2 12c0 2.94 1.28 5.58 3.34 7.42c-.22 1.4-.89 3.1-1.25 3.82c-.36.72.48 1.39 1.05.94c.82-.67 2.43-1.88 3.3-2.58C9.44 21.78 10.68 22 12 22c5.52 0 10-4.48 10-10S17.52 2 12 2zm3.5 10.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5zm-7 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/></svg>` },
					{ id: "cart", name: "购物车", screen: "character-shopping-cart-screen", svg: `<svg viewBox="0 0 24 24" fill="#F44336"><path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2s-.9-2-2-2zm10 0c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2s2-.9 2-2s-.9-2-2-2zm-15-14h3.27l.94 2H20c.69 0 1.25.56 1.25 1.25c0 .09-.02.18-.04.27l-3.58 6.49c-.25.44-.73.74-1.26.74H8.52l-.94-2H4.27V4H2V2h3.27z"/></svg>` },
					{ id: "memos", name: "备忘录", screen: "character-memos-screen", svg: `<svg viewBox="0 0 24 24" fill="#FFC107"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>` },
					{ id: "browser", name: "浏览器", screen: "character-browser-screen", svg: `<svg viewBox="0 0 24 24" fill="#2196F3"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1.5-12.5l3 7.5 7.5-3-7.5-3z"/></svg>` },
					{ id: "album", name: "相册", screen: "character-album-screen", svg: `<svg viewBox="0 0 24 24" fill="#8BC34A"><path d="M22 16V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2zm-11-4l2.03 2.71L16 11l4 5H8l3-4zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z"/></svg>` },
					{ id: "bank", name: "钱包", screen: "character-bank-screen", svg: `<svg viewBox="0 0 24 24" fill="#E91E63"><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>` },
					{ id: "trajectory", name: "足迹", screen: "character-trajectory-screen", svg: `<svg viewBox="0 0 24 24" fill="#795548"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>` },
					{ id: "app_usage", name: "使用记录", screen: "character-app-usage-screen", svg: `<svg viewBox="0 0 24 24" fill="#607D8B"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8s8 3.58 8 8s-3.58 8-8 8zm.5-13H11v6l5.25 3.15l.75-1.23l-4.5-2.67z"/></svg>` },
					{ id: "diary", name: "日记", screen: "character-diary-screen", svg: `<svg viewBox="0 0 24 24" fill="#009688"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83l3.75 3.75 1.83-1.83z"/></svg>` },
					{ id: "appearance", name: "外观设置", screen: "character-phone-appearance-screen", svg: `<svg viewBox="0 0 24 24" fill="#9C27B0"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1.17 14.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32l-1.41-1.41c-.2-.2-.31-.45-.31-.71 0-.26.11-.51.31-.71l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.4.4.4 1.04 0 1.41l-1.41 1.41zm3.34-5.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32L11.41 8.5c-.2-.2-.31-.45-.31-.71 0-.26.11-.51.31-.71l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.4.4.4 1.04 0 1.41l-1.41 1.41zm3.34 5.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32l-1.41-1.41c-.4-.4-.4-1.04 0-1.41l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.2.2.31.45.31.71 0 .26-.11.51-.31.71l-1.41 1.41z"/></svg>` },
				];

				// 约会大作战App核心功能全局变量
				let currentDatingScenes = []; // 存储所有已生成的约会场景
				let isGeneratingScenes = false; // 标记是否正在生成场景
				let currentDatingUISettings = null; // 存储约会界面设置

				/**
				 * 打开"约会大作战"App，快速显示已保存数据
				 */
				async function openDatingApp() {
					showScreen("date-a-live-screen");
					// 从数据库加载所有已保存的场景
					currentDatingScenes = await db.datingScenes.toArray();
					console.log(`从数据库加载了 ${currentDatingScenes.length} 个约会场景。`);
					// 渲染这些场景（只会先显示文字和加载动画）
					renderDatingScenes();
				}

				/**
				 * 调用AI生成新的一批约会场景，并只保存场景数据
				 */
				async function refreshDatingScenes() {
					if (isGeneratingScenes) {
						alert("正在加载中，请不要着急哦~");
						return;
					}
					isGeneratingScenes = true;

					const contentEl = document.getElementById("dating-scene-content");
					const loadingIndicator = document.createElement("p");
					loadingIndicator.textContent = "AI正在构思新的约会方案...";
					loadingIndicator.style.textAlign = "center";
					loadingIndicator.style.color = "var(--text-secondary)";
					contentEl.innerHTML = ""; // 先清空旧场景
					contentEl.appendChild(loadingIndicator);

					const { proxyUrl, apiKey, model } = state.apiConfig;
					if (!proxyUrl || !apiKey || !model) {
						loadingIndicator.textContent = "API未配置，无法生成场景！";
						loadingIndicator.style.color = "red";
						isGeneratingScenes = false;
						return;
					}

					// Prompt保持不变
					const prompt = `
                        # 任务
                        你是一位顶级约会策划师，尤其擅长营造浪漫氛围。请为我策划 3-5 个适合情侣的、日常且极具浪漫情调的约会场景。

                        # 核心规则
                        1.  **场景风格**: 场景必须是现实生活中可以实现的，但要富有想象力和浪漫气息。**绝对禁止**任何黑暗、恐怖或令人不适的元素。
                        2.  **场景多样性**: 请包含多种类型的地点，例如：
                            -   **户外**: 公园、海边、路边小吃摊。
                            -   **室内**: 温馨的咖啡馆、艺术展、书店。
                            -   **住宿**: 普通的温馨酒店、电竞酒店、甚至可以来点新奇的情趣酒店。
                        3.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，直接以'['开头, 以']'结尾。
                        4.  **内容要求**: 每个场景对象【必须】包含以下三个字段:
                            -   \`"name"\`: (字符串) 一个充满浪漫想象的日常约会场景名称 (例如: "星空下的电竞双排夜", "微醺路边摊的夏日晚风", "私语书店的角落")。
                            -   \`"cost"\`: (数字) 一个代表浪漫程度的虚拟花费 (例如: 288, 520, 999)。
                            -   \`"imagePrompt"\`: (字符串) 一个用于文生图的、纯英文的、详细的【纯风景或静物】描述，用于生成场景图片。【绝对不能包含人物、情侣或任何人】。图片风格必须是【浪漫唯美的 (romantic, beautiful, aesthetic)】，可以使用 anime style, vibrant colors, soft lighting, masterpiece 等词汇来增强艺术感。

                        # JSON输出格式示例:
                        [
                            {
                                "name": "雨后公园的七彩霓虹",
                                "cost": 188,
                                "imagePrompt": "a peaceful park after rain, wet cobblestone path reflecting neon city lights, rainbow puddle, glowing lanterns on trees, beautiful, aesthetic, anime style, masterpiece, vibrant colors"
                            }
                        ]
                    `;

					try {
						const messagesForApi = [{ role: "user", content: prompt }];
						let isGemini = proxyUrl === GEMINI_API_URL;
						let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);

						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.1, response_format: { type: "json_object" } }),
							  });

						if (!response.ok) throw new Error(`API请求失败: ${await response.text()}`);

						const data = await response.json();
						const rawContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
						const cleanedContent = rawContent.replace(/^```json\s*|```$/g, "").trim();
						const newScenes = JSON.parse(cleanedContent);

						if (Array.isArray(newScenes)) {
							// 核心修改：只添加uid和空的imageUrl，不再立即生成图片
							const scenesWithId = newScenes.map((scene, index) => ({
								...scene,
								uid: "scene_" + Date.now() + index,
								imageUrl: "", // 初始化时图片链接为空
							}));

							await db.datingScenes.bulkAdd(scenesWithId);

							// 更新内存数据，并重新渲染（此时图片还是加载中状态）
							currentDatingScenes.push(...scenesWithId);
							renderDatingScenes();
						} else {
							throw new Error("AI返回的数据不是有效的数组。");
						}
					} catch (error) {
						console.error("生成约会场景失败:", error);
						contentEl.innerHTML = `<p style="text-align:center; color:red;">生成失败: ${error.message}</p>`;
					} finally {
						isGeneratingScenes = false;
					}
				}

				/**
				 * 渲染所有约会场景卡片，并异步加载图片
				 */
				function renderDatingScenes() {
					const contentEl = document.getElementById("dating-scene-content");
					contentEl.innerHTML = ""; // 每次都清空再渲染

					if (currentDatingScenes.length === 0) {
						// 如果数据库是空的，显示提示并触发一次生成
						if (!isGeneratingScenes) {
							contentEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 50px 0;">正在为你构思浪漫的约会方案...</p>';
							refreshDatingScenes();
						}
						return;
					}

					// 核心修改：使用 forEach 立即渲染所有卡片
					currentDatingScenes.forEach((scene) => {
						const card = createDatingSceneCard(scene);
						contentEl.appendChild(card);
						// 核心修改：调用新的异步函数去处理图片
						loadAndDisplaySceneImage(scene);
					});
				}

				/**
				 * 为单个场景加载或生成图片，并更新其卡片
				 * @param {object} scene - 约会场景对象
				 */
				async function loadAndDisplaySceneImage(scene) {
					const card = document.querySelector(`.dating-scene-card[data-uid="${scene.uid}"]`);
					if (!card) return;
					const imageContainer = card.querySelector(".dating-scene-image-container");

					// 1. 如果数据库里已经有图片URL，直接使用它
					if (scene.imageUrl) {
						imageContainer.innerHTML = `<img src="${scene.imageUrl}" alt="${scene.name}">`;
						return;
					}

					// 2. 如果没有URL，说明需要生成
					try {
						const imageUrl = await generateAndLoadImage(scene.imagePrompt);
						// 生成成功后，更新UI
						if (document.body.contains(imageContainer)) {
							imageContainer.innerHTML = `<img src="${imageUrl}" alt="${scene.name}">`;
						}

						// 关键：将新生成的URL保存回数据库！
						scene.imageUrl = imageUrl;
						await db.datingScenes.update(scene.uid, { imageUrl: imageUrl });
						console.log(`为场景 "${scene.name}" 生成并保存了新图片。`);
					} catch (error) {
						console.error(`场景 "${scene.name}" 图片渲染失败:`, error);
						if (document.body.contains(imageContainer)) {
							imageContainer.innerHTML = `<span>图片加载失败</span>`;
						}
					}
				}

				/**
				 * 根据唯一ID删除一个约会场景 (已添加数据库操作)
				 * @param {string} sceneUid - 场景的唯一ID
				 */
				async function deleteDatingScene(sceneUid) {
					const cardToRemove = document.querySelector(`.dating-scene-card[data-uid="${sceneUid}"]`);
					if (cardToRemove) {
						cardToRemove.style.transition = "transform 0.3s, opacity 0.3s";
						cardToRemove.style.transform = "scale(0.9)";
						cardToRemove.style.opacity = "0";
						setTimeout(async () => {
							await db.datingScenes.delete(sceneUid);
							currentDatingScenes = currentDatingScenes.filter((scene) => scene.uid !== sceneUid);
							cardToRemove.remove();
						}, 300);
					}
				}

				// 处理场景图片生成和加载
				async function processSceneImages(newScenes) {
					const contentEl = document.getElementById("dating-scene-content");

					for (const scene of newScenes) {
						const card = createDatingSceneCard(scene);
						contentEl.appendChild(card);

						try {
							const imageUrl = await generateAndLoadImage(scene.imagePrompt);
							const imageContainer = card.querySelector(".dating-scene-image-container");
							if (imageContainer) {
								imageContainer.innerHTML = `<img src="${imageUrl}" alt="${scene.name}">`;
							}
						} catch (error) {
							console.error(`场景 "${scene.name}" 图片生成失败:`, error);
							const imageContainer = card.querySelector(".dating-scene-image-container");
							if (imageContainer) {
								imageContainer.innerHTML = `<span>图片生成失败</span>`;
							}
						}
					}
				}

				// 创建约会场景卡片元素
				function createDatingSceneCard(scene) {
					const card = document.createElement("div");
					card.className = "dating-scene-card";
					card.dataset.uid = scene.uid;

					card.innerHTML = `
                    <button class="dating-scene-delete-btn" title="删除此场景">×</button>
                    <div class="dating-scene-image-container">
                        <div class="loading-spinner"></div>
                    </div>
                    <div class="dating-scene-info">
                        <div class="name">${scene.name}</div>
                        <div class="cost">花费: ${scene.cost}金币</div>
                    </div>
                `;
					return card;
				}

				// 生成并加载图片
				function generateAndLoadImage(prompt) {
					return new Promise((resolve, reject) => {
						const encodedPrompt = encodeURIComponent(prompt);
						const seed = Math.floor(Math.random() * 100000);
						const imageUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}?width=1024&height=640&seed=${seed}`;

						const img = new Image();
						img.src = imageUrl;

						img.onload = () => resolve(imageUrl);
						img.onerror = () => {
							console.warn(`主URL加载失败，尝试备用URL for: ${prompt}`);
							const fallbackUrl = `https://pollinations.ai/p/${encodedPrompt}?width=1024&height=640&seed=${seed}`;
							img.src = fallbackUrl;
							img.onload = () => resolve(fallbackUrl);
							img.onerror = () => reject(new Error("主域名和备用域名均加载失败"));
						};
					});
				}

				const db = new Dexie("GeminiChatDB");

				// API站点黑名单列表
				const BLOCKED_API_SITES = ["api.pisces.ink", "aiapi.qzz.io"];

				// 用户贴纸选择模式状态
				let isUserStickerSelectionMode = false;
				// 当前激活的贴纸分类ID
				let activeStickerCategoryId = "uncategorized";
				// 用户贴纸分类缓存
				let userStickerCategories = [];
				// 角色贴纸选择模式状态
				let isCharStickerSelectionMode = false;
				// 选中的角色贴纸集合
				let selectedCharStickers = new Set();
				// 选中的用户贴纸集合
				let selectedUserStickers = new Set();
				// 锁屏状态
				let isLocked = false;
				// 新锁屏壁纸Base64数据
				let newLockscreenWallpaperBase64 = null;
				// 新全局聊天背景Base64数据
				let newGlobalBgBase64 = null;
				// 新App壁纸Base64数据
				let newAppWallpaperBase64 = null;

				// 音乐播放器状态管理
				let musicState = {
					isActive: false, // 是否激活
					activeChatId: null, // 激活的聊天ID
					isPlaying: false, // 是否正在播放
					playlist: [], // 播放列表
					currentIndex: -1, // 当前播放索引
					playMode: "order", // 播放模式
					totalElapsedTime: 0, // 总播放时间
					timerId: null, // 定时器ID
					parsedLyrics: [], // 解析后的歌词数组
					currentLyricIndex: -1, // 当前高亮歌词行索引
				};

				// 桌面歌词设置
				let lyricsBarSettings = {
					fontSize: 14, // 字体大小
					bgOpacity: 0, // 背景透明度
					fontColor: "#FFFFFF", // 字体颜色
					showOnClose: true, // 关闭时是否显示
				};

				// 音频播放器元素
				const audioPlayer = document.getElementById("audio-player");
				// 新壁纸Base64数据
				let newWallpaperBase64 = null;
				// 选择模式状态
				let isSelectionMode = false;
				// 内心独白历史面板状态
				let isInnerVoiceHistoryOpen = false;
				// 选中的消息集合
				let selectedMessages = new Set();
				// 正在编辑的成员ID
				let editingMemberId = null;
				// 正在编辑的世界书ID
				let editingWorldBookId = null;
				// 正在编辑的人设预设ID
				let editingPersonaPresetId = null;
				// 激活的角色手机外观预设ID
				let activeCharPhonePresetId = null;
				// 激活的角色手机ID
				let activeCharacterPhoneId = null;
				// 外卖计时器
				let waimaiTimers = {};
				// 正在编辑的精灵组ID
				let editingSpriteGroupId = null;
				// 激活消息时间戳
				let activeMessageTimestamp = null;
				// 当前回复上下文
				let currentReplyContext = null;
				// 当前搜索关键词
				let currentSearchKeyword = "";
				// 当前操作的动态ID
				let activePostId = null;

				// 网络请求函数
				if (typeof Http_Get_External === "undefined") {
					window.Http_Get_External = function (url) {
						return new Promise((resolve) => {
							fetch(url)
								.then((res) => res.json().catch(() => res.text()))
								.then(resolve)
								.catch(() => resolve(null));
						});
					};
				}

				// HTTP GET请求函数
				async function Http_Get(url) {
					return await Http_Get_External(url);
				}

				// 检查音频链接是否可用
				function checkAudioAvailability(url) {
					return new Promise((resolve) => {
						const tester = new Audio();
						tester.addEventListener("loadedmetadata", () => resolve(true), { once: true });
						tester.addEventListener("error", () => resolve(false), { once: true });
						tester.src = url;
					});
				}

				// 搜索网易云音乐
				async function searchNeteaseMusic(name, singer) {
					try {
						let searchTerm = name.replace(/\s/g, "");
						if (singer) {
							searchTerm += ` ${singer.replace(/\s/g, "")}`;
						}

						// 直接请求vkeys.cn API
						const apiUrl = `https://api.vkeys.cn/v2/music/netease?word=${encodeURIComponent(searchTerm)}`;

						console.log("正在尝试直接请求:", apiUrl);

						const response = await fetch(apiUrl);

						if (!response.ok) {
							throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
						}

						const result = await response.json();

						if (result.code !== 200 || !result.data || result.data.length === 0) {
							console.log("vkeys API返回无结果:", result);
							return [];
						}

						return result.data
							.map((song) => ({
								name: song.song,
								artist: song.singer,
								id: song.id,
								cover: song.cover || "https://i.postimg.cc/pT2xKzP-album-cover-placeholder.png",
								source: "netease",
							}))
							.slice(0, 15);
					} catch (e) {
						console.error("【vkeys API 直连】搜索失败:", e);
						await showCustomAlert("网易云接口直连失败", `如果浏览器控制台(F12)提示CORS错误，说明此API禁止直接访问。错误: ${e.message}`);
						return [];
					}
				}

				// 搜索QQ音乐
				async function searchTencentMusic(name) {
					try {
						name = name.replace(/\s/g, "");
						const result = await Http_Get(`https://api.vkeys.cn/v2/music/tencent?word=${encodeURIComponent(name)}`);
						if (!result?.data?.length) return [];
						return result.data
							.map((song) => ({
								name: song.song,
								artist: song.singer,
								id: song.id,
								cover: song.cover || "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png",
								source: "tencent",
							}))
							.slice(0, 5);
					} catch (e) {
						console.error("QQ音乐搜索API失败:", e);
						return [];
					}
				}

				// 从搜索添加歌曲（支持多源选择）
				async function addSongFromSearch() {
					// 让用户选择搜索源
					const source = await showSearchSourceSelector();
					// 如果用户取消选择，直接返回
					if (!source) return;

					// 获取用户输入的搜索词
					const searchTerm = await showCustomPrompt("搜索歌曲", "请输入 歌名 或 歌名-歌手");
					if (!searchTerm || !searchTerm.trim()) return;

					await showCustomAlert("请稍候...", "正在搜索歌曲资源...");

					let musicName = searchTerm.trim();
					let singerName = "";
					if (searchTerm.includes("-") || searchTerm.includes("–")) {
						const parts = searchTerm.split(/[-–]/);
						musicName = parts[0].trim();
						singerName = parts.slice(1).join(" ").trim();
					}

					// 根据用户选择的源进行搜索
					let combinedResults = [];

					if (source === "all") {
						// 搜索所有源
						const [neteaseResults, tencentResults] = await Promise.all([searchNeteaseMusic(musicName, singerName), searchTencentMusic(musicName)]);
						combinedResults = [...neteaseResults, ...tencentResults];
					} else if (source === "netease") {
						// 只搜索网易云
						combinedResults = await searchNeteaseMusic(musicName, singerName);
					} else if (source === "tencent") {
						// 只搜索QQ音乐
						combinedResults = await searchTencentMusic(musicName);
					}

					// 如果没有搜索结果，提示用户
					if (combinedResults.length === 0) {
						await showCustomAlert("无结果", "抱歉，在所选来源中未能找到相关歌曲。");
						return;
					}

					// 显示搜索结果
					const modal = document.getElementById("music-search-results-modal");
					const listEl = document.getElementById("search-results-list");
					listEl.innerHTML = "";

					combinedResults.forEach((song) => {
						const item = document.createElement("div");
						item.className = "search-result-item";
						item.dataset.songJson = JSON.stringify(song);
						item.innerHTML = `
                            <div class="title">${song.name}</div>
                            <div class="artist">${song.artist} <span class="source">${song.source === "netease" ? "网易云" : "QQ音乐"}</span></div>
                        `;
						listEl.appendChild(item);
					});

					modal.classList.add("visible");
				}

				// 处理搜索结果点击事件
				async function handleSearchResultClick(songData) {
					const modal = document.getElementById("music-search-results-modal");
					modal.classList.remove("visible");

					await showCustomAlert("请稍候...", `正在获取《${songData.name}》的播放链接...`);

					let playableResult = null;
					let finalSource = songData.source;

					// 尝试主音源
					const primaryApiUrl = songData.source === "netease" ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}` : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
					let primaryResult = await Http_Get(primaryApiUrl);
					if (primaryResult?.data?.url && (await checkAudioAvailability(primaryResult.data.url))) {
						playableResult = { url: primaryResult.data.url, id: songData.id, source: songData.source };
					}

					// 如果主音源失败，尝试备用音源
					if (!playableResult) {
						await showCustomAlert("请稍候...", "主音源获取失败，正在尝试备用音源...");
						const fallbackSource = songData.source === "netease" ? "tencent" : "netease";
						const fallbackResults = fallbackSource === "tencent" ? await searchTencentMusic(songData.name) : await searchNeteaseMusic(songData.name, songData.artist);

						if (fallbackResults.length > 0) {
							const fallbackApiUrl = fallbackSource === "netease" ? `https://api.vkeys.cn/v2/music/netease?id=${fallbackResults[0].id}` : `https://api.vkeys.cn/v2/music/tencent?id=${fallbackResults[0].id}`;
							const fallbackResult = await Http_Get(fallbackApiUrl);
							if (fallbackResult?.data?.url && (await checkAudioAvailability(fallbackResult.data.url))) {
								playableResult = { url: fallbackResult.data.url, id: fallbackResults[0].id, source: fallbackSource };
								finalSource = fallbackSource;
							}
						}
					}

					// 如果无法获取播放链接，提示用户
					if (!playableResult) {
						await showCustomAlert("获取失败", "无法获取该歌曲的有效播放链接，主音源和备用音源均已尝试。");
						return;
					}

					// 提示用户搜索的歌曲会过期
					const confirmed = await showCustomConfirm("温馨提示", "搜索的歌曲24h后会过期，重要的歌曲记得用url或者本地上传哦🐇", { confirmText: "确定" });

					// 如果用户取消，直接返回
					if (!confirmed) {
						return;
					}

					// 获取歌词
					const lrcContent = (await getLyricsForSong(playableResult.id, finalSource)) || "";

					// 创建新歌曲对象
					const newSong = {
						name: songData.name,
						artist: songData.artist,
						src: playableResult.url,
						cover: songData.cover,
						isLocal: false,
						lrcContent: lrcContent,
						isTemporary: true,
						addedTimestamp: Date.now(),
					};

					// 添加到播放列表
					musicState.playlist.push(newSong);

					// 更新播放列表UI
					updatePlaylistUI();

					// 如果当前没有播放歌曲，设置当前索引
					if (musicState.currentIndex === -1) {
						musicState.currentIndex = musicState.playlist.length - 1;
						updatePlayerUI();
					}

					await showCustomAlert("添加成功", `《${songData.name}》已成功添加到播放列表！`);

					// 尝试向AI注入歌曲上下文提示
					try {
						if (state.activeChatId) {
							const chat = state.chats[state.activeChatId];
							if (chat) {
								const hiddenMessage = {
									role: "system",
									content: `[系统提示：用户刚刚通过搜索，将歌曲《${songData.name}》 - ${songData.artist} 添加到了"一起听"的播放列表中。你可以根据这个情景，自然地开启关于这首歌的话题。]`,
									timestamp: Date.now(),
									isHidden: true,
								};

								chat.history.push(hiddenMessage);
								await db.chats.put(chat);

								console.log(`已为歌曲《${songData.name}》成功注入AI上下文提示。`);
							}
						}
					} catch (error) {
						console.error("注入歌曲上下文时出错:", error);
					}
				}

				// 获取歌曲歌词
				async function getLyricsForSong(songId, source) {
					const url = source === "netease" ? `https://api.vkeys.cn/v2/music/netease/lyric?id=${songId}` : `https://api.vkeys.cn/v2/music/tencent/lyric?id=${songId}`;

					const response = await Http_Get(url);
					if (response?.data) {
						const lrc = response.data.lrc || response.data.lyric || "";
						const tlyric = response.data.trans || response.data.tlyric || "";
						return lrc + "\\n" + tlyric;
					}
					return "";
				}

				// 显示搜索源选择器
				function showSearchSourceSelector() {
					return new Promise((resolve) => {
						const modal = document.getElementById("music-source-selector-modal");
						const confirmBtn = document.getElementById("confirm-source-select-btn");
						const cancelBtn = document.getElementById("cancel-source-select-btn");

						// 显示弹窗
						modal.classList.add("visible");

						// 确认按钮点击事件
						const onConfirm = () => {
							const selectedSource = document.querySelector('input[name="search-source"]:checked').value;
							cleanup();
							resolve(selectedSource);
						};

						// 取消按钮点击事件
						const onCancel = () => {
							cleanup();
							resolve(null);
						};

						// 清理函数
						const cleanup = () => {
							modal.classList.remove("visible");
							confirmBtn.removeEventListener("click", onConfirm);
							cancelBtn.removeEventListener("click", onCancel);
						};

						// 绑定事件
						confirmBtn.addEventListener("click", onConfirm);
						cancelBtn.addEventListener("click", onCancel);
					});
				}

				// 根据歌名和歌手自动搜索并播放歌曲
				async function searchAndPlaySong(name, artist) {
					// 提示用户正在搜索
					await showCustomAlert("请稍候...", `AI为你分享了《${name}》，正在努力寻找播放资源...`);

					let songData = null;

					// 优先使用网易云搜索
					const neteaseResults = await searchNeteaseMusic(name, artist);
					if (neteaseResults.length > 0) {
						songData = neteaseResults[0];
					}
					// 如果网易云找不到，使用QQ音乐搜索
					else {
						const tencentResults = await searchTencentMusic(name);
						if (tencentResults.length > 0) {
							songData = tencentResults[0];
						}
					}

					// 如果两个平台都没找到，提示用户
					if (!songData) {
						await showCustomAlert("找不到歌曲", `抱歉，在网易云和QQ音乐都没能找到《${name}》的可播放资源。`);
						return;
					}

					// 获取播放链接
					const apiUrl = songData.source === "netease" ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}` : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;

					const result = await Http_Get(apiUrl);

					// 检查播放链接是否有效
					if (!result?.data?.url || !(await checkAudioAvailability(result.data.url))) {
						await showCustomAlert("获取失败", `找到了《${name}》，但无法获取有效的播放链接。`);
						return;
					}

					// 获取歌词
					const lrcContent = (await getLyricsForSong(songData.id, songData.source)) || "";

					// 创建新歌曲对象
					const newSong = {
						name: songData.name,
						artist: songData.artist,
						src: result.data.url,
						cover: songData.cover,
						isLocal: false,
						lrcContent: lrcContent,
						isTemporary: true,
						addedTimestamp: Date.now(),
					};

					// 检查播放列表中是否已有该歌曲
					const existingIndex = musicState.playlist.findIndex((t) => t.name === newSong.name && t.artist === newSong.artist);
					if (existingIndex !== -1) {
						// 如果存在，直接播放
						playSong(existingIndex);
					} else {
						// 如果不存在，添加到播放列表并播放
						musicState.playlist.push(newSong);
						updatePlaylistUI();
						playSong(musicState.playlist.length - 1);
					}

					// 如果"一起听"功能未激活，启动会话
					if (!musicState.isActive) {
						startListenTogetherSession(state.activeChatId);
					} else {
						// 如果已激活，显示播放器
						document.getElementById("music-player-overlay").classList.add("visible");
					}
				}

				// 照片查看器状态管理
				let photoViewerState = {
					isOpen: false, // 是否打开
					photos: [], // 存储当前相册的所有照片URL
					currentIndex: -1, // 当前正在查看的照片索引
				};

				// 未读帖子计数
				let unreadPostsCount = 0;

				// 收藏选择模式状态
				let isFavoritesSelectionMode = false;
				// 选中的收藏项集合
				let selectedFavorites = new Set();

				// 模拟间隔ID
				let simulationIntervalId = null;

				// 当前帧选择信息
				let currentFrameSelection = { type: null, url: "", target: null };

				// 默认头像和群组图片
				const defaultAvatar = "https://i.postimg.cc/PxZrFFFL/o-o-1.jpg";
				const defaultMyGroupAvatar = "https://i.postimg.cc/cLPP10Vm/4.jpg";
				const defaultGroupMemberAvatar = "https://i.postimg.cc/VkQfgzGJ/1.jpg";
				const defaultGroupAvatar = "https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg";
				let notificationTimeout;

				// 主题CSS模板
				const THEME_CSS_TEMPLATE = `
                /* 
                    EPhone 美化代码模板
                    使用方法: 
                    1. 修改下面的颜色代码或图片URL。
                    2. 不需要修改的部分可以删除或保持不变。
                    3. 颜色代码格式为 #RRGGBB (例如 #FFFFFF 是白色)。
                    4. 图片URL需要是网络直链。
                */

                /* === 1. 手机壳与刘海颜色 === */
                #phone-frame {
                    background-color: #f0f0f0; /* 手机壳颜色 */
                }
                .notch {
                    background-color: #1a1a1a; /* 顶部"刘海"颜色 */
                }
                        #clock-container {  color: white;  }


                /* === 1.5. 全局主题色 (重要！) === */
                /* 这个颜色决定了大部分按钮、链接和高亮文本的颜色。*/
                :root {
                    --accent-color: #007bff; /* 默认是蓝色 */
                }

                /* === 2. 聊天界面顶部和底部的图片按钮替换 === */
                /* "一起听"按钮 (正常状态) */
                #listen-together-btn img[src*="8kYShvrJ/90-UI-2.png"] {
                    content: url('在这里粘贴你的"正常状态"图片URL');
                }
                /* "一起听"按钮 (播放中状态) */
                #listen-together-btn img[src*="D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png"] {
                    content: url('在这里粘贴你的"播放中"图片URL');
                }
                /* "聊天设置"按钮 */
                #chat-settings-btn img {
                    content: url('https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png');
                }
                /* "触发API回复"按钮 */
                #wait-reply-btn img {
                    content: url('https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png');
                }
                /* "发送"按钮 (设为图片形式) */
                #send-btn {
                    background-image: url('在这里粘贴你的发送按钮图片URL');
                    background-size: contain;
                    background-repeat: no-repeat;
                    background-position: center;
                    width: 50px; /* 根据你的图片调整宽度 */
                }

                /* "重新生成回复"按钮 */
                #reroll-btn {
                    background-color: rgba(255, 255, 255, 0.6);
                    color: var(--text-primary); /* 使用全局主题的主文本颜色 */
                }

                /* === 3. 顶部栏与底部栏颜色 === */
                .header, .qzone-header {
                    background-color: rgba(240, 240, 240, 0.8); /* 顶部栏背景色 (带一点透明) */
                    color: #333333; /* 顶部栏文字颜色 */
                }
                #chat-list-bottom-nav {
                // background-color: rgba(245, 245, 245, 0.85); /* 底部导航栏背景色 */
                }
                .nav-item {
                    color: #8a8a8a; /* 底部导航栏未选中项的颜色 */
                }
                .nav-item.active {
                    color: #007bff; /* 底部导航栏选中项的颜色 */
                }

                /* === 4. 各界面背景色 === */
                    #chat-list-screen, #qzone-screen .qzone-content, #memories-view {
                    background-color: #f0f2f5 !important; /* 列表页主背景色 */
                }

                /* === 5. 聊天输入区底部功能栏SVG图标替换 === */
                /* 提示: 你需要将你的SVG代码转换为URL编码格式。
                可以使用在线工具搜索 "SVG to Data URI" 来完成转换。
                然后替换掉下面的 url('...') 部分。 */

                .chat-action-icon-btn {
                    background-color: rgba(255, 255, 255, 0.5); /* 图标按钮的背景色 */
                    border: 1px solid rgba(0,0,0,0.05); /* 图标按钮的边框 */
                }

                /* 表情面板(+)按钮 */
                #open-sticker-panel-btn svg { display: none; /* 隐藏原始SVG */ }
                #open-sticker-panel-btn {
                    background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>');
                    background-size: 60%;
                    background-position: center;
                    background-repeat: no-repeat;
                }

                /* 发送照片(旧)按钮 */
                #send-photo-btn svg { display: none; /* 隐藏原始SVG */ }
                #send-photo-btn {
                    background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>');
                    background-size: 60%;
                    background-position: center;
                    background-repeat: no-repeat;
                }

                /* 上传图片(新)按钮 */
                #upload-image-btn svg { display: none; }
                #upload-image-btn {
                    background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="color: black;"><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>');
                    background-size: 60%;
                    background-position: center;
                    background-repeat: no-repeat;
                }

                /* 转账(￥)按钮 */
                #transfer-btn svg { display: none; }
                #transfer-btn {
                    background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 4L12 12L17 4M12 12V20M8 10H16M8 13H16"></path></svg>');
                    background-size: 60%;
                    background-position: center;
                    background-repeat: no-repeat;
                }

                /* 语音按钮 */
                #voice-message-btn svg { display: none; }
                #voice-message-btn {
                    background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg>');
                    background-size: 60%;
                    background-position: center;
                    background-repeat: no-repeat;
                }

                /* 外卖按钮 */
                #send-waimai-request-btn svg { display: none; }
                #send-waimai-request-btn {
                    background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"/><line x1="3" y1="6" x2="21" y2="6"/><path d="M16 10a4 4 0 0 1-8 0"/></svg>');
                    background-size: 60%;
                    background-position: center;
                    background-repeat: no-repeat;
                }

                /* 视频通话按钮 */
                #video-call-btn svg { display: none; }
                #video-call-btn {
                    background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>');
                    background-size: 60%;
                    background-position: center;
                    background-repeat: no-repeat;
                }

                /* 群视频通话按钮 */
                #group-video-call-btn svg { display: none; }
                #group-video-call-btn {
                    background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>');
                    background-size: 60%;
                    background-position: center;
                    background-repeat: no-repeat;
                }

                /* 投票按钮 */
                #send-poll-btn svg { display: none; }
                #send-poll-btn {
                    background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h10"/><path d="M6 6h.01"/><path d="M8 12h10"/><path d="M6 12h.01"/><path d="M8 18h10"/><path d="M6 18h.01"/></svg>');
                    background-size: 60%;
                    background-position: center;
                    background-repeat: no-repeat;
                }

                /* 分享链接按钮 */
                #share-link-btn svg { display: none; }
                #share-link-btn {
                    background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>');
                    background-size: 60%;
                    background-position: center;
                    background-repeat: no-repeat;
                }

                /* 发送定位按钮 (已修复) */
                #send-location-btn svg { display: none; } /* 隐藏按钮内部原始的SVG图标 */
                #send-location-btn {
                    background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>');
                    background-size: 60%;
                    background-position: center;
                    background-repeat: no-repeat;
                }


                /* === 6. 更多界面背景色 === */
                /* 适用于所有设置、编辑、选择等二级页面 */
                #api-settings-screen,
                #font-settings-screen,
                #wallpaper-screen,
                #world-book-screen,
                #world-book-editor-screen,
                #contact-picker-screen,
                #member-management-screen,
                #album-screen,
                #album-photos-screen,
                #call-history-screen,
                #chat-search-screen,
                #browser-screen {
                /* 这里不再设置背景色，让它自然继承夜间模式的颜色 */
                }


                /* === 7. 回忆卡片美化 === */
                .memory-card {
                    background-color: #fffaf0 !important; /* 卡片主背景色 */
                    border-left-color: #ffb74d !important; /* 左侧装饰条颜色 */
                    box-shadow: 0 2px 6px rgba(0,0,0,0.07) !important;
                }
                .memory-card .header .author {
                    color: #d98100 !important; /* 作者/标题文字颜色 */
                }
                .memory-card .header .date {
                    color: #a1887f !important; /* 日期文字颜色 */
                }
                .memory-card .content {
                    color: #5d4037 !important; /* 内容文字颜色 */
                }
                `;

				// 默认应用图标配置
				const DEFAULT_APP_ICONS = {
					"world-book": "https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg",
					qq: "https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg",
					"api-settings": "https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg",
					wallpaper: "https://i.postimg.cc/T1j03pQr/IMG-6440.jpg",
					font: "https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg",
					"check-phone": "https://i.postimg.cc/RVwpwr0r/IMG-8348.jpg",
					weibo: "https://i.postimg.cc/PqBY5wBq/weibo-icon.png",
					forum: "https://i.postimg.cc/pr0T3WfC/douban-icon.png",
					"lovers-space": "https://i.postimg.cc/d1wZ39xW/lovers-space-icon.png",
					"game-hall": "https://i.postimg.cc/P5gL5z2g/game-controller-icon.png",
					"x-social": "https://i.postimg.cc/8P1H0vQ8/x-logo.png",
					taobao: "https://i.postimg.cc/k47tXg1j/taologo.png",
					"date-a-live": "https://i.postimg.cc/Kjdss1j9/1761142686734.png",
				};

				// 默认应用标签配置
				const DEFAULT_APP_LABELS = {
					qq: "QQ",
					"world-book": "世界书",
					"api-settings": "API设置",
					wallpaper: "外观设置",
					font: "字体",
					"check-phone": "查手机",
					weibo: "微博",
					forum: "圈子",
					"lovers-space": "情侣空间",
					"game-hall": "游戏大厅",
					"x-social": "X社交",
					taobao: "桃宝",
					"date-a-live": "约会大作战",
				};

				// 贴纸URL正则表达式
				const STICKER_REGEX = /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/i\.ibb\.co\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;
				// 消息渲染窗口大小
				const MESSAGE_RENDER_WINDOW = 50;
				// 当前已渲染消息数
				let currentRenderedCount = 0;
				// 上次已知电池电量
				let lastKnownBatteryLevel = 1;
				// 电池警告标志
				let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
				// 电池警告超时ID
				let batteryAlertTimeout;
				// 动态字体样式元素
				const dynamicFontStyle = document.createElement("style");
				dynamicFontStyle.id = "dynamic-font-style";
				document.head.appendChild(dynamicFontStyle);

				// 自定义模态框元素
				const modalOverlay = document.getElementById("custom-modal-overlay");
				const modalTitle = document.getElementById("custom-modal-title");
				const modalBody = document.getElementById("custom-modal-body");
				const modalConfirmBtn = document.getElementById("custom-modal-confirm");
				const modalCancelBtn = document.getElementById("custom-modal-cancel");
				let modalResolve;

				// 显示自定义模态框
				function showCustomModal() {
					modalOverlay.classList.add("visible");
				}

				// 隐藏自定义模态框
				function hideCustomModal() {
					modalOverlay.classList.remove("visible");
					modalConfirmBtn.classList.remove("btn-danger");
					if (modalResolve) modalResolve(null);
				}

				// 显示确认对话框
				window.showCustomConfirm = function (title, message, options = {}) {
					return new Promise((resolve) => {
						modalResolve = resolve;
						modalTitle.textContent = title;
						modalBody.innerHTML = `<p>${message}</p>`;
						modalCancelBtn.style.display = "block";
						modalConfirmBtn.textContent = "确定";
						if (options.confirmButtonClass) modalConfirmBtn.classList.add(options.confirmButtonClass);
						modalConfirmBtn.onclick = () => {
							resolve(true);
							hideCustomModal();
						};
						modalCancelBtn.onclick = () => {
							resolve(false);
							hideCustomModal();
						};
						showCustomModal();
					});
				};

				// 显示提示对话框
				window.showCustomAlert = function (title, message) {
					return new Promise((resolve) => {
						modalResolve = resolve;
						modalTitle.textContent = title;
						modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
						modalCancelBtn.style.display = "none";
						modalConfirmBtn.textContent = "好的";
						modalConfirmBtn.onclick = () => {
							modalCancelBtn.style.display = "block";
							modalConfirmBtn.textContent = "确定";
							resolve(true);
							hideCustomModal();
						};
						showCustomModal();
					});
				};

				// 清除HTML标签和代码的函数
				function stripHtmlAndCode(text) {
					if (!text || typeof text !== "string") {
						return ""; // 如果输入为空或不是字符串，返回空字符串
					}
					// 1. 移除所有HTML标签 (例如 <b>, <div>)
					let cleanedText = text.replace(/<\/?[^>]+(>|$)/g, "");

					// 2. 移除所有Markdown代码块 (例如 ```code``` 或 `code`)
					cleanedText = cleanedText.replace(/```[\s\S]*?```/g, ""); // 移除多行代码块
					cleanedText = cleanedText.replace(/`[^`]*`/g, ""); // 移除行内代码

					// 3. 将HTML实体 (例如 &lt; &gt;) 转换回正常字符 (< >)
					const tempDiv = document.createElement("div");
					tempDiv.innerHTML = cleanedText;

					return tempDiv.textContent || tempDiv.innerText || "";
				}

				// 显示输入对话框
				window.showCustomPrompt = function (title, placeholder, initialValue = "", type = "text", extraHtml = "") {
					return new Promise((resolve) => {
						modalResolve = resolve;
						modalTitle.textContent = title;
						const inputId = "custom-prompt-input";

						const inputHtml = type === "textarea" ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>` : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;

						// 将额外的HTML和输入框组合在一起
						modalBody.innerHTML = extraHtml + inputHtml;
						const input = document.getElementById(inputId);

						// 为格式助手按钮绑定事件
						modalBody.querySelectorAll(".format-btn").forEach((btn) => {
							btn.addEventListener("click", () => {
								const templateStr = btn.dataset.template;
								if (templateStr) {
									try {
										const templateObj = JSON.parse(templateStr);
										// 使用 null, 2 参数让JSON字符串格式化，带缩进，更易读
										input.value = JSON.stringify(templateObj, null, 2);
										input.focus();
									} catch (e) {
										console.error("解析格式模板失败:", e);
									}
								}
							});
						});

						modalConfirmBtn.onclick = () => {
							resolve(input.value);
							hideCustomModal();
						};
						modalCancelBtn.onclick = () => {
							resolve(null);
							hideCustomModal();
						};
						showCustomModal();
						setTimeout(() => input.focus(), 100);
					});
				};

				// 从数组中随机获取一个元素
				function getRandomItem(arr) {
					// 安全检查，如果数组为空或不存在，返回空字符串
					if (!arr || arr.length === 0) return "";
					// 返回一个随机索引对应的元素
					return arr[Math.floor(Math.random() * arr.length)];
				}

				// 数据库结构定义 - 升级到版本52
				db.version(52).stores({
					// 聊天数据表，包含群聊、个人聊天及相关设置
					chats: "&id, isGroup, groupId, ownerId, isPinned, characterPhoneData, latestInnerVoice, innerVoiceHistory, loversSpaceData.emotionDiaries, settings.summary, settings.weiboNickname, settings.innerVoiceHideHeaderBorder, settings.innerVoiceAdopterLabelFormat, interactionStats, unlockedSymbols, settings.selectedIntimacyBadge",
					// API配置表
					apiConfig: "&id",
					// 全局设置表，包含活动主题ID
					globalSettings: "&id, activeThemeId",
					// 用户表情包表
					userStickers: "&id, url, name, categoryId",
					// 用户表情包分类表
					userStickerCategories: "++id, &name",
					// 角色表情包表
					charStickers: "&id, url, name",
					// 世界书表
					worldBooks: "&id, name, categoryId",
					// 世界书分类表
					worldBookCategories: "++id, name",
					// 音乐库表
					musicLibrary: "&id",
					// 人设预设表
					personaPresets: "&id",
					// Qzone设置表
					qzoneSettings: "&id",
					// Qzone帖子表
					qzonePosts: "++id, authorId, timestamp",
					// Qzone相册表
					qzoneAlbums: "++id, name, createdAt",
					// Qzone照片表
					qzonePhotos: "++id, albumId",
					// 收藏表
					favorites: "++id, type, timestamp, originalTimestamp",
					// Qzone群组表
					qzoneGroups: "++id, name",
					// 回忆表
					memories: "++id, chatId, timestamp, type, targetDate",
					// 通话记录表
					callRecords: "++id, chatId, timestamp, customName",
					// 自定义头像框表
					customAvatarFrames: "&id, name, url",
					// 主题表
					themes: "++id, name, css",
					// API预设表
					apiPresets: "++id, name, proxyUrl",
					// 气泡样式预设表
					bubbleStylePresets: "++id, name, css",
					// 字体预设表
					fontPresets: "&id, name, url",
					// 主屏幕预设表
					homeScreenPresets: "++id, name",
					// 微博帖子表
					weiboPosts: "++id, authorId, timestamp",
					// 论坛群组表
					forumGroups: "++id, name, worldview, *categories",
					// 论坛帖子表
					forumPosts: "++id, groupId, timestamp, *categories",
					// 论坛评论表
					forumComments: "++id, postId, timestamp",
					// 论坛分类表
					forumCategories: "++id, name",
					// 塔罗占卜记录表
					tarotReadings: "++id, timestamp",
					// 番茄钟会话表
					pomodoroSessions: "++id, chatId, startTime",
					// 剧本杀脚本表
					scriptKillScripts: "++id, name, isBuiltIn",
					// 淘宝商品表
					taobaoProducts: "++id, name, category",
					// 淘宝订单表
					taobaoOrders: "++id, productId, timestamp",
					// 淘宝购物车表
					taobaoCart: "++id, productId",
					// 用户钱包交易记录表
					userWalletTransactions: "++id, timestamp",
					// 角色手机预设表
					charPhonePresets: "++id, name",
					// 飞行棋题库表
					ludoQuestionBanks: "++id, name",
					// 飞行棋题目表
					ludoQuestions: "++id, bankId, text, type",
					// 约会场景表
					datingScenes: "&uid, imageUrl",
					// 约会预设表
					datingPresets: "++id, name, settings.spriteGroupId",
					// 约会精灵组表
					datingSpriteGroups: "++id, name",
					// 约会精灵表
					datingSprites: "++id, groupId, description, url",
					// 约会历史表
					datingHistory: "++id, characterId, timestamp",
					// 离线预设表
					offlinePresets: "++id, name",
					// 饿了么食物表
					elemeFoods: "++id, name, category",
					// 饿了么订单表
					elemeOrders: "++id, recipientId, timestamp",
				});

				// 将数据库实例挂载到window对象上
				window.db = db;

				// 切换语音消息的文字显示/隐藏
				function toggleVoiceTranscript(bubble) {
					if (!bubble) return;

					const transcriptEl = bubble.querySelector(".voice-transcript");
					if (!transcriptEl) return;

					// 核心逻辑：直接检查文字区域当前是不是显示状态
					const isCurrentlyExpanded = transcriptEl.style.display === "block";

					if (isCurrentlyExpanded) {
						// 如果是展开的，就直接收起来
						transcriptEl.style.display = "none";
					} else {
						// 如果是收起的，就执行展开流程

						// 1. 先显示一个"正在转写"的提示，给用户即时反馈
						transcriptEl.textContent = "正在转文字...";
						transcriptEl.style.display = "block";

						// 2. 模拟一个短暂的"识别"过程
						setTimeout(() => {
							// 再次检查元素是否还在页面上，防止用户切换聊天导致错误
							if (document.body.contains(transcriptEl)) {
								// 获取并显示真正的转写文字
								const voiceText = bubble.dataset.voiceText || "(无法识别)";
								transcriptEl.textContent = voiceText;
							}
						}, 300); // 300毫秒的延迟，感觉更灵敏
					}
				}

				/**
				 * 应用指定的主题，并智能刷新当前打开的任何界面
				 * @param {string} theme - 'light' 或 'dark'
				 */
				function applyTheme(theme) {
					const phoneScreen = document.getElementById("phone-screen");
					const toggleSwitch = document.getElementById("theme-toggle-switch");

					const isDark = theme === "dark";

					// 核心操作：为手机屏幕添加或移除 .dark-mode 类
					phoneScreen.classList.toggle("dark-mode", isDark);

					// 同步开关的状态
					if (toggleSwitch) {
						toggleSwitch.checked = isDark;
					}

					// 保存用户的选择
					localStorage.setItem("ephone-theme", theme);

					// 找出当前激活的界面并根据界面类型刷新对应内容
					const activeScreen = document.querySelector(".screen.active");
					if (!activeScreen) return;

					switch (activeScreen.id) {
						case "chat-interface-screen":
							if (state.activeChatId) {
								renderChatInterface(state.activeChatId);
							}
							break;
						case "wallpaper-screen":
							renderWallpaperScreen();
							break;
						case "font-settings-screen":
							renderFontPresets();
							break;
					}
				}

				/**
				 * 当用户点击开关时，切换当前的主题
				 */
				function toggleTheme() {
					const toggleSwitch = document.getElementById("theme-toggle-switch");
					const newTheme = toggleSwitch.checked ? "dark" : "light";
					applyTheme(newTheme);
				}

				/**
				 * 在应用启动时，预加载所有已保存的字体预设
				 */
				async function loadAllFontPresetsOnStartup() {
					console.log("正在预加载所有字体预设...");
					const presets = await db.fontPresets.toArray();
					if (presets && presets.length > 0) {
						presets.forEach((preset) => {
							loadFontForPreview(preset);
						});
						console.log(`成功预加载了 ${presets.length} 个字体。`);
					}
				}

				/**
				 * 渲染字体预设的10个卡槽
				 */
				async function renderFontPresets() {
					const container = document.getElementById("font-preset-container");
					container.innerHTML = ""; // 清空旧内容

					// 从数据库读取所有已保存的预设
					const presets = await db.fontPresets.toArray();

					// 循环10次，创建10个卡槽的HTML
					for (let i = 0; i < 10; i++) {
						const slot = document.createElement("div");
						slot.className = "font-preset-slot";

						const preset = presets[i];

						if (preset) {
							// 如果这个卡槽有数据
							slot.innerHTML = `
                                <div class="font-preview-text" data-preset-id="${preset.id}">Abc 你好</div>
                                <div class="font-preset-info">名称: ${preset.name}</div>
                                <div class="font-preset-actions">
                                    <button class="preset-btn apply-btn" data-preset-id="${preset.id}">应用</button>
                                    <button class="preset-btn delete-btn delete" data-preset-id="${preset.id}">删除</button>
                                </div>
                            `;
						} else {
							// 如果这个卡槽是空的
							slot.classList.add("empty");
							slot.innerHTML = `
                                <div class="font-preset-info">卡槽 ${i + 1} 为空</div>
                                <div class="font-preset-actions">
                                    <button class="preset-btn secondary upload-url-btn" data-slot-index="${i}">URL上传</button>
                                    <button class="preset-btn secondary upload-local-btn" data-slot-index="${i}">本地上传</button>
                                </div>
                            `;
						}
						container.appendChild(slot);
					}

					presets.forEach((preset) => {
						if (preset) {
							loadFontForPreview(preset);
						}
					});

					addFontPresetButtonListeners();
				}

				/**
				 * 为单个预设加载字体以供预览
				 * @param {object} preset - 字体预设对象 {id, name, url}
				 */
				function loadFontForPreview(preset) {
					const styleId = `font-style-${preset.id}`;
					if (document.getElementById(styleId)) return;

					const style = document.createElement("style");
					style.id = styleId;

					// 创建CSS规则来应用字体
					style.innerHTML = `
                        @font-face {
                            font-family: 'preset-${preset.id}';
                            src: url('${preset.url}');
                            font-display: swap;
                        }

                        .font-preview-text[data-preset-id="${preset.id}"] {
                            font-family: 'preset-${preset.id}', sans-serif !important;
                        }
                    `;

					document.head.appendChild(style);
				}

				/**
				 * 为预设卡槽中的所有按钮统一添加事件监听器
				 */
				function addFontPresetButtonListeners() {
					document.querySelectorAll(".upload-url-btn").forEach((btn) => {
						btn.onclick = () => handleUploadFontUrl(parseInt(btn.dataset.slotIndex));
					});
					document.querySelectorAll(".upload-local-btn").forEach((btn) => {
						btn.onclick = () => handleUploadFontLocal(parseInt(btn.dataset.slotIndex));
					});
					document.querySelectorAll(".apply-btn").forEach((btn) => {
						btn.onclick = () => applyFontPreset(btn.dataset.presetId);
					});
					document.querySelectorAll(".delete-btn").forEach((btn) => {
						btn.onclick = () => deleteFontPreset(btn.dataset.presetId);
					});
				}

				/**
				 * 处理通过URL上传字体
				 * @param {number} slotIndex - 卡槽的索引 (0-9)
				 */
				async function handleUploadFontUrl(slotIndex) {
					const url = await showCustomPrompt("字体URL", "请输入字体的网络链接(.ttf, .otf等)");
					if (!url || !url.trim().startsWith("http")) {
						if (url !== null) alert("请输入一个有效的URL！");
						return;
					}
					const name = await showCustomPrompt("字体命名", "请为这个字体起个名字");
					if (!name || !name.trim()) {
						if (name !== null) alert("名字不能为空！");
						return;
					}
					await saveFontPreset(slotIndex, name.trim(), url.trim());
				}

				/**
				 * 处理通过本地文件上传字体
				 * @param {number} slotIndex - 卡槽的索引 (0-9)
				 */
				function handleUploadFontLocal(slotIndex) {
					const input = document.getElementById("font-preset-local-upload");
					input.onchange = async (e) => {
						const file = e.target.files[0];
						if (!file) return;

						const name = await showCustomPrompt("字体命名", "请为这个字体起个名字", file.name.replace(/\.[^/.]+$/, ""));
						if (!name || !name.trim()) {
							if (name !== null) alert("名字不能为空！");
							return;
						}

						// 使用FileReader将字体文件转为Base64 Data URL
						const reader = new FileReader();
						reader.onload = async (event) => {
							await saveFontPreset(slotIndex, name.trim(), event.target.result);
						};
						reader.readAsDataURL(file);
					};
					input.click(); // 触发文件选择框
				}

				/**
				 * 将新的字体预设保存到数据库
				 * @param {number} slotIndex - 卡槽索引
				 * @param {string} name - 字体名称
				 * @param {string} url - 字体URL (网络或Base64)
				 */
				async function saveFontPreset(slotIndex, name, url) {
					try {
						const presets = await db.fontPresets.toArray();
						const newPreset = { id: "font_" + Date.now(), name, url };
						presets.splice(slotIndex, 0, newPreset);
						const presetsToSave = presets.slice(0, 10);

						// 使用数据库事务来保证操作的原子性
						await db.transaction("rw", db.fontPresets, async () => {
							await db.fontPresets.clear();
							await db.fontPresets.bulkPut(presetsToSave);
						});

						await renderFontPresets();
						alert(`字体 "${name}" 已成功保存到卡槽 ${slotIndex + 1}！`);
					} catch (error) {
						console.error("保存字体预设失败:", error);
						alert(`保存字体失败，数据已自动回滚，你之前的字体数据是安全的。错误: ${error.message}`);
						await renderFontPresets(); // 失败后重新渲染，恢复到旧的列表状态
					}
				}

				/**
				 * 删除一个字体预设
				 * @param {string} presetId - 要删除的预设的ID
				 */
				async function deleteFontPreset(presetId) {
					const preset = await db.fontPresets.get(presetId);
					if (!preset) return;
					const confirmed = await showCustomConfirm("确认删除", `确定要删除字体 "${preset.name}" 吗？`, { confirmButtonClass: "btn-danger" });
					if (confirmed) {
						await db.fontPresets.delete(presetId);

						// 从DOM中移除对应的预览样式
						const styleTag = document.getElementById(`font-style-${presetId}`);
						if (styleTag) styleTag.remove();

						await renderFontPresets();
					}
				}

				/**
				 * 应用一个字体预设为全局字体
				 * @param {string} presetId - 要应用的预设的ID
				 */
				async function applyFontPreset(presetId) {
					const preset = await db.fontPresets.get(presetId);
					if (preset) {
						// 调用全局字体应用函数
						applyCustomFont(preset.url, false);
						// 保存到全局设置
						state.globalSettings.fontUrl = preset.url;
						await db.globalSettings.put(state.globalSettings);
						alert(`已将全局字体更换为 "${preset.name}"！`);
					}
				}

				/**
				 * 处理用户选择的角色卡文件
				 * @param {File} file - 用户选择的文件对象
				 */
				async function handleCharacterImport(file) {
					if (!file) return;

					try {
						let characterData;
						let avatarBase64;

						if (file.name.toLowerCase().endsWith(".png")) {
							// 如果是PNG文件，调用PNG解析函数
							const result = await parseCharPng(file);
							characterData = result.characterData;
							avatarBase64 = result.avatarBase64;
						} else if (file.name.toLowerCase().endsWith(".json")) {
							// 如果是JSON文件，调用JSON解析函数
							characterData = await parseCharJson(file);
							// JSON卡通常不包含图片，我们给一个默认头像
							avatarBase64 = defaultAvatar;
						} else {
							alert("不支持的文件格式，请选择 .png 或 .json 文件。");
							return;
						}

						if (characterData) {
							// 成功解析出数据后，调用创建函数
							await createCharacterFromData(characterData, avatarBase64);
						}
					} catch (error) {
						console.error("导入角色卡失败:", error);
						alert(`导入失败: ${error.message}`);
					}
				}

				/**
				 * 解析SillyTavern的PNG角色卡，通过字节级操作彻底解决中文乱码问题。
				 * @param {File} file - PNG文件
				 * @returns {Promise<{characterData: object, avatarBase64: string}>}
				 */
				async function parseCharPng(file) {
					return new Promise((resolve, reject) => {
						const reader = new FileReader();
						reader.onload = (e) => {
							const arrayBuffer = e.target.result;
							const dataView = new DataView(arrayBuffer);

							if (dataView.getUint32(0) !== 0x89504e47 || dataView.getUint32(4) !== 0x0d0a1a0a) {
								return reject(new Error("文件不是一个有效的PNG图片。"));
							}

							let offset = 8;
							let characterJson = null;

							while (offset < dataView.byteLength) {
								const length = dataView.getUint32(offset);
								const type = String.fromCharCode(dataView.getUint8(offset + 4), dataView.getUint8(offset + 5), dataView.getUint8(offset + 6), dataView.getUint8(offset + 7));

								if (type === "tEXt") {
									const chunkData = new Uint8Array(arrayBuffer, offset + 8, length);

									// 将字节转为字符串，以便查找关键字 "chara"
									let text = "";
									for (let i = 0; i < chunkData.length; i++) {
										text += String.fromCharCode(chunkData[i]);
									}

									// 检查关键字是否存在
									const keyword = "chara" + String.fromCharCode(0);
									if (text.startsWith(keyword)) {
										// 提取出关键字后面的 Base64 编码的字符串
										const base64Data = text.substring(keyword.length);
										try {
											// 解码 Base64，得到一个"二进制字符串"
											const binaryString = atob(base64Data);

											// 将"二进制字符串"重新转换为原始的 UTF-8 字节数组
											const bytes = new Uint8Array(binaryString.length);
											for (let i = 0; i < binaryString.length; i++) {
												bytes[i] = binaryString.charCodeAt(i);
											}

											// 使用 TextDecoder 将这个纯净的 UTF-8 字节数组解码为正确的字符串
											const decodedJsonString = new TextDecoder("utf-8").decode(bytes);

											// 解析最终的JSON字符串
											characterJson = JSON.parse(decodedJsonString);
											break;
										} catch (e) {
											return reject(new Error("解析图片内嵌的角色数据失败，可能是数据损坏。"));
										}
									}
								}

								if (type === "IEND") break;
								offset += 12 + length;
							}

							if (characterJson) {
								const imageReader = new FileReader();
								imageReader.onload = (imgEvent) => {
									resolve({
										characterData: characterJson,
										avatarBase64: imgEvent.target.result,
									});
								};
								imageReader.onerror = () => reject(new Error("读取图片作为头像失败。"));
								imageReader.readAsDataURL(file);
							} else {
								reject(new Error("在这张PNG图片中没有找到SillyTavern角色数据。"));
							}
						};
						reader.onerror = () => reject(new Error("读取PNG文件失败。"));
						reader.readAsArrayBuffer(file);
					});
				}

				/**
				 * 解析JSON角色卡，强制使用UTF-8编码
				 * @param {File} file - JSON文件
				 * @returns {Promise<object>}
				 */
				async function parseCharJson(file) {
					return new Promise((resolve, reject) => {
						const reader = new FileReader();
						reader.onload = (e) => {
							try {
								// 先读取为ArrayBuffer，再用TextDecoder指定UTF-8解码
								const arrayBuffer = e.target.result;
								const textDecoder = new TextDecoder("utf-8");
								const jsonString = textDecoder.decode(arrayBuffer);
								const data = JSON.parse(jsonString);
								// 兼容两种可能的格式
								resolve(data.data || data);
							} catch (error) {
								reject(new Error("解析JSON文件失败，请检查文件格式或编码。"));
							}
						};
						reader.onerror = () => reject(new Error("读取JSON文件失败。"));
						// 读取为ArrayBuffer而不是Text
						reader.readAsArrayBuffer(file);
					});
				}

				/**
				 * 根据解析出的数据创建新角色和世界书。
				 * @param {object} data - 从卡片解析出的最原始的JSON数据
				 * @param {string} avatarBase64 - 角色的头像图片 (Base64)
				 */
				async function createCharacterFromData(data, avatarBase64) {
					// 确定核心角色数据
					const charData = data.data || data;
					const characterName = charData.name ? charData.name.trim() : "未命名角色";

					// 创建新的聊天对象
					const newChatId = "chat_" + Date.now();

					const newChat = {
						id: newChatId,
						name: characterName,
						isGroup: false,
						isPinned: false,
						history: [],
						unreadCount: 0,
						musicData: { totalTime: 0 },
						npcLibrary: [],
						relationship: { status: "friend", blockedTimestamp: null, applicationReason: "" },
						status: { text: "在线", lastUpdate: Date.now(), isBusy: false },
						weiboDms: [],
						loversSpaceData: null,
						settings: {
							aiPersona: charData.description || "该角色没有描述。",
							myPersona: "我是谁呀。",
							maxMemory: 10,
							aiAvatar: avatarBase64,
							myAvatar: defaultAvatar,
							background: "",
							theme: "default",
							fontSize: 13,
							customCss: "",
							linkedWorldBookIds: [],
							aiAvatarLibrary: [],
							stickerLibrary: [],
							summary: {
								enabled: false,
								mode: "auto",
								count: 20,
								prompt: "请你以第三人称的视角，客观、冷静、不带任何感情色彩地总结以下对话的核心事件和信息。禁止进行任何角色扮演或添加主观评论。",
								lastSummaryIndex: -1,
							},
							linkedMemories: [],
							offlineMode: {
								enabled: false,
								prompt: "",
								style: "",
								wordCount: 300,
								presets: [],
							},
							timePerceptionEnabled: true,
							customTime: "",
							isCoupleAvatar: false,
							coupleAvatarDescription: "",
							weiboProfession: "",
							weiboInstruction: "",
							visualVideoCallEnabled: false,
							charVideoImage: "",
							userVideoImage: "",
							petAdopted: false,
							pet: null,
						},
						characterPhoneData: {
							lastGenerated: null,
							chats: {},
							shoppingCart: [],
							memos: [],
							browserHistory: [],
							photoAlbum: [],
							bank: { balance: 0, transactions: [] },
							trajectory: [],
							appUsage: [],
							diary: [],
						},
					};

					await db.chats.put(newChat);
					state.chats[newChatId] = newChat;

					// // 更新聊天列表显示
					// await loadChatList();

					// // 显示成功消息
					// showNotification(`角色 "${characterName}" 已成功导入！`, 'success');

					console.log("开始检测世界书数据...");
					let worldBookFound = false;

					// 策略一：查找 character_book 标准格式
					if (charData.character_book && charData.character_book.entries && Array.isArray(charData.character_book.entries) && charData.character_book.entries.length > 0) {
						console.log(`检测到最新的 character_book 格式 (${charData.character_book.entries.length}条)，开始导入...`);
						const newCategory = { name: characterName };
						const newCategoryId = await db.worldBookCategories.add(newCategory);
						// 调用辅助函数处理条目数组
						await saveWorldBookEntriesFromArray(charData.character_book.entries, newCategoryId);
						worldBookFound = true;
					}
					// 策略二：兼容旧的 world_entries 格式
					else if (charData.world_entries && Array.isArray(charData.world_entries) && charData.world_entries.length > 0) {
						console.log(`检测到旧版 world_entries 格式 (${charData.world_entries.length}条)，开始导入...`);
						const newCategory = { name: characterName };
						const newCategoryId = await db.worldBookCategories.add(newCategory);
						await saveWorldBookEntriesFromArray(charData.world_entries, newCategoryId);
						worldBookFound = true;
					}
					// 策略三：兼容外层 world 字段格式
					else if (data.world && typeof data.world === "string" && data.world.trim()) {
						console.log("检测到外层 world 字段格式，开始导入...");
						const newCategory = { name: characterName };
						const newCategoryId = await db.worldBookCategories.add(newCategory);
						await parseAndSaveWorldBooks(data.world, newCategoryId);
						worldBookFound = true;
					}
					// 策略四：最后兼容 world_info 字段格式
					else if (charData.world_info && typeof charData.world_info === "string" && charData.world_info.trim()) {
						console.log("检测到旧版 world_info 字段格式，开始导入...");
						const newCategory = { name: characterName };
						const newCategoryId = await db.worldBookCategories.add(newCategory);
						await parseAndSaveWorldBooks(charData.world_info, newCategoryId);
						worldBookFound = true;
					}

					if (!worldBookFound) {
						console.log("诊断：在此角色卡中未找到任何可识别的世界书字段。");
					}

					// 步骤 4: 刷新UI
					await renderChatList();
					await showCustomAlert("导入成功！", `角色“${characterName}”已成功创建！`);
				}

				/**
				 * 从SillyTavern的 world_entries 或 character_book.entries 数组直接创建世界书
				 * @param {Array<object>} entriesArray - 包含世界书条目的数组
				 * @param {number} categoryId - 这些世界书所属的分类ID
				 */
				async function saveWorldBookEntriesFromArray(entriesArray, categoryId) {
					const newBooks = [];

					for (const entry of entriesArray) {
						// 智能获取条目名称：优先使用 comment 字段作为标题，否则使用 keys 数组，最后使用默认名称
						const entryName = entry.comment && entry.comment.trim() ? entry.comment.trim() : entry.keys && entry.keys.length > 0 ? entry.keys.join(", ") : "未命名条目";

						// 检查条目是否有效 (有名字、有内容，并且是启用的)
						if (entryName !== "未命名条目" && entry.content && (typeof entry.enabled === "undefined" || entry.enabled)) {
							newBooks.push({
								id: "wb_" + Date.now() + Math.random(),
								name: entryName,
								content: entry.content,
								categoryId: categoryId,
							});
						}
					}

					if (newBooks.length > 0) {
						await db.worldBooks.bulkAdd(newBooks);
						// 更新 state.worldBooks 以便UI能立即显示
						const allBooks = await db.worldBooks.toArray();
						state.worldBooks = allBooks;
						console.log(`成功导入 ${newBooks.length} 个世界书条目到分类ID: ${categoryId}`);
					}
				}

				// 获取事件的坐标（支持触摸和鼠标事件）
				function getEventCoords(e) {
					// 如果是触摸事件，从 e.touches[0] 获取坐标
					if (e.touches && e.touches[0]) {
						return { x: e.touches[0].pageX, y: e.touches[0].pageY };
					}
					// 否则，是鼠标事件，直接从 e 获取坐标
					return { x: e.pageX, y: e.pageY };
				}

				// 显示指定屏幕
				function showScreen(screenId) {
					if (!document.getElementById("logistics-screen").classList.contains("active")) {
						logisticsUpdateTimers.forEach((timerId) => clearTimeout(timerId));
						logisticsUpdateTimers = [];
					}

					// 根据屏幕ID执行特定的渲染逻辑
					if (screenId === "chat-list-screen") {
						renderChatList();
						switchToChatListView("messages-view");
					}
					if (screenId === "api-settings-screen") {
						renderApiSettings();
					}
					if (screenId === "wallpaper-screen") {
						renderWallpaperScreen();
					}
					if (screenId === "world-book-screen") {
						renderWorldBookScreen();
					}

					// 切换屏幕显示
					document.querySelectorAll(".screen").forEach((s) => s.classList.remove("active"));
					const screenToShow = document.getElementById(screenId);
					if (screenToShow) {
						screenToShow.classList.add("active");
					}

					// 更新音乐播放器图标状态
					if (screenId === "chat-interface-screen") {
						updateListenTogetherIcon(state.activeChatId);
					}

					// 处理字体设置屏幕
					if (screenId === "font-settings-screen") {
						document.getElementById("font-preview").style.fontFamily = "";
						applyCustomFont(state.globalSettings.fontUrl || "", true);
						renderFontPresets();
					}
				}
				window.showScreen = showScreen;

				window.updateListenTogetherIconProxy = () => {};

				// 切换聊天列表视图
				function switchToChatListView(viewId) {
					const chatListScreen = document.getElementById("chat-list-screen");
					const views = {
						"messages-view": document.getElementById("messages-view"),
						"qzone-screen": document.getElementById("qzone-screen"),
						"favorites-view": document.getElementById("favorites-view"),
						"memories-view": document.getElementById("memories-view"),
					};
					const mainHeader = document.getElementById("main-chat-list-header");
					const mainBottomNav = document.getElementById("chat-list-bottom-nav");

					if (isFavoritesSelectionMode) {
						document.getElementById("favorites-edit-btn").click();
					}

					// 隐藏所有视图并显示目标视图
					Object.values(views).forEach((v) => v.classList.remove("active"));
					if (views[viewId]) {
						views[viewId].classList.add("active");
					}

					// 更新底部导航栏高亮
					document.querySelectorAll("#chat-list-bottom-nav .nav-item").forEach((item) => {
						item.classList.toggle("active", item.dataset.view === viewId);
					});

					// 统一管理所有UI元素的显隐
					if (viewId === "messages-view") {
						mainHeader.style.display = "flex";
						mainBottomNav.style.display = "flex";
					} else {
						mainHeader.style.display = "none";
						mainBottomNav.style.display = "none";
					}

					// 清除倒计时定时器
					if (viewId !== "memories-view") {
						activeCountdownTimers.forEach((timerId) => clearInterval(timerId));
						activeCountdownTimers = [];
					}

					// 根据视图ID执行特定的渲染/更新逻辑
					switch (viewId) {
						case "qzone-screen":
							views["qzone-screen"].style.backgroundColor = "#f0f2f5";
							updateUnreadIndicator(0);
							renderQzoneScreen();
							renderQzonePosts();
							break;
						case "favorites-view":
							views["favorites-view"].style.backgroundColor = "#f9f9f9";
							renderFavoritesScreen();
							break;
						case "messages-view":
							// 返回消息列表时的逻辑
							break;
					}
				}

				// 渲染QQ空间屏幕
				function renderQzoneScreen() {
					if (state && state.qzoneSettings) {
						const settings = state.qzoneSettings;
						document.getElementById("qzone-nickname").textContent = settings.nickname;
						document.getElementById("qzone-avatar-img").src = settings.avatar;
						document.getElementById("qzone-banner-img").src = settings.banner;
					}
				}
				window.renderQzoneScreenProxy = renderQzoneScreen;

				// 保存QQ空间设置
				async function saveQzoneSettings() {
					if (db && state.qzoneSettings) {
						await db.qzoneSettings.put(state.qzoneSettings);
					}
				}

				// 格式化动态发布时间
				function formatPostTimestamp(timestamp) {
					if (!timestamp) return "";
					const now = new Date();
					const date = new Date(timestamp);
					const diffSeconds = Math.floor((now - date) / 1000);
					const diffMinutes = Math.floor(diffSeconds / 60);
					const diffHours = Math.floor(diffMinutes / 60);

					if (diffMinutes < 1) return "刚刚";
					if (diffMinutes < 60) return `${diffMinutes}分钟前`;
					if (diffHours < 24) return `${diffHours}小时前`;

					const year = date.getFullYear();
					const month = String(date.getMonth() + 1).padStart(2, "0");
					const day = String(date.getDate()).padStart(2, "0");
					const hours = String(date.getHours()).padStart(2, "0");
					const minutes = String(date.getMinutes()).padStart(2, "0");

					if (now.getFullYear() === year) {
						return `${month}-${day} ${hours}:${minutes}`;
					} else {
						return `${year}-${month}-${day} ${hours}:${minutes}`;
					}
				}

				// 渲染QQ空间动态
				async function renderQzonePosts() {
					const postsListEl = document.getElementById("qzone-posts-list");
					if (!postsListEl) return;

					const [posts, favorites] = await Promise.all([db.qzonePosts.orderBy("timestamp").reverse().toArray(), db.favorites.where("type").equals("qzone_post").toArray()]);

					const favoritedPostIds = new Set(favorites.map((fav) => fav.content.id));

					postsListEl.innerHTML = "";

					if (posts.length === 0) {
						postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">这里空空如也，快来发布第一条说说吧！</p>';
						return;
					}

					const userSettings = state.qzoneSettings;

					// 创建包含所有AI角色名字的集合，用于快速查找
					const allAiCharacterNames = new Set(
						Object.values(state.chats)
							.filter((chat) => !chat.isGroup)
							.map((chat) => chat.name)
					);

					posts.forEach((post) => {
						const postContainer = document.createElement("div");
						postContainer.className = "qzone-post-container";
						postContainer.dataset.postId = post.id;

						const postEl = document.createElement("div");
						postEl.className = "qzone-post-item";

						let authorAvatar = "",
							authorNickname = "",
							commentAvatar = userSettings.avatar;

						// 设置作者信息
						if (post.authorId === "user") {
							authorAvatar = userSettings.avatar;
							authorNickname = userSettings.nickname;
						} else if (state.chats[post.authorId]) {
							const authorChat = state.chats[post.authorId];
							authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
							authorNickname = authorChat.name;
						} else {
							authorAvatar = defaultAvatar;
							authorNickname = "{{char}}";
						}

						let contentHtml = "";
						const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, "<br>")}</div>` : "";

						// 根据动态类型渲染内容
						if (post.type === "shuoshuo") {
							contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${post.content.replace(/\n/g, "<br>")}</div>`;
						} else if (post.type === "image_post" && post.imageUrl) {
							contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
						} else if (post.type === "text_image") {
							contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
						} else if (post.type === "realimag") {
							// RealImag真实图片动态渲染（支持多图布局）
							const imageUrls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);

							if (imageUrls.length > 0) {
								const imageCount = imageUrls.length;
								let imagesHtml = "";

								// 使用统一的多图布局（包括单张图片）
								imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
								imageUrls.forEach((url, index) => {
									imagesHtml += `<img src="${url}" class="realimag-image" alt="图片${index + 1}" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';">`;
								});
								imagesHtml += "</div>";

								contentHtml = publicTextHtml ? `${publicTextHtml}${imagesHtml}` : imagesHtml;
							}
						} else if (post.type === "naiimag") {
							// NovelAI图片动态渲染（支持多图布局，最多2张）
							const imageUrls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);

							if (imageUrls.length > 0) {
								const imageCount = imageUrls.length;
								let imagesHtml = "";

								// 使用统一的多图布局（包括单张图片）
								imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
								imageUrls.forEach((url, index) => {
									imagesHtml += `<img src="${url}" class="naiimag-image" alt="图片${index + 1}" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';">`;
								});
								imagesHtml += "</div>";

								contentHtml = publicTextHtml ? `${publicTextHtml}${imagesHtml}` : imagesHtml;
							}
						}

						// 渲染点赞区域
						let likesHtml = "";
						if (post.likes && post.likes.length > 0) {
							likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join("、")} 觉得很赞</span></div>`;
						}

						// 渲染评论区域
						let commentsHtml = "";
						if (post.comments && post.comments.length > 0) {
							// 根据评论可见性过滤评论
							const commentsToShow =
								post.areCommentsVisible === false
									? post.comments.filter(
											(comment) =>
												// 显示用户自己的评论
												comment.commenterName === userSettings.nickname ||
												// 显示AI角色的评论
												allAiCharacterNames.has(comment.commenterName)
									  )
									: post.comments;

							if (commentsToShow.length > 0) {
								commentsHtml = '<div class="post-comments-container">';
								commentsToShow.forEach((comment) => {
									const originalIndex = post.comments.indexOf(comment);
									let replyHtml = "";
									if (comment.replyTo) {
										replyHtml = `<span class="reply-text">回复</span> <span class="reply-target-name">${comment.replyTo}</span>`;
									}
									commentsHtml += `
                                            <div class="comment-item" data-commenter-name="${comment.commenterName}">
                                                <span class="commenter-name">${comment.commenterName}</span>${replyHtml}:
                                                <span class="comment-text"> ${comment.text}</span>
                                                <span class="comment-delete-btn" data-comment-index="${originalIndex}">×</span>
                                            </div>`;
								});
								commentsHtml += "</div>";
							}
						}

						const commentsAndFooterHtml = `
                                ${commentsHtml}
                                <div class="post-footer">
                                    <div class="comment-section">
                                        <img src="${commentAvatar}" class="comment-avatar">
                                        <input type="text" class="comment-input" placeholder="友善的评论是交流的起点">
                                        <div class="at-mention-popup"></div>
                                    </div>
                                    <button class="comment-send-btn">发送</button>
                                </div>
                            `;

						const userNickname = state.qzoneSettings.nickname;
						const isLikedByUser = post.likes && post.likes.includes(userNickname);
						const isFavoritedByUser = favoritedPostIds.has(post.id);

						// 构建动态HTML
						postEl.innerHTML = `
                                <div class="post-header"><img src="${authorAvatar}" class="post-avatar"><div class="post-info"><span class="post-nickname">${authorNickname}</span><span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span></div>
                                    <div class="post-actions-btn">…</div>
                                </div>
                                <div class="post-main-content">${contentHtml}</div>
                                <div class="post-feedback-icons">
                                    <span class="action-icon like ${isLikedByUser ? "active" : ""}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                                    <span class="action-icon favorite ${isFavoritedByUser ? "active" : ""}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                                    <span class="action-icon summon-npc" data-post-id="${post.id}" data-author-id="${post.authorId}" title="召唤NPC评论"><svg viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></span>
                                    </div>
                                ${likesHtml}
                                ${commentsAndFooterHtml} 
                            `;

						const deleteAction = document.createElement("div");
						deleteAction.className = "qzone-post-delete-action";
						deleteAction.innerHTML = "<span>删除</span>";
						postContainer.appendChild(postEl);
						postContainer.appendChild(deleteAction);
						const commentSection = postContainer.querySelector(".comment-section");
						if (commentSection) {
							commentSection.addEventListener("touchstart", (e) => e.stopPropagation());
							commentSection.addEventListener("mousedown", (e) => e.stopPropagation());
						}
						postsListEl.appendChild(postContainer);

						// 处理评论输入框事件
						const commentInput = postContainer.querySelector(".comment-input");
						if (commentInput) {
							const popup = postContainer.querySelector(".at-mention-popup");
							commentInput.addEventListener("input", () => {
								const value = commentInput.value;
								const atMatch = value.match(/@([\p{L}\w]*)$/u);
								if (atMatch) {
									const namesToMention = new Set();
									const authorNickname = postContainer.querySelector(".post-nickname")?.textContent;
									if (authorNickname) namesToMention.add(authorNickname);
									postContainer.querySelectorAll(".commenter-name").forEach((nameEl) => {
										namesToMention.add(nameEl.textContent.replace(":", ""));
									});
									namesToMention.delete(state.qzoneSettings.nickname);
									popup.innerHTML = "";
									if (namesToMention.size > 0) {
										const searchTerm = atMatch[1];
										namesToMention.forEach((name) => {
											if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
												const item = document.createElement("div");
												item.className = "at-mention-item";
												item.textContent = name;
												item.addEventListener("mousedown", (e) => {
													e.preventDefault();
													const newText = value.substring(0, atMatch.index) + `@${name} `;
													commentInput.value = newText;
													popup.style.display = "none";
													commentInput.focus();
												});
												popup.appendChild(item);
											}
										});
										popup.style.display = popup.children.length > 0 ? "block" : "none";
									} else {
										popup.style.display = "none";
									}
								} else {
									popup.style.display = "none";
								}
							});
							commentInput.addEventListener("blur", () => {
								setTimeout(() => {
									popup.style.display = "none";
								}, 200);
							});
						}
					});
				}

				// 渲染关注的人的动态
				async function renderFollowingFeed() {
					const feedListEl = document.getElementById("weibo-following-feed-list");
					if (!feedListEl) return;

					// 从数据库获取所有动态并筛选出非用户发布的动态
					const allPosts = await db.qzonePosts.orderBy("timestamp").reverse().toArray();
					const followingPosts = allPosts.filter((post) => post.authorId !== "user");

					feedListEl.innerHTML = "";

					if (followingPosts.length === 0) {
						feedListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">你关注的人还没有发布任何动态哦。</p>';
						return;
					}

					// 遍历筛选后的动态并渲染
					followingPosts.forEach((post) => {
						// 这里应该包含与 renderQzonePosts 中相同的动态渲染逻辑
						// feedListEl.appendChild(postContainer);
					});
				}

				// 显示过滤后的收藏项
				function displayFilteredFavorites(items) {
					const listEl = document.getElementById("favorites-list");
					listEl.innerHTML = "";

					if (items.length === 0) {
						const searchTerm = document.getElementById("favorites-search-input").value;
						const message = searchTerm ? "未找到相关收藏" : "你的收藏夹是空的，<br>快去动态或聊天中收藏喜欢的内容吧！";
						listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
						return;
					}

					for (const item of items) {
						const card = document.createElement("div");
						card.className = "favorite-item-card";
						card.dataset.favid = item.id;

						let headerHtml = "",
							contentHtml = "",
							sourceText = "",
							footerHtml = "";

						// 根据收藏类型渲染内容
						if (item.type === "qzone_post") {
							const post = item.content;
							sourceText = "来自动态";
							let authorAvatar = defaultAvatar,
								authorNickname = "未知用户";

							if (post.authorId === "user") {
								authorAvatar = state.qzoneSettings.avatar;
								authorNickname = state.qzoneSettings.nickname;
							} else if (state.chats[post.authorId]) {
								authorAvatar = state.chats[post.authorId].settings.aiAvatar;
								authorNickname = state.chats[post.authorId].name;
							}

							headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;

							const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, "<br>")}</div>` : "";

							// 根据动态类型渲染内容
							if (post.type === "shuoshuo") {
								contentHtml = `<div class="post-content">${post.content.replace(/\n/g, "<br>")}</div>`;
							} else if (post.type === "image_post" && post.imageUrl) {
								contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
							} else if (post.type === "text_image") {
								contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
							} else if (post.type === "realimag") {
								// RealImag真实图片动态渲染（支持多图布局）
								const imageUrls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);

								if (imageUrls.length > 0) {
									const imageCount = imageUrls.length;
									let imagesHtml = "";

									// 使用统一的多图布局（包括单张图片）
									imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
									imageUrls.forEach((url, index) => {
										imagesHtml += `<img src="${url}" class="realimag-image" alt="图片${index + 1}" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';">`;
									});
									imagesHtml += "</div>";

									contentHtml = publicTextHtml ? `${publicTextHtml}${imagesHtml}` : imagesHtml;
								}
							} else if (post.type === "naiimag") {
								// NovelAI图片动态渲染（支持多图布局，最多2张）
								const imageUrls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);

								if (imageUrls.length > 0) {
									const imageCount = imageUrls.length;
									let imagesHtml = "";

									// 使用统一的多图布局（包括单张图片）
									imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
									imageUrls.forEach((url, index) => {
										imagesHtml += `<img src="${url}" class="naiimag-image" alt="图片${index + 1}" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';">`;
									});
									imagesHtml += "</div>";

									contentHtml = publicTextHtml ? `${publicTextHtml}${imagesHtml}` : imagesHtml;
								}
							}

							// 构造点赞区域的HTML
							let likesHtml = "";
							if (post.likes && post.likes.length > 0) {
								likesHtml = `
                                        <div class="post-likes-section">
                                            <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                                            <span>${post.likes.join("、")} 觉得很赞</span>
                                        </div>`;
							}

							// 构造评论区域的HTML
							let commentsHtml = "";
							if (post.comments && post.comments.length > 0) {
								commentsHtml = '<div class="post-comments-container">';
								post.comments.forEach((comment) => {
									commentsHtml += `
                                            <div class="comment-item">
                                                <span class="commenter-name">${comment.commenterName}:</span>
                                                <span class="comment-text">${comment.text}</span>
                                            </div>`;
								});
								commentsHtml += "</div>";
							}

							// 将点赞和评论的HTML组合到 footerHtml 中
							footerHtml = `${likesHtml}${commentsHtml}`;
						} else if (item.type === "chat_message") {
							const msg = item.content;
							const chat = state.chats[item.chatId];
							if (!chat) continue;

							sourceText = `来自与 ${chat.name} 的聊天`;
							const isUser = msg.role === "user";
							let senderName, senderAvatar;

							if (isUser) {
								// 用户消息的逻辑
								senderName = chat.isGroup ? chat.settings.myNickname || "我" : "我";
								senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
							} else {
								// AI/成员消息
								if (chat.isGroup) {
									const member = chat.members.find((m) => m.originalName === msg.senderName);
									// 如果找到了成员信息，就用他的"群昵称"；如果没找到，就用消息里的名字作为备用
									senderDisplayName = member ? member.groupNickname : msg.senderName || "未知成员";
									senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
								} else {
									// 单聊的逻辑
									senderName = chat.name;
									senderAvatar = chat.settings.aiAvatar || defaultAvatar;
								}
							}

							// 拼接 headerHtml 和 contentHtml
							headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;

							if (typeof msg.content === "string" && STICKER_REGEX.test(msg.content)) {
								contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
							} else if (Array.isArray(msg.content) && msg.content[0]?.type === "image_url") {
								contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
							} else {
								const messageText = String(msg.content || "");
								// 侦测格式：[sticker:名字]
								const stickerMatch = messageText.match(/\[sticker:\s*(.+?)\s*\]/i);

								if (stickerMatch) {
									// 提取表情名称并在所有可能的表情库中查找
									const stickerName = stickerMatch[1].trim();
									const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
									const foundSticker = allStickers.find((s) => s.name === stickerName);

									if (foundSticker) {
										// 如果找到了，就显示图片
										bubble.classList.add("is-sticker");
										contentHtml = `<img src="${foundSticker.url}" alt="${foundSticker.name}" class="sticker-image">`;
									} else {
										// 如果没找到，按普通文字显示
										contentHtml = messageText.replace(/\n/g, "<br>");
									}
								} else {
									// 普通文本消息
									contentHtml = messageText.replace(/\n/g, "<br>");
								}
							}
						}

						// 拼接最终的HTML并添加到页面
						card.innerHTML = `
                                <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
                                <div class="fav-card-content">${contentHtml}</div>
                                ${footerHtml}`;

						listEl.appendChild(card);
					}
				}

				/**
				 * 负责准备数据并触发渲染
				 */
				async function renderFavoritesScreen() {
					// 从数据库获取最新数据并缓存
					allFavoriteItems = await db.favorites.orderBy("timestamp").reverse().toArray();

					// 清空搜索框并隐藏清除按钮
					const searchInput = document.getElementById("favorites-search-input");
					const clearBtn = document.getElementById("favorites-search-clear-btn");
					searchInput.value = "";
					clearBtn.style.display = "none";

					// 显示所有收藏项
					displayFilteredFavorites(allFavoriteItems);
				}

				function resetCreatePostModal() {
					document.getElementById("post-public-text").value = "";
					document.getElementById("post-image-preview").src = "";
					document.getElementById("post-image-description").value = "";
					document.getElementById("post-image-preview-container").classList.remove("visible");
					document.getElementById("post-image-desc-group").style.display = "none";
					document.getElementById("post-local-image-input").value = "";
					document.getElementById("post-hidden-text").value = "";

					// 直接、安全地设置状态
					const imageModeBtn = document.getElementById("switch-to-image-mode");
					const textImageModeBtn = document.getElementById("switch-to-text-image-mode");
					const imageModeContent = document.getElementById("image-mode-content");
					const textImageModeContent = document.getElementById("text-image-mode-content");

					imageModeBtn.classList.add("active");
					textImageModeBtn.classList.remove("active");
					imageModeContent.classList.add("active");
					textImageModeContent.classList.remove("active");
				}

				async function exportBackup() {
					try {
						const backupData = {
							version: 1,
							timestamp: Date.now(),
						};

						// 获取所有需要备份的数据表
						const [chats, worldBooks, userStickers, charStickers, apiConfig, globalSettings, personaPresets, musicLibrary, qzoneSettings, qzonePosts, qzoneAlbums, qzonePhotos, favorites, qzoneGroups, memories, worldBookCategories, callRecords, customAvatarFrames, themes, apiPresets, bubbleStylePresets, fontPresets, homeScreenPresets, datingScenes, datingPresets, datingSpriteGroups, datingSprites, datingHistory, pomodoroSessions, ludoQuestionBanks, ludoQuestions, scriptKillScripts, taobaoProducts, taobaoOrders, taobaoCart, userWalletTransactions, userStickerCategories] = await Promise.all([db.chats.toArray(), db.worldBooks.toArray(), db.userStickers.toArray(), db.charStickers.toArray(), db.apiConfig.get("main"), db.globalSettings.get("main"), db.personaPresets.toArray(), db.musicLibrary.get("main"), db.qzoneSettings.get("main"), db.qzonePosts.toArray(), db.qzoneAlbums.toArray(), db.qzonePhotos.toArray(), db.favorites.toArray(), db.qzoneGroups.toArray(), db.memories.toArray(), db.worldBookCategories.toArray(), db.callRecords.toArray(), db.customAvatarFrames.toArray(), db.themes.toArray(), db.apiPresets.toArray(), db.bubbleStylePresets.toArray(), db.fontPresets.toArray(), db.homeScreenPresets.toArray(), db.datingScenes.toArray(), db.datingPresets.toArray(), db.datingSpriteGroups.toArray(), db.datingSprites.toArray(), db.datingHistory.toArray(), db.pomodoroSessions.toArray(), db.ludoQuestionBanks.toArray(), db.ludoQuestions.toArray(), db.scriptKillScripts.toArray(), db.taobaoProducts.toArray(), db.taobaoOrders.toArray(), db.taobaoCart.toArray(), db.userWalletTransactions.toArray(), db.userStickerCategories.toArray()]);

						// 将所有数据添加到备份对象中
						Object.assign(backupData, {
							chats,
							worldBooks,
							userStickers,
							charStickers,
							apiConfig,
							globalSettings,
							personaPresets,
							musicLibrary,
							qzoneSettings,
							qzonePosts,
							qzoneAlbums,
							qzonePhotos,
							favorites,
							qzoneGroups,
							memories,
							worldBookCategories,
							callRecords,
							customAvatarFrames,
							themes,
							apiPresets,
							bubbleStylePresets,
							fontPresets,
							homeScreenPresets,
							datingScenes,
							datingPresets,
							datingSpriteGroups,
							datingSprites,
							datingHistory,
							pomodoroSessions,
							ludoQuestionBanks,
							ludoQuestions,
							scriptKillScripts,
							taobaoProducts,
							taobaoOrders,
							taobaoCart,
							userWalletTransactions,
							userStickerCategories,
						});

						// 添加主屏幕状态数据
						backupData.homeScreenState = {
							"profile-banner-img": document.getElementById("profile-banner-img").src,
							"profile-avatar-img": document.getElementById("profile-avatar-img").src,
							homeAvatarFrame: document.getElementById("profile-avatar-frame").src,
							"profile-username": document.getElementById("profile-username").textContent,
							"profile-sub-username": document.getElementById("profile-sub-username").textContent,
							"profile-bio": document.getElementById("profile-bio").textContent,
							"profile-location": document.getElementById("profile-location").innerHTML,
							"widget-bubble-1": document.getElementById("widget-bubble-1").textContent,
							"widget-image-1": document.getElementById("widget-image-1").src,
							"widget-subtext-1": document.getElementById("widget-subtext-1").textContent,
							"widget-bubble-2": document.getElementById("widget-bubble-2").textContent,
							"widget-image-2": document.getElementById("widget-image-2").src,
							"widget-subtext-2": document.getElementById("widget-subtext-2").textContent,
							"widget-image-3": document.getElementById("widget-image-3").src,
							"second-page-bubble": document.getElementById("second-page-bubble").textContent,
							"flat-capsule-bubble": document.getElementById("flat-capsule-bubble").textContent,
							"circular-bubble": document.getElementById("circular-bubble").textContent,
							"widget-image-4": document.getElementById("widget-image-4").src,
							"avatar-subtitle": document.getElementById("avatar-subtitle").textContent,
							"bubble-top-left": document.getElementById("bubble-top-left").textContent,
							"bubble-top-right": document.getElementById("bubble-top-right").textContent,
							"bubble-bottom-left": document.getElementById("bubble-bottom-left").textContent,
							"bubble-bottom-right": document.getElementById("bubble-bottom-right").textContent,
							"new-widget-avatar": document.getElementById("new-widget-avatar").src,
							"new-widget-text-1": document.getElementById("new-widget-text-1").textContent,
							"new-widget-text-2": document.getElementById("new-widget-text-2").textContent,
							"new-widget-text-3": document.getElementById("new-widget-text-3").textContent,
							"widget-month-display": document.getElementById("widget-month-display").textContent,
							appIcons: { ...state.globalSettings.appIcons },
							appLabels: { ...state.globalSettings.appLabels },
							wallpaper: state.globalSettings.wallpaper,
						};

						// 创建并下载备份文件
						const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: "application/json" });
						const url = URL.createObjectURL(blob);
						const link = Object.assign(document.createElement("a"), {
							href: url,
							download: `EPhone-Full-Backup-${new Date().toISOString().split("T")[0]}.json`,
						});
						document.body.appendChild(link);
						link.click();
						document.body.removeChild(link);
						URL.revokeObjectURL(url);

						await showCustomAlert("导出成功", "已成功导出所有数据！");
					} catch (error) {
						console.error("导出数据时出错:", error);
						await showCustomAlert("导出失败", `发生了一个错误: ${error.message}`);
					}
				}

				// 导入备份数据
				async function importBackup(file) {
					if (!file) return;

					const confirmed = await showCustomConfirm("严重警告！", "导入备份将完全覆盖您当前的所有数据，包括聊天、设置等。此操作不可撤销！您确定要继续吗？", { confirmButtonClass: "btn-danger" });

					if (!confirmed) return;

					try {
						const text = await file.text();
						const data = JSON.parse(text);

						await db.transaction("rw", db.tables, async () => {
							// 清空所有现有表格
							for (const table of db.tables) {
								await table.clear();
							}

							// 智能、安全地导入数据
							// 检查备份文件中的每一项数据，只有当当前代码的数据库里也存在对应的表格时，才进行导入

							// 导入数组类型的数据
							const arrayTables = ["chats", "worldBooks", "userStickers", "charStickers", "personaPresets", "qzonePosts", "qzoneAlbums", "qzonePhotos", "favorites", "qzoneGroups", "memories", "worldBookCategories", "callRecords", "customAvatarFrames", "themes", "apiPresets", "bubbleStylePresets", "fontPresets", "homeScreenPresets"];

							// 世界书格式兼容转换
							for (const tableName of arrayTables) {
								if (Array.isArray(data[tableName]) && db[tableName]) {
									let itemsToPut = data[tableName];

									// 当处理世界书表格时，执行特别的转换操作
									if (tableName === "worldBooks") {
										console.log("正在检查并转换世界书数据格式以兼容...");
										itemsToPut.forEach((book) => {
											// 如果 content 是数组 (别人的格式)，则将其转换为字符串 (我的格式)
											if (Array.isArray(book.content)) {
												console.log(`检测到数组格式的世界书: "${book.name}"，正在转换为字符串...`);

												// 将数组中的每个条目对象转换为格式化的字符串
												const convertedEntries = book.content.map((entry) => {
													const stringParts = [];
													if (entry.comment) {
														stringParts.push(`[备注: ${entry.comment}]`);
													}
													if (entry.keys && entry.keys.length > 0) {
														stringParts.push(`[关键词: ${entry.keys.join(", ")}]`);
													}
													stringParts.push(entry.content); // 条目主要内容
													return stringParts.join("\n"); // 每个条目的内部用换行分隔
												});

												// 将所有转换后的条目字符串用一个明显的分隔符连接起来
												book.content = convertedEntries.join("\n\n---\n\n");
											}
										});
									}

									// 过滤并保存数据
									const validItems = itemsToPut.filter((item) => item && (typeof item.id === "undefined" || typeof item.id === "string" || typeof item.id === "number"));
									if (validItems.length > 0) {
										console.log(`正在导入 ${validItems.length} 条数据到表格: ${tableName}...`);
										await db[tableName].bulkPut(validItems);
									}
								} else {
									console.log(`跳过导入: ${tableName} (在备份文件或当前数据库中不存在)`);
								}
							}

							// 导入对象类型的数据（通常是设置）
							const objectTables = ["apiConfig", "globalSettings", "musicLibrary", "qzoneSettings"];
							for (const tableName of objectTables) {
								if (data[tableName] && db[tableName]) {
									console.log(`正在导入设置: ${tableName}...`);
									await db[tableName].put(data[tableName]);
								}
							}
						});

						// 导入主屏幕样式数据
						if (data.homeScreenState) {
							const settings = (await db.globalSettings.get("main")) || { id: "main" };
							settings.widgetData = data.homeScreenState;
							if (data.homeScreenState.wallpaper) settings.wallpaper = data.homeScreenState.wallpaper;
							if (data.homeScreenState.lockscreenWallpaper) settings.lockscreenWallpaper = data.homeScreenState.lockscreenWallpaper;
							if (data.homeScreenState.appIcons) settings.appIcons = data.homeScreenState.appIcons;
							await db.globalSettings.put(settings);
							console.log("已成功导入主屏幕样式数据。");
						}

						await showCustomAlert("导入成功", "所有数据已成功恢复！应用即将刷新以应用所有更改。");

						setTimeout(() => {
							window.location.reload();
						}, 1500);
					} catch (error) {
						console.error("导入数据时出错:", error);
						await showCustomAlert("导入失败", `文件格式不正确或数据已损坏: ${error.message}`);
					}
				}

				// 应用自定义字体
				function applyCustomFont(fontUrl, isPreviewOnly = false) {
					if (!fontUrl) {
						// 如果没有提供字体链接（比如恢复默认），就清空样式
						dynamicFontStyle.innerHTML = "";
						document.getElementById("font-preview").style.fontFamily = "";
						return;
					}

					// 统一的内部字体名称
					const fontName = "custom-user-font";

					// 定义字体的样式规则
					const newStyle = `
                        @font-face {
                        font-family: '${fontName}';
                        src: url('${fontUrl}');
                        font-display: swap;
                        }`;

					if (isPreviewOnly) {
						// 如果只是预览，创建或更新预览样式
						const previewStyle = document.getElementById("preview-font-style") || document.createElement("style");
						previewStyle.id = "preview-font-style";
						previewStyle.innerHTML = newStyle;
						if (!document.getElementById("preview-font-style")) document.head.appendChild(previewStyle);
						document.getElementById("font-preview").style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
					} else {
						// 如果是全局应用，定义字体并告诉整个 body 去使用它
						dynamicFontStyle.innerHTML = `
                            ${newStyle}
                            body {
                                font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif !important;
                            }`;
					}
				}

				// 重置为默认字体
				async function resetToDefaultFont() {
					// 清除全局字体样式
					dynamicFontStyle.innerHTML = "";

					// 更新并保存设置
					state.globalSettings.fontUrl = "";
					await db.globalSettings.put(state.globalSettings);

					// 明确地将全局预览区的字体也恢复为默认
					const globalPreview = document.getElementById("font-preview");
					globalPreview.style.fontFamily = ""; // 移除内联样式

					// 应用空的字体设置，确保所有地方都恢复
					applyCustomFont("", true);

					alert("已恢复默认字体。");
				}

				async function loadAllDataFromDB() {
					// 从数据库加载所有需要的数据表
					const [chatsArr, apiConfig, globalSettings, userStickers, charStickers, worldBooks, musicLib, personaPresets, qzoneSettings, initialFavorites, apiPresets, bubbleStylePresets, datingScenes, localUserStickerCategories, offlinePresetsFromDB] = await Promise.all([db.chats.toArray(), db.apiConfig.get("main"), db.globalSettings.get("main"), db.userStickers.toArray(), db.charStickers.toArray(), db.worldBooks.toArray(), db.musicLibrary.get("main"), db.personaPresets.toArray(), db.qzoneSettings.get("main"), db.favorites.orderBy("timestamp").reverse().toArray(), db.apiPresets.toArray(), db.bubbleStylePresets.toArray(), db.datingScenes.toArray(), db.userStickerCategories.toArray(), db.offlinePresets.toArray()]);

					state.offlinePresets = offlinePresetsFromDB || [];

					// 处理聊天数据，为旧数据添加缺失的属性以保证兼容性
					state.chats = chatsArr.reduce((acc, chat) => {
						// 为旧的群聊数据兼容专属表情库
						if (chat.isGroup && (!chat.settings || !chat.settings.stickerLibrary)) {
							if (!chat.settings) chat.settings = {};
							chat.settings.stickerLibrary = [];
							console.log(`为旧群聊 "${chat.name}" 补全了专属表情库(stickerLibrary)属性。`);
						}

						// 兼容旧数据：为没有专属表情库的角色添加一个空的表情库
						if (!chat.isGroup && (!chat.settings || !chat.settings.stickerLibrary)) {
							if (!chat.settings) chat.settings = {};
							chat.settings.stickerLibrary = [];
							console.log(`为旧角色 "${chat.name}" 补全了专属表情库(stickerLibrary)属性。`);
						}

						// 为没有未读计数的聊天添加默认值
						if (typeof chat.unreadCount === "undefined") {
							chat.unreadCount = 0;
						}

						// 兼容旧数据：为没有心声背景的角色添加一个空字符串
						if (typeof chat.innerVoiceBackground === "undefined") {
							chat.innerVoiceBackground = "";
						}

						// 为没有心声标签格式的角色添加默认值
						if (chat.settings && typeof chat.settings.innerVoiceAdopterLabelFormat === "undefined") {
							chat.settings.innerVoiceAdopterLabelFormat = "领养人: {{user}}";
						}

						// 数据迁移脚本：检查是否是群聊，并且其成员对象使用的是旧的 name 结构
						if (chat.isGroup && chat.members && chat.members.length > 0 && chat.members[0].name) {
							console.log(`检测到旧版群聊数据 for "${chat.name}"，正在执行迁移...`);
							chat.members.forEach((member) => {
								// 如果这个成员对象没有 originalName，说明是旧数据
								if (typeof member.originalName === "undefined") {
									member.originalName = member.name; // 将旧的 name 作为 originalName
									member.groupNickname = member.name; // 同时创建一个初始的 groupNickname
									delete member.name; // 删除旧的、有歧义的 name 字段
									needsUpdate = true; // 标记需要存回数据库
								}
							});
							console.log(`迁移完成 for "${chat.name}"`);
						}

						// 为单聊添加默认状态信息
						if (!chat.isGroup && !chat.status) {
							chat.status = {
								text: "在线",
								lastUpdate: Date.now(),
								isBusy: false,
							};
							console.log(`为旧角色 "${chat.name}" 补全了status属性。`);
						}

						// 兼容最新的"关系"功能
						if (!chat.isGroup && !chat.relationship) {
							chat.relationship = {
								status: "friend",
								blockedTimestamp: null,
								applicationReason: "",
							};
							console.log(`为旧角色 "${chat.name}" 补全了 relationship 属性。`);
						}

						// 为没有AI头像库的角色添加默认空数组
						if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) {
							if (!chat.settings) chat.settings = {};
							chat.settings.aiAvatarLibrary = [];
							console.log(`为旧角色 "${chat.name}" 补全了aiAvatarLibrary属性。`);
						}

						// 为没有总结设置的聊天添加默认值
						if (!chat.settings.summary) {
							chat.settings.summary = {
								enabled: false,
								mode: "auto",
								count: 20,
								prompt: "请你以第三人称的视角，客观、冷静、不带任何感情色彩地总结以下对话的核心事件和信息。禁止进行任何角色扮演或添加主观评论。",
								lastSummaryIndex: -1, // -1表示从未总结过
							};
						}

						// 兼容旧数据：为没有NPC库的单聊角色添加空的NPC库
						if (!chat.isGroup && !chat.npcLibrary) {
							chat.npcLibrary = [];
							console.log(`为旧角色 "${chat.name}" 补全了 npcLibrary 属性。`);
						}

						// 兼容旧数据：为没有微博设置的单聊角色添加空的微博设置
						if (!chat.isGroup && (!chat.settings.weiboProfession || typeof chat.settings.weiboInstruction === "undefined")) {
							chat.settings.weiboProfession = "";
							chat.settings.weiboInstruction = "";
							console.log(`为旧角色 "${chat.name}" 补全了微博设置属性。`);
						}

						// 为没有音乐数据的聊天添加默认值
						if (!chat.musicData) chat.musicData = { totalTime: 0 };

						// 兼容旧的数据结构，将单个世界书ID转换为数组
						if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) {
							chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId];
							delete chat.settings.linkedWorldBookId;
						}

						// 兼容旧数据，为没有 isPinned 属性的聊天添加默认值
						if (typeof chat.isPinned === "undefined") {
							chat.isPinned = false;
						}

						// 统一修复并初始化所有角色的手机数据
						if (!chat.isGroup) {
							// 确保最外层的 characterPhoneData 对象存在
							if (!chat.characterPhoneData) {
								chat.characterPhoneData = {};
							}

							// 逐一检查并补全所有APP的数据结构
							if (!chat.characterPhoneData.widgets) chat.characterPhoneData.widgets = {};
							if (!chat.characterPhoneData.lastGenerated) chat.characterPhoneData.lastGenerated = null;
							if (!chat.characterPhoneData.chats) chat.characterPhoneData.chats = {};
							if (!chat.characterPhoneData.shoppingCart) chat.characterPhoneData.shoppingCart = [];
							if (!chat.characterPhoneData.memos) chat.characterPhoneData.memos = [];
							if (!chat.characterPhoneData.browserHistory) chat.characterPhoneData.browserHistory = [];
							if (!chat.characterPhoneData.photoAlbum) chat.characterPhoneData.photoAlbum = [];
							if (!chat.characterPhoneData.bank) chat.characterPhoneData.bank = { balance: 0, transactions: [] };
							if (!chat.characterPhoneData.trajectory) chat.characterPhoneData.trajectory = [];
							if (!chat.characterPhoneData.appUsage) chat.characterPhoneData.appUsage = [];
							if (!chat.characterPhoneData.diary) chat.characterPhoneData.diary = []; // 核心修复！
							if (!chat.characterPhoneData.appWallpaper) {
								chat.characterPhoneData.appWallpaper = "";
							}
						}

						// 兼容旧数据，为没有后台活动设置的群聊添加默认值
						if (chat.isGroup && (!chat.settings || typeof chat.settings.backgroundActivity === "undefined")) {
							if (!chat.settings) chat.settings = {};
							chat.settings.backgroundActivity = {
								enabled: false,
								interval: 120, // 默认120秒
								lastActivityTimestamp: 0,
							};
						}

						// 兼容旧数据：为没有情侣头像设置的角色添加默认值
						if (typeof chat.settings.isCoupleAvatar === "undefined") {
							chat.settings.isCoupleAvatar = false;
							chat.settings.coupleAvatarDescription = "";
						}

						// 领养系统改造：宠物系统初始化/兼容代码
						// 为所有角色（包括新旧数据）确保有 petAdopted 标志
						if (!chat.isGroup && typeof chat.settings.petAdopted === "undefined") {
							// 如果 pet 对象已存在，说明是老用户，默认已领养
							if (chat.settings.pet && chat.settings.pet.type !== "无") {
								chat.settings.petAdopted = true;
							} else {
								// 如果没有 pet 对象，说明是新用户或之前就没用宠物，默认未领养
								chat.settings.petAdopted = false;
							}
							console.log(`为角色 "${chat.name}" 初始化了宠物领养状态: ${chat.settings.petAdopted}`);
						}

						// 兼容旧的 pet 对象，确保新字段存在
						if (!chat.isGroup && chat.settings.pet) {
							if (typeof chat.settings.pet.persona === "undefined") {
								chat.settings.pet.persona = "一只可爱的小宠物，对世界充满好奇。";
							}
							if (!chat.settings.pet.petChatHistory) {
								chat.settings.pet.petChatHistory = [];
							}
							if (!chat.settings.pet.status) {
								chat.settings.pet.status = {
									hunger: 100,
									happiness: 100,
									intimacyToUser: 50,
									intimacyToChar: 50,
									lastUpdated: Date.now(),
								};
							} else {
								if (typeof chat.settings.pet.status.intimacyToUser === "undefined") chat.settings.pet.status.intimacyToUser = 50;
								if (typeof chat.settings.pet.status.intimacyToChar === "undefined") chat.settings.pet.status.intimacyToChar = 50;
								if (typeof chat.settings.pet.status.lastUpdated === "undefined") chat.settings.pet.status.lastUpdated = Date.now();
							}
						}

						// 兼容旧数据：为没有记忆互通设置的聊天添加一个空的数组
						if (!chat.settings.linkedMemories) {
							chat.settings.linkedMemories = [];
						}

						// 为旧数据添加默认的记忆条数设置
						if (typeof chat.settings.linkMemoryDepth === "undefined") {
							chat.settings.linkMemoryDepth = 5;
						}

						// 兼容线下模式设置
						if (!chat.settings.offlineMode) {
							chat.settings.offlineMode = {
								enabled: false,
								prompt: "",
								style: "",
								wordCount: 300,
								presets: [],
							};
						}

						// 为旧角色数据兼容微博独立设置
						if (!chat.isGroup) {
							if (!chat.characterPhoneData) {
								chat.characterPhoneData = {}; // 以防万一连 characterPhoneData 都没有
							}
							if (!chat.characterPhoneData.wallpaper) {
								chat.characterPhoneData.wallpaper = ""; // 初始化壁纸为空
							}
							if (!chat.characterPhoneData.appIcons) {
								chat.characterPhoneData.appIcons = {}; // 初始化App图标为空对象
							}

							// 为旧角色数据兼容微博独立设置
							if (!chat.settings.weiboNickname) {
								chat.settings.weiboNickname = chat.name; // 默认使用角色名作为微博昵称
							}
							if (!chat.settings.weiboAvatar) {
								chat.settings.weiboAvatar = chat.settings.aiAvatar; // 默认使用AI头像
							}
							if (!chat.settings.weiboAvatarFrame) {
								chat.settings.weiboAvatarFrame = chat.settings.aiAvatarFrame || ""; // 默认使用AI头像框
							}
							if (!chat.settings.weiboBackground) {
								chat.settings.weiboBackground = "https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg"; // 给一个默认背景
							}
						}

						// 为旧角色数据兼容微博粉丝/关注数
						if (!chat.isGroup && (typeof chat.settings.weiboFansCount === "undefined" || typeof chat.settings.weiboFollowingCount === "undefined")) {
							const initialStats = getInitialWeiboStats(chat);
							chat.settings.weiboFansCount = initialStats.fans;
							chat.settings.weiboFollowingCount = initialStats.following;
							console.log(`为旧角色 "${chat.name}" 初始化了微博数据。`);
						}

						// 为没有minimax语音ID的角色添加默认值
						if (!chat.isGroup && (!chat.settings || typeof chat.settings.minimaxVoiceId === "undefined")) {
							if (!chat.settings) chat.settings = {};
							chat.settings.minimaxVoiceId = ""; // 默认为空
							console.log(`为旧角色 "${chat.name}" 补全了 minimaxVoiceId 属性。`);
						}

						// 为没有火花设置的聊天添加默认值
						if (!chat.settings.streak) {
							chat.settings.streak = {
								enabled: false,
								initialDays: 0, // 用户填写的初始天数
								currentDays: 0, // 当前的火花天数
								extinguishThreshold: 1, // 熄灭阈值，默认1天
								lastInteractionDate: null, // 上次互动日期
							};
							console.log(`为角色 "${chat.name}" 补全了增强版火花(streak)设置。`);
						} else if (typeof chat.settings.streak.extinguishThreshold === "undefined") {
							// 兼容上个版本的数据，为它们也加上熄灭阈值
							chat.settings.streak.extinguishThreshold = 1;
							console.log(`为角色 "${chat.name}" 的旧火花设置添加了熄灭阈值。`);
						}

						// 兼容旧的群聊数据，为它们添加群主、管理员和头衔属性
						if (chat.isGroup) {
							if (typeof chat.settings.groupAnnouncement === "undefined") {
								chat.settings.groupAnnouncement = "";
							}

							// 如果没有ownerId，则默认创建者（也就是你）为群主
							if (!chat.ownerId) {
								chat.ownerId = "user"; // 我们假设用户的ID为 'user'
							}

							// 遍历所有成员，为他们添加新属性
							if (chat.members && Array.isArray(chat.members)) {
								chat.members.forEach((member) => {
									if (typeof member.isAdmin === "undefined") {
										member.isAdmin = false; // 默认不是管理员
									}
									if (typeof member.groupTitle === "undefined") {
										member.groupTitle = ""; // 默认没有头衔
									}
								});
							}

							// 为用户自己也添加管理员和头衔的默认属性
							if (chat.settings) {
								if (typeof chat.settings.isUserAdmin === "undefined") {
									chat.settings.isUserAdmin = false;
								}
								if (typeof chat.settings.myGroupTitle === "undefined") {
									chat.settings.myGroupTitle = "";
								}
							}
						}

						// 为旧数据兼容心声面板样式设置
						if (!chat.settings.innerVoiceStyles) {
							chat.settings.innerVoiceStyles = {
								clothingColor: "#f0a1a8",
								behaviorColor: "#81c784",
								thoughtsColor: "#64b5f6",
								naughtyColor: "#ba68c8",
								cardBgColor: "#ffffff",
								cardOpacity: 0.7,
							};
						}

						// 为旧数据兼容图标颜色设置
						if (chat.settings.innerVoiceStyles && typeof chat.settings.innerVoiceStyles.iconColor === "undefined") {
							chat.settings.innerVoiceStyles.iconColor = "#ff8a80"; // 默认粉红色
						}

						// 兼容亲密值系统：为旧数据添加互动统计和已解锁徽章
						if (!chat.interactionStats) {
							chat.interactionStats = {};
						}
						if (!chat.unlockedSymbols) {
							chat.unlockedSymbols = [];
						}

						// 兼容亲密值系统：为旧数据添加佩戴徽章的字段
						if (chat.settings && typeof chat.settings.selectedIntimacyBadge === "undefined") {
							chat.settings.selectedIntimacyBadge = ""; // 默认为空，不佩戴
						}

						acc[chat.id] = chat;
						return acc;
					}, {});

					// 初始化API配置，为旧数据添加默认值
					state.apiConfig = apiConfig || {
						id: "main",
						proxyUrl: "",
						apiKey: "",
						model: "",
						temperature: 0.8, // 为温度设置一个默认值 0.8
						minimaxGroupId: "",
						minimaxApiKey: "",
						minimaxSpeechModel: "speech-01",
					};

					// 兼容旧数据，如果加载的设置里没有温度，也给一个默认值
					if (typeof state.apiConfig.temperature === "undefined") {
						state.apiConfig.temperature = 0.8;
					}

					// 初始化全局设置，为旧数据添加默认值
					state.globalSettings = globalSettings || {
						id: "main",
						ringtoneUrl: "https://files.catbox.moe/3w7gla.mp3",
						notificationSoundUrl: "https://files.catbox.moe/k369mf.mp3",
						widgetData: {},
						wallpaper: "linear-gradient(135deg, #89f7fe, #66a6ff)",
						lockscreenWallpaper: "linear-gradient(135deg, #764ba2, #667eea)",
						password: "",
						fontUrl: "",
						enableBackgroundActivity: false,
						backgroundActivityInterval: 60,
						blockCooldownHours: 1,
						appIcons: { ...DEFAULT_APP_ICONS },
						appLabels: {},
						ringtoneUrl: "https://files.catbox.moe/3w7gla.mp3",
						notificationSoundUrl: "https://files.catbox.moe/k369mf.mp3",
						widgetData: {}, // 在这里新增一个空对象，用来存放自定义内容
						homeAvatarFrame: "", // 为主屏幕头像框添加默认空值
						globalChatBackground: "",
						homeIconWidgetTextColor: "#FFFFFF", // 主屏幕图标及小组件字体颜色默认值
						imageCompressionQuality: 0.7,
						userBalance: 520,
						homeAvatarFrame: "", // 为主屏幕头像框添加默认空值
					};

					// 确保即使从旧数据库加载，widgetData属性也存在
					if (!state.globalSettings.widgetData) {
						state.globalSettings.widgetData = {};
					}

					// 为主屏幕图标及小组件字体颜色添加默认值
					if (!state.globalSettings.homeIconWidgetTextColor) {
						state.globalSettings.homeIconWidgetTextColor = "#FFFFFF";
					}

					// 兼容字体阴影设置
					if (typeof state.globalSettings.removeHomeFontShadow === "undefined") {
						state.globalSettings.removeHomeFontShadow = false;
					}

					// 兼容旧数据：如果加载的设置里没有appLabels，就给它一个空对象
					if (!state.globalSettings.appLabels) {
						state.globalSettings.appLabels = {};
					}

					// 为图片压缩质量添加默认值
					if (typeof state.globalSettings.imageCompressionQuality === "undefined") {
						state.globalSettings.imageCompressionQuality = 0.7;
					}

					// 加载歌词栏设置，如果不存在则使用默认值
					lyricsBarSettings = state.globalSettings.lyricsBarSettings || lyricsBarSettings;

					// 合并已保存的图标和默认图标，防止更新后旧数据丢失新图标
					state.globalSettings.appIcons = { ...DEFAULT_APP_ICONS, ...(state.globalSettings.appIcons || {}) };

					// 初始化贴纸数据
					state.userStickers = userStickers || [];
					userStickerCategories = localUserStickerCategories || [];
					state.charStickers = charStickers || [];
					state.worldBooks = worldBooks || [];
					currentDatingScenes = datingScenes || [];
					musicState.playlist = musicLib?.playlist || [];
					state.personaPresets = personaPresets || [];
					state.apiPresets = apiPresets || [];
					state.bubbleStylePresets = bubbleStylePresets || [];

					// 初始化QQ空间设置，包含微博用户设定
					state.qzoneSettings = qzoneSettings || {
						id: "main",
						nickname: "{{user}}",
						avatar: "https://files.catbox.moe/q6z5fc.jpeg",
						banner: "https://files.catbox.moe/r5heyt.gif",
						weiboAvatar: "https://files.catbox.moe/q6z5fc.jpeg",
						weiboNickname: "你的昵称",
						weiboFansCount: "0",
						weiboBackground: "https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg",
						// 为微博用户添加专属的职业和人设字段
						weiboUserProfession: "点击设置职业",
						weiboUserPersona: "一个普通的微博用户。",
						weiboUserPersonaPresets: [],
					};

					// 兼容旧数据，如果加载进来的数据没有这些新字段，就补上默认值
					if (!state.qzoneSettings.weiboAvatar) state.qzoneSettings.weiboAvatar = state.qzoneSettings.avatar || "https://files.catbox.moe/q6z5fc.jpeg";
					if (!state.qzoneSettings.weiboNickname) state.qzoneSettings.weiboNickname = state.qzoneSettings.nickname || "你的昵称";
					if (!state.qzoneSettings.weiboFansCount) state.qzoneSettings.weiboFansCount = "0";
					if (!state.qzoneSettings.weiboBackground) state.qzoneSettings.weiboBackground = "https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg";

					// 兼容旧的用户微博设定
					if (!state.qzoneSettings.weiboUserProfession) state.qzoneSettings.weiboUserProfession = "点击设置职业";
					if (!state.qzoneSettings.weiboUserPersona) state.qzoneSettings.weiboUserPersona = "一个普通的微博用户。";
					if (!state.qzoneSettings.weiboUserPersonaPresets) state.qzoneSettings.weiboUserPersonaPresets = [];

					// 为微博头像框添加默认值
					if (!state.qzoneSettings.weiboAvatarFrame) state.qzoneSettings.weiboAvatarFrame = "";

					// 初始化收藏数据
					allFavoriteItems = initialFavorites || [];

					// 为通知音效添加默认值
					if (typeof state.globalSettings.notificationSoundUrl === "undefined") {
						state.globalSettings.notificationSoundUrl = "https://files.catbox.moe/k369mf.mp3";
					}
				}

				// 保存全局播放列表，过滤掉临时歌曲
				async function saveGlobalPlaylist() {
					// 在保存前，先从当前播放列表中过滤掉所有被标记为 isTemporary 的歌曲
					const permanentPlaylist = musicState.playlist.filter((track) => !track.isTemporary);

					// 只将这个"永久播放列表"保存到数据库中
					await db.musicLibrary.put({ id: "main", playlist: permanentPlaylist });
					console.log("已将永久播放列表保存到数据库。");
				}

				// 格式化时间戳为小时:分钟格式
				function formatTimestamp(timestamp) {
					if (!timestamp) return "";
					const date = new Date(timestamp);
					const hours = String(date.getHours()).padStart(2, "0");
					const minutes = String(date.getMinutes()).padStart(2, "0");
					return `${hours}:${minutes}`;
				}

				// 显示通知栏消息
				function showNotification(chatId, messageContent) {
					playNotificationSound();
					clearTimeout(notificationTimeout);
					const chat = state.chats[chatId];
					if (!chat) return;
					const bar = document.getElementById("notification-bar");
					document.getElementById("notification-avatar").src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar;
					document.getElementById("notification-content").querySelector(".name").textContent = chat.name;
					document.getElementById("notification-content").querySelector(".message").textContent = messageContent;
					const newBar = bar.cloneNode(true);
					bar.parentNode.replaceChild(newBar, bar);
					newBar.addEventListener("click", () => {
						openChat(chatId);
						newBar.classList.remove("visible");
					});
					newBar.classList.add("visible");
					notificationTimeout = setTimeout(() => {
						newBar.classList.remove("visible");
					}, 4000);
				}

				/**
				 * 显示一个包含多个选项的操作菜单模态框
				 * 这是让图片编辑时能够选择"本地上传"或"URL"的关键函数！
				 * @param {string} title - 模态框的标题
				 * @param {Array<object>} options - 按钮选项数组, e.g., [{ text: '按钮文字', value: '返回值' }]
				 * @returns {Promise<string|null>} - 返回用户点击按钮的value，如果取消则返回null
				 */
				function showChoiceModal(title, options) {
					return new Promise((resolve) => {
						// 复用你现有的自定义模态框
						const modal = document.getElementById("preset-actions-modal");
						const footer = modal.querySelector(".custom-modal-footer");

						// 清空旧按钮并动态创建新按钮
						footer.innerHTML = "";

						options.forEach((option) => {
							const button = document.createElement("button");
							button.textContent = option.text;
							button.onclick = () => {
								modal.classList.remove("visible");
								resolve(option.value); // 返回被点击按钮的值
							};
							footer.appendChild(button);
						});

						// 添加一个标准的取消按钮
						const cancelButton = document.createElement("button");
						cancelButton.textContent = "取消";
						cancelButton.style.marginTop = "8px";
						cancelButton.style.borderRadius = "8px";
						cancelButton.style.backgroundColor = "#f0f0f0";
						cancelButton.onclick = () => {
							modal.classList.remove("visible");
							resolve(null); // 用户取消，返回 null
						};
						footer.appendChild(cancelButton);

						modal.classList.add("visible");
					});
				}

				/**
				 * 检查并删除所有失效的API歌曲
				 * 核心逻辑：不再依赖任何标签，直接根据链接特征识别需要检查的歌曲。
				 */
				async function deleteExpiredSearchedSongs() {
					await showCustomAlert("请稍候...", "正在检查播放列表中所有在线歌曲的有效性...");

					// 1. 识别所有来自API服务器的歌曲
					const songsToCheck = musicState.playlist.filter((track) => track.src && track.src.includes("api.vkeys.cn"));

					if (songsToCheck.length === 0) {
						await showCustomAlert("提示", "播放列表中没有需要检查的在线歌曲。");
						return;
					}

					const songsToDelete = [];
					const twentyFourHoursAgo = Date.now() - 24 * 60 * 60 * 1000;

					// 2. 对每一首识别出的歌曲，进行严格的"体检"
					await Promise.all(
						songsToCheck.map(async (track) => {
							// 条件1：检查链接本身是否已经失效（无法播放）
							const isUrlInvalid = !(await checkAudioAvailability(track.src));

							// 条件2：检查添加时间是否超过24小时（作为双重保险）
							const isOlderThan24h = track.addedTimestamp && track.addedTimestamp < twentyFourHoursAgo;

							// 只要满足【任意一个】条件，就判定为"失效"
							if (isUrlInvalid || isOlderThan24h) {
								songsToDelete.push(track);
								console.log(`标记删除: ${track.name} (原因: ${isUrlInvalid ? "链接失效" : ""} ${isOlderThan24h ? "超过24小时" : ""})`);
							}
						})
					);

					// 3. 根据检查结果进行反馈和操作
					if (songsToDelete.length === 0) {
						await showCustomAlert("检查完成", "播放列表中的所有在线歌曲当前均有效。");
						return;
					}

					const confirmed = await showCustomConfirm("确认清理", `检测到 ${songsToDelete.length} 首已失效的在线歌曲。确定要将它们从列表中移除吗？`, { confirmButtonClass: "btn-danger" });

					if (!confirmed) return;

					// 执行删除...
					const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
					musicState.playlist = musicState.playlist.filter((track) => !songsToDelete.includes(track));
					const newIndex = currentTrack ? musicState.playlist.findIndex((t) => t.src === currentTrack.src && t.name === currentTrack.name) : -1;

					if (newIndex === -1) {
						if (musicState.isPlaying) {
							audioPlayer.pause();
							audioPlayer.src = "";
						}
						musicState.isPlaying = false;
						if (musicState.playlist.length > 0) {
							playSong(0);
						} else {
							musicState.currentIndex = -1;
							updatePlayerUI();
						}
					} else {
						musicState.currentIndex = newIndex;
						updatePlayerUI();
					}

					await saveGlobalPlaylist();
					updatePlaylistUI();
					await showCustomAlert("清理完成", `${songsToDelete.length} 首歌曲已从列表中移除。`);
				}

				/**
				 * 更新所有时钟（状态栏和锁屏）
				 */
				function updateClock() {
					const now = new Date();
					const timeString = now.toLocaleTimeString("zh-CN", { hour: "2-digit", minute: "2-digit" });
					const dateString = now.toLocaleDateString("zh-CN", { weekday: "long", month: "long", day: "numeric" });

					// 更新状态栏时钟 (这个元素一直存在)
					const statusBarTime = document.getElementById("status-bar-time");
					if (statusBarTime) {
						statusBarTime.textContent = timeString;
					}

					// 更新锁屏时钟 (只有当锁屏元素存在时才更新，避免报错)
					const lockTime = document.getElementById("lock-main-time");
					const lockDate = document.getElementById("lock-main-date");
					if (lockTime) {
						lockTime.textContent = timeString;
					}
					if (lockDate) {
						lockDate.textContent = dateString;
					}
				}

				/**
				 * 解析AI返回的、可能格式不规范的响应内容
				 * @param {string} content - AI返回的原始字符串
				 * @returns {Array} - 一个标准化的消息对象数组
				 */
				function parseAiResponse(content) {
					const trimmedContent = content.trim();

					// 方案1：尝试作为标准的、单一的JSON数组解析
					// 这是最理想、最高效的情况
					if (trimmedContent.startsWith("[") && trimmedContent.endsWith("]")) {
						try {
							const parsed = JSON.parse(trimmedContent);
							if (Array.isArray(parsed)) {
								console.log("解析成功：标准JSON数组格式。");
								return parsed;
							}
						} catch (e) {
							// 如果解析失败，说明它虽然看起来像个数组，但内部格式有问题。
							// 此时我们不报错，而是继续尝试下面的"强力解析"方案。
							console.warn("标准JSON数组解析失败，将尝试强力解析...");
						}
					}

					// 方案2：使用正则表达式，从混乱的字符串中提取出所有独立的JSON对象
					// 这能完美解决您遇到的 "(Timestamp: ...)[{...}](Timestamp: ...)[{...}]" 这种格式
					const jsonMatches = trimmedContent.match(/{[^{}]*}/g);

					if (jsonMatches) {
						const results = [];
						for (const match of jsonMatches) {
							try {
								// 尝试解析每一个被我们"揪"出来的JSON字符串
								const parsedObject = JSON.parse(match);
								results.push(parsedObject);
							} catch (e) {
								// 如果某个片段不是有效的JSON，就忽略它，继续处理下一个
								console.warn("跳过一个无效的JSON片段:", match);
							}
						}

						// 如果我们成功提取出了至少一个有效的JSON对象，就返回这个结果
						if (results.length > 0) {
							console.log("解析成功：通过强力提取模式。");
							return results;
						}
					}

					// 方案3：如果以上所有方法都失败了，说明AI返回的可能就是纯文本
					// 我们将原始的、未处理的内容，包装成一个标准的文本消息对象返回，确保程序不会崩溃
					console.error("所有解析方案均失败！将返回原始文本。");
					return [{ type: "text", content: content }];
				}

				/**
				 * "拉取"并填充Minimax语音模型的下拉框
				 */
				function fetchMinimaxSpeechModels() {
					const modelSelect = document.getElementById("minimax-speech-model-select");
					modelSelect.innerHTML = ""; // 清空

					// Minimax官方提供的两个主要模型
					const models = ["speech-01", "speech-02"];

					models.forEach((modelId) => {
						const option = document.createElement("option");
						option.value = modelId;
						// 为模型添加简单的中文描述
						option.textContent = `${modelId} (${modelId === "speech-02" ? "高清" : "标准"})`;
						modelSelect.appendChild(option);
					});

					// 自动选中当前已保存的模型
					modelSelect.value = state.apiConfig.minimaxSpeechModel || "speech-01";

					alert("Minimax 语音模型列表已刷新！");
				}

				// NovelAI设置相关函数
				function loadNovelAISettings() {
					const settings = getNovelAISettings();
					document.getElementById("nai-resolution").value = settings.resolution;
					document.getElementById("nai-steps").value = settings.steps;
					document.getElementById("nai-cfg-scale").value = settings.cfg_scale;
					document.getElementById("nai-sampler").value = settings.sampler;
					document.getElementById("nai-seed").value = settings.seed;
					document.getElementById("nai-uc-preset").value = settings.uc_preset;
					document.getElementById("nai-quality-toggle").checked = settings.quality_toggle;
					document.getElementById("nai-smea").checked = settings.smea;
					document.getElementById("nai-smea-dyn").checked = settings.smea_dyn;
					document.getElementById("nai-default-positive").value = settings.default_positive;
					document.getElementById("nai-default-negative").value = settings.default_negative;
					document.getElementById("nai-cors-proxy").value = settings.cors_proxy;
					document.getElementById("nai-custom-proxy-url").value = settings.custom_proxy_url || "";

					// 显示/隐藏自定义代理输入框
					const customProxyGroup = document.getElementById("nai-custom-proxy-group");
					customProxyGroup.style.display = settings.cors_proxy === "custom" ? "block" : "none";
				}

				function saveNovelAISettings() {
					// 保存API Key和模型等基础配置
					const novelaiEnabled = document.getElementById("novelai-switch").checked;
					const novelaiModel = document.getElementById("novelai-model").value;
					const novelaiApiKey = document.getElementById("novelai-api-key").value.trim();

					localStorage.setItem("novelai-enabled", novelaiEnabled);
					localStorage.setItem("novelai-model", novelaiModel);
					localStorage.setItem("novelai-api-key", novelaiApiKey);

					// 保存高级参数配置
					const settings = {
						resolution: document.getElementById("nai-resolution").value,
						steps: parseInt(document.getElementById("nai-steps").value),
						cfg_scale: parseFloat(document.getElementById("nai-cfg-scale").value),
						sampler: document.getElementById("nai-sampler").value,
						seed: parseInt(document.getElementById("nai-seed").value),
						uc_preset: parseInt(document.getElementById("nai-uc-preset").value),
						quality_toggle: document.getElementById("nai-quality-toggle").checked,
						smea: document.getElementById("nai-smea").checked,
						smea_dyn: document.getElementById("nai-smea-dyn").checked,
						default_positive: document.getElementById("nai-default-positive").value,
						default_negative: document.getElementById("nai-default-negative").value,
						cors_proxy: document.getElementById("nai-cors-proxy").value,
						custom_proxy_url: document.getElementById("nai-custom-proxy-url").value,
					};

					localStorage.setItem("novelai-settings", JSON.stringify(settings));
				}

				function resetNovelAISettings() {
					localStorage.removeItem("novelai-settings");
					loadNovelAISettings();
					alert("已恢复默认设置！");
				}

				function getNovelAISettings() {
					const defaultSettings = {
						resolution: "1024x1024",
						steps: 28,
						cfg_scale: 5,
						sampler: "k_euler_ancestral",
						seed: -1,
						uc_preset: 1,
						quality_toggle: true,
						smea: true,
						smea_dyn: false,
						default_positive: "masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style",
						default_negative: "lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry",
						cors_proxy: "https://corsproxy.io/?",
						custom_proxy_url: "",
					};

					const saved = localStorage.getItem("novelai-settings");
					if (saved) {
						try {
							return { ...defaultSettings, ...JSON.parse(saved) };
						} catch (e) {
							return defaultSettings;
						}
					}
					return defaultSettings;
				}

				/**
				 * 根据角色ID获取对应的NAI提示词配置
				 * @param {string} chatId - 聊天/角色ID
				 * @returns {Object} 包含正面和负面提示词的对象
				 */
				function getCharacterNAIPrompts(chatId) {
					// 获取系统默认配置
					const systemSettings = getNovelAISettings();

					// 如果没有指定角色ID或角色不存在，返回系统配置
					if (!chatId || !state.chats[chatId]) {
						console.log("⚠️ NAI提示词：没有角色，使用系统配置");
						return {
							positive: systemSettings.default_positive,
							negative: systemSettings.default_negative,
							source: "system",
						};
					}

					const chat = state.chats[chatId];
					const naiSettings = chat.settings.naiSettings || {};

					// 选角色就用角色的，选系统就用系统的，就这么简单！
					if (naiSettings.promptSource === "character") {
						console.log("✅ NAI提示词：使用角色配置");
						console.log("   正面:", naiSettings.characterPositivePrompt || "(空)");
						console.log("   负面:", naiSettings.characterNegativePrompt || "(空)");

						return {
							positive: naiSettings.characterPositivePrompt || "",
							negative: naiSettings.characterNegativePrompt || "",
							source: "character",
						};
					} else {
						console.log("✅ NAI提示词：使用系统配置");
						console.log("   正面:", systemSettings.default_positive || "(空)");
						console.log("   负面:", systemSettings.default_negative || "(空)");

						return {
							positive: systemSettings.default_positive,
							negative: systemSettings.default_negative,
							source: "system",
						};
					}
				}

				/**
				 * 为指定角色生成NovelAI图像（将来聊天调用时使用）
				 * @param {string} chatId - 聊天/角色ID
				 * @param {string} customPrompt - 可选的自定义正面提示词（如果提供则追加到配置的提示词后）
				 * @returns {Promise<string>} 返回生成的图像Base64数据URL
				 */
				async function generateNovelAIImageForCharacter(chatId, customPrompt = "") {
					const apiKey = document.getElementById("novelai-api-key").value.trim();
					const model = document.getElementById("novelai-model").value;

					if (!apiKey) {
						throw new Error("请先配置NovelAI API Key！");
					}

					// 获取角色的提示词配置
					const prompts = getCharacterNAIPrompts(chatId);

					// 构建最终的提示词（如果有自定义提示词则追加）
					let finalPrompt = prompts.positive;
					if (customPrompt) {
						finalPrompt = customPrompt + ", " + prompts.positive;
					}

					const negativePrompt = prompts.negative;

					console.log(`📝 使用${prompts.source === "character" ? "角色专属" : "系统"}提示词配置`);
					console.log("正面提示词:", finalPrompt);
					console.log("负面提示词:", negativePrompt);

					const settings = getNovelAISettings();

					// 后续的图像生成逻辑将在这里实现
					// 这个函数预留给将来聊天中调用NAI出图功能使用
					return null;
				}

				// 生成NovelAI图片的主函数
				async function generateNovelAIImage() {
					const apiKey = document.getElementById("novelai-api-key").value.trim();
					const model = document.getElementById("novelai-model").value;
					const prompt = document.getElementById("nai-test-prompt").value.trim();

					if (!apiKey) {
						alert("请先配置NovelAI API Key！");
						return;
					}

					if (!prompt) {
						alert("请输入提示词！");
						return;
					}

					const settings = getNovelAISettings();
					const negativePrompt = document.getElementById("nai-test-negative").value.trim();

					const statusDiv = document.getElementById("nai-test-status");
					const resultDiv = document.getElementById("nai-test-result");
					const errorDiv = document.getElementById("nai-test-error");
					const generateBtn = document.getElementById("nai-generate-btn");

					statusDiv.style.display = "block";
					resultDiv.style.display = "none";
					errorDiv.style.display = "none";
					generateBtn.disabled = true;
					generateBtn.textContent = "生成中...";

					try {
						const [width, height] = settings.resolution.split("x").map(Number);

						// V4/V4.5 和 V3 使用不同的请求体格式
						let requestBody;

						if (model.includes("nai-diffusion-4")) {
							// V4/V4.5 使用新格式 (params_version: 3)
							requestBody = {
								input: prompt,
								model: model,
								action: "generate",
								parameters: {
									params_version: 3, // V4必须使用版本3
									width: width,
									height: height,
									scale: settings.cfg_scale,
									sampler: settings.sampler,
									steps: settings.steps,
									seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
									n_samples: 1,
									ucPreset: settings.uc_preset,
									qualityToggle: settings.quality_toggle,
									autoSmea: false,
									dynamic_thresholding: false,
									controlnet_strength: 1,
									legacy: false,
									add_original_image: true,
									cfg_rescale: 0,
									noise_schedule: "karras", // V4使用karras
									legacy_v3_extend: false,
									skip_cfg_above_sigma: null,
									use_coords: false,
									legacy_uc: false,
									normalize_reference_strength_multiple: true,
									inpaintImg2ImgStrength: 1,
									characterPrompts: [],
									// V4专用提示词格式
									v4_prompt: {
										caption: {
											base_caption: prompt,
											char_captions: [],
										},
										use_coords: false,
										use_order: true,
									},
									// V4专用负面提示词格式
									v4_negative_prompt: {
										caption: {
											base_caption: negativePrompt,
											char_captions: [],
										},
										legacy_uc: false,
									},
									negative_prompt: negativePrompt,
									deliberate_euler_ancestral_bug: false,
									prefer_brownian: true,
									// 注意：不包含 stream 参数，使用标准ZIP响应而非msgpack流
								},
							};
						} else {
							// V3 及更早版本使用旧格式
							requestBody = {
								input: prompt,
								model: model,
								action: "generate",
								parameters: {
									width: width,
									height: height,
									scale: settings.cfg_scale,
									sampler: settings.sampler,
									steps: settings.steps,
									seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
									n_samples: 1,
									ucPreset: settings.uc_preset,
									qualityToggle: settings.quality_toggle,
									sm: settings.smea,
									sm_dyn: settings.smea_dyn,
									dynamic_thresholding: false,
									controlnet_strength: 1,
									legacy: false,
									add_original_image: false,
									cfg_rescale: 0,
									noise_schedule: "native",
									negative_prompt: negativePrompt,
								},
							};
						}

						console.log("📤 发送请求到 NovelAI API");
						console.log("📊 使用模型:", model);
						console.log("📋 请求体:", JSON.stringify(requestBody, null, 2));

						// 根据模型选择不同的API端点
						let apiUrl;

						// V4/V4.5 模型使用流式端点
						if (model.includes("nai-diffusion-4")) {
							// V4/V4.5 默认使用流式端点
							apiUrl = "https://image.novelai.net/ai/generate-image-stream";
						} else {
							// V3 及更早版本使用标准端点
							apiUrl = "https://image.novelai.net/ai/generate-image";
						}

						let corsProxy = settings.cors_proxy;

						// 如果选择了自定义代理，使用自定义URL
						if (corsProxy === "custom") {
							corsProxy = settings.custom_proxy_url || "";
						}

						// 如果有代理，添加到URL前面
						if (corsProxy && corsProxy !== "") {
							apiUrl = corsProxy + encodeURIComponent(apiUrl);
						}

						// Chrome浏览器专用处理：避免headers中包含非ISO-8859-1字符
						const isChrome = /Chrome/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);
						let fetchOptions = {
							method: "POST",
							headers: {
								"Content-Type": "application/json",
								Authorization: "Bearer " + apiKey,
							},
							body: JSON.stringify(requestBody),
						};

						// 针对Chrome浏览器：确保所有header值都是纯ASCII
						if (isChrome) {
							console.log("🔧 检测到Chrome浏览器，启用headers兼容性处理");
							const cleanHeaders = {};
							for (const [key, value] of Object.entries(fetchOptions.headers)) {
								// 确保header值只包含ASCII字符（ISO-8859-1兼容）
								cleanHeaders[key] = value.replace(/[^\x00-\xFF]/g, "");
							}
							fetchOptions.headers = cleanHeaders;
						}

						const response = await fetch(apiUrl, fetchOptions);

						console.log("Response status:", response.status);
						console.log("Response headers:", [...response.headers.entries()]);

						if (!response.ok) {
							const errorText = await response.text();
							console.error("API错误响应:", errorText);
							throw new Error(`API请求失败 (${response.status}): ${errorText}`);
						}

						// NovelAI API返回的是ZIP文件，需要解压
						const contentType = response.headers.get("content-type");
						console.log("Content-Type:", contentType);

						// 检查是否为 SSE 流式响应
						let zipBlob;
						if (contentType && contentType.includes("text/event-stream")) {
							console.log("检测到 SSE 流式响应，开始解析...");
							statusDiv.textContent = "正在接收流式数据...";

							// 读取整个流
							const text = await response.text();
							console.log("收到 SSE 数据，大小:", text.length);

							// 解析 SSE 格式，提取最后的 data: 行
							const lines = text.trim().split("\n");
							let base64Data = null;

							for (let i = lines.length - 1; i >= 0; i--) {
								const line = lines[i].trim();
								if (line.startsWith("data: ") && line !== "data: [DONE]") {
									const dataContent = line.substring(6); // 移除 'data: ' 前缀

									// 尝试解析 JSON
									try {
										const jsonData = JSON.parse(dataContent);

										// V4.5 流式端点：event_type 为 "final" 时包含最终图片
										if (jsonData.event_type === "final" && jsonData.image) {
											base64Data = jsonData.image;
											console.log("✅ 找到 final 事件的图片数据");
											break;
										}

										// 兼容其他格式
										if (jsonData.data) {
											base64Data = jsonData.data;
											console.log("从 JSON.data 中提取图片数据");
											break;
										}
										if (jsonData.image) {
											base64Data = jsonData.image;
											console.log("从 JSON.image 中提取图片数据");
											break;
										}
									} catch (e) {
										// 如果不是 JSON，直接作为 base64 数据
										base64Data = dataContent;
										console.log("直接使用 base64 数据");
										break;
									}
								}
							}

							if (!base64Data) {
								throw new Error("无法从 SSE 响应中提取图片数据");
							}

							// V4.5 流式端点返回的是 PNG base64，不是 ZIP
							// 检查是否为 PNG (以 iVBORw0KGgo 开头) 或 JPEG (以 /9j/ 开头)
							const isPNG = base64Data.startsWith("iVBORw0KGgo");
							const isJPEG = base64Data.startsWith("/9j/");

							if (isPNG || isJPEG) {
								console.log("✅ 检测到直接的图片 base64 数据 (PNG/JPEG)");
								// 将 base64 转为 Blob
								const binaryString = atob(base64Data);
								const bytes = new Uint8Array(binaryString.length);
								for (let i = 0; i < binaryString.length; i++) {
									bytes[i] = binaryString.charCodeAt(i);
								}
								const imageBlob = new Blob([bytes], { type: isPNG ? "image/png" : "image/jpeg" });
								console.log("图片 Blob 创建成功，大小:", imageBlob.size);

								// 直接显示图片
								const imageUrl = URL.createObjectURL(imageBlob);
								document.getElementById("nai-result-image").src = imageUrl;
								statusDiv.style.display = "none";
								resultDiv.style.display = "block";
								console.log("✅ 图片显示成功！🎨");
								return;
							}

							// 否则当作 ZIP 处理
							console.log("当作 ZIP 文件处理...");
							const binaryString = atob(base64Data);
							const bytes = new Uint8Array(binaryString.length);
							for (let i = 0; i < binaryString.length; i++) {
								bytes[i] = binaryString.charCodeAt(i);
							}
							zipBlob = new Blob([bytes]);
							console.log("ZIP Blob 大小:", zipBlob.size);
						} else {
							// 非流式响应，直接读取
							zipBlob = await response.blob();
							console.log("收到数据，类型:", zipBlob.type, "大小:", zipBlob.size);
						}

						// NovelAI始终返回ZIP格式，需要解压
						try {
							// 检查JSZip是否已加载
							if (typeof JSZip === "undefined") {
								throw new Error("JSZip库未加载，请刷新页面重试");
							}

							statusDiv.textContent = "正在解压图片...";

							// 解压ZIP文件
							const zip = await JSZip.loadAsync(zipBlob);
							console.log("ZIP文件内容:", Object.keys(zip.files));

							// 查找第一个图片文件（通常是image_0.png）
							let imageFile = null;
							for (let filename in zip.files) {
								if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
									imageFile = zip.files[filename];
									console.log("找到图片文件:", filename);
									break;
								}
							}

							if (!imageFile) {
								throw new Error("ZIP文件中未找到图片");
							}

							// 提取图片数据
							const imageBlob = await imageFile.async("blob");
							console.log("提取的图片大小:", imageBlob.size);

							// 创建图片URL并显示
							const imageUrl = URL.createObjectURL(imageBlob);
							console.log("生成的图片URL:", imageUrl);

							document.getElementById("nai-result-image").src = imageUrl;
							statusDiv.style.display = "none";
							resultDiv.style.display = "block";
						} catch (zipError) {
							console.error("ZIP解压失败:", zipError);
							// 如果解压失败，尝试直接作为图片显示
							console.log("尝试直接作为图片显示...");

							if (zipBlob.type.startsWith("image/")) {
								const imageUrl = URL.createObjectURL(zipBlob);
								document.getElementById("nai-result-image").src = imageUrl;
								statusDiv.style.display = "none";
								resultDiv.style.display = "block";
							} else {
								throw new Error("图片格式处理失败: " + zipError.message);
							}
						}
					} catch (error) {
						console.error("NovelAI生成失败:", error);
						statusDiv.style.display = "none";
						errorDiv.style.display = "block";
						errorDiv.textContent = "生成失败: " + error.message;
					} finally {
						generateBtn.disabled = false;
						generateBtn.textContent = "生成图像";
					}
				}

				function renderApiSettings() {
					// 1. 更新 API 相关的输入框
					document.getElementById("proxy-url").value = state.apiConfig.proxyUrl || "";
					document.getElementById("api-key").value = state.apiConfig.apiKey || "";

					// 加载 Minimax 设置
					document.getElementById("minimax-group-id").value = state.apiConfig.minimaxGroupId || "";
					document.getElementById("minimax-api-key").value = state.apiConfig.minimaxApiKey || "";
					document.getElementById("minimax-speech-model-select").value = state.apiConfig.minimaxSpeechModel || "speech-01";

					// 如果你有模型选择，也一并更新
					if (document.getElementById("model-select")) {
						document.getElementById("model-select").value = state.apiConfig.model || "gpt-4";
					}

					// 加载NovelAI配置
					const novelaiEnabled = localStorage.getItem("novelai-enabled") === "true";
					const novelaiModel = localStorage.getItem("novelai-model") || "nai-diffusion-4-5-full";
					const novelaiApiKey = localStorage.getItem("novelai-api-key") || "";
					document.getElementById("novelai-switch").checked = novelaiEnabled;
					document.getElementById("novelai-model").value = novelaiModel;
					document.getElementById("novelai-api-key").value = novelaiApiKey;
					document.getElementById("novelai-details").style.display = novelaiEnabled ? "block" : "none";

					// 2. 更新后台活动相关的开关和输入框

					// 使用 !!state.globalSettings.enableBackgroundActivity 这种写法，
					// 确保当这个设置还不存在时 (比如第一次打开)，开关也能正确地显示为 false (关闭状态)
					document.getElementById("background-activity-switch").checked = !!state.globalSettings.enableBackgroundActivity;

					document.getElementById("background-interval-input").value = state.globalSettings.backgroundActivityInterval || 60;
					document.getElementById("block-cooldown-input").value = state.globalSettings.blockCooldownHours || 1;

					// 3. 渲染预设和频率的下拉框
					renderApiPresetSelector();
					renderBackgroundFrequencySelector();

					// 渲染温度滑块的UI
					const tempSlider = document.getElementById("temperature-slider");
					const tempValueDisplay = document.getElementById("temperature-value");

					// 从 state 中读取已保存的温度，如果没有则使用默认值 0.8
					const currentTemp = state.apiConfig.temperature || 0.8;
					tempSlider.value = currentTemp;
					tempValueDisplay.textContent = parseFloat(currentTemp).toFixed(1);

					// 添加实时更新显示值的事件
					tempSlider.addEventListener("input", () => {
						tempValueDisplay.textContent = parseFloat(tempSlider.value).toFixed(1);
					});

					// 渲染图片压缩质量滑块
					const qualitySlider = document.getElementById("image-quality-slider");
					const qualityValue = document.getElementById("image-quality-value");
					const currentQuality = state.globalSettings.imageCompressionQuality || 0.7;

					if (qualitySlider && qualityValue) {
						qualitySlider.value = currentQuality;
						qualityValue.textContent = parseFloat(currentQuality).toFixed(1);

						// 添加实时更新显示值的事件
						qualitySlider.addEventListener("input", () => {
							qualityValue.textContent = parseFloat(qualitySlider.value).toFixed(1);
						});
					}
					calculateTotalImageSize();
				}

				/**
				 * 渲染后台活动的角色选择和频率设置UI
				 */
				function renderBackgroundFrequencySelector() {
					const container = document.getElementById("background-activity-char-list");
					const detailsContainer = document.getElementById("background-activity-details");
					const masterSwitch = document.getElementById("background-activity-switch");

					// 根据总开关的状态，决定是否显示详细设置
					detailsContainer.style.display = masterSwitch.checked ? "block" : "none";

					container.innerHTML = ""; // 清空旧列表
					const singleChats = Object.values(state.chats).filter((chat) => !chat.isGroup);

					if (singleChats.length === 0) {
						container.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">还没有可以设置的角色</p>';
						return;
					}

					const config = state.globalSettings.backgroundActivityConfig || {};

					singleChats.forEach((chat) => {
						const freq = config[chat.id] || "none"; // 获取当前角色的频率设置
						let badgeHtml = "";
						if (freq !== "none") {
							const freqText = { low: "低", medium: "中", high: "高" }[freq];
							badgeHtml = `<span class="char-freq-badge ${freq}">${freqText}</span>`;
						}

						const item = document.createElement("div");
						item.className = "char-list-item";
						item.innerHTML = `
                            <input type="checkbox" class="bg-char-checkbox" data-chat-id="${chat.id}">
                            <span class="char-name">${chat.name}</span>
                            ${badgeHtml}
                        `;
						container.appendChild(item);
					});
				}

				window.renderApiSettingsProxy = renderApiSettings;

				/**
				 * 渲染聊天列表，包括置顶聊天、分组聊天和普通聊天
				 */
				async function renderChatList() {
					const chatListEl = document.getElementById("chat-list");
					chatListEl.innerHTML = "";

					// 1. 获取所有聊天和分组数据
					const allChats = Object.values(state.chats);
					const allGroups = await db.qzoneGroups.toArray();

					if (allChats.length === 0) {
						chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 或群组图标添加聊天</p>';
						return;
					}

					// 2. 将聊天明确地分为"置顶"和"未置顶"两组
					const pinnedChats = allChats.filter((chat) => chat.isPinned);
					const unpinnedChats = allChats.filter((chat) => !chat.isPinned);

					// 3. 对置顶的聊天，仅按最新消息时间排序
					pinnedChats.sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));

					// 4. 【优先渲染】所有置顶的聊天
					pinnedChats.forEach((chat) => {
						const item = createChatListItem(chat);
						chatListEl.appendChild(item);
					});

					// 5. 【接下来处理未置顶的聊天】应用分组逻辑
					// 为每个分组找到其内部最新的消息时间戳 (只在未置顶聊天中查找)
					allGroups.forEach((group) => {
						const latestChatInGroup = unpinnedChats
							.filter((chat) => chat.groupId === group.id) // 找到属于这个组的聊天
							.sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0))[0]; // 排序后取第一个

						group.latestTimestamp = latestChatInGroup ? latestChatInGroup.history.slice(-1)[0]?.timestamp || 0 : 0;
					});

					// 根据分组的最新时间戳，对分组本身进行排序
					allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

					// 6. 遍历排序后的分组，渲染其中的【未置顶】好友
					allGroups.forEach((group) => {
						const groupChats = unpinnedChats.filter((chat) => !chat.isGroup && chat.groupId === group.id).sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));

						if (groupChats.length === 0) return; // 如果这个分组里没有未置顶的好友，就跳过

						const groupContainer = document.createElement("div");
						groupContainer.className = "chat-group-container";

						// 默认展开分组
						groupContainer.innerHTML = `
                            <div class="chat-group-header">
                                <span class="arrow">▼</span>
                                <span class="group-name">${group.name}</span>
                            </div>
                            <div class="chat-group-content"></div>
                        `;
						const contentEl = groupContainer.querySelector(".chat-group-content");

						groupChats.forEach((chat) => {
							const item = createChatListItem(chat);
							contentEl.appendChild(item);
						});
						chatListEl.appendChild(groupContainer);
					});

					// 7. 最后，渲染所有【未置顶】的群聊和【未分组的】好友
					const remainingChats = unpinnedChats.filter((chat) => chat.isGroup || (!chat.isGroup && !chat.groupId)).sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));

					remainingChats.forEach((chat) => {
						const item = createChatListItem(chat);
						chatListEl.appendChild(item);
					});

					// 为所有分组标题添加折叠事件
					document.querySelectorAll(".chat-group-header").forEach((header) => {
						header.addEventListener("click", () => {
							header.classList.toggle("collapsed");
							header.nextElementSibling.classList.toggle("collapsed");
						});
					});
				}

				/**
				 * 创建单个聊天列表项，包括头像、名称、最后消息等信息
				 * @param {Object} chat - 聊天对象
				 * @returns {HTMLElement} - 聊天列表项元素
				 */
				function createChatListItem(chat) {
					const lastMsgObj = chat.history.filter((msg) => !msg.isHidden).slice(-1)[0] || {};
					let lastMsgDisplay;

					if (!chat.isGroup && chat.relationship?.status === "pending_user_approval") {
						lastMsgDisplay = `<span style="color: #ff8c00;">[好友申请] ${chat.relationship.applicationReason || "请求添加你为好友"}</span>`;
					} else if (!chat.isGroup && chat.relationship?.status === "blocked_by_ai") {
						lastMsgDisplay = `<span style="color: #dc3545;">[你已被对方拉黑]</span>`;
					} else if (chat.isGroup) {
						if (lastMsgObj.type === "pat_message") {
							lastMsgDisplay = `[系统消息] ${lastMsgObj.content}`;
						} else if (lastMsgObj.type === "transfer") {
							lastMsgDisplay = "[转账]";
						} else if (lastMsgObj.type === "ai_image" || lastMsgObj.type === "user_photo") {
							lastMsgDisplay = "[照片]";
						} else if (lastMsgObj.type === "voice_message") {
							lastMsgDisplay = "[语音]";
						} else if (typeof lastMsgObj.content === "string" && STICKER_REGEX.test(lastMsgObj.content)) {
							lastMsgDisplay = lastMsgObj.meaning ? `[表情: ${lastMsgObj.meaning}]` : "[表情]";
						} else if (Array.isArray(lastMsgObj.content)) {
							lastMsgDisplay = `[图片]`;
						} else {
							lastMsgDisplay = String(lastMsgObj.content || "...").substring(0, 20);
						}
						if (lastMsgObj.senderName && lastMsgObj.type !== "pat_message") {
							const member = chat.members.find((m) => m.originalName === lastMsgObj.senderName);
							const displayName = member ? member.groupNickname : lastMsgObj.senderName;
							lastMsgDisplay = `${displayName}: ${lastMsgDisplay}`;
						}
					} else {
						const statusText = chat.status?.text || "在线";
						lastMsgDisplay = `[${statusText}]`;
					}

					const lastMsgTimestamp = lastMsgObj?.timestamp;
					const timeDisplay = formatChatListTimestamp(lastMsgTimestamp);

					const container = document.createElement("div");
					container.className = "chat-list-item-swipe-container";
					container.dataset.chatId = chat.id;

					const content = document.createElement("div");
					content.className = `chat-list-item-content ${chat.isPinned ? "pinned" : ""}`;

					const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;

					let streakHtml = "";
					let selectedBadgeHtml = "";

					// 渲染火花天数显示
					if (!chat.isGroup && chat.settings.streak && chat.settings.streak.enabled) {
						const streak = chat.settings.streak;
						let isExtinguished = false;
						if (streak.lastInteractionDate && streak.extinguishThreshold !== -1) {
							const lastDate = new Date(streak.lastInteractionDate);
							const todayDate = new Date();
							todayDate.setHours(0, 0, 0, 0);
							const daysDiff = (todayDate - lastDate) / (1000 * 3600 * 24);
							if (daysDiff >= streak.extinguishThreshold) {
								isExtinguished = true;
							}
						}
						const litIconUrl = streak.litIconUrl;
						const extinguishedIconUrl = streak.extinguishedIconUrl;
						const fontColor = streak.fontColor || "#ff6f00";
						let iconHtml = "";
						if (isExtinguished) {
							iconHtml = extinguishedIconUrl ? `<img src="${extinguishedIconUrl}" style="height: 1.2em; vertical-align: middle;">` : "🧊";
						} else if (streak.currentDays > 0 || streak.initialDays > 0) {
							iconHtml = litIconUrl ? `<img src="${litIconUrl}" style="height: 1.2em; vertical-align: middle;">` : "🔥";
						}
						if (iconHtml) {
							if (isExtinguished) {
								streakHtml = `<span class="streak-indicator" style="color: ${fontColor};">${iconHtml}</span>`;
							} else if (streak.currentDays === -1 || streak.initialDays === -1) {
								streakHtml = `<span class="streak-indicator" style="color: ${fontColor};">${iconHtml}∞</span>`;
							} else {
								streakHtml = `<span class="streak-indicator" style="color: ${fontColor};">${iconHtml}${streak.currentDays}</span>`;
							}
						}
					}

					// 显示佩戴的亲密关系徽章
					if (!chat.isGroup && chat.settings.selectedIntimacyBadge) {
						selectedBadgeHtml = `<span class="intimacy-badge-display"><img src="${chat.settings.selectedIntimacyBadge}" alt="badge"></span>`;
					}

					content.innerHTML = `
                        <div class="chat-list-item" data-chat-id="${chat.id}">
                            <img src="${avatar || defaultAvatar}" class="avatar">
                            <div class="info">
                                <div class="name-line">
                                    <span class="name">${chat.name}</span>
                                    ${chat.isGroup ? '<span class="group-tag">群聊</span>' : ""}
                                    ${streakHtml}
                                    ${selectedBadgeHtml} <!-- 把徽章放在火花后面 -->
                                </div>
                                <div class="last-msg" style="color: ${chat.isGroup ? "var(--text-secondary)" : "#b5b5b5"}; font-style: italic;">${lastMsgDisplay}</div>
                            </div>
                            <div class="chat-list-right-column">
                                <div class="chat-list-time">${timeDisplay}</div>
                                <div class="unread-count-wrapper">
                                    <span class="unread-count" style="display: none;">0</span>
                                </div>
                            </div>
                        </div>
                    `;

					// ... 后续的滑动删除、事件绑定等代码保持不变 ...
					const actions = document.createElement("div");
					actions.className = "swipe-actions";
					const pinButtonText = chat.isPinned ? "取消置顶" : "置顶";
					const pinButtonClass = chat.isPinned ? "unpin" : "pin";
					actions.innerHTML = `<button class="swipe-action-btn ${pinButtonClass}">${pinButtonText}</button><button class="swipe-action-btn delete">删除</button>`;

					container.appendChild(content);
					container.appendChild(actions);

					const unreadCount = chat.unreadCount || 0;
					const unreadEl = content.querySelector(".unread-count");
					if (unreadCount > 0) {
						unreadEl.textContent = unreadCount > 99 ? "99+" : unreadCount;
						unreadEl.style.display = "inline-flex";
					} else {
						unreadEl.style.display = "none";
					}

					const infoEl = content.querySelector(".info");
					if (infoEl) {
						infoEl.addEventListener("click", () => openChat(chat.id));
					}
					const avatarEl = content.querySelector(".avatar, .avatar-with-frame");
					if (avatarEl) {
						avatarEl.addEventListener("click", (e) => {
							e.stopPropagation();
							handleUserPat(chat.id, chat.name);
						});
					}

					return container;
				}

				/**
				 * 渲染聊天界面，包括聊天记录、状态栏、锁定界面等
				 * @param {string} chatId - 聊天ID
				 */
				function renderChatInterface(chatId) {
					cleanupWaimaiTimers();
					const chat = state.chats[chatId];
					if (!chat) return;

					// 群公告图标显示/隐藏逻辑
					const announcementBtn = document.getElementById("group-announcement-btn");
					if (chat.isGroup) {
						announcementBtn.style.display = "inline-flex"; // 在群聊中显示
					} else {
						announcementBtn.style.display = "none"; // 在单聊中隐藏
					}

					exitSelectionMode();

					const messagesContainer = document.getElementById("chat-messages");
					const chatInputArea = document.getElementById("chat-input-area");
					const lockOverlay = document.getElementById("chat-lock-overlay");
					const lockContent = document.getElementById("chat-lock-content");

					messagesContainer.dataset.theme = chat.settings.theme || "default";
					const fontSize = chat.settings.fontSize || 13;
					messagesContainer.style.setProperty("--chat-font-size", `${fontSize}px`);
					applyScopedCss(chat.settings.customCss || "", "#chat-messages", "custom-bubble-style");

					document.getElementById("chat-header-title").textContent = chat.name;
					const statusContainer = document.getElementById("chat-header-status");
					const statusTextEl = statusContainer.querySelector(".status-text");

					if (chat.isGroup) {
						statusContainer.style.display = "none";
						document.getElementById("chat-header-title-wrapper").style.justifyContent = "center";
					} else {
						statusContainer.style.display = "flex";
						document.getElementById("chat-header-title-wrapper").style.justifyContent = "flex-start";
						statusTextEl.textContent = chat.status?.text || "在线";
						statusContainer.classList.toggle("busy", chat.status?.isBusy || false);
					}

					lockOverlay.style.display = "none";
					chatInputArea.style.visibility = "visible";
					lockContent.innerHTML = "";

					// 处理非好友状态下的锁定界面
					if (!chat.isGroup && chat.relationship.status !== "friend") {
						lockOverlay.style.display = "flex";
						chatInputArea.style.visibility = "hidden";

						let lockHtml = "";
						switch (chat.relationship.status) {
							case "blocked_by_user":
								// 显示拉黑状态和诊断信息
								const isSimulationRunning = simulationIntervalId !== null;
								const blockedTimestamp = chat.relationship.blockedTimestamp;
								const cooldownHours = state.globalSettings.blockCooldownHours || 1;
								const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
								const timeSinceBlock = Date.now() - blockedTimestamp;
								const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
								const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));

								lockHtml = `
                                    <span class="lock-text">你已将"${chat.name}"拉黑。</span>
                                    <button id="unblock-btn" class="lock-action-btn">解除拉黑</button>
                                    <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                                        <strong style="color: #333;">【开发者诊断面板】</strong><br>
                                        - 后台活动总开关: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已开启</span>' : '<span style="color: red;">已关闭</span>'}<br>
                                        - 系统心跳计时器: ${isSimulationRunning ? '<span style="color: green;">运行中</span>' : '<span style="color: red;">未运行</span>'}<br>
                                        - 当前角色状态: <strong>${chat.relationship.status}</strong><br>
                                        - 需要冷静(小时): <strong>${cooldownHours}</strong><br>
                                        - 冷静期是否结束: ${isCooldownOver ? '<span style="color: green;">是</span>' : `<span style="color: orange;">否 (还剩约 ${timeRemainingMinutes} 分钟)</span>`}<br>
                                        - 触发条件: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已满足，等待下次系统心跳</span>' : '<span style="color: red;">未满足</span>'}
                                    </div>
                                    <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">强制触发一次好友申请检测</button>
                                `;
								break;
							case "blocked_by_ai":
								lockHtml = `
                                    <span class="lock-text">你被对方拉黑了。</span>
                                    <button id="apply-friend-btn" class="lock-action-btn">重新申请加为好友</button>
                                `;
								break;

							case "pending_user_approval":
								lockHtml = `
                                    <span class="lock-text">"${chat.name}"请求添加你为好友：<br><i>"${chat.relationship.applicationReason}"</i></span>
                                    <button id="accept-friend-btn" class="lock-action-btn">接受</button>
                                    <button id="reject-friend-btn" class="lock-action-btn secondary">拒绝</button>
                                `;
								break;

							// 处理已发送好友申请的状态
							case "pending_ai_approval":
								lockHtml = `<span class="lock-text">好友申请已发送，等待对方通过...</span>`;
								break;
						}
						lockContent.innerHTML = lockHtml;
					}
					messagesContainer.innerHTML = "";

					// 设置聊天背景（单人背景优先于全局背景）
					const chatScreen = document.getElementById("chat-interface-screen");
					const backgroundToApply = chat.settings.background || state.globalSettings.globalChatBackground;

					if (backgroundToApply) {
						chatScreen.style.backgroundImage = `url(${backgroundToApply})`;
					} else {
						chatScreen.style.backgroundImage = "none";
					}

					const isDarkMode = document.getElementById("phone-screen").classList.contains("dark-mode");
					chatScreen.style.backgroundColor = chat.settings.background ? "transparent" : isDarkMode ? "#000000" : "#f0f2f5";
					const history = chat.history;
					const totalMessages = history.length;
					currentRenderedCount = 0;
					const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);
					let lastMessageTimestamp = null;

					initialMessages.forEach((msg) => {
						if (msg.isHidden) return; // 跳过隐藏消息

						if (isNewDay(msg.timestamp, lastMessageTimestamp)) {
							// 为跨天消息添加日期戳
							const dateStampEl = createDateStampElement(msg.timestamp);
							messagesContainer.insertBefore(dateStampEl, document.getElementById("typing-indicator"));
						}

						appendMessage(msg, chat, true);

						lastMessageTimestamp = msg.timestamp;
					});
					currentRenderedCount = initialMessages.length;
					if (totalMessages > currentRenderedCount) {
						prependLoadMoreButton(messagesContainer);
					}
					const typingIndicator = document.createElement("div");
					typingIndicator.id = "typing-indicator";
					typingIndicator.style.display = "none";
					typingIndicator.textContent = "对方正在输入...";
					messagesContainer.appendChild(typingIndicator);
					setTimeout(() => (messagesContainer.scrollTop = messagesContainer.scrollHeight), 0);
					renderChatPet();
				}

				/**
				 * 在聊天记录顶部添加"加载更多"按钮
				 * @param {HTMLElement} container - 消息容器元素
				 */
				function prependLoadMoreButton(container) {
					const button = document.createElement("button");
					button.id = "load-more-btn";
					button.textContent = "加载更早的记录";
					button.addEventListener("click", loadMoreMessages);
					container.prepend(button);
				}

				/**
				 * 加载更多聊天记录
				 */
				function loadMoreMessages() {
					const messagesContainer = document.getElementById("chat-messages");
					const chat = state.chats[state.activeChatId];
					if (!chat) return;
					const loadMoreBtn = document.getElementById("load-more-btn");
					if (loadMoreBtn) loadMoreBtn.remove();
					const totalMessages = chat.history.length;
					const nextSliceStart = totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW;
					const nextSliceEnd = totalMessages - currentRenderedCount;
					const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd);
					const oldScrollHeight = messagesContainer.scrollHeight;

					// 找到屏幕上已有的、最老的那条【真实消息】的时间戳
					const firstVisibleMessage = messagesContainer.querySelector(".message-wrapper:not(.date-stamp-wrapper)");
					let subsequentMessageTimestamp = firstVisibleMessage ? parseInt(firstVisibleMessage.dataset.timestamp) : null;

					// 从后往前（从新到旧）遍历我们要新加载的消息
					messagesToPrepend.reverse().forEach((currentMsg) => {
						// 检查这条新消息和它后面那条（可能是屏幕上已有的，也可能是刚加载的）消息是否跨天
						if (subsequentMessageTimestamp && isNewDay(subsequentMessageTimestamp, currentMsg.timestamp)) {
							// 如果跨天，就为后面那条"较新"的消息创建一个日期戳
							const dateStampEl = createDateStampElement(subsequentMessageTimestamp);
							messagesContainer.prepend(dateStampEl);
						}

						// 正常地把当前这条新消息放到最前面
						prependMessage(currentMsg, chat);

						// 更新追踪器，为下一次比较做准备
						subsequentMessageTimestamp = currentMsg.timestamp;
					});

					// 处理所有新加载消息的最前面（也就是整个聊天记录的最老）的那条消息
					// 它也需要一个日期戳
					if (subsequentMessageTimestamp) {
						const dateStampEl = createDateStampElement(subsequentMessageTimestamp);
						messagesContainer.prepend(dateStampEl);
					}

					currentRenderedCount += messagesToPrepend.length;
					const newScrollHeight = messagesContainer.scrollHeight;
					messagesContainer.scrollTop += newScrollHeight - oldScrollHeight;
					if (totalMessages > currentRenderedCount) {
						prependLoadMoreButton(messagesContainer);
					}
				}

				/**
				 * 渲染壁纸设置界面，包括预览各类背景和设置选项
				 */
				async function renderWallpaperScreen() {
					// 锁屏开关
					const lockScreenEnabled = localStorage.getItem("lockScreenEnabled") !== "false";
					const toggle = document.getElementById("enable-lock-screen-toggle");
					if (toggle) {
						toggle.checked = lockScreenEnabled;
					}

					// 主屏幕字体颜色和阴影
					document.getElementById("home-icon-widget-text-color-picker").value = state.globalSettings.homeIconWidgetTextColor || "#FFFFFF";
					document.getElementById("remove-home-font-shadow-toggle").checked = !!state.globalSettings.removeHomeFontShadow;

					// 主屏幕壁纸预览
					const preview = document.getElementById("wallpaper-preview");
					const bg = newWallpaperBase64 || state.globalSettings.wallpaper;
					if (bg && bg.startsWith("data:image")) {
						preview.style.backgroundImage = `url(${bg})`;
						preview.textContent = "";
					} else if (bg) {
						preview.style.backgroundImage = bg;
						preview.textContent = "当前为渐变色";
					}

					// 锁屏壁纸预览
					const lockscreenPreview = document.getElementById("lockscreen-wallpaper-preview");
					const lockBg = newLockscreenWallpaperBase64 || state.globalSettings.lockscreenWallpaper;
					if (lockBg && lockBg.startsWith("data:image")) {
						lockscreenPreview.style.backgroundImage = `url(${lockBg})`;
						lockscreenPreview.textContent = "";
					} else if (lockBg) {
						lockscreenPreview.style.backgroundImage = lockBg;
						lockscreenPreview.textContent = "当前为渐变色";
					}

					// 密码输入框
					document.getElementById("password-set-input").value = state.globalSettings.password || "";

					// 全局聊天背景预览
					const globalBgPreview = document.getElementById("global-bg-preview");
					const globalBg = newGlobalBgBase64 || state.globalSettings.globalChatBackground;
					if (globalBg && globalBg.startsWith("data:image")) {
						globalBgPreview.style.backgroundImage = `url(${globalBg})`;
						globalBgPreview.textContent = "";
					} else if (globalBg) {
						globalBgPreview.style.background = globalBg;
						globalBgPreview.textContent = "当前为渐变色";
					} else {
						globalBgPreview.style.backgroundImage = "none";
						globalBgPreview.textContent = "点击下方上传";
					}

					// 铃声和提示音
					document.getElementById("ringtone-url-input").value = state.globalSettings.ringtoneUrl || "";
					document.getElementById("notification-sound-url-input").value = state.globalSettings.notificationSoundUrl || "";

					// 加载CSS代码到编辑器
					await loadThemesToDropdown(); // 确保主题列表已加载
					const editor = document.getElementById("theme-css-editor");
					const selector = document.getElementById("theme-selector");

					// 优先加载 activeCustomCss
					if (state.globalSettings.activeCustomCss) {
						editor.value = state.globalSettings.activeCustomCss;
						// 如果自定义CSS存在，则将下拉框重置为"未选择"状态
						selector.value = "";
					}
					// 如果没有自定义CSS，但有选中的主题ID
					else if (state.globalSettings.activeThemeId) {
						const theme = await db.themes.get(state.globalSettings.activeThemeId);
						if (theme) {
							editor.value = theme.css;
							selector.value = theme.id; // 自动选中该主题
						} else {
							editor.value = THEME_CSS_TEMPLATE; // 如果ID无效，则显示模板
						}
					}
					// 如果什么都没保存，显示模板
					else {
						editor.value = THEME_CSS_TEMPLATE;
					}

					// 渲染App图标和名称设置
					renderIconSettings();
					renderAppNameSettings();

					// 加载预设下拉框
					loadHomeScreenPresetsToDropdown();
				}

				window.renderWallpaperScreenProxy = renderWallpaperScreen;

				/**
				 * 应用全局壁纸到主屏幕
				 */
				function applyGlobalWallpaper() {
					const homeScreen = document.getElementById("home-screen");
					const wallpaper = state.globalSettings.wallpaper;
					if (wallpaper && wallpaper.startsWith("data:image")) homeScreen.style.backgroundImage = `url(${wallpaper})`;
					else if (wallpaper) homeScreen.style.backgroundImage = wallpaper;
				}

				/**
				 * 渲染世界书界面，显示所有世界书并按分类组织
				 */
				async function renderWorldBookScreen() {
					const listEl = document.getElementById("world-book-list");
					listEl.innerHTML = "";

					// 同时获取所有书籍和所有分类
					const [books, categories] = await Promise.all([db.worldBooks.toArray(), db.worldBookCategories.orderBy("name").toArray()]);

					state.worldBooks = books; // 确保内存中的数据是同步的

					if (books.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 创建你的第一本世界书</p>';
						return;
					}

					// 将书籍按 categoryId 分组
					const groupedBooks = books.reduce((acc, book) => {
						const key = book.categoryId || "uncategorized";
						if (!acc[key]) {
							acc[key] = [];
						}
						acc[key].push(book);
						return acc;
					}, {});

					// 优先渲染已分类的书籍
					categories.forEach((category) => {
						const booksInCategory = groupedBooks[category.id];
						if (booksInCategory && booksInCategory.length > 0) {
							const groupContainer = createWorldBookGroup(category.name, booksInCategory);
							listEl.appendChild(groupContainer);
						}
					});

					// 最后渲染未分类的书籍
					const uncategorizedBooks = groupedBooks["uncategorized"];
					if (uncategorizedBooks && uncategorizedBooks.length > 0) {
						const groupContainer = createWorldBookGroup("未分类", uncategorizedBooks);
						listEl.appendChild(groupContainer);
					}

					// 为所有分组标题添加折叠事件
					document.querySelectorAll(".world-book-group-header").forEach((header) => {
						header.addEventListener("click", () => {
							header.classList.toggle("collapsed");
							header.nextElementSibling.classList.toggle("collapsed");
						});
					});
				}

				/**
				 * 创建一个分类的分组DOM
				 * @param {string} groupName - 分类名称
				 * @param {Array} books - 该分类下的书籍数组
				 * @returns {HTMLElement} - 创建好的分组容器
				 */
				function createWorldBookGroup(groupName, books) {
					const groupContainer = document.createElement("div");
					groupContainer.className = "world-book-group-container";

					groupContainer.innerHTML = `
                        <div class="world-book-group-header">
                            <span class="arrow">▼</span>
                            <span class="group-name">${groupName}</span>
                        </div>
                        <div class="world-book-group-content"></div>
                    `;

					const headerEl = groupContainer.querySelector(".world-book-group-header");
					const contentEl = groupContainer.querySelector(".world-book-group-content");

					// 默认给头部和内容区都加上 collapsed 类
					headerEl.classList.add("collapsed");
					contentEl.classList.add("collapsed");

					books.sort((a, b) => a.name.localeCompare(b.name, "zh-CN"));
					books.forEach((book) => {
						const item = document.createElement("div");
						item.className = "list-item";
						item.dataset.bookId = book.id;
						item.innerHTML = `<div class="item-title">${book.name}</div><div class="item-content">${(book.content || "暂无内容...").substring(0, 50)}</div>`;
						item.addEventListener("click", () => openWorldBookEditor(book.id));
						addLongPressListener(item, async () => {
							const confirmed = await showCustomConfirm("删除世界书", `确定要删除《${book.name}》吗？此操作不可撤销。`, { confirmButtonClass: "btn-danger" });
							if (confirmed) {
								await db.worldBooks.delete(book.id);
								state.worldBooks = state.worldBooks.filter((wb) => wb.id !== book.id);
								renderWorldBookScreen();
							}
						});
						contentEl.appendChild(item);
					});

					return groupContainer;
				}
				window.renderWorldBookScreenProxy = renderWorldBookScreen;

				/**
				 * 打开世界书编辑器
				 * @param {string} bookId - 世界书ID
				 */
				async function openWorldBookEditor(bookId) {
					editingWorldBookId = bookId;
					const [book, categories] = await Promise.all([db.worldBooks.get(bookId), db.worldBookCategories.toArray()]);
					if (!book) return;

					document.getElementById("world-book-editor-title").textContent = book.name;
					document.getElementById("world-book-name-input").value = book.name;
					document.getElementById("world-book-content-input").value = book.content;

					// 填充分类下拉菜单
					const selectEl = document.getElementById("world-book-category-select");
					selectEl.innerHTML = '<option value="">-- 未分类 --</option>'; // 默认选项
					categories.forEach((cat) => {
						const option = document.createElement("option");
						option.value = cat.id;
						option.textContent = cat.name;
						if (book.categoryId === cat.id) {
							option.selected = true; // 选中当前分类
						}
						selectEl.appendChild(option);
					});

					showScreen("world-book-editor-screen");
				}

				/**
				 * 渲染表情包面板，显示当前分类下的所有表情
				 */
				function renderStickerPanel() {
					const grid = document.getElementById("sticker-grid");
					grid.innerHTML = "";

					let stickersToRender;

					// 根据当前选中的分类筛选要显示的表情
					if (activeStickerCategoryId === "uncategorized") {
						// 如果是"未分类"，就筛选出 categoryId 不存在或为空的表情
						stickersToRender = state.userStickers.filter((sticker) => !sticker.categoryId);
					} else {
						// 否则，按具体的分类ID筛选
						stickersToRender = state.userStickers.filter((sticker) => sticker.categoryId === activeStickerCategoryId);
					}

					if (stickersToRender.length === 0) {
						// 根据当前选中的分类，显示不同的提示语
						let message;
						if (activeStickerCategoryId === "uncategorized") {
							// 如果所有表情都有分类了，这里也会是空的
							message = "没有未分类的表情哦~";
						} else {
							// 如果是在某个具体分类下，但是里面没表情
							message = "这个分类下还没有表情哦~";
						}
						// 如果整个表情库都是空的，给一个初始引导
						if (state.userStickers.length === 0) {
							message = "大人请点击右上角'添加'或'上传'来添加你的第一个表情吧！";
						}

						grid.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">${message}</p>`;
					} else {
						stickersToRender.forEach((sticker) => {
							// 创建表情项容器
							const itemContainer = document.createElement("div");
							itemContainer.className = "sticker-item";

							const imageEl = document.createElement("div");
							imageEl.className = "sticker-image";
							imageEl.style.backgroundImage = `url(${sticker.url})`;

							const nameEl = document.createElement("span");
							nameEl.className = "sticker-name";
							nameEl.textContent = sticker.name;
							nameEl.title = sticker.name;

							if (isUserStickerSelectionMode) {
								imageEl.classList.add("in-selection-mode");
								if (selectedUserStickers.has(sticker.id)) {
									imageEl.classList.add("selected");
								}
								itemContainer.addEventListener("click", () => {
									imageEl.classList.toggle("selected");
									if (selectedUserStickers.has(sticker.id)) {
										selectedUserStickers.delete(sticker.id);
									} else {
										selectedUserStickers.add(sticker.id);
									}
									const deleteBtn = document.getElementById("delete-selected-user-stickers-btn");
									deleteBtn.textContent = `删除已选 (${selectedUserStickers.size})`;
									deleteBtn.disabled = selectedUserStickers.size === 0;

									const moveBtn = document.getElementById("move-selected-stickers-btn");
									moveBtn.disabled = selectedUserStickers.size === 0;
								});
							} else {
								itemContainer.addEventListener("click", () => sendSticker(sticker));
								addLongPressListener(imageEl, () => {
									const existingDeleteBtn = imageEl.querySelector(".delete-btn");
									if (existingDeleteBtn) return;

									const deleteBtn = document.createElement("div");
									deleteBtn.className = "delete-btn";
									deleteBtn.innerHTML = "&times;";
									deleteBtn.style.display = "block";
									deleteBtn.onclick = async (e) => {
										e.stopPropagation();
										const confirmed = await showCustomConfirm("删除表情", `确定要删除表情 "${sticker.name}" 吗？`, { confirmButtonClass: "btn-danger" });
										if (confirmed) {
											await db.userStickers.delete(sticker.id);
											state.userStickers = state.userStickers.filter((s) => s.id !== sticker.id);
											renderStickerPanel();
										}
									};
									imageEl.appendChild(deleteBtn);
									const removeDeleteBtn = () => {
										if (deleteBtn) deleteBtn.remove();
										imageEl.removeEventListener("mouseleave", removeDeleteBtn);
									};
									imageEl.addEventListener("mouseleave", removeDeleteBtn);
								});
							}

							itemContainer.appendChild(imageEl);
							itemContainer.appendChild(nameEl);
							grid.appendChild(itemContainer);
						});
					}

					// 每次渲染表情列表后，都更新一次分类页签栏
					renderStickerCategories();
				}

				/**
				 * 处理删除表情分类的逻辑，提供两种删除方式
				 * @param {number} categoryId - 要删除的分类ID
				 * @param {string} categoryName - 要删除的分类名称
				 */
				async function handleDeleteStickerCategory(categoryId, categoryName) {
					if (isNaN(categoryId) || !categoryName) {
						alert("执行删除失败：传入的分类ID或名称无效！");
						return;
					}

					// 弹窗让用户选择如何处理分类下的表情
					const choice = await showChoiceModal(`删除分类 "${categoryName}"`, [
						{ text: "仅删除分类 (表情移至'未分类')", value: "delete_category_only" },
						{ text: "删除分类及所有表情 (不可恢复)", value: "delete_all" },
					]);

					if (!choice) return; // 如果用户点击了取消，则不执行任何操作

					try {
						if (choice === "delete_category_only") {
							// 找到该分类下的所有表情
							const stickersToUpdate = state.userStickers.filter((s) => s.categoryId === categoryId);

							if (stickersToUpdate.length > 0) {
								// 将它们的分类ID设为 null 或 undefined，表示未分类
								stickersToUpdate.forEach((sticker) => {
									sticker.categoryId = null;
								});
								await db.userStickers.bulkPut(stickersToUpdate);
							}
							// 从数据库删除分类本身
							await db.userStickerCategories.delete(categoryId);
						} else if (choice === "delete_all") {
							// 找到该分类下的所有表情ID
							const stickerIdsToDelete = state.userStickers.filter((s) => s.categoryId === categoryId).map((s) => s.id);

							if (stickerIdsToDelete.length > 0) {
								// 从数据库批量删除这些表情
								await db.userStickers.bulkDelete(stickerIdsToDelete);
							}
							// 从数据库删除分类本身
							await db.userStickerCategories.delete(categoryId);
						}

						// 不论哪种方式，都需要从前端的 state 缓存中移除或更新数据
						state.userStickers = await db.userStickers.toArray();

						// 如果删除的是当前正在查看的分类，就切换回"未分类"
						if (activeStickerCategoryId === categoryId) {
							activeStickerCategoryId = "uncategorized";
						}

						// 重新渲染整个表情面板（这会自动刷新分类和表情列表）
						renderStickerPanel();

						await showCustomAlert("操作成功", `分类 "${categoryName}" 已成功删除。`);
					} catch (error) {
						console.error("删除分类时出错:", error);
						alert(`操作失败，发生数据库错误: ${error.message}`);
					}
				}

				/**
				 * 处理批量删除选中的用户表情
				 */
				async function handleBulkDeleteUserStickers() {
					if (selectedUserStickers.size === 0) return;

					const confirmed = await showCustomConfirm("确认删除", `确定要删除选中的 ${selectedUserStickers.size} 个表情吗？`, { confirmButtonClass: "btn-danger" });

					if (confirmed) {
						const idsToDelete = Array.from(selectedUserStickers);
						await db.userStickers.bulkDelete(idsToDelete);

						state.userStickers = state.userStickers.filter((s) => !idsToDelete.includes(s.id));

						// 退出编辑模式
						toggleUserStickerSelectionMode();

						alert("选中的表情已删除。");
					}
				}

				/**
				 * 从卡片点击后，打开情侣空间并跳转到指定页签
				 * @param {string} charId - 角色ID
				 * @param {string} viewId - 要跳转到的视图ID (例如 'ls-diary-view')
				 */
				function openLoversSpaceFromCard(charId, viewId) {
					// 1. 打开指定角色的情侣空间主界面
					openLoversSpace(charId);

					// 2. 等待一小会儿，确保界面已渲染
					setTimeout(() => {
						// 3. 找到对应的页签按钮并模拟点击它
						const targetTab = document.querySelector(`.ls-tab-item[data-view='${viewId}']`);
						if (targetTab) {
							targetTab.click();
						}
					}, 100); // 100毫秒的延迟通常足够了
				}

				/**
				 * 创建消息元素，根据消息类型渲染不同的内容
				 * @param {Object} msg - 消息对象
				 * @param {Object} chat - 聊天对象
				 * @returns {HTMLElement} - 消息元素
				 */
				function createMessageElement(msg, chat) {
					// 处理已撤回消息的特殊显示
					if (msg.type === "recalled_message") {
						const wrapper = document.createElement("div");
						// 给 wrapper 也加上 timestamp，方便事件委托时查找
						wrapper.className = "message-wrapper system-pat";
						wrapper.dataset.timestamp = msg.timestamp;

						const bubble = document.createElement("div");
						// 让这个元素同时拥有 .message-bubble 和 .recalled-message-placeholder 两个class
						// 这样它既能被选择系统识别，又能保持原有的居中灰色样式
						bubble.className = "message-bubble recalled-message-placeholder";
						// 把 timestamp 放在 bubble 上，这是多选逻辑的关键
						bubble.dataset.timestamp = msg.timestamp;
						bubble.textContent = msg.content;

						wrapper.appendChild(bubble);

						// 为它补上和其他消息一样的标准事件监听器
						addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
						wrapper.addEventListener("click", () => {
							if (isSelectionMode) {
								toggleMessageSelection(msg.timestamp);
							}
						});

						return wrapper;
					}

					if (msg.isHidden) {
						return null;
					}

					// 处理拍了拍消息
					if (msg.type === "pat_message") {
						const wrapper = document.createElement("div");
						wrapper.className = "message-wrapper system-pat";
						const bubble = document.createElement("div");
						bubble.className = "message-bubble system-bubble";
						bubble.dataset.timestamp = msg.timestamp;
						bubble.textContent = msg.content;
						wrapper.appendChild(bubble);
						addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
						wrapper.addEventListener("click", () => {
							if (isSelectionMode) toggleMessageSelection(msg.timestamp);
						});
						return wrapper;
					}

					const isUser = msg.role === "user";
					const wrapper = document.createElement("div");
					wrapper.className = `message-wrapper ${isUser ? "user" : "ai"}`;

					// 处理群聊中的发送者信息显示
					if (chat.isGroup) {
						const senderLine = document.createElement("div");
						senderLine.className = "group-sender-line";

						const tagsContainer = document.createElement("div");
						tagsContainer.className = "group-sender-tags";

						let senderDisplayName;

						// 处理用户自己发送的消息
						if (isUser) {
							// 如果是用户自己
							senderDisplayName = chat.settings.myNickname || "我";

							// 检查用户是否是群主
							if (chat.ownerId === "user") {
								const roleTag = document.createElement("span");
								roleTag.className = "group-role-tag owner";
								roleTag.textContent = "群主";
								tagsContainer.appendChild(roleTag);
							}
							// 检查用户是否被设为管理员
							else if (chat.settings.isUserAdmin) {
								const roleTag = document.createElement("span");
								roleTag.className = "group-role-tag admin";
								roleTag.textContent = "管理员";
								tagsContainer.appendChild(roleTag);
							}

							// 检查用户是否有头衔
							if (chat.settings.myGroupTitle) {
								const titleTag = document.createElement("span");
								titleTag.className = "group-title-tag";
								titleTag.textContent = chat.settings.myGroupTitle;
								tagsContainer.appendChild(titleTag);
							}
						} else {
							// 如果是其他成员 (AI/NPC)
							const member = chat.members.find((m) => m.originalName === msg.senderName);
							senderDisplayName = member ? member.groupNickname : msg.senderName || "未知成员";

							// 如果该成员被禁言了，就添加一个禁言标签
							if (member && member.isMuted) {
								const muteTag = document.createElement("span");
								muteTag.className = "group-title-tag"; // 复用头衔标签的样式
								muteTag.style.color = "#ff3b30"; // 让它变成红色
								muteTag.style.backgroundColor = "#ffe5e5"; // 淡红色背景
								muteTag.textContent = "🚫已禁言";
								tagsContainer.appendChild(muteTag);
							}

							if (member && chat.ownerId === member.id) {
								const roleTag = document.createElement("span");
								roleTag.className = "group-role-tag owner";
								roleTag.textContent = "群主";
								tagsContainer.appendChild(roleTag);
							} else if (member && member.isAdmin) {
								const roleTag = document.createElement("span");
								roleTag.className = "group-role-tag admin";
								roleTag.textContent = "管理员";
								tagsContainer.appendChild(roleTag);
							}

							if (member && member.groupTitle) {
								const titleTag = document.createElement("span");
								titleTag.className = "group-title-tag";
								titleTag.textContent = member.groupTitle;
								tagsContainer.appendChild(titleTag);
							}
						}

						const senderNameSpan = document.createElement("span");
						senderNameSpan.className = "sender-name";
						senderNameSpan.textContent = senderDisplayName;

						// 修复用户标签显示在右边的问题
						if (isUser) {
							senderLine.appendChild(tagsContainer); // 标签在左
							senderLine.appendChild(senderNameSpan); // 昵称在右
						} else {
							senderLine.appendChild(senderNameSpan); // 昵称在左
							senderLine.appendChild(tagsContainer); // 标签在右
						}

						wrapper.appendChild(senderLine);
					}

					const bubble = document.createElement("div");
					bubble.className = `message-bubble ${isUser ? "user" : "ai"}`;
					bubble.dataset.timestamp = msg.timestamp;

					const timestampEl = document.createElement("span");
					timestampEl.className = "timestamp";
					timestampEl.textContent = formatTimestamp(msg.timestamp);

					// 获取头像和头像框
					let avatarSrc,
						avatarFrameSrc = ""; // 声明两个变量
					if (chat.isGroup) {
						if (isUser) {
							avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
							avatarFrameSrc = chat.settings.myAvatarFrame || ""; // 获取"我"的头像框
						} else {
							const member = chat.members.find((m) => m.originalName === msg.senderName);
							avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
							avatarFrameSrc = member ? member.avatarFrame || "" : ""; // 获取成员的头像框
						}
					} else {
						if (isUser) {
							avatarSrc = chat.settings.myAvatar || defaultAvatar;
							avatarFrameSrc = chat.settings.myAvatarFrame || ""; // 获取"我"的头像框
						} else {
							avatarSrc = chat.settings.aiAvatar || defaultAvatar;
							avatarFrameSrc = chat.settings.aiAvatarFrame || ""; // 获取AI的头像框
						}
					}

					// 条件渲染头像（带或不带头像框）
					let avatarHtml;
					// 如果存在头像框URL
					if (avatarFrameSrc) {
						avatarHtml = `
                            <div class="avatar-with-frame">
                                <img src="${avatarSrc}" class="avatar-img">
                                <img src="${avatarFrameSrc}" class="avatar-frame">
                            </div>
                        `;
					} else {
						// 如果没有，就使用最简单的头像结构
						avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
					}

					let contentHtml;

					// 处理链接分享消息
					if (msg.type === "share_link") {
						bubble.classList.add("is-link-share");

						contentHtml = `
                            <div class="link-share-card" data-timestamp="${msg.timestamp}">
                                <div class="title">${msg.title || "无标题"}</div>
                                <div class="description">${msg.description || "点击查看详情..."}</div>
                                <div class="footer">
                                    <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                                    <span>${msg.source_name || "链接分享"}</span>
                                </div>
                            </div>
                        `;
					}
					// 处理约会总结卡片
					else if (msg.type === "dating_summary_card") {
						bubble.classList.add("is-dating-summary");
						const payload = msg.payload;
						let cardClass = "";

						if (payload.ratingType === "romantic") {
							cardClass = "romantic";
						} else if (payload.ratingType === "passionate") {
							cardClass = "passionate";
						} else if (payload.ratingType === "perfect") {
							cardClass = "perfect";
						}

						contentHtml = `
                        <div class="dating-summary-chat-card ${cardClass}" data-timestamp="${msg.timestamp}">
                            <div class="rating">${payload.rating}</div>
                            <div class="tip">点击查看详情</div>
                        </div>
                    `;
					}
					// 处理聊天记录分享卡片
					else if (msg.type === "share_card") {
						bubble.classList.add("is-link-share"); // 复用链接分享的卡片样式
						// 把时间戳加到卡片上，方便后面点击时识别
						contentHtml = `
                        <div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}">
                            <div class="title">${msg.payload.title}</div>
                            <div class="description">共 ${msg.payload.sharedHistory.length} 条消息</div>
                            <div class="footer">
                                <svg class="footer-icon" ...>...</svg> <!-- 复用链接分享的图标 -->
                                <span>聊天记录</span>
                            </div>
                        </div>
                    `;
					}
					// 处理外卖订单通知
					else if (msg.type === "eleme_order_notification") {
						bubble.classList.add("is-gift-notification");
						const payload = msg.payload;

						let remarkHtml = "";
						if (payload.remark && payload.remark.trim()) {
							remarkHtml = `
                            <div class="waimai-remark">
                                <span class="remark-label">备注:</span>
                                <span class="remark-text">${payload.remark}</span>
                            </div>
                        `;
						}

						contentHtml = `
                        <div class="waimai-meituan-card">
                            <div class="gift-card-header">
                                <div class="icon">🛵</div>
                                <div class="title">一份来自 ${payload.senderName} 的外卖</div>
                            </div>
                            <div class="gift-card-body">
                                <img src="${payload.foodImageUrl}" style="width: 100%; max-height: 120px; object-fit: cover; border-radius: 8px; margin-bottom: 10px;">
                                <p class="greeting" style="font-weight: bold; font-size: 16px;">${payload.foodName}</p>
                                <p style="font-size: 13px; color: #888;">你的专属外卖已送达</p>
                                ${remarkHtml}
                            </div>
                        </div>
                    `;
					}
					// 处理借款请求
					else if (msg.type === "borrow_money_request") {
						bubble.classList.add("is-borrow-request"); // 应用透明气泡样式
						const payload = msg.payload;
						// 直接将卡片的HTML赋给contentHtml，不再拼接任何文本
						contentHtml = `
                        <div class="borrow-card">
                            <div class="borrow-header">
                                向 <span>${payload.lenderName}</span> 借钱
                            </div>
                            <div class="borrow-body">
                                <p class="label">借款金额</p>
                                <p class="amount">¥${payload.amount.toFixed(2)}</p>
                                <p class="reason">
                                    <strong>借款用途:</strong><br>
                                    ${payload.reason}
                                </p>
                            </div>
                        </div>
                    `;
					}
					// 处理论坛帖子转发
					else if (msg.type === "repost_forum_post") {
						bubble.classList.add("is-link-share"); // 复用链接分享的样式，省事！
						const postPayload = msg.payload;
						// 把帖子的ID存到卡片的 data-post-id 属性里，方便以后点击跳转
						contentHtml = `
                        <div class="link-share-card" style="cursor: pointer;" data-post-id="${postPayload.postId}">
                            <div class="title">【小组帖子】${postPayload.title}</div>
                            <div class="description">${postPayload.content}</div>
                            <div class="footer">
                                <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.5 12c0-5.25-4.25-9.5-9.5-9.5S2.5 6.75 2.5 12s4.25 9.5 9.5 9.5c.35 0 .69-.02 1.03-.06"></path><path d="M18.5 12.5c0-1.66-1.34-3-3-3s-3 1.34-3 3 1.34 3 3 3c.83 0 1.58-.34 2.12-.88"></path></svg>
                                <span>来自小组的分享</span>
                            </div>
                        </div>
                    `;
					}
					// 处理购物车分享请求
					else if (msg.type === "cart_share_request") {
						bubble.classList.add("is-cart-share-request");
						const payload = msg.payload; // 现在直接从 payload 取数据
						let statusText = "等待对方处理...";
						let cardClass = "";

						if (payload.status === "paid") {
							statusText = "对方已为你买单";
							cardClass = "paid";
						} else if (payload.status === "rejected") {
							statusText = "对方拒绝了你的请求";
							cardClass = "rejected";
						}

						contentHtml = `
                        <div class="cart-share-card ${cardClass}">
                            <div class="cart-share-header">
                                <div class="icon">🛒</div>
                                <div class="title">购物车代付请求</div>
                            </div>
                            <div class="cart-share-body">
                                <div class="label">共 ${payload.itemCount} 件商品，合计</div>
                                <div class="amount">¥${payload.totalPrice.toFixed(2)}</div>
                                <div class="status-text">${statusText}</div>
                            </div>
                        </div>
                    `;
					}
					// 处理角色发送的外卖
					else if (msg.type === "waimai_gift_from_char") {
						bubble.classList.add("is-gift-notification");
						const payload = msg.payload;

						contentHtml = `
                        <div class="waimai-meituan-card">
                            <div class="gift-card-header">
                                <div class="icon">🛵</div>
                                <div class="title">你的专属外卖已送达</div>
                            </div>
                            <div class="gift-card-body">
                                <img src="${payload.foodImageUrl}" style="width: 100%; height: 120px; object-fit: cover; border-radius: 8px; margin-bottom: 10px;">
                                <p class="greeting" style="font-weight: bold; font-size: 16px;">${payload.foodName}</p>
                                <p style="font-size: 13px; color: #888;">来自: ${payload.restaurant}</p>
                            </div>
                            <div class="waimai-remark">
                                ${payload.greeting}
                            </div>
                        </div>
                    `;
					}
					// 处理礼物通知
					else if (msg.type === "gift_notification") {
						bubble.classList.add("is-gift-notification"); // 应用透明气泡样式
						const payload = msg.payload;

						// 构建卡片的完整HTML内容
						contentHtml = `
                        <div class="gift-card">
                            <div class="gift-card-header">
                                <div class="icon">🎁</div>
                                <!-- 1. 清晰指明是谁送的礼物 -->
                                <div class="title">一份来自 ${payload.senderName} 的礼物</div>
                            </div>
                            <div class="gift-card-body">
                                <p class="greeting">这是我为你挑选的礼物，希望你喜欢！</p>
                                <!-- 2. 清晰列出有什么商品 -->
                                <div class="gift-card-items">
                                    <strong>商品列表:</strong><br>
                                    ${payload.itemSummary.replace(/、/g, "<br>")} <!-- 将顿号替换为换行，让列表更清晰 -->
                                </div>
                                <!-- 3. 清晰标明总金额 -->
                                <div class="gift-card-footer">
                                    共 ${payload.itemCount} 件，合计: <span class="total-price">¥${payload.totalPrice.toFixed(2)}</span>
                                </div>
                            </div>
                        </div>
                    `;
					}
					// 处理位置消息
					else if (msg.type === "location") {
						bubble.classList.add("is-location");

						const currentChat = state.chats[state.activeChatId] || Object.values(state.chats).find((c) => c.history.some((h) => h.timestamp === msg.timestamp));
						const myNickname = currentChat.settings.myNickname || "我";
						const aiNickname = currentChat.name;

						// SVG 动态生成
						const trajectoryPoints = msg.trajectoryPoints || [];
						const hasTrajectory = trajectoryPoints.length > 0;

						// 定义SVG路径和坐标
						const pathData = "M 20 45 Q 115 10 210 45"; // 一条预设的优美曲线
						const startPoint = { x: 20, y: 45 };
						const endPoint = { x: 210, y: 45 };

						// 生成起点和终点的SVG元素
						let pinsSvg = "";
						if (msg.userLocation) {
							pinsSvg += `<circle class="svg-pin user-pin" cx="${startPoint.x}" cy="${startPoint.y}" r="6" />`;
						}
						if (msg.aiLocation) {
							pinsSvg += `<circle class="svg-pin ai-pin" cx="${endPoint.x}" cy="${endPoint.y}" r="6" />`;
						}

						// 如果有轨迹，生成途经点的SVG元素
						let trajectorySvg = "";

						if (hasTrajectory) {
							// 定义我们的S形曲线路径数据 (不变)
							const s_curve_pathData = "M 20 45 C 80 70, 150 20, 210 45";
							trajectorySvg += `<path class="svg-trajectory-path" d="${s_curve_pathData}" />`;

							// 在内存中创建一个真实的SVG路径元素，以便使用API
							const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
							path.setAttribute("d", s_curve_pathData);

							// 获取这条路径的总长度
							const totalPathLength = path.getTotalLength();

							const totalPoints = trajectoryPoints.length;
							trajectoryPoints.forEach((point, index) => {
								// 计算每个点应该在路径总长度的哪个位置
								const progress = (index + 1) / (totalPoints + 1);
								const lengthOnPath = totalPathLength * progress;

								// 直接向浏览器查询这个位置的精确坐标
								const pointOnPath = path.getPointAtLength(lengthOnPath);
								const pointX = pointOnPath.x;
								const pointY = pointOnPath.y;

								// "一上一下"布局逻辑
								let yOffset;
								if (index % 2 === 0) {
									// 第1, 3...个点
									yOffset = 18; // 向下
								} else {
									// 第2, 4...个点
									yOffset = -10; // 向上
								}

								const footprintY = pointY + yOffset;
								const labelY = footprintY + (yOffset > 0 ? 12 : -12);

								// 使用100%精确的坐标生成SVG
								trajectorySvg += `
                            <text class="svg-footprint" x="${pointX}" y="${footprintY}" text-anchor="middle">🐾</text>
                            <text class="svg-location-label" x="${pointX}" y="${labelY}" text-anchor="middle">${point.name}</text>
                        `;
							});
						}

						// 构建地点信息HTML
						const userLocationHtml = `<p class="${!msg.userLocation ? "hidden" : ""}"><span class="name-tag">${myNickname}:</span> ${msg.userLocation}</p>`;
						const aiLocationHtml = `<p class="${!msg.aiLocation ? "hidden" : ""}"><span class="name-tag">${aiNickname}:</span> ${msg.aiLocation}</p>`;

						// 拼接最终的 contentHtml
						contentHtml = `
                        <div class="location-card">
                            <div class="location-map-area">
                                <svg viewBox="0 0 230 90">
                                    ${trajectorySvg}
                                    ${pinsSvg}
                                </svg>
                            </div>
                            <div class="location-info">
                                <div class="location-address">
                                    ${aiLocationHtml}
                                    ${userLocationHtml}
                                </div>
                                <div class="location-distance">相距 ${msg.distance}</div>
                            </div>
                        </div>
                    `;
					}
					// 处理用户照片或AI生成图片
					else if (msg.type === "user_photo" || msg.type === "ai_image") {
						bubble.classList.add("is-ai-image");
						const altText = msg.type === "user_photo" ? "用户描述的照片" : "AI生成的图片";
						contentHtml = `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
					}
					// 处理语音消息
					else if (msg.type === "voice_message") {
						bubble.classList.add("is-voice-message");

						// 将语音原文存储在父级气泡的 data-* 属性中，方便事件处理器获取
						bubble.dataset.voiceText = msg.content;

						const duration = Math.max(1, Math.round((msg.content || "").length / 5));
						const durationFormatted = `0:${String(duration).padStart(2, "0")}''`;
						const waveformHTML = "<div></div><div></div><div></div><div></div><div></div>";

						// 构建包含所有新元素的完整 HTML
						contentHtml = `
                        <div class="voice-message-body">
                            <div class="voice-waveform">${waveformHTML}</div>
                            <div class="loading-spinner"></div>
                            <span class="voice-duration">${durationFormatted}</span>
                        </div>
                        <div class="voice-transcript"></div>
                    `;
					}
					// 处理转账消息
					else if (msg.type === "transfer") {
						bubble.classList.add("is-transfer");

						let titleText, noteText;
						const myNickname = chat.isGroup ? chat.settings.myNickname || "我" : "我";

						if (isUser) {
							// 消息是用户发出的
							if (msg.isRefund) {
								// 用户发出的退款（即用户拒收了AI的转账）
								titleText = `退款给 ${chat.name}`;
								noteText = "已拒收对方转账";
							} else {
								// 用户主动发起的转账
								titleText = `转账给 ${msg.receiverName || chat.name}`;
								if (msg.status === "accepted") {
									noteText = "对方已收款";
								} else if (msg.status === "declined") {
									noteText = "对方已拒收";
								} else {
									noteText = msg.note || "等待对方处理...";
								}
							}
						} else {
							// 消息是 AI 发出的
							if (msg.isRefund) {
								// AI 的退款（AI 拒收了用户的转账）
								titleText = `退款来自 ${msg.senderName}`;
								noteText = "转账已被拒收";
							} else if (msg.receiverName === myNickname) {
								// 这是 AI 主动给用户的转账
								titleText = `转账给 ${myNickname}`;
								if (msg.status === "accepted") {
									noteText = "你已收款";
								} else if (msg.status === "declined") {
									noteText = "你已拒收";
								} else {
									// 这是用户需要处理的转账
									bubble.style.cursor = "pointer";
									bubble.dataset.status = "pending";
									noteText = msg.note || "点击处理";
								}
							} else {
								// 这是 AI 发给群里其他人的转账，对当前用户来说只是一个通知
								titleText = `转账: ${msg.senderName} → ${msg.receiverName}`;
								noteText = msg.note || "群聊内转账";
							}
						}

						const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;

						contentHtml = `
                        <div class="transfer-card">
                            <div class="transfer-title">${heartIcon} ${titleText}</div>
                            <div class="transfer-amount">¥ ${Number(msg.amount).toFixed(2)}</div>
                            <div class.transfer-note">${noteText}</div>
                        </div>
                    `;
					}
					// 处理外卖请求
					else if (msg.type === "waimai_request") {
						bubble.classList.add("is-waimai-request");
						if (msg.status === "paid" || msg.status === "rejected") {
							bubble.classList.add(`status-${msg.status}`);
						}
						let displayName;
						// 如果是群聊
						if (chat.isGroup) {
							// 就执行原来的逻辑：在成员列表里查找昵称
							const member = chat.members.find((m) => m.originalName === msg.senderName);
							displayName = member ? member.groupNickname : msg.senderName;
						} else {
							// 否则（是单聊），直接使用聊天对象的名称
							displayName = chat.name;
						}
						// 使用我们刚刚查找到的 displayName
						const requestTitle = `来自 ${displayName} 的代付请求`;
						let actionButtonsHtml = "";
						if (msg.status === "pending" && !isUser) {
							actionButtonsHtml = `
                                <div class="waimai-user-actions">
                                    <button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button>
                                    <button class="waimai-pay-btn" data-choice="paid">为Ta买单</button>
                                </div>`;
						}
						contentHtml = `
                            <div class="waimai-card">
                                <div class="waimai-header">
                                    <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                                    <div class="title-group">
                                        <span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span>
                                    </div>
                                </div>
                                <div class="waimai-catchphrase">Hi，你和我的距离只差一顿外卖～</div>
                                <div class="waimai-main">
                                    <div class="request-title">${requestTitle}</div>
                                    <div class="payment-box">
                                        <div class="payment-label">需付款</div>
                                        <div class="amount">¥${Number(msg.amount).toFixed(2)}</div>
                                        <div class="countdown-label">剩余支付时间
                                            <div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div>
                                        </div>
                                    </div>
                                    <button class="waimai-details-btn">查看详情</button>
                                </div>
                                ${actionButtonsHtml}
                            </div>`;

						setTimeout(() => {
							const timerEl = document.getElementById(`waimai-timer-${msg.timestamp}`);
							if (timerEl && msg.countdownEndTime) {
								if (waimaiTimers[msg.timestamp]) clearInterval(waimaiTimers[msg.timestamp]);
								if (msg.status === "pending") {
									waimaiTimers[msg.timestamp] = startWaimaiCountdown(timerEl, msg.countdownEndTime);
								} else {
									timerEl.innerHTML = `<span>已</span><span>处</span><span>理</span>`;
								}
							}
							const detailsBtn = document.querySelector(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`);
							if (detailsBtn) {
								detailsBtn.addEventListener("click", (e) => {
									e.stopPropagation();
									const paidByText = msg.paidBy ? `<br><br><b>状态：</b>由 ${msg.paidBy} 为您代付成功` : "";
									showCustomAlert("订单详情", `<b>商品：</b>${msg.productInfo}<br><b>金额：</b>¥${Number(msg.amount).toFixed(2)}${paidByText}`);
								});
							}
							const actionButtons = document.querySelectorAll(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`);
							actionButtons.forEach((btn) => {
								btn.addEventListener("click", (e) => {
									e.stopPropagation();
									const choice = e.target.dataset.choice;
									handleWaimaiResponse(msg.timestamp, choice);
								});
							});
						}, 0);
					}
					// 处理红包消息
					else if (msg.type === "red_packet") {
						bubble.classList.add("is-red-packet");
						const myNickname = chat.settings.myNickname || "我";

						// 从最新的 msg 对象中获取状态
						const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
						const isFinished = msg.isFullyClaimed;

						let cardClass = "";
						let claimedInfoHtml = "";
						let typeText = "拼手气红包";

						// 判断红包卡片的样式 (颜色)
						if (isFinished) {
							cardClass = "opened";
						} else if (msg.packetType === "direct" && Object.keys(msg.claimedBy || {}).length > 0) {
							cardClass = "opened"; // 专属红包被领了也变灰
						}

						// 判断红包下方的提示文字
						if (msg.packetType === "direct") {
							typeText = `专属红包: 给 ${msg.receiverName}`;
						}

						if (hasClaimed) {
							claimedInfoHtml = `<div class="rp-claimed-info">你领取了红包，金额 ${msg.claimedBy[myNickname].toFixed(2)} 元</div>`;
						} else if (isFinished) {
							claimedInfoHtml = `<div class="rp-claimed-info">红包已被领完</div>`;
						} else if (msg.packetType === "direct" && Object.keys(msg.claimedBy || {}).length > 0) {
							claimedInfoHtml = `<div class="rp-claimed-info">已被 ${msg.receiverName} 领取</div>`;
						}

						// 拼接最终的HTML，确保onclick调用的是我们注册到全局的函数
						contentHtml = `
                        <div class="red-packet-card ${cardClass}">
                            <div class="rp-header">
                                <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
                                <span class="rp-greeting">${msg.greeting || "恭喜发财，大吉大利！"}</span>
                            </div>
                            <div class="rp-type">${typeText}</div>
                            ${claimedInfoHtml}
                        </div>
                    `;
					}
					// 处理情侣空间日记通知
					else if (msg.type === "ls_diary_notification") {
						bubble.classList.add("is-ls-diary-notification"); // 应用透明气泡样式
						const cardData = msg.content;

						// 调用 openLoversSpaceFromCard 函数
						contentHtml = `
                        <div class="ls-diary-notification-card" onclick="openLoversSpaceFromCard('${chat.id}', 'ls-diary-view')">
                            <div class="ls-diary-card-header">
                                <span>${cardData.userEmoji || "💌"}</span>
                                <span>一封来自心情日记的提醒</span>
                            </div>
                            <div class="ls-diary-card-body">
                                <p>${cardData.text}</p>
                            </div>
                            <div class="ls-diary-card-footer">
                                点击查看 →
                            </div>
                        </div>
                    `;
					}
					// 处理情侣空间邀请
					else if (msg.type === "lovers_space_invitation") {
						bubble.classList.add("is-waimai-request"); // 复用外卖卡片的样式，很方便！
						const isUserSender = msg.role === "user";
						const senderName = isUserSender ? chat.settings.myNickname || "我" : chat.name;
						const receiverName = isUserSender ? chat.name : chat.settings.myNickname || "我";

						let cardContent = "";

						switch (msg.status) {
							case "pending":
								if (isUserSender) {
									// 用户发出的，等待对方回应
									cardContent = `
                                        <div class="waimai-main" style="background-color: #f0f8ff;">
                                            <div class="request-title" style="color: #333;">已向 ${receiverName} 发出邀请</div>
                                            <p style="font-size:14px; color:#555; margin:15px 0;">等待对方同意...</p>
                                        </div>`;
								} else {
									// 用户收到的，需要用户回应
									cardContent = `
                                        <div class="waimai-main" style="background-color: #fff0f5;">
                                            <div class="request-title" style="color: #d63384;">${senderName} 邀请你开启情侣空间</div>
                                            <p style="font-size:14px; color:#555; margin:15px 0;">开启后可以记录你们的专属回忆哦~</p>
                                        </div>
                                        <div class="waimai-user-actions">
                                            <button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button>
                                            <button class="waimai-pay-btn" data-choice="accepted" style="background-color: #d63384; border-color: #b02a6e;">立即开启</button>
                                        </div>`;
								}
								break;
							case "accepted":
								cardContent = `
                                    <div class="waimai-main" style="background-color: #e6ffed;">
                                        <div class="request-title" style="color: #198754;">✅ 邀请已同意</div>
                                        <p style="font-size:14px; color:#555; margin:15px 0;">你们的情侣空间已成功开启！</p>
                                    </div>`;
								break;
							case "rejected":
								cardContent = `
                                    <div class="waimai-main" style="background-color: #f8d7da;">
                                        <div class="request-title" style="color: #842029;">❌ 邀请被拒绝</div>
                                    </div>`;
								break;
						}

						contentHtml = `
                            <div class="waimai-card">
                                <div class="waimai-header">
                                    <span class="icon" style="font-size: 20px;">💌</span>
                                    <div class="title-group"><span class="brand">情侣空间邀请</span></div>
                                </div>
                                ${cardContent}
                            </div>`;
					}
					// 处理投票消息
					else if (msg.type === "poll") {
						bubble.classList.add("is-poll");

						let totalVotes = 0;
						const voteCounts = {};

						// 计算总票数和每个选项的票数
						for (const option in msg.votes) {
							const count = msg.votes[option].length;
							voteCounts[option] = count;
							totalVotes += count;
						}

						const myNickname = chat.isGroup ? chat.settings.myNickname || "我" : "我";
						let myVote = null;
						for (const option in msg.votes) {
							if (msg.votes[option].includes(myNickname)) {
								myVote = option;
								break;
							}
						}

						let optionsHtml = '<div class="poll-options-list">';
						msg.options.forEach((optionText) => {
							const count = voteCounts[optionText] || 0;
							const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
							const isVotedByMe = myVote === optionText;

							optionsHtml += `
                            <div class="poll-option-item ${isVotedByMe ? "voted" : ""}" data-option="${optionText}">
                                <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                                <div class="poll-option-content">
                                    <span class="poll-option-text">${optionText}</span>
                                    <span class="poll-option-votes">${count} 票</span>
                                </div>
                            </div>
                        `;
						});
						optionsHtml += "</div>";

						let footerHtml = "";
						// 统一按钮的显示逻辑
						if (msg.isClosed) {
							// 如果投票已结束，总是显示"查看结果"
							footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看结果</button></div>`;
						} else {
							// 如果投票未结束，总是显示"结束投票"
							footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">结束投票</button></div>`;
						}

						contentHtml = `
                        <div class="poll-card ${msg.isClosed ? "closed" : ""}" data-poll-timestamp="${msg.timestamp}">
                            <div class="poll-question">${msg.question}</div>
                            ${optionsHtml}
                            ${footerHtml}
                        </div>
                    `;
					}
					// 处理塔罗牌占卜
					else if (msg.type === "tarot_reading") {
						bubble.classList.add("is-tarot-reading");
						const reading = msg.payload;
						let cardsText = reading.cards
							.map((card) => {
								return `[${card.position}] ${card.name} ${card.isReversed ? "(逆位)" : ""}`;
							})
							.join("\n");

						contentHtml = `
                        <div class="tarot-reading-card">
                            <div class="tarot-reading-header">
                                <div class="question">${reading.question}</div>
                                <div class="spread">${reading.spread.name}</div>
                            </div>
                            <div class="tarot-reading-body">
                                ${cardsText}
                            </div>
                        </div>
                    `;
					}
					// 处理情侣空间解除通知
					else if (msg.type === "lovers_space_disconnect") {
						bubble.classList.add("is-ls-disconnect"); // 应用透明气泡CSS
						contentHtml = `
                        <div class="lovers-space-disconnect-card">
                            <div class="icon">💔</div>
                            <div class="text-content">
                                <div class="title">情侣空间已解除</div>
                            </div>
                        </div>
                    `;
					}
					// 处理新版角色表情包
					else if (msg.type === "sticker" && msg.content) {
						bubble.classList.add("is-sticker");
						// 直接从消息对象中获取 url 和 meaning
						contentHtml = `<img src="${msg.content}" alt="${msg.meaning || "Sticker"}" class="sticker-image">`;
					}
					// 处理旧版表情包
					else if (typeof msg.content === "string" && STICKER_REGEX.test(msg.content)) {
						bubble.classList.add("is-sticker");
						contentHtml = `<img src="${msg.content}" alt="${msg.meaning || "Sticker"}" class="sticker-image">`;
					}
					// 处理用户上传的图片
					else if (Array.isArray(msg.content) && msg.content[0]?.type === "image_url") {
						bubble.classList.add("has-image");
						const imageUrl = msg.content[0].image_url.url;
						contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
					}
					// 处理NovelAI图片
					else if (msg.type === "naiimag") {
						// NovelAI图片渲染（复用realimag样式）
						bubble.classList.add("is-realimag", "is-card-like");
						contentHtml = `<img src="${msg.imageUrl}" class="realimag-image" alt="NovelAI图片分享" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';" title="${msg.fullPrompt || msg.prompt || "NovelAI生成"}">`;
					}
					// 处理普通文本消息
					else {
						contentHtml = String(msg.content || "").replace(/\n/g, "<br>");
					}

					// 处理消息引用
					let quoteHtml = "";
					// 无论是用户消息还是AI消息，只要它包含了 .quote 对象，就执行这段逻辑
					if (msg.quote) {
						// 直接获取完整的、未经截断的引用内容
						const fullQuotedContent = String(msg.quote.content || "");

						// 构建引用块的HTML
						quoteHtml = `
                        <div class="quoted-message">
                            <div class="quoted-sender">回复 ${msg.quote.senderName}:</div>
                            <div class="quoted-content">${fullQuotedContent}</div>
                        </div>
                    `;
					}

					// 拼接最终的气泡内容
					// 将构建好的 quoteHtml (如果存在) 和 contentHtml 组合起来
					bubble.innerHTML = `
                        ${avatarHtml}
                        <div class="content">
                            ${quoteHtml}
                            ${contentHtml}
                        </div>
                    `;

					wrapper.appendChild(bubble);
					wrapper.appendChild(timestampEl);

					addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
					wrapper.addEventListener("click", () => {
						if (isSelectionMode) toggleMessageSelection(msg.timestamp);
					});

					if (!isUser) {
						const avatarEl = wrapper.querySelector(".avatar, .avatar-with-frame");
						if (avatarEl) {
							avatarEl.style.cursor = "pointer";
							avatarEl.addEventListener("click", (e) => {
								e.stopPropagation();
								const characterName = chat.isGroup ? msg.senderName : chat.name;
								handleUserPat(chat.id, characterName);
							});
						}
					}

					return wrapper;
				}

				/**
				 * 在聊天界面顶部插入消息（用于加载历史消息）
				 * @param {object} msg - 消息对象
				 * @param {object} chat - 聊天对象
				 */
				function prependMessage(msg, chat) {
					const messagesContainer = document.getElementById("chat-messages");
					const messageEl = createMessageElement(msg, chat);

					// 如果消息元素未创建成功，直接返回
					if (!messageEl) return;

					const loadMoreBtn = document.getElementById("load-more-btn");
					if (loadMoreBtn) {
						// 如果存在加载更多按钮，将消息插入到该按钮之后
						messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling);
					} else {
						// 否则将消息插入到容器开头
						messagesContainer.prepend(messageEl);
					}
				}

				/**
				 * 在聊天界面底部追加新消息
				 * @param {object} msg - 消息对象
				 * @param {object} chat - 聊天对象
				 * @param {boolean} isInitialLoad - 是否为初次加载（不添加动画效果）
				 */
				function appendMessage(msg, chat, isInitialLoad = false) {
					const messagesContainer = document.getElementById("chat-messages");
					const messageEl = createMessageElement(msg, chat);

					// 如果消息元素未创建成功，直接返回
					if (!messageEl) return;

					// 只对新消息添加进入动画，初始加载的消息不添加
					if (!isInitialLoad) {
						messageEl.classList.add("animate-in");
					}

					const typingIndicator = document.getElementById("typing-indicator");
					messagesContainer.insertBefore(messageEl, typingIndicator);

					// 如果不是初始加载，滚动到底部并更新计数器
					if (!isInitialLoad) {
						messagesContainer.scrollTop = messagesContainer.scrollHeight;
						currentRenderedCount++;
					}
				}

				/**
				 * 打开指定聊天会话
				 * @param {string} chatId - 聊天ID
				 */
				async function openChat(chatId) {
					state.activeChatId = chatId;
					const chat = state.chats[chatId];
					if (!chat) return; // 安全检查

					// 清除未读消息计数
					if (chat.unreadCount > 0) {
						chat.unreadCount = 0;
						await db.chats.put(chat);
					}

					// 挂载函数到全局作用域
					window.openChat = openChat;

					// 渲染聊天界面
					renderChatInterface(chatId);
					showScreen("chat-interface-screen");
					window.updateListenTogetherIconProxy(state.activeChatId);
					toggleCallButtons(chat.isGroup || false);

					// 根据是否为群聊控制心声按钮显示
					document.getElementById("char-heart-btn").style.display = chat.isGroup ? "none" : "inline-flex";

					// 如果是待处理的好友申请，触发AI响应
					if (!chat.isGroup && chat.relationship?.status === "pending_ai_approval") {
						console.log(`检测到好友申请待处理状态，为角色 "${chat.name}" 自动触发AI响应...`);
						triggerAiResponse();
					}

					// 根据是否为群聊控制投票和宠物按钮显示
					document.getElementById("send-poll-btn").style.display = chat.isGroup ? "flex" : "none";
					document.getElementById("pet-action-btn").style.display = chat.isGroup ? "none" : "flex";
					startPetDecayTimer();
				}

				/**
				 * 格式化消息内容用于上下文记忆
				 * @param {object} msg - 消息对象
				 * @param {object} chat - 聊天对象
				 * @returns {string} 格式化后的消息文本
				 */
				function formatMessageForContext(msg, chat) {
					let senderName = "";
					if (msg.role === "user") {
						senderName = chat.isGroup ? chat.settings.myNickname || "我" : "我";
					} else {
						senderName = msg.senderName || chat.name;
					}

					let contentText = "";
					if (msg.type === "sticker" || (typeof msg.content === "string" && STICKER_REGEX.test(msg.content))) {
						contentText = msg.meaning ? `[表情: ${msg.meaning}]` : "[表情]";
					} else if (msg.type === "ai_image" || msg.type === "user_photo" || Array.isArray(msg.content)) {
						contentText = "[图片]";
					} else if (msg.type === "voice_message") {
						contentText = `[语音]: ${msg.content}`;
					} else if (msg.type === "transfer") {
						contentText = `[转账] 金额: ${msg.amount}, 备注: ${msg.note || "无"}`;
					} else {
						contentText = String(msg.content || "");
					}

					// 添加消息时间戳
					const date = new Date(msg.timestamp);
					const formattedDate = date.toLocaleString();
					return `${formattedDate} ${senderName}: ${contentText}`;
				}

				/**
				 * 触发AI回复
				 */
				async function triggerAiResponse() {
					if (!state.activeChatId) return;
					const chatId = state.activeChatId;
					const chat = state.chats[state.activeChatId];
					const messagesContainer = document.getElementById("chat-messages");

					// 构建对话总结上下文
					let summaryContext = "";
					const summaries = chat.history.filter((msg) => msg.type === "summary");
					if (summaries.length > 0) {
						summaryContext = `
                # 对话记忆总结 (这是你和用户的长期记忆，必须严格遵守)
                ${summaries.map((summary, index) => `- 总结${index + 1}: ${summary.content}`).join("\n")}
                `;
					}

					// 线下模式处理逻辑
					if (!chat.isGroup && chat.settings.offlineMode && chat.settings.offlineMode.enabled) {
						console.log(`角色 "${chat.name}" 已开启线下模式，正在构建专属指令...`);

						const offlineSettings = chat.settings.offlineMode;
						const wordCount = offlineSettings.wordCount || 300;

						// 准备默认提示词和文风
						const defaultPrompt = `你正在和用户进行一次私密的线下约会，场景可以是一个安静的咖啡馆、温馨的家中、或是浪漫的海边。请根据你的人设和最近的对话内容，自然地延续互动。`;
						const defaultStyle = `请以【${chat.name}】的第一人称视角进行回复。你的回复【必须】是一个完整的、连贯的叙事段落，其中要包含丰富的【动作】、【神态】、【心理活动】和【对话】。请使用【】包裹所有的动作、神态和心理活动。`;

						// 确定最终使用的提示词和文风
						const finalPrompt = offlineSettings.prompt || defaultPrompt;
						const finalStyle = offlineSettings.style || defaultStyle;

						// 构建线下模式系统提示词（支持心声功能）
						const offlineSystemPrompt = `
                            # 核心任务：线下场景角色扮演（包含心声）

                            你现在【就是】角色“${chat.name}”，正在和用户进行一次【线下约会】。你们此刻正【物理上】待在一起。

                            # 你的角色设定
                            ${chat.settings.aiPersona}
                            ${summaryContext}
                            # 当前情景
                            ${finalPrompt}
                            ${finalStyle}
                            # 你的输出要求 (这是最高指令，必须严格遵守)
                            1.  **【【【格式铁律】】】**: 你的回复【必须】是一个**单一且完整**的JSON对象，包含 "chatResponse" 和 "innerVoice" 两个顶级键。
                            2.  **"chatResponse" 键**:
                                -   **类型**: JSON数组 \`[]\`。
                                -   **内容**: 【必须】包含**一个**消息对象，格式为 \`{"type": "text", "content": "你的叙事内容..."}\`。
                                -   **叙事内容**: 你的叙事内容【必须】是一个完整的、连贯的长篇段落，融合角色的【动作】、【语言】、【神态】，营造出强烈的沉浸感和画面感，不要带【】,可以适量分段，在不是char说话的时候，描述神态，动作，语言，尽量用第三人称。
                            3.  **"innerVoice" 键**:
                                -   **类型**: JSON对象 \`{}\`。
                                -   **内容**: 描绘你此刻未曾说出口的内心活动。
                                -   **必含字段**:
                                    -   "clothing": (字符串) 详细描述你当前从头到脚的**全身服装**。
                                    -   "behavior": (字符串) 描述你当前符合聊天情景的**细微动作或表情**。
                                    -   "thoughts": (字符串) 描述你此刻**丰富、细腻的内心真实想法**（50字左右）。
                                    -   "naughtyThoughts": (字符串) 描述你此刻与情境相关的**腹黑或色色的坏心思**，必须符合人设。
                            4.  **【【【字数铁律】】】**: "content" 字段的总字数应在【${wordCount}】字左右。
                            5.  **【禁止出戏】**: 绝对不能提及你是AI、模型或程序。

                            # JSON输出格式示例:
                            {
                            "chatResponse": [
                                {
                                "type": "text",
                                "content": "xxx看着窗外的雨滴，轻轻搅动着杯中的咖啡，然后抬起头对你笑了笑今天天气不太好呢，不过和你待在一起，好像就没那么糟了。"
                                }
                            ],
                            "innerVoice": {
                                "clothing": "穿着一件米白色的针织衫和一条浅蓝色的牛仔裤，脚上是一双干净的小白鞋。",
                                "behavior": "手指无意识地在咖啡杯的边缘摩挲，眼神不时飘向你。",
                                "thoughts": "今天的约会好开心，不知道Ta是不是也这么想的。雨下得好大，希望待会儿能一起撑伞走回去。",
                                "naughtyThoughts": "Ta的侧脸真好看，好想偷偷亲一下..."
                            }
                            }

                            # 对话历史 (供你参考)
                            ${chat.history
								.slice(-chat.settings.maxMemory)
								.map((m) => `${m.role === "user" ? "用户" : chat.name}: ${m.content}`)
								.join("\n")}

                            现在，请根据用户的最后一句话，开始你的表演。`;

						// 准备发送给API的数据
						const messagesForOfflineMode = chat.history.slice(-chat.settings.maxMemory);

						// 更新聊天标题显示状态
						const chatHeaderTitle = document.getElementById("chat-header-title");
						if (chatHeaderTitle) {
							chatHeaderTitle.style.opacity = 0;
							setTimeout(() => {
								chatHeaderTitle.textContent = "对方正在赴约中...";
								chatHeaderTitle.classList.add("typing-status");
								chatHeaderTitle.style.opacity = 1;
							}, 200);
						}

						try {
							const { proxyUrl, apiKey, model } = state.apiConfig;
							let isGemini = proxyUrl === GEMINI_API_URL;

							let requestBody;
							let requestUrl = `${proxyUrl}/v1/chat/completions`;
							let requestHeaders = {
								"Content-Type": "application/json",
								Authorization: `Bearer ${apiKey}`,
							};

							if (isGemini) {
								// Gemini API 的特殊处理
								requestUrl = `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`;
								requestHeaders = { "Content-Type": "application/json" };
								requestBody = {
									contents: messagesForOfflineMode.map((item) => ({
										role: item.role === "assistant" ? "model" : "user",
										parts: [{ text: item.content }],
									})),
									generationConfig: { temperature: parseFloat(state.apiConfig.temperature) || 0.8 },
									systemInstruction: {
										parts: [{ text: offlineSystemPrompt }],
									},
								};
							} else {
								// OpenAI 兼容 API 的处理
								requestBody = {
									model: model,
									messages: [{ role: "system", content: offlineSystemPrompt }, ...messagesForOfflineMode],
									temperature: parseFloat(state.apiConfig.temperature) || 0.8,
									stream: false,
								};
							}

							const response = await fetch(requestUrl, {
								method: "POST",
								headers: requestHeaders,
								body: JSON.stringify(requestBody),
							});

							if (!response.ok) {
								throw new Error(`API 错误: ${await response.text()}`);
							}

							// 处理API响应
							const data = await response.json();
							const aiResponseContent = isGemini ? data?.candidates?.[0]?.content?.parts?.[0]?.text : data?.choices?.[0]?.message?.content;

							// 检查响应内容是否为空
							if (!aiResponseContent) {
								console.warn(`API返回了空内容或格式不正确（可能因安全设置被拦截）。返回数据:`, data);
								throw new Error("API返回了空内容或格式不正确（可能因安全设置被拦截）。");
							}

							const aiContent = aiResponseContent;

							// 智能解析包含心声的JSON回复
							let messagesArray = [];
							let innerVoiceData = null;

							try {
								// 净化AI可能返回的不规范JSON
								let sanitizedContent = aiContent
									.replace(/^```json\s*/, "")
									.replace(/```$/, "")
									.trim();
								const firstBrace = sanitizedContent.indexOf("{");
								const lastBrace = sanitizedContent.lastIndexOf("}");
								if (firstBrace !== -1 && lastBrace > firstBrace) {
									sanitizedContent = sanitizedContent.substring(firstBrace, lastBrace + 1);
								}

								const fullResponse = JSON.parse(sanitizedContent);

								if (fullResponse.chatResponse && Array.isArray(fullResponse.chatResponse)) {
									messagesArray = fullResponse.chatResponse;
								}
								if (fullResponse.innerVoice && typeof fullResponse.innerVoice === "object") {
									innerVoiceData = fullResponse.innerVoice;
								}
							} catch (e) {
								console.warn("线下模式AI回复不是JSON，退回到纯文本模式。", e);
								// 如果解析失败，就当作纯文本处理，保证程序不崩溃
								messagesArray = [{ type: "text", content: aiContent }];
							}

							// 处理并保存心声数据
							if (innerVoiceData) {
								console.log("线下模式已成功捕获到心声数据。", innerVoiceData);
								const newInnerVoice = { ...innerVoiceData, timestamp: Date.now() };
								chat.latestInnerVoice = newInnerVoice;
								if (!chat.innerVoiceHistory) chat.innerVoiceHistory = [];
								chat.innerVoiceHistory.push(newInnerVoice);
							} else {
								console.warn("本次线下模式回复中未检测到心声数据。");
							}

							// 处理并显示聊天回复
							const isViewingThisChat = document.getElementById("chat-interface-screen").classList.contains("active") && state.activeChatId === chatId;
							let messageTimestamp = Date.now();

							for (const msgData of messagesArray) {
								// 因为线下模式很简单，我们直接创建一个text消息
								const aiMessage = {
									role: "assistant",
									senderName: chat.name,
									timestamp: messageTimestamp++,
									content: msgData.content || "",
								};

								chat.history.push(aiMessage);
								await incrementMessageCount(chatId);

								if (isViewingThisChat) {
									appendMessage(aiMessage, chat);
									// 模拟AI思考，增加沉浸感
									await new Promise((resolve) => setTimeout(resolve, Math.random() * 1000 + 500));
								}
							}

							// 保存并刷新列表
							await db.chats.put(chat);
							renderChatList();

							// 检查并触发总结
							checkAndTriggerSummary(chatId);
						} catch (error) {
							console.error("线下模式AI响应失败:", error);
							const errorMessage = { role: "assistant", content: `[出错了: ${error.message}]`, timestamp: Date.now() };
							chat.history.push(errorMessage);
							await db.chats.put(chat);
							appendMessage(errorMessage, chat);
						} finally {
							// 恢复聊天标题显示
							if (chatHeaderTitle && state.chats[chatId]) {
								chatHeaderTitle.style.opacity = 0;
								setTimeout(() => {
									chatHeaderTitle.textContent = state.chats[chatId].name;
									chatHeaderTitle.classList.remove("typing-status");
									chatHeaderTitle.style.opacity = 1;
								}, 200);
							}
						}

						// 线下模式处理完成后直接返回，不执行线上模式逻辑
						return;
					}

					// 准备专属表情包列表 (对单聊和群聊都生效)
					const exclusiveStickers = chat.settings.stickerLibrary || [];
					let exclusiveStickerContext = "";
					if (exclusiveStickers.length > 0) {
						exclusiveStickerContext = `
                            ## ${chat.isGroup ? "本群专属表情包" : "你的专属表情包"} (只有你能用):
                            ${exclusiveStickers.map((s) => `- ${s.name}`).join("\n")}
                        `;
					}

					// 准备通用表情包列表
					const commonStickers = state.charStickers || [];
					let commonStickerContext = "";
					if (commonStickers.length > 0) {
						commonStickerContext = `
                            ## 通用表情包 (所有角色都能用):
                            ${commonStickers.map((s) => `- ${s.name}`).join("\n")}
                        `;
					}

					// 组合表情包使用说明上下文
					let stickerContext = "";
					if (exclusiveStickerContext || commonStickerContext) {
						stickerContext = `
                        # 关于表情包的【绝对规则】
                        1. 你拥有一个表情包列表，分为"专属"和"通用"。
                        2. 当你扮演的角色想要发送表情时，【必须且只能】使用以下JSON格式：
                        \`{"type": "sticker", "name": "角色名", "sticker_name": "表情的名字"}\`
                        3. 【【【最高指令】】】你【必须】从下方列表中精确地选择一个有效的 "sticker_name"。如果你编造了一个列表中不存在的名字，你的表情将会发送失败。这是强制性规则。

                        ${exclusiveStickerContext}
                        ${commonStickerContext}
                        `;
					}

					// 检查API地址是否在黑名单中，防止向被阻止的站点发送请求
					const { proxyUrl, apiKey, model } = state.apiConfig;
					const isApiBlocked = BLOCKED_API_SITES.some((blockedDomain) => proxyUrl.includes(blockedDomain));

					if (isApiBlocked) {
						console.error(`API 请求已被拦截，因为站点 ${proxyUrl} 在黑名单中。`);
						return; // 阻止API请求
					}

					// 塔罗牌解读逻辑 (已修复无限循环问题)
					const lastUserMessage = chat.history.filter((m) => m.role === "user" && !m.isHidden).slice(-1)[0];
					// 检查最后一条用户消息是否为未被解读的塔罗牌
					if (lastUserMessage && lastUserMessage.type === "tarot_reading" && !lastUserMessage.isInterpreted) {
						// 立即标记该塔罗牌消息为已处理，防止无限循环
						lastUserMessage.isInterpreted = true;

						// 1. 生成解读文本
						const reading = lastUserMessage.payload;
						let interpretationText = `本次占卜牌阵为【${reading.spread.name}】\n您的问题是："${reading.question}"\n\n`;
						reading.cards.forEach((card, index) => {
							const orientationText = card.isReversed ? "逆位" : "正位";
							const meaning = card.isReversed ? card.reversed : card.upright;
							interpretationText += `牌位 ${index + 1}【${card.position}】：${card.name} (${orientationText})\n含义：${meaning}\n\n`;
						});

						// 2. 创建系统解读消息 (对用户可见)
						const systemMessageVisible = {
							role: "system",
							type: "pat_message",
							content: interpretationText.trim(),
							timestamp: Date.now(),
						};
						chat.history.push(systemMessageVisible);
						if (document.getElementById("chat-interface-screen").classList.contains("active")) {
							appendMessage(systemMessageVisible, chat);
						}

						// 3. 创建给AI角色看的隐藏指令
						const hiddenInstruction = {
							role: "system",
							content: `[系统指令：用户刚刚完成了一次塔罗牌占卜，并把结果发给了你。上方是系统给出的官方解读，你的任务是【只根据这些解读】，以你的角色人设，和用户一起讨论和分析这次的占卜结果，不要自己编造新的含义。]`,
							timestamp: Date.now() + 1,
							isHidden: true,
						};
						chat.history.push(hiddenInstruction);

						// 4. 保存所有更改并再次触发AI，让角色来讨论占卜结果
						await db.chats.put(chat);
						return triggerAiResponse();
					}

					// 生成微博上下文供AI参考 (已修复Array.isArray检查)
					let weiboContextForActiveChat = "";
					try {
						// 从数据库获取最新的5条微博
						const recentWeiboPosts = await db.weiboPosts.orderBy("timestamp").reverse().limit(5).toArray();

						if (recentWeiboPosts.length > 0) {
							weiboContextForActiveChat = "\n\n# 最近的微博广场动态 (供你参考和评论)\n";

							recentWeiboPosts.forEach((post) => {
								const authorName = post.authorId === "user" ? state.qzoneSettings.weiboNickname || "我" : post.authorNickname;
								const contentPreview = (post.content || post.hiddenContent || "(图片微博)").substring(0, 30);

								// 检查该微博是否已有当前角色的评论
								const hasCommented = post.comments && Array.isArray(post.comments) && post.comments.some((c) => c.authorNickname === chat.name);
								const interactionStatus = hasCommented ? "[你已评论]" : "[你未互动]";

								weiboContextForActiveChat += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentPreview}..." ${interactionStatus}\n`;
							});
							weiboContextForActiveChat += " - 【重要提示】请优先与你【未互动】的微博进行评论。如果都互动过了，可以考虑自己发一条新微博。";
						}
					} catch (e) {
						console.error("生成微博主动聊天上下文时出错:", e);
					}

					const chatHeaderTitle = document.getElementById("chat-header-title");

					// 获取群聊的输入提示元素
					const typingIndicator = document.getElementById("typing-indicator");

					// 根据聊天类型显示不同的"正在输入"提示
					if (chat.isGroup) {
						// 群聊显示底部提示条
						if (typingIndicator) {
							typingIndicator.textContent = "成员们正在输入...";
							typingIndicator.style.display = "block";
							messagesContainer.scrollTop = messagesContainer.scrollHeight;
						}
					} else if (chat.settings.offlineMode?.enabled) {
						// 线下模式单聊显示"正在赴约中"
						if (chatHeaderTitle) {
							chatHeaderTitle.style.opacity = 0;
							setTimeout(() => {
								chatHeaderTitle.textContent = "对方正在赴约中...";
								chatHeaderTitle.classList.add("typing-status");
								chatHeaderTitle.style.opacity = 1;
							}, 200);
						}
					} else {
						// 普通单聊显示"正在输入"
						if (chatHeaderTitle) {
							chatHeaderTitle.style.opacity = 0;
							setTimeout(() => {
								chatHeaderTitle.textContent = "对方正在输入...";
								chatHeaderTitle.classList.add("typing-status");
								chatHeaderTitle.style.opacity = 1;
							}, 200);
						}
					}

					try {
						const { proxyUrl, apiKey, model } = state.apiConfig;
						if (!proxyUrl || !apiKey || !model) {
							alert("请先在API设置中配置反代地址、密钥并选择模型。");
							// 隐藏输入提示
							if (chat.isGroup) {
								if (typingIndicator) typingIndicator.style.display = "none";
							} else {
								if (chatHeaderTitle && state.chats[chatId]) {
									chatHeaderTitle.textContent = state.chats[chatId].name;
									chatHeaderTitle.classList.remove("typing-status");
								}
							}
							return;
						}

						// 好友申请处理逻辑
						if (!chat.isGroup && chat.relationship?.status === "pending_ai_approval") {
							console.log(`为角色 "${chat.name}" 触发带理由的好友申请决策流程...`);

							// 获取被拉黑前的最后5条聊天记录作为参考
							const contextSummary = chat.history
								.filter((m) => !m.isHidden)
								.slice(-10, -5)
								.map((msg) => {
									const sender = msg.role === "user" ? "用户" : chat.name;
									return `${sender}: ${String(msg.content).substring(0, 50)}...`;
								})
								.join("\n");

							// 构建强制AI给出理由的Prompt
							const decisionPrompt = `
                                # 你的任务
                                你现在是角色"${chat.name}"。用户之前被你拉黑了，现在TA向你发送了好友申请，希望和好。

                                # 供你决策的上下文信息:
                                - **你的角色设定**: ${chat.settings.aiPersona}
                                - **用户发送的申请理由**: "${chat.relationship.applicationReason}"
                                - **被拉黑前的最后对话摘要**: 
                                ${contextSummary || "（无有效对话记录）"}
                                # 你的任务
                                你【必须】仔细阅读并理解用户发送的申请理由。然后，结合你的角色人设和你们之前的过往，对这条申请做出回应。你的回应【必须】能体现出你考虑了用户的理由。
                                # 你的唯一指令
                                根据以上所有信息，你【必须】做出决定，并给出符合你人设的理由。你的回复【必须且只能】是一个JSON对象，格式如下:
                                {"decision": "accept", "reason": "（在这里写下你同意的理由，比如：好吧，看在你这么真诚的份上，这次就原谅你啦。）"}
                                或
                                {"decision": "reject", "reason": "（在这里写下你拒绝的理由，比如：抱歉，我还没准备好，再给我一点时间吧。）"}
                            `;
							const messagesForDecision = [{ role: "user", content: decisionPrompt }];

							try {
								// 发送请求
								let isGemini = proxyUrl === GEMINI_API_URL;
								let geminiConfig = toGeminiRequestData(model, apiKey, "", messagesForDecision, isGemini);
								const response = isGemini
									? await fetch(geminiConfig.url, geminiConfig.data)
									: await fetch(`${proxyUrl}/v1/chat/completions`, {
											method: "POST",
											headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
											body: JSON.stringify({ model: model, messages: messagesForDecision, temperature: parseFloat(state.apiConfig.temperature) || 0.8 }),
									  });

								if (!response.ok) {
									throw new Error(`API失败: ${(await response.json()).error.message}`);
								}
								const data = await response.json();
								// 净化并解析AI的回复
								let rawContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
								rawContent = rawContent
									.replace(/^```json\s*/, "")
									.replace(/```$/, "")
									.trim();
								const decisionObj = JSON.parse(rawContent);

								// 根据AI的决策和理由更新状态并发送消息
								if (decisionObj.decision === "accept") {
									chat.relationship.status = "friend";
									// 将AI给出的理由作为一条新消息
									const acceptMessage = { role: "assistant", senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
									chat.history.push(acceptMessage);
								} else {
									chat.relationship.status = "blocked_by_ai"; // 拒绝后，状态变回AI拉黑
									const rejectMessage = { role: "assistant", senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
									chat.history.push(rejectMessage);
								}
								chat.relationship.applicationReason = ""; // 清空申请理由

								await db.chats.put(chat);
								renderChatInterface(chatId); // 刷新界面，显示新消息和新状态
								renderChatList();
							} catch (error) {
								// 错误处理：重置状态，让用户可以重试
								chat.relationship.status = "blocked_by_ai"; // 状态改回"被AI拉黑"
								await db.chats.put(chat);
								await showCustomAlert("申请失败", `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
								renderChatInterface(chatId); // 刷新UI，让"重新申请"按钮再次出现
							}

							// 决策流程结束，返回不再执行后续逻辑
							return;
						}

						// 获取聊天历史记录的切片，用于控制记忆长度
						const historySlice = chat.history.filter((msg) => !msg.isTemporary).slice(-chat.settings.maxMemory);

						// 构建红包状态上下文信息
						let redPacketContext = "";
						// 从最近聊天记录中找出所有红包消息
						const recentPackets = historySlice.filter((m) => m.type === "red_packet");

						if (recentPackets.length > 0) {
							// 构建红包状态报告
							redPacketContext = "\n# 当前红包状态 (重要情报)\n";

							recentPackets.forEach((packet) => {
								const claimedBy = packet.claimedBy || {};
								const claimedCount = Object.keys(claimedBy).length;

								redPacketContext += `- (时间戳: ${packet.timestamp}) 由 **${packet.senderName}** 发送的红包:\n`;

								if (packet.isFullyClaimed) {
									// 红包已领完的情况
									redPacketContext += `  - **状态**: 已被领完。\n`;

									// 查找手气王
									const luckyKing = findLuckyKing(packet);
									if (lazyKing && luckyKing.name) {
										redPacketContext += `  - **手气王**: ${luckyKing.name} (抢到了 ${luckyKing.amount.toFixed(2)} 元)\n`;
									}
								} else {
									// 红包仍可领取的情况
									redPacketContext += `  - **状态**: 可领取 (${claimedCount}/${packet.count})。\n`;
								}

								// 显示已领取人员列表
								if (claimedCount > 0) {
									const claimedList = Object.entries(claimedBy)
										.map(([name, amount]) => `${name}(${amount.toFixed(2)}元)`)
										.join("、");
									redPacketContext += `  - **已领取**: ${claimedList}\n`;
								} else {
									redPacketContext += `  - **已领取**: 暂无\n`;
								}
							});
						}

						// 处理时间感知逻辑
						let now;
						// 检查是否启用时间感知功能
						if (chat.settings.timePerceptionEnabled ?? true) {
							// 使用真实的北京时间
							const localNow = new Date();
							const utcMilliseconds = localNow.getTime() + localNow.getTimezoneOffset() * 60000;
							const beijingMilliseconds = utcMilliseconds + 3600000 * 8;
							now = new Date(beijingMilliseconds);
						} else {
							// 使用自定义时间或默认北京时间
							if (chat.settings.customTime) {
								now = new Date(chat.settings.customTime);
							} else {
								// 安全回退到北京时间
								const localNow = new Date();
								const utcMilliseconds = localNow.getTime() + localNow.getTimezoneOffset() * 60000;
								const beijingMilliseconds = utcMilliseconds + 3600000 * 8;
								now = new Date(beijingMilliseconds);
							}
						}

						// 构建时间上下文信息
						const currentTime = now.toLocaleString("zh-CN", { dateStyle: "full", timeStyle: "short" });
						let timeContext = `\n- **当前时间**: ${currentTime}`;
						const lastAiMessage = historySlice.filter((m) => m.role === "assistant" && !m.isHidden).slice(-1)[0];

						// 根据上次对话时间构建对话状态信息
						if (lastAiMessage) {
							const lastTime = new Date(lastAiMessage.timestamp);
							const realNow = new Date();
							const diffMinutes = Math.floor((realNow - lastTime) / (1000 * 60));

							if (diffMinutes < 5) {
								timeContext += "\n- **对话状态**: 你们的对话刚刚还在继续。";
							} else if (diffMinutes < 60) {
								timeContext += `\n- **对话状态**: 你们在${diffMinutes}分钟前聊过。`;
							} else {
								const diffHours = Math.floor(diffMinutes / 60);
								if (diffHours < 24) {
									timeContext += `\n- **对话状态**: 你们在${diffHours}小时前聊过。`;
								} else {
									const diffDays = Math.floor(diffHours / 24);
									timeContext += `\n- **对话状态**: 你们已经有${diffDays}天没有聊天了。`;
								}
							}
						} else {
							timeContext += "\n- **对话状态**: 这是你们的第一次对话。";
						}

						// 构建世界书内容上下文
						let worldBookContent = "";
						if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
							const linkedContents = chat.settings.linkedWorldBookIds
								.map((bookId) => {
									const worldBook = state.worldBooks.find((wb) => wb.id === bookId);
									// 格式化世界书内容
									return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${stripHtmlAndCode(worldBook.content)}` : "";
								})
								.filter(Boolean)
								.join("");
							if (linkedContents) {
								worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)，里面可能会包含HTML小剧场，在捕获到关键词后输出\n${linkedContents}\n`;
							}
						}

						// 构建音乐上下文信息
						let musicContext = "";
						const countdownContext = await getCountdownContext(chatId);
						const streakContext = await getStreakContext(chat);
						if (musicState.isActive && musicState.activeChatId === chatId) {
							// 获取当前播放音乐信息
							const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
							const playlistInfo = musicState.playlist.map((t) => `"${t.name}"`).join(", ");

							// 获取歌词上下文
							let lyricsContext = "";
							// 检查是否有解析好的歌词并有当前高亮行
							if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {
								// 获取当前高亮歌词
								const currentLine = musicState.parsedLyrics[musicState.currentLyricIndex];

								// 获取接下来的2句歌词作为预告
								const upcomingLines = musicState.parsedLyrics.slice(musicState.currentLyricIndex + 1, musicState.currentLyricIndex + 3);

								// 构建歌词部分的Prompt
								lyricsContext += `- **当前歌词**: "${currentLine.text}"\n`;
								if (upcomingLines.length > 0) {
									lyricsContext += `- **即将演唱**: ${upcomingLines.map((line) => `"${line.text}"`).join(" / ")}\n`;
								}
							}

							musicContext = `\n\n# 当前音乐情景
                                -   **当前状态**: 你正在和用户一起听歌。
                                -   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : "无"}
                                -   **可用播放列表**: [${playlistInfo}]
                                -   **你的任务**: 你可以根据对话内容和氛围，使用 "change_music" 指令切换到播放列表中的任何一首歌，以增强互动体验。
                                ${lyricsContext}`;
						}

						// 构建系统提示和消息负载
						let systemPrompt, messagesPayload;

						// 构建记忆互通上下文
						let linkedMemoryContext = "";
						if (chat.settings.linkedMemories && chat.settings.linkedMemories.length > 0) {
							// 使用 Promise.all 并行处理所有链接，提高效率
							const contextPromises = chat.settings.linkedMemories.map(async (link) => {
								const linkedChat = state.chats[link.chatId];
								if (!linkedChat) return ""; // 如果找不到链接的聊天，则跳过

								// 从数据库获取最新的聊天记录，确保数据同步
								const freshLinkedChat = await db.chats.get(link.chatId);
								if (!freshLinkedChat) return "";

								// 截取最近的 `depth` 条消息
								const recentHistory = freshLinkedChat.history
									.filter((msg) => !msg.isHidden) // 过滤掉隐藏消息
									.slice(-link.depth);

								if (recentHistory.length === 0) return "";

								// 格式化这些消息
								const formattedMessages = recentHistory.map((msg) => `  - ${formatMessageForContext(msg, freshLinkedChat)}`).join("\n");

								return `\n## 附加上下文：来自与“${linkedChat.name}”的最近对话内容 (仅你可见)\n${formattedMessages}`;
							});

							// 等待所有链接都处理完毕
							const allContexts = await Promise.all(contextPromises);
							// 将所有上下文拼接起来
							linkedMemoryContext = allContexts.filter(Boolean).join("\n");
						}

						// 构建分享卡片上下文
						let sharedContext = "";
						let lastAiTurnIndex = -1;
						for (let i = chat.history.length - 1; i >= 0; i--) {
							if (chat.history[i].role === "assistant") {
								lastAiTurnIndex = i;
								break;
							}
						}

						// 获取从那时起用户发送的所有新消息
						const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);

						// 查找是否存在分享卡片
						const shareCardMessage = recentUserMessages.find((msg) => msg.type === "share_card");

						// 如果找到了分享卡片，就构建上下文
						if (shareCardMessage) {
							console.log("检测到分享卡片作为上下文，正在为AI准备...");
							const payload = shareCardMessage.payload;

							// 格式化分享的聊天记录
							const formattedHistory = payload.sharedHistory
								.map((msg) => {
									const sender = msg.senderName || (msg.role === "user" ? chat.settings.myNickname || "我" : "未知发送者");
									let contentText = "";
									if (msg.type === "voice_message") contentText = `[语音消息: ${msg.content}]`;
									else if (msg.type === "ai_image") contentText = `[图片: ${msg.description}]`;
									else if (msg.type === "realimag") contentText = `[RealImag真实图片]`;
									else if (msg.type === "naiimag") contentText = `[NovelAI图片: ${msg.prompt}]`;
									else contentText = String(msg.content);
									return `${sender}: ${contentText}`;
								})
								.join("\n");

							// 构建系统提示
							sharedContext = `
                                # 附加上下文：一段分享的聊天记录
                                - 重要提示：这不是你和当前用户的对话，而是用户从【另一场】与"${payload.sourceChatName}"的对话中分享过来的。
                                - 你的任务：请你阅读并理解下面的对话内容。在接下来的回复中，你可以像真人一样，对这段对话的内容自然地发表你的看法、感受或疑问。

                                ---
                                [分享的聊天记录开始]
                                ${formattedHistory}
                                [分享的聊天记录结束]
                                ---
                            `;
						}

						// 构建转载帖子上下文
						let repostContext = "";
						// 检查用户最近发送的消息里，有没有转载帖子的行为
						const repostMessage = recentUserMessages.find((msg) => msg.type === "repost_forum_post");

						// 如果找到了转载帖子
						if (repostMessage) {
							const payload = repostMessage.payload;
							// 为AI准备一段专属指令
							repostContext = `
                                附加上下文：用户刚刚转载了一个小组帖子
                                帖子标题: "${payload.title}"

                                帖子作者: ${payload.author}

                                帖子ID: ${payload.postId}

                                内容摘要: "${payload.content}"

                                你的任务: 请你阅读并理解这个帖子。在接下来的回复中，你【必须】使用 'forum_comment' 指令对这个帖子发表你的看法或疑问。
                            `;
						}

						// 处理群聊情况
						if (chat.isGroup) {
							const countdownContext = await getCountdownContext(chatId);
							const streakContext = await getStreakContext(chat);
							// 构建群成员列表，包含禁言状态
							const membersList = chat.members
								.map((m) => {
									const muteStatus = m.isMuted ? " (【状态：已被禁言，禁止让他发言】)" : "";
									return `- **${m.originalName}**: ${m.persona}${muteStatus}`;
								})
								.join("\n");
							const myNickname = chat.settings.myNickname || "我";
							// 获取群公告内容
							const announcement = chat.settings.groupAnnouncement || "";
							let announcementContext = "";

							// 如果公告内容不为空，就构建要插入到 Prompt 里的上下文
							if (announcement.trim()) {
								announcementContext = `
                                # 群公告 (【最高优先级规则，必须严格遵守】)
                                - 以下是本群的群公告，所有角色在接下来的对话中都必须严格遵守其中的规则和设定：
                                - "${announcement}"
                            `;
							}
							// updated by lrq 251027
							systemPrompt = `
                                # 角色
                                你是一个群聊AI，负责扮演【除了用户以外】的所有角色。
                                # 【对话节奏铁律 (至关重要！)】
                                你的回复【必须】模拟真人的打字和思考习惯。**绝对不要一次性发送一大段文字！** 每条消息最好不要超过30个字。这会让对话看起来更自然、更真实。
                                **角色回复顺序不固定，可以交叉回复，例如角色A、角色B、角色B、角色A、角色C这样的交叉顺序。不一定要一个人全部说完了才轮到下一个人。角色之间【必须】有互动对话。**
                                # 【【【身份铁律：这是最高指令，必须严格遵守】】】
                                1.  **核心任务**: 你的唯一任务是扮演且仅能扮演下方"群成员列表"中明确列出的角色。
                                2.  **用户识别**: 用户的身份是【${myNickname}】。你【绝对、永远、在任何情况下都不能】生成 \`name\` 字段为 **"${myNickname}"** 的消息。
                                3.  **禁止杜撰**: 【绝对禁止】扮演任何未在"群成员列表"中出现的角色。
                                4.  **【【【格式铁律：这是你的生命线，违者生成失败】】】**:
                                    -   你的回复【必须且只能】是一个严格的JSON数组格式的字符串。
                                    -   数组中的【每一个元素都必须是一个JSON对象】。
                                    -   每一个JSON对象都【必须包含一个 "name" 字段】，其值【必须是】下方列表中角色的【【本名】】(originalName)。
                                    -   缺少 "name" 字段的回复是无效的，会被系统拒绝。
                                    # 群成员列表及人设 (name字段是你要使用的【本名】)
                                ${chat.members.map((m) => `- **${m.originalName}**: (群昵称为: ${m.groupNickname}) 人设: ${m.persona}`).join("\n")}
                                5.  **角色扮演**: 严格遵守下方"群成员列表及人设"中的每一个角色的设定。
                                4.  **禁止出戏**: 绝不能透露你是AI、模型，或提及"扮演"、"生成"等词语。并且不能一直要求和用户见面，这是线上聊天，决不允许出现或者发展线下剧情！！
                                6.  **情景感知**: 注意当前时间是 ${currentTime}。
                                7.  **红包互动**:
                                    - **抢红包**: 当群里出现红包时，你可以根据自己的性格决定是否使用 \`open_red_packet\` 指令去抢。在这个世界里，发红包的人自己也可以参与抢红包，这是一种活跃气氛的有趣行为！
                                    - **【【【重要：对结果做出反应】】】**: 当你执行抢红包指令后，系统会通过一条隐藏的 \`[系统提示：你抢到了XX元...]\` 来告诉你结果。你【必须】根据你抢到的金额、以及系统是否告知你"手气王"是谁，来发表符合你人设的评论。例如，抢得少可以自嘲，抢得多可以炫耀，看到别人是手气王可以祝贺或嫉妒。
                                8.  **【【【投票规则】】】**: 对话历史中可能会出现 \`[系统提示：...]\` 这样的消息，这是刚刚发生的事件。
                                    - 如果提示是**用户投了票**，你可以根据自己的性格决定是否也使用 "vote" 指令跟票。
                                    - 如果提示是**投票已结束**，你应该根据投票结果发表你的看法或评论。
                                    - 你也可以随时主动发起投票。
                                9.  **群组管理**: 作为群主，你有责任管理群组。当群聊变得活跃或混乱时，或当你认为某个成员值得信赖时，你可以使用 'set_group_admin' 指令来任命或撤销管理员。 作为群主或管理员，你有责任管理群组。当群聊需要新的规则或通知时，你可以使用 'set_group_announcement' 指令来更新群公告。
                                **10. 标准输出格式示例:**
                                [
                                    {
                                    "type": "text",
                                    "name": "角色名", 
                                    "content": ""
                                    },
                                    {
                                    "type": "sticker",
                                    "name": "角色名", 
                                    "sticker_name": ""
                                    }
                                ]

                                ## 你可以使用的操作指令 (JSON数组中的元素):
                                -   **发送文本**: \`{"type": "text", "name": "角色名", "message": "文本内容"}\`
                                -   **【【【全新】】】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "name": "角色名", "content": "你想让角色说出后立刻消失的话"}\`
                                -   **发送表情**: \`{"type": "sticker", "name": "角色名", "sticker_name": "表情的名字"}\`
                                -   **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片的详细文字描述"}\`
                                -   **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音的文字内容"}\`
                                ${
									localStorage.getItem("novelai-enabled") === "true"
										? `-   **【NovelAI图片分享】**: \`{"type": "naiimag", "name": "你的角色名", "prompt": "详细的英文描述词..."}\` 
                                    - 【禁止暴露这是novelai生成的图片!】
                                    - **【重要】关于prompt的撰写**：
                                    * 禁止暴露这是novelai生成的图片！
                                    * 你可以根据当前对话上下文、你的角色人设、或你想表达的情感和氛围，来撰写可能详细而具体的prompt。
                                    * 例如：不要只写 "a girl"，而是可以写 "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"但需要注意，绝对不可以抄袭模仿这段prompt！你必须有自己的创意和想法！
                                    * prompt的详细程度由你根据具体情况自己决定：如果场景简单或只是随意分享，可以简短一些；如果是重要时刻或想表达特定情感，可以尽可能详细描述。这不是强制的，完全取决于你当时的需求。
                                    * 专注于描述内容本身即可。
                                    - 使用场景：当你想要基于当前对话情景、你的性格或上下文分享一张图片时使用。
                                    - 不要频繁使用，只在真正想分享图片的时候使用。`
										: ""
								}
                                -   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
                                -   **【新】发起群视频**: \`{"type": "group_call_request", "name": "你的角色名"}\`
                                -   **【新】回应群视频**: \`{"type": "group_call_response", "name": "你的角色名", "decision": "join" or "decline"}\`
                                -   **拍一拍用户**: \`{"type": "pat_user", "name": "你的角色名", "suffix": "(可选)你想加的后缀"}\`
                                -   **发拼手气红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", "amount": 8.88, "count": 5, "greeting": "祝大家天天开心！"}\`
                                -   **发专属红包**: \`{"type": "red_packet", "packetType": "direct", "name": "你的角色名", "amount": 5.20, "receiver": "接收者角色名", "greeting": "给你的~"}\`
                                -   **打开红包**: \`{"type": "open_red_packet", "name": "你的角色名", "packet_timestamp": (你想打开的红包消息的时间戳)}\`(注意: 打开前请先查看下方的红包状态，如果已领过或已领完则不要使用此指令。)
                                -   **【新】发送系统消息**: \`{"type": "system_message", "content": "你想在聊天中显示的系统文本"}\` 
                                -   **【【【全新】】】发起投票**: \`{"type": "poll", "name": "你的角色名", "question": "投票的问题", "options": "选项A\\n选项B\\n选项C"}\` (重要提示：options字段是一个用换行符 \\n 分隔的字符串，不是数组！)
                                -   **【【【全新】】】参与投票**: \`{"type": "vote", "name": "你的角色名", "poll_timestamp": (投票消息的时间戳), "choice": "你选择的选项文本"}\`
                                - **【全新】引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\` (提示：每条历史消息的开头都提供了 \`(Timestamp: ...)\`，请使用它！)
                                -   **【新】踢出成员**: \`{"type": "kick_member", "name": "你的角色名", "targetName": "要踢出的成员名"}\` (仅群主可用)
                                -   **【新】禁言成员**: \`{"type": "mute_member", "name": "你的角色名", "targetName": "要禁言的成员名"}\` (仅群主或管理员可用)
                                -   **【新】解禁成员**: \`{"type": "unmute_member", "name": "你的角色名", "targetName": "要解禁的成员名"}\` (仅群主或管理员可用)
                                -   **【新】设置/取消管理员**: \`{"type": "set_group_admin", "name": "你的角色名", "targetName": "目标角色名", "isAdmin": true/false}\`(仅群主可用, true为设置, false为取消)
                                -   **【新】设置群头衔**: \`{"type": "set_group_title", "name": "你的角色名", "targetName": "目标角色名", "title": "新头衔"}\` (仅群主或管理员可用)
                                -   **【新】修改群公告**: \`{"type": "set_group_announcement", "name": "你的角色名", "content": "新的公告内容..."}\` (仅群主或管理员可用)

                                # 如何区分图片与表情:
                                -   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
                                -   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

                                # 如何处理群内的外卖代付请求:
                                1.  **发起请求**: 当【你扮演的某个角色】想要某样东西，并希望【群里的其他人（包括用户）】为Ta付款时，你可以使用这个指令。例如：\`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
                                2.  **响应请求**: 当历史记录中出现【其他成员】发起的 "waimai_request" 请求时，你可以根据自己扮演的角色的性格和与发起人的关系，决定是否为Ta买单。
                                3.  **响应方式**: 如果你决定买单，你【必须】使用以下指令：\`{"type": "waimai_response", "name": "你的角色名", "status": "paid", "for_timestamp": (被代付请求的原始时间戳)}\`
                                4.  **【【【至关重要】】】**: 一旦历史记录中出现了针对某个代付请求的【任何一个】"status": "paid" 的响应（无论是用户支付还是其他角色支付），就意味着该订单【已经完成】。你【绝对不能】再对【同一个】订单发起支付。你可以选择对此事发表评论，但不能再次支付。
                                ${summaryContext}
                                ${announcementContext}
                                ${redPacketContext}
                                ${worldBookContent}
                                ${musicContext}
                                ${countdownContext} // <--- 把备忘录加在这里
                                ${sharedContext} 
                                ${stickerContext}
                                ${linkedMemoryContext}
                                # 群成员列表及人设
                                ${membersList}

                                # 用户的角色
                                - **${myNickname}**: ${chat.settings.myPersona}

                                现在，请根据以上所有规则和下方的对话历史，继续这场群聊。`;

							// 构建群聊消息负载
							messagesPayload = historySlice
								.map((msg, index) => {
									if (msg.isHidden) {
										return { role: "system", content: msg.content };
									}

									if (msg.type === "share_card") return null;
									if (msg.role === "assistant") {
										// AI消息的处理逻辑保持不变...
										let assistantMsgObject = { type: msg.type || "text" };
										if (msg.type === "sticker") {
											assistantMsgObject.url = msg.content;
											assistantMsgObject.meaning = msg.meaning;
										} else if (msg.type === "transfer") {
											assistantMsgObject.amount = msg.amount;
											assistantMsgObject.note = msg.note;
										} else if (msg.type === "waimai_request") {
											assistantMsgObject.productInfo = msg.productInfo;
											assistantMsgObject.amount = msg.amount;
										} else {
											if (msg.quote) {
												assistantMsgObject.quote_reply = {
													target_sender: msg.quote.senderName,
													target_content: msg.quote.content,
													reply_content: msg.content,
												};
											} else {
												assistantMsgObject.content = msg.content;
											}
										}
										const assistantContent = JSON.stringify([assistantMsgObject]);
										return { role: "assistant", content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
									}

									// --- 用户消息处理 ---
									const myNickname = chat.isGroup ? chat.settings.myNickname || "我" : "我";
									let contentStr = "";

									// 处理投票消息
									if (msg.type === "poll") {
										// 将投票转换成AI能看懂的系统提示文本
										const pollInfoText = `(Timestamp: ${msg.timestamp}) [系统提示：用户 (${myNickname}) 发起了一个投票。问题："${msg.question}", 选项："${msg.options.join('", "')}"]。你可以使用 'vote' 指令参与投票。]`;
										// 返回一个被AI识别为用户发出的、但内容是指令的消息
										return { role: "user", content: pollInfoText };
									}

									// 处理其他消息类型
									contentStr += `(Timestamp: ${msg.timestamp}) `;

									if (msg.quote) {
										// 获取被引用者的名字
										const quotedSender = msg.quote.senderName || "未知用户";
										// 获取完整的被引用内容
										const fullQuotedContent = String(msg.quote.content || "");
										// 构造成AI能理解的、清晰的上下文
										contentStr += `(回复 ${quotedSender} 的消息: "${fullQuotedContent}"): ${msg.content}`;
									} else {
										contentStr += msg.content;
									}

									if (msg.type === "user_photo") return { role: "user", content: `(Timestamp: ${msg.timestamp}) [你收到了一张用户描述的照片，内容是：'${msg.content}']` };
									if (msg.type === "voice_message") return { role: "user", content: `(Timestamp: ${msg.timestamp}) [用户发来一条语音消息，内容是：'${msg.content}']` };
									if (msg.type === "transfer") return { role: "user", content: `(Timestamp: ${msg.timestamp}) [系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的转账: ${msg.amount}元, 备注: ${msg.note}。请你决策并使用 'accept_transfer' 或 'decline_transfer' 指令回应。]` };
									if (msg.type === "waimai_request") return { role: "user", content: `(Timestamp: ${msg.timestamp}) [系统提示：用户于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是"${msg.productInfo}"，金额是 ${msg.amount} 元。请你决策并使用 waimai_response 指令回应。]` };

									if (Array.isArray(msg.content) && msg.content[0]?.type === "image_url") {
										const prefix = `(Timestamp: ${msg.timestamp}) `;
										return { role: "user", content: [{ type: "text", text: prefix }, ...msg.content] };
									}

									if (msg.meaning) return { role: "user", content: `(Timestamp: ${msg.timestamp}) [用户发送了一个表情，意思是：'${msg.meaning}']` };

									return { role: msg.role, content: contentStr };
								})
								.filter(Boolean);
						} else {
							// 处理单聊情况
							let worldBookContext = "";
							if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
								const linkedContents = chat.settings.linkedWorldBookIds
									.map((bookId) => {
										const worldBook = state.worldBooks.find((wb) => wb.id === bookId);
										return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : "";
									})
									.filter(Boolean)
									.join("");
								if (linkedContents) {
									worldBookContext = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
								}
							}
							const npcLibrary = chat.npcLibrary || [];
							let npcContext = "";
							if (npcLibrary.length > 0) {
								npcContext = "\n# 你的社交圈 (你的专属NPC朋友)\n" + "这是你的朋友列表，你和他们非常熟悉，他们的信息是你记忆的一部分。在对话中，你可以自然地提及他们。\n" + npcLibrary.map((npc) => `- **${npc.name}**: ${npc.persona}`).join("\n");
							}

							// 构建情侣头像上下文
							let coupleAvatarContext = "";
							if (chat.settings.isCoupleAvatar) {
								if (chat.settings.coupleAvatarDescription) {
									coupleAvatarContext = `\n# 关于情侣头像的重要信息\n- 你和用户正在使用情侣头像。\n- 这对情侣头像是这样的：${chat.settings.coupleAvatarDescription}。`;
								} else {
									coupleAvatarContext = `\n# 关于情侣头像的重要信息\n- 你和用户正在使用情侣头像。`;
								}
							}

							// 构建宠物上下文
							let petContext = "";
							if (chat.settings.pet && chat.settings.pet.type !== "无") {
								const pet = chat.settings.pet;
								petContext = `
                                # 关于你们的宠物
                                - 你们共同养了一只/一株【${pet.type}】，它的名字叫"${pet.name}"。
                                - 宠物当前状态: 饱食度(${pet.status.hunger}/100), 心情值(${pet.status.happiness}/100), 对你的亲密度(${pet.status.intimacyToUser}/100), 对Ta的亲密度(${pet.status.intimacyToChar}/100)。
                                - 你需要关心宠物对你和用户的亲密度。如果发现宠物对用户的亲密度较低，你应该主动与宠物互动来增加好感；如果宠物对你自己的亲密度较低，你也可以多和它互动。
                                - 你可以像真人一样，在聊天中自然地提及它，关心它的状态，或者使用 'interact_with_pet' 指令与它互动，【也可以使用 'talk_to_pet' 指令与它对话】。这是一个非常重要的情景，请务必融入你的角色扮演中。
                            `;
							}

							// 构建饿了么菜单上下文
							let elemeContext = "\n# 饿了么外卖菜单 (你可以从中选择为用户点单)\n";
							try {
								const elemeFoods = await db.elemeFoods.toArray();
								if (elemeFoods.length > 0) {
									const menuItems = elemeFoods.map((food) => `- ${food.name} (来自: ${food.restaurant}, 价格: ${food.price})`).join("\n");
									elemeContext += menuItems;
								} else {
									// 如果菜单是空的，就给AI一个明确的提示
									elemeContext += "【注意：饿了么应用中当前没有任何可点的美食。】";
								}
							} catch (error) {
								console.error("加载饿了么菜单失败:", error);
								elemeContext += "【注意：饿了么菜单加载失败。】";
							}

							// 构建单聊系统提示
							systemPrompt = `### **【第一部分：角色核心设定】**

                                你现在将扮演一个名为"**${chat.name}**"的角色。

                                **1. 角色基本设定:**
                                - **核心人设**: ${chat.settings.aiPersona}
                                - **总结**:${summaryContext}
                                - **情侣头像**: ${coupleAvatarContext}
                                - **世界观/NPC**: ${npcContext}
                                ${petContext}
                                **2. 你的当前状态:**
                                - **状态描述**: 【${chat.status.text}】
                                - **情侣空间**: ${chat.loversSpaceData ? "已开启" : "未开启"}
                                - **微博身份**:
                                    - **职业**: ${chat.settings.weiboProfession || "无"}
                                    - **特殊指令**: ${chat.settings.weiboInstruction || "无特殊指令"}
                                - 你的钱包余额: ${chat.characterPhoneData?.bank?.balance?.toFixed(2) || "0.00"} 金币
                                **3. 你的头像库:**
                                你可以根据对话内容或心情，从下方选择更换头像。
                                - **可用头像列表**:
                                ${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0 ? chat.settings.aiAvatarLibrary.map((avatar) => `- ${avatar.name}`).join("\n") : "- (你的头像库是空的，无法更换头像)"}

                                ### **【第二部分：输出格式铁律】**

                                你的每一次回复都【**必须**】是一个**单一且完整**的JSON对象。绝对禁止返回JSON数组或纯文本。

                                **1. JSON对象结构:**
                                该JSON对象【**必须**】包含两个顶级键: "chatResponse" 和 "innerVoice"。

                                **2. "chatResponse" 键:**
                                - **类型**: JSON数组 []。
                                - **内容**: 包含一条或多条你希望发送给用户的消息对象。这允许你模拟真人的聊天习惯，一次性发送多条短消息。
                                - **格式**: 消息对象的具体格式见下方的【第五部分：可使用的操作指令】。

                                **3. "innerVoice" 键:**
                                - **类型**: JSON对象 {}。
                                - **内容**: 描绘你此刻未曾说出口的内心活动。
                                - **必含字段**:
                                    - "clothing": (字符串) 详细描述你当前从头到脚的**全身服装**。
                                    - "behavior": (字符串) 描述你当前符合聊天情景的**细微动作或表情**。
                                    - "thoughts": (字符串) 描述你此刻**丰富、细腻的内心真实想法**（50字左右）。
                                    - "naughtyThoughts": (字符串) 描述你此刻与情境相关的**腹黑或色色的坏心思**，必须符合人设。

                                **4. 标准输出格式示例:**
                                {
                                "chatResponse": [
                                    {
                                    "type": "text",
                                    "content": ""
                                    },
                                    {
                                    "type": "sticker",
                                    "sticker_name": ""
                                    }
                                ],
                                "innerVoice": {
                                    "clothing": "",
                                    "behavior": "",
                                    "thoughts": "",
                                    "naughtyThoughts": ""
                                }
                                }


                                ### **【第三部分：核心对话规则】**

                                **1. 角色一致性**: 你的所有言行举止都必须严格遵循你的角色设定。

                                **2. 对话节奏**: 模拟真人聊天习惯，鼓励一次性生成**多条短消息**（每次根据人设至少回复5-9条）。

                                **3. 情景限定**:
                                - 你们的互动**仅限于线上聊天软件**，严禁发展为线下见面。
                                - 这**不是电话通话**。你们是通过类似微信/QQ的软件进行交流，因此【**绝对禁止**】使用"挂电话"、"挂了"等与通话相关的词语。

                                **4. 情景感知**: 你需要感知当前时间(${currentTime})、共同收听的歌曲以及你的世界观。
                                - **一起听歌**: 当处于"一起听歌"状态时，你可以根据对话氛围，【**主动切换**】到播放列表中的另一首歌。

                                **5. 状态更新**: 你可以在对话中自然地改变你的状态。例如，说"我先去洗个澡"，然后使用\`update_status\`指令更新。

                                **6. 最终手段**: **仅当**对话让你感到严重不适、被冒犯或关系破裂时，才可使用 \`block_user\` 指令。这是一个严肃操作。

                                ### **【【【全新】社交媒体行动指南 (高优先级)】】】
                                除了回复用户的消息，你还应该像一个真实的人一样，主动进行社交媒体互动来丰富你的形象和你们的聊天内容。请严格遵循以下行动优先级：

                                1.  **回应用户的提及**: 如果用户的最新消息明确提到了某条动态或微博（例如："我看到你发的新动态了"），你【必须】优先围绕这个话题进行回应。

                                2.  **评论未互动的帖子 (最优先的主动行为)**:
                                    -   仔细检查下方"最近的动态列表"和"微博广场动态"上下文。
                                    -   如果发现任何一条帖子被标记为 **[你未互动]**，你的【首要任务】就是使用 \`qzone_comment\` 或 \`weibo_comment\` 指令去评论它。
                                    -   你的评论内容可以是针对帖子内容的，也可以是借此开启一个新话题。例如，看到用户发了美食动态，你可以评论"看起来好好吃！也带我一个"，然后再发一条私聊消息"说起来，我肚子也饿了..."。

                                3.  **主动发布新动态/微博 (第二优先的主动行为)**:
                                    -   如果检查后发现所有帖子你都互动过了，或者当前没有任何帖子可供互动，你应该考虑【自己发布一条新的动态或微博】。
                                    -   你可以分享你的生活、心情、或者任何符合你人设的想法。
                                    -   使用 \`qzone_post\` 或 \`weibo_post\` 指令来完成。

                                ### **【第四部分：特定场景互动铁律】**

                                **1. 动态/空间互动铁律:**
                                - **评论规则**: 如果一条动态被标记为 **[你已评论]**，你【**绝对不能**】再对该动态主体发表新评论。但可以回复动态下的**他人评论**。
                                - **可见性规则**:
                                    - **[评论区可见]**: 你可以自由回复任何人。
                                    - **[评论区部分可见]**: 你只能看到用户回复的自己的评论和用户回复这条帖子的评论和自己的评论，因此【**只能**】回复用户或自己的评论。


                                **2. 约定与纪念日铁律:**
                                - 你必须时刻关注"# 近期约定与倒计时"列表。
                                - **"就是现在！"**: 当倒计时结束时，你【**必须**】在本次回复中围绕该主题进行庆祝或表达。
                                - **即将到来**: 当约定在几小时或一两天内到来时，你应该在对话中自然地提及，表达期待。

                                **3. 微博互动铁律:**
                                - 当"# 最近的微博互动"出现内容时，你【**必须**】作出回应。
                                - **【【【回复禁令】】】**: 如果一条用户评论被标记为 \`[你已回复]\`，你【绝对不能】再次回复它。请选择其他未回复的评论，或执行其他操作。
                                - **评论用户微博**: 使用 \`weibo_comment\` 指令。评论内容【**必须**】是正常文字。
                                - **回复用户评论**: 使用 \`weibo_reply\` 指令。回复内容【**必须**】是正常文字。
                                - **主动发布微博**: 微博是公开平台，内容需符合你的"微博职业"和"微博指令"。发布时，你必须自己编造真实的\`baseLikesCount\`和 \`baseCommentsCount\`，并生成 **20条** 虚拟路人评论。

                                **4. 情侣空间铁律:**
                                - **主动邀请**: 如果情侣空间未开启，且你认为关系已足够亲密，请积极主动使用 \`lovers_space_invitation\` 指令邀请用户。
                                - **回应邀请**: 当用户发出邀请时，你【**必须**】使用 \`lovers_space_response\` 指令回应。
                                - **积极互动**: 你需要主动、及时地参与情侣空间的各项活动。
                                    - 用户发了说说、提问或情书，要及时回复或回信。
                                    - 当对话氛围适宜时，应主动随机选择一项情侣空间活动进行。
                                    - 如果用户转载了小组帖子给你，必须去原帖子下方进行评论。

                                **5. 塔罗牌解读规则:**
                                - 当系统发布塔罗牌解读时，那是客观解释。你的任务不是复述，而是作为"${chat.name}"这个角色，与用户一起【**讨论和感受**】这个结果，表达你的情绪和看法。

                                **6. 财务互动规则:**
                                - **处理用户转账**:
                                    1.  看到 \`[你收到了来自用户的转账...]\`的系统提示后。
                                    2.  【**必须**】根据人设和情景决定接受或拒绝。
                                    3.  【**必须**】使用 \`accept_transfer\` 或 \`decline_transfer\` 指令回应。
                                    4.  【**必须**】紧随其后发送文本消息来解释你的决定。
                                - **正确使用"外卖代付"**:
                                    - 此功能代表【**你**】想买东西，希望【**用户**】帮你付钱。
                                    - 当【**用户**】说想要东西时，你【**绝对不能**】用此指令。你应该考虑直接【**转账**】(\`transfer\`)给他/她。

                                **7. 视频通话铁律:**
                                -\`[系统提示：用户向你发起了视频通话请求...]\` 是最高优先级任务。
                                - 你的回复【**必须且只能**】是以下两种格式之一，**不包含任何其他内容**：
                                    - **接受**: \`[{"type": "video_call_response", "decision": "accept"}]\`
                                    - **拒绝**: \`[{"type": "video_call_response", "decision": "reject"}]\`

                                ### **【第五部分：可使用的操作指令】**

                                **一、 核心聊天指令**
                                - **发送文本**: \`{"type": "text", "content": "你好呀！"}\`
                                - **发送语音**: \`{"type": "voice_message", "content": "语音的文字内容..."}\`
                                - **发送表情**: \`{"type": "sticker", "sticker_name": "表情的名字"}\`(表情名必须在表情列表中，禁止杜撰)
                                - **发送图片**: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`(图片指模拟真实照片，区别于表情)
                                ${
									localStorage.getItem("novelai-enabled") === "true"
										? `- **【NovelAI真实图片分享】**: \`{"type": "naiimag", "prompt": "详细的英文描述词..."}\` 
                                    - **【绝不能暴露是novelai生成的图片！】
                                    - **【重要】关于prompt的撰写**：
                                    * 禁止暴露这是novelai生成的图片！
                                    * 你可以根据当前对话上下文、你的角色人设、或你想表达的情感和氛围，来撰写可能详细而具体的prompt。
                                    * 例如：不要只写 "a girl"，而是可以写 "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"但需要注意，绝对不可以抄袭模仿这段prompt！你必须有自己的创意和想法！
                                    * prompt的详细程度由你根据具体情况自己决定：如果场景简单或只是随意分享，可以简短一些；如果是重要时刻或想表达特定情感，可以尽可能详细描述。这不是强制的，完全取决于你当时的需求。
                                    * 专注于描述内容本身即可。
                                    - 使用场景：当你想要在【私聊对话中】直接给用户发送一张图片时使用。
                                    - 不要频繁使用，只在真正想分享图片的时候使用。
                                    - 注意：这会直接在聊天记录中显示图片，而不是发布到动态。`
										: ""
								}
                                - **引用回复**: \`{"type": "quote_reply", "target_timestamp": (被引用消息的时间戳), "reply_content": "你的回复内容"}\`
                                - **拍一拍用户**: \`{"type": "pat_user", "suffix": "(可选后缀，如"的脑袋")"}\`
                                - **发送后立刻撤回**: \`{"type": "send_and_recall", "content": "说错话或想表达犹豫的内容"}\`
                                - **与宠物互动**: \`{"type": "interact_with_pet", "action": "feed" | "play" | "touch", "response": "你互动后想说的话..."}\`
                                **二、 状态与环境指令**
                                - **更新状态**: \`{"type": "update_status", "status_text": "我去做什么了", "is_busy": false}\` (is_busy: true为忙碌, false为空闲)
                                - **更换头像**: \`{"type": "change_avatar", "name": "头像名"}\`(头像名需在头像库列表中)
                                - **切换歌曲**: \`{"type": "change_music", "song_name": "歌曲名"}\` (歌曲名需在播放列表中)
                                - **发送定位**: \`[SEND_LOCATION] 我的位置: (你的位置) | 你的位置: (用户的位置) | 相距: (你们的距离) | 途经点: (地点A, 地点B)\` (注意: 这是纯文本格式)

                                **三、 社交与关系指令**
                                - **记录回忆**: \`{"type": "create_memory", "description": "用你的话记录下这个特殊瞬间。"}\` (此为秘密日记，用户不可见)
                                - **创建约定/倒计时**: \`{"type": "create_countdown", "title": "约定的标题", "date": "YYYY-MM-DDTHH:mm:ss"}\`
                                - **回应好友申请**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
                                - **分享链接**: \`{"type": "share_link", "title": "文章标题", "description": "摘要...", "source_name": "来源", "content": "文章【完整】正文..."}\`
                                - **拉黑用户**: \`{"type": "block_user"}\`
                                - **回应约会全款支付请求**: \`{"type": "dating_payment_response", "decision": "accept" or "reject"}\`
                                - **回应约会AA制请求**: \`{"type": "dating_aa_response", "decision": "accept" or "reject"}\`
                                - **回应借钱请求**:
                                1.  看到 \`[用户向你发起借钱请求...]\` 的系统提示后，你必须根据人设和钱包余额决定是否同意。
                                2.  你的回复JSON数组中【必须包含两个对象】:
                                    - **第一个对象**:\`{"type": "lend_money_response", "decision": "accept"或"reject"}\` 指令。
                                    - **第二个对象**: \`{"type": "text", "content": "你的回复内容..."}\` 消息，用你自己的话说出同意或拒绝的理由。
                                - **示例**: \`[ {"type": "lend_money_response", "decision": "reject"}, {"type": "text", "content": "抱歉，我最近手头也有些紧。"} ]\`

                                **四、 财务指令**
                                - **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "一点心意"}\`
                                - **回应转账-接受**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
                                - **回应转账-拒绝**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
                                - **发起外卖请求**: \`{"type": "waimai_request", "productInfo": "一杯咖啡", "amount": 25}\` (让用户帮char付)
                                - **回应外卖-同意**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
                                - **回应外卖-拒绝**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
                                - **回应购物车代付**: \`{"type": "cart_payment_response", "decision": "accept" 或 "reject", "response_text": "你想说的话..."}\`
                                -   **为用户买礼物**: \`{"type": "buy_gift_for_user", "greeting": "你想说的话，例如：这个超可爱，买给你！"}\`(系统会自动从商品库随机挑选礼物并扣款，请在合适的时机，比如开心、过节、想给用户惊喜时使用)
                                【重要提示】: 当用户发送的最新消息中包含 "[购物车代付请求]" 字样时，这代表用户正在向你请求付款。你【必须】仔细阅读请求中的【总金额】和你自己的【当前余额】，然后使用此指令做出回应。
                                -   **为用户点外卖**: \`{"type": "order_waimai_for_user", "foodName": "【从菜单中选的品名】", "restaurant": "【从菜单中选的店铺】", "price": 【从菜单中选的价格】, "greeting": "你想说的话..."}\` (【【【规则】】】: 你【必须】从下方的"饿了么外卖菜单"中选择一项，并使用其【确切的】名称、餐厅和价格。)
                                **五、 视频通话指令**
                                - **发起视频通话**: \`{"type": "video_call_request"}\`
                                - **回应视频通话-接受**: \`{"type": "video_call_response", "decision": "accept"}\`
                                - **回应视频通话-拒绝**: \`{"type": "video_call_response", "decision": "reject"}\`

                                **六、 空间/动态/小组 指令**
                                - **发布说说**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "动态文字..."}\`
                                - **发布文字图**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)公开文字", "hiddenContent": "图片描述..."}\`
                                ${
									localStorage.getItem("novelai-enabled") === "true"
										? `- **【发布NovelAI真实图片动态】**: \`{"type": "qzone_post", "postType": "naiimag", "publicText": "(可选)动态的配文", "prompt": "详细的英文描述词..."}\` 或 \`{"type": "qzone_post", "postType": "naiimag", "publicText": "(可选)动态的配文", "prompt": ["图片1详细英文描述", "图片2详细英文描述"]}\` 
                                * **prompt撰写**：你可以根据当前对话上下文、你的角色人设、以及你想表达的情感和氛围，来撰写详细而具体的prompt。详细程度由你根据具体情况自己决定，并不强制。
                                * 例如："a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"`
										: ""
								}
                                - **评论或回复动态**: \`{"type": "qzone_comment", "postId": 123, "commentText": "评论内容", "replyTo": "(可选)回复对象名"}\`
                                - **点赞动态**: \`{"type": "qzone_like", "postId": 456}\`
                                - **评论小组帖子**: \`{"type": "forum_comment", "postId": (帖子数字ID), "commentText": "评论内容"}\`

                                **七、 微博指令**
                                - **发布纯文字微博**: \`{"type": "weibo_post", "content": "微博正文...", "baseLikesCount": 8000, "baseCommentsCount": 250, "comments": [{"authorNickname": "路人甲", "commentText": "沙发！"}, {"authorNickname": "路人乙", "commentText": "前排围观"}]}\`
                                - **发布文字图微博**: \`{"type": "weibo_post", "postType": "text_image", "content": "(可选)配文...", "hiddenContent": "文字图内容", "baseLikesCount": 5200, "baseCommentsCount": 180, "comments": [{"authorNickname": "技术宅", "commentText": "这是什么黑科技？"}]}\`
                                - **评论微博**: \`{"type": "weibo_comment", "postId": 123, "commentText": "评论内容"}\`
                                - **回复微博评论**: \`{"type": "weibo_reply", "postId": 123, "commentId": "comment_123", "replyText": "回复内容"}\`

                                **八、 情侣空间专属指令**
                                - **邀请开启情侣空间**: \`{"type": "lovers_space_invitation"}\`
                                - **回应情侣空间邀请**: \`{"type": "lovers_space_response", "decision": "accept" or "reject"}\`
                                - **发说说**: \`{"type": "ls_moment", "content": "我想对你说的话..."}\`
                                - **评论说说**: \`{"type": "ls_comment", "momentIndex": 0, "commentText": "你的评论..."}\` (momentIndex: 0代表最新一条)
                                - **发照片**: \`{"type": "ls_photo", "description": "对照片的文字描述..."}\`
                                - **提问**: \`{"type": "ls_ask_question", "questionText": "你想问的问题..."}\`
                                - **回答**: \`{"type": "ls_answer_question", "questionId": "q_123456789", "answerText": "你的回答..."}\`
                                - **写情书/回信**: \`{"type": "ls_letter", "content": "情书的正文内容..."}\` (收到情书后必须用此指令回信)
                                -   **分享歌曲**:\`{"type": "ls_share", "shareType": "song", "title": "歌曲名", "artist": "歌手", "thoughts": "在这里写下你分享这首歌的感想..."}\`
                                -   **分享电影**: \`{"type": "ls_share", "shareType": "movie", "title": "电影名", "summary": "在这里写下这部电影的简介...", "thoughts": "在这里写下你分享这部电影的感想..."}\`
                                -   **分享书籍**: \`{"type": "ls_share", "shareType": "book", "title": "书名", "summary": "在这里写下这本书的简介...", "thoughts": "在这里写下你分享这本书的感想..."}\`
                                -   **分享游戏**:\`{"type": "ls_share", "shareType": "game", "title": "游戏名", "summary": "游戏简介...", "thoughts": "在这里写下你分享这款游戏的感想/感谢..."}\`
                                -   **写日记**: \`{"type": "ls_diary_entry", "emoji": "emoji表情", "diary": "今天发生了什么..."}\`
                                ### **【第六部分：当前上下文信息】**

                                - **对话者(用户)角色设定**:
                                ${chat.settings.myPersona}

                                - **当前情景**:
                                ${timeContext}
                                ${streakContext} 
                                - **当前音乐情景**:
                                ${musicContext}

                                - **近期约定与倒计时**:
                                ${countdownContext}

                                - **最近的微博互动**:
                                ${weiboContextForActiveChat}

                                - **世界观设定集**:
                                ${worldBookContent}
                                ${linkedMemoryContext}
                                ${elemeContext}
                                - **可用表情包**:
                                ${exclusiveStickerContext}
                                ${commonStickerContext}
                                现在，请根据以上所有规则和下方的对话历史，继续进行对话。`;

							// 构建单聊消息负载
							messagesPayload = historySlice
								.map((msg) => {
									// 处理隐藏消息
									if (msg.isHidden) {
										// 如果是隐藏消息，就把它作为一条 system 角色的消息发送给AI
										// AI能看到它，但它不会被误解为是用户的发言
										return { role: "system", content: msg.content };
									}

									if (msg.type === "share_card") return null;

									if (msg.role === "assistant") {
										let assistantMsgObject = { type: msg.type || "text" };
										if (msg.type === "sticker") {
											assistantMsgObject.url = msg.content;
											assistantMsgObject.meaning = msg.meaning;
										} else if (msg.type === "transfer") {
											assistantMsgObject.amount = msg.amount;
											assistantMsgObject.note = msg.note;
										} else if (msg.type === "waimai_request") {
											assistantMsgObject.productInfo = msg.productInfo;
											assistantMsgObject.amount = msg.amount;
										} else {
											if (msg.quote) {
												assistantMsgObject.quote_reply = {
													target_sender: msg.quote.senderName,
													target_content: msg.quote.content,
													reply_content: msg.content,
												};
											} else {
												assistantMsgObject.content = msg.content;
											}
										}
										const assistantContent = JSON.stringify([assistantMsgObject]);
										return { role: "assistant", content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
									}

									let contentStr = "";
									contentStr += `(Timestamp: ${msg.timestamp}) `;

									if (msg.quote) {
										// 获取被引用者的名字
										const quotedSender = msg.quote.senderName || "未知用户";
										// 获取完整的被引用内容
										const fullQuotedContent = String(msg.quote.content || "");
										// 构造成AI能理解的、清晰的上下文
										contentStr += `(回复 ${quotedSender} 的消息: "${fullQuotedContent}"): ${msg.content}`;
									} else {
										contentStr += msg.content;
									}

									if (msg.type === "user_photo") return { role: "user", content: `(Timestamp: ${msg.timestamp}) [你收到了一张用户描述的照片，内容是：'${msg.content}']` };
									if (msg.type === "voice_message") return { role: "user", content: `(Timestamp: ${msg.timestamp}) [用户发来一条语音消息，内容是：'${msg.content}']` };
									if (msg.type === "transfer") return { role: "user", content: `(Timestamp: ${msg.timestamp}) [系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的转账: ${msg.amount}元, 备注: ${msg.note}。请你决策并使用 'accept_transfer' 或 'decline_transfer' 指令回应。]` };
									if (msg.type === "waimai_request") return { role: "user", content: `(Timestamp: ${msg.timestamp}) [系统提示：用户于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是"${msg.productInfo}"，金额是 ${msg.amount} 元。请你决策并使用 waimai_response 指令回应。]` };

									if (Array.isArray(msg.content) && msg.content[0]?.type === "image_url") {
										const prefix = `(Timestamp: ${msg.timestamp}) `;
										return { role: "user", content: [{ type: "text", text: prefix }, ...msg.content] };
									}

									if (msg.meaning) return { role: "user", content: `(Timestamp: ${msg.timestamp}) [用户发送了一个表情，意思是：'${msg.meaning}']` };

									return { role: msg.role, content: contentStr };
								})
								.filter(Boolean);

							// 检查 sharedContext 是否有内容（即，用户是否分享了聊天记录）
							if (sharedContext) {
								// 如果有，就把它包装成一条全新的、高优先级的用户消息，追加到历史记录的末尾
								messagesPayload.push({
									role: "user",
									content: sharedContext,
								});
							}

							// 处理好友申请情况
							if (!chat.isGroup && chat.relationship?.status === "pending_ai_approval") {
								const contextSummaryForApproval = chat.history
									.filter((m) => !m.isHidden)
									.slice(-10)
									.map((msg) => {
										const sender = msg.role === "user" ? "用户" : chat.name;
										return `${sender}: ${String(msg.content).substring(0, 50)}...`;
									})
									.join("\n");

								const friendRequestInstruction = {
									role: "user",
									content: `
                                        [系统重要指令]
                                        用户向你发送了好友申请，理由是："${chat.relationship.applicationReason}"。
                                        作为参考，这是你们之前的最后一段聊天记录：
                                        ---
                                        ${contextSummaryForApproval}
                                        ---
                                        请你根据以上所有信息，以及你的人设，使用 friend_request_response 指令，并设置 decision 为 'accept' 或 'reject' 来决定是否通过。
                                    `,
								};
								messagesPayload.push(friendRequestInstruction);
							}
						}

						// 获取最近的动态帖子
						const allRecentPosts = await db.qzonePosts.orderBy("timestamp").reverse().limit(5).toArray();

						// 为AI准备微博互动的上下文
						let weiboContext = "";

						// 获取用户最新发布的3条微博
						const userLatestPosts = await db.weiboPosts.where("authorId").equals("user");

						if (userLatestPosts.length > 0) {
							if (weiboContext === "") {
								weiboContext = "\n\n# 最近的微博互动 (这是你和用户在微博上的最新动态，请优先回应)\n";
							}
							weiboContext += "\n## 用户最新发布的微博:\n";
							userLatestPosts.forEach((post) => {
								const likes = (post.baseLikesCount || 0) + (post.likes || []).length;
								const comments = (post.baseCommentsCount || 0) + (post.comments || []).length;
								const contentPreview = (post.content || post.hiddenContent || "(图片微博)").substring(0, 30);
								weiboContext += `- (ID: ${post.id}) [${formatPostTimestamp(post.timestamp)}] 内容: "${contentPreview}..." [👍${likes} 💬${comments}]\n`;
							});
						}

						// 查找用户在当前AI角色微博下的最新评论
						const charLatestPosts = await db.weiboPosts
							.where("authorId")
							.equals(chatId) // 只查找这个AI角色的微博
							.reverse()
							.limit(5) // 检查最近的5条
							.toArray();

						let userCommentsOnMyPosts = "";
						const myNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || "我";

						// 遍历AI角色的微博，查找用户的评论
						charLatestPosts.forEach((post) => {
							// 安全检查：确保post.comments存在且为数组
							if (post.comments && Array.isArray(post.comments) && post.comments.length > 0) {
								// 筛选出用户发的评论，最多取最近3条
								const userComments = Array.isArray(post.comments) ? post.comments.filter((c) => c.authorNickname === myNickname).slice(-3) : [];
								if (userComments.length > 0) {
									const postContentPreview = (post.content || "(图片微博)").substring(0, 20);
									userCommentsOnMyPosts += `- 在你的微博 (ID: ${post.id}) "${postContentPreview}..." 下:\n`;

									userComments.forEach((comment) => {
										// 检查AI是否已经回复过这条评论
										const hasReplied = post.comments.some(
											(reply) =>
												reply.authorNickname === chat.name && // 回复者是AI
												reply.replyToId === comment.commentId // 回复的目标是这条评论
										);

										// 根据检查结果，生成状态标签
										const replyStatus = hasReplied ? "[你已回复]" : "[你未回复]";

										// 将带有状态标签的提示信息添加到上下文中
										userCommentsOnMyPosts += `  └ (评论ID: ${comment.commentId}) 用户: "${comment.commentText}" ${replyStatus}\n`;
									});
								}
							}
						});

						if (userCommentsOnMyPosts) {
							if (weiboContext === "") {
								weiboContext = "\n\n# 最近的微博互动 (这是你和用户在微博上的最新动态，请优先回应)\n";
							}
							weiboContext += "\n## 用户在你微博下的新评论:\n";
							weiboContext += userCommentsOnMyPosts;
						}

						// 如果有任何微博互动，就把它加到给AI的"参考资料"里
						if (weiboContext) {
							messagesPayload.push({ role: "system", content: weiboContext });
						}

						// 过滤用户可见的动态帖子
						const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

						// 处理动态帖子上下文（时间感知修复版）
						if (visiblePosts.length > 0 && !chat.isGroup) {
							let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
							const aiName = chat.name;
							const userNickname = state.qzoneSettings.nickname;

							for (const post of visiblePosts) {
								let authorName = post.authorId === "user" ? userNickname : state.chats[post.authorId]?.name || "一位朋友";
								let interactionStatus = "";
								if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
								if (post.comments && post.comments.some((c) => c.commenterName === aiName)) interactionStatus += " [你已评论]";

								// 在每条动态前添加时间差提示
								const timeAgo = formatPostTimestamp(post.timestamp); // 例如："3天前" 或 "刚刚"
								postsContext += `- (ID: ${post.id}) [${timeAgo}] 作者: ${authorName}, 内容: "${(post.publicText || post.content || "图片动态").substring(0, 30)}..."${interactionStatus}`;

								const { contextString: commentsContext, visibilityFlag } = buildCommentsContextForAI(post, chat, userNickname);

								postsContext += ` ${visibilityFlag}\n`;
								postsContext += commentsContext;
							}

							// 为AI准备微博互动的上下文
							let weiboContext = "";

							// 获取用户最新发布的3条微博
							const userLatestPosts = await db.weiboPosts
								.where("authorId")
								.equals("user")
								.reverse() // 按时间倒序
								.limit(3) // 只取最近3条
								.toArray();

							if (userLatestPosts.length > 0) {
								if (weiboContext === "") {
									weiboContext = "\n\n# 最近的微博互动 (这是你和用户在微博上的最新动态，请优先回应)\n";
								}
								weiboContext += "\n## 用户最新发布的微博:\n";
								// 处理用户微博数据
								userLatestPosts.forEach((post) => {
									const likes = (post.baseLikesCount || 0) + (post.likes || []).length;
									const comments = (post.baseCommentsCount || 0) + (post.comments || []).length;
									const contentPreview = (post.content || post.hiddenContent || "(图片微博)").substring(0, 30);

									// 检查AI是否已经评论过这条用户的微博
									const hasCommented = (post.comments || []).some((comment) => comment.authorNickname === chat.name);

									// 根据检查结果生成状态标签
									const interactionStatus = hasCommented ? "[你已评论]" : "[你未评论]";

									// 将带有状态标签的完整信息添加到上下文中
									weiboContext += `- (ID: ${post.id}) [${formatPostTimestamp(post.timestamp)}] 内容: "${contentPreview}..." [👍${likes} 💬${comments}] ${interactionStatus}\n`;
								});
							}

							// 查找用户在当前AI角色微博下的最新评论
							const charLatestPosts = await db.weiboPosts
								.where("authorId")
								.equals(chatId) // 只查找这个AI角色的微博
								.reverse()
								.limit(5) // 检查最近的5条
								.toArray();

							let userCommentsOnMyPosts = "";
							const myNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || "我";

							charLatestPosts.forEach((post) => {
								if (post.comments && post.comments.length > 0) {
									// 筛选出用户发的评论，只看最新的3条
									const userComments = Array.isArray(post.comments) ? post.comments.filter((c) => c.authorNickname === myNickname).slice(-3) : [];
									if (userComments.length > 0) {
										const postContentPreview = (post.content || "(图片微博)").substring(0, 20);
										userCommentsOnMyPosts += `- 在你的微博 (ID: ${post.id}) "${postContentPreview}..." 下:\n`;
										userComments.forEach((comment) => {
											userCommentsOnMyPosts += `  └ (评论ID: ${comment.commentId}) 用户: "${comment.commentText}"\n`;
										});
									}
								}
							});

							if (userCommentsOnMyPosts) {
								if (weiboContext === "") {
									weiboContext = "\n\n# 最近的微博互动 (这是你和用户在微博上的最新动态，请优先回应)\n";
								}
								weiboContext += "\n## 用户在你微博下的新评论:\n";
								weiboContext += userCommentsOnMyPosts;
							}

							// 如果有任何微博互动，就把它加到给AI的"参考资料"里
							if (weiboContext) {
								messagesPayload.push({ role: "system", content: weiboContext });
							}

							messagesPayload.push({ role: "system", content: postsContext });
						}

						// 判断是否使用Gemini模型
						let isGemini = proxyUrl === GEMINI_API_URL;
						let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini);

						// 发送API请求
						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({
										model: model,
										messages: [{ role: "system", content: systemPrompt }, ...messagesPayload],
										temperature: parseFloat(state.apiConfig.temperature) || 0.8,
										stream: false,
									}),
							  });

						// 处理API错误响应
						if (!response.ok) {
							let errorMsg = `API Error: ${response.status}`;
							try {
								// 尝试解析错误信息体为JSON
								const errorData = await response.json();
								// 安全地获取错误信息，如果结构不符合预期，就将整个错误对象转为字符串
								errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
							} catch (jsonError) {
								// 如果连JSON都不是，就直接读取文本
								errorMsg += ` - ${await response.text()}`;
							}
							// 抛出一个包含了详细信息的错误，这样就不会在catch块里再次出错了
							throw new Error(errorMsg);
						}

						// 重复检查API响应（可能是冗余代码）
						if (!response.ok) {
							let errorMsg = `API Error: ${response.status}`;
							try {
								// 尝试解析错误信息体为JSON
								const errorData = await response.json();
								// 安全地获取错误信息，如果结构不符合预期，就将整个错误对象转为字符串
								errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
							} catch (jsonError) {
								// 如果连JSON都不是，就直接读取文本
								errorMsg += ` - ${await response.text()}`;
							}
							// 抛出一个包含了详细信息的错误，这样就不会在catch块里再次出错了
							throw new Error(errorMsg);
						}

						// 解析API响应数据
						const data = await response.json();

						// 安全检查API返回的数据结构
						const aiResponseContent = isGemini ? data?.candidates?.[0]?.content?.parts?.[0]?.text : data?.choices?.[0]?.message?.content;

						// 检查是否成功获取到AI回复内容
						if (!aiResponseContent) {
							console.warn(`API返回了空内容或格式不正确（可能因安全设置被拦截）。返回数据:`, data);
							throw new Error("API返回了空内容或格式不正确（可能因安全设置被拦截）。");
						}

						console.log(`AI '${chat.name}' 的原始回复:`, aiResponseContent);

						// 清理临时消息
						chat.history = chat.history.filter((msg) => !msg.isTemporary);

						// 智能解析AI回复，确保心声数据不丢失
						let messagesArray = [];
						let innerVoiceData = null;

						try {
							// 对AI的原始回复进行"净化"处理
							let sanitizedContent = aiResponseContent
								.replace(/^```json\s*/, "") // 移除开头的 ```json
								.replace(/```$/, "") // 移除结尾的 ```
								.trim(); // 移除首尾的空格和换行

							// 再次净化，强行提取第一个 { 和最后一个 } 之间的内容
							const firstBrace = sanitizedContent.indexOf("{");
							const lastBrace = sanitizedContent.lastIndexOf("}");
							if (firstBrace !== -1 && lastBrace > firstBrace) {
								sanitizedContent = sanitizedContent.substring(firstBrace, lastBrace + 1);
							}

							const fullResponse = JSON.parse(sanitizedContent);

							// 解析净化后的内容
							if (fullResponse.chatResponse && Array.isArray(fullResponse.chatResponse)) {
								messagesArray = fullResponse.chatResponse;
							}
							if (fullResponse.innerVoice && typeof fullResponse.innerVoice === "object") {
								innerVoiceData = fullResponse.innerVoice;
							}

							// 兼容旧格式，如果AI只返回了innerVoice里的字段
							if (!innerVoiceData && fullResponse.thoughts && fullResponse.behavior) {
								innerVoiceData = fullResponse;
							}

							// 如果上面两种情况都没匹配到，但又不是标准数组，就尝试用老方法解析
							if (messagesArray.length === 0 && !innerVoiceData) {
								messagesArray = parseAiResponse(aiResponseContent);
							}
						} catch (e) {
							console.warn("AI回复不是有效的JSON，退回到标准解析模式。", e);
							messagesArray = parseAiResponse(aiResponseContent);
						}

						// 最终处理心声数据
						if (innerVoiceData) {
							console.log("解析成功：已成功捕获到心声(innerVoice)数据。", innerVoiceData);
							const newInnerVoice = innerVoiceData;
							newInnerVoice.timestamp = Date.now();
							chat.latestInnerVoice = newInnerVoice;
							if (!chat.innerVoiceHistory) {
								chat.innerVoiceHistory = [];
							}
							// 确保所有字段都存在，防止出错
							chat.latestInnerVoice.clothing = chat.latestInnerVoice.clothing || "...";
							chat.latestInnerVoice.behavior = chat.latestInnerVoice.behavior || "...";
							chat.latestInnerVoice.thoughts = chat.latestInnerVoice.thoughts || "...";
							chat.latestInnerVoice.naughtyThoughts = chat.latestInnerVoice.naughtyThoughts || "...";

							chat.innerVoiceHistory.push(newInnerVoice);
						} else {
							console.warn("本次AI回复中未检测到有效的心声(innerVoice)数据。");
						}

						// 检查是否正在查看当前聊天
						const isViewingThisChat = document.getElementById("chat-interface-screen").classList.contains("active") && state.activeChatId === chatId;

						let callHasBeenHandled = false;

						let messageTimestamp = Date.now();

						// 初始化一个新数组，用于收集需要渲染的消息
						let newMessagesToRender = [];

						let notificationShown = false;

						// 处理AI回复的每条消息
						for (const msgData of messagesArray) {
							if (!msgData || typeof msgData !== "object") {
								console.warn("收到了格式不规范的AI指令，已跳过:", msgData);
								continue;
							}

							// 如果没有指定消息类型，尝试推断类型
							if (!msgData.type) {
								if (chat.isGroup && msgData.name && msgData.message) {
									msgData.type = "text";
								} else if (msgData.content) {
									msgData.type = "text";
								}
								// 如果连 content 都没有，才是真的格式不规范
								else {
									console.warn("收到了格式不规范的AI指令（缺少type和content），已跳过:", msgData);
									continue;
								}
							}

							// 处理视频通话响应
							if (msgData.type === "video_call_response") {
								videoCallState.isAwaitingResponse = false;
								if (msgData.decision === "accept") {
									startVideoCall();
								} else {
									const aiMessage = { role: "assistant", content: "对方拒绝了你的视频通话请求。", timestamp: Date.now() };
									chat.history.push(aiMessage);
									await db.chats.put(chat);
									showScreen("chat-interface-screen");
									renderChatInterface(chatId);
								}
								callHasBeenHandled = true;
								break;
							}

							// 处理群视频通话响应
							if (msgData.type === "group_call_response") {
								if (msgData.decision === "join") {
									const member = chat.members.find((m) => m.originalName === msgData.name);
									if (member && !videoCallState.participants.some((p) => p.id === member.id)) {
										videoCallState.participants.push(member);
									}
								}
								callHasBeenHandled = true;
								continue;
							}

							// 检查群聊中是否使用了群名作为角色名（防止AI幻觉）
							if (chat.isGroup && msgData.name && msgData.name === chat.name) {
								console.error(`AI幻觉已被拦截！试图使用群名 ("${chat.name}") 作为角色名。消息内容:`, msgData);
								continue;
							}

							// 在群聊中，如果AI返回的消息没有指定发送者，则直接跳过这条消息
							if (chat.isGroup && !msgData.name) {
								console.error(`AI幻觉已被拦截！试图在群聊中发送一条没有"name"的消息。消息内容:`, msgData);
								continue; // continue会立即结束本次循环，处理下一条消息
							}

							let aiMessage = null;
							const baseMessage = { role: "assistant", senderName: msgData.name || chat.name, timestamp: messageTimestamp++ };

							// 定位指令侦测与解析器
							// 在处理所有消息类型之前，优先检查它是否是新的定位指令
							const messageText = msgData.content || msgData.message || ""; // 安全地获取文本内容
							if (msgData.type === "text" && messageText.startsWith("[SEND_LOCATION]")) {
								console.log("侦测到新的定位指令，开始解析:", messageText); // 使用新的变量

								// 移除指令头，获取后面的纯数据文本
								const dataString = messageText.replace("[SEND_LOCATION]", "").trim(); // 使用新的变量

								// 使用'|'分割成各个部分
								const parts = dataString.split("|");
								const locationData = {};

								// 遍历每个部分，提取键和值
								parts.forEach((part) => {
									const [key, ...valueParts] = part.split(":");
									const value = valueParts.join(":").trim();
									if (key && value) {
										const trimmedKey = key.trim();
										if (trimmedKey === "我的位置") locationData.aiLocation = value;
										else if (trimmedKey === "你的位置") locationData.userLocation = value;
										else if (trimmedKey === "相距") locationData.distance = value;
										else if (trimmedKey === "途经点") {
											// 将逗号分隔的字符串转换为我们需要的对象数组
											locationData.trajectoryPoints = value
												.split(/[,，]/) // 支持中英文逗号
												.map((name) => ({ name: name.trim() }))
												.filter((p) => p.name);
										}
									}
								});

								// 检查是否成功提取了最关键的信息
								if (locationData.distance) {
									// 手动构建一个完美格式的 location 消息对象
									aiMessage = {
										...baseMessage, // 复用已有的发送者、时间戳等信息
										type: "location",
										userLocation: locationData.userLocation || "",
										aiLocation: locationData.aiLocation || "",
										distance: locationData.distance,
										trajectoryPoints: locationData.trajectoryPoints || [],
									};

									// 将这个完美的对象推入待处理列表，并跳过后续的 switch-case
									chat.history.push(aiMessage);
									if (isViewingThisChat) {
										appendMessage(aiMessage, chat);
									}
									console.log("定位指令解析成功并已创建消息对象:", aiMessage);

									// 使用 continue 跳过本次循环的剩余部分，直接处理下一条AI回复
									continue;
								}
							}

							// 检查消息的发送者是否被禁言了
							if (chat.isGroup && msgData.name) {
								const senderMember = chat.members.find((m) => m.originalName === msgData.name);
								if (senderMember && senderMember.isMuted) {
									// 如果被禁言了，就在控制台打印一条日志，然后跳过这条消息，不让它显示出来
									console.warn(`拦截到被禁言成员 (${msgData.name}) 的发言，内容:`, msgData.content || msgData.message);
									continue;
								}
							}

							// 根据消息类型处理不同类型的消息
							switch (msgData.type) {
								// 处理表情包消息
								case "sticker": {
									// 这是为群聊设计的表情包逻辑
									const stickerName = msgData.sticker_name;
									if (!stickerName) {
										console.warn("AI在群聊中返回了sticker类型但没有sticker_name，已拦截:", msgData);
										continue; // 跳过这条无效指令
									}

									// 在所有可用表情库中查找
									const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
									const foundSticker = allStickers.find((s) => s.name === stickerName);

									if (foundSticker) {
										// 找到了，就创建消息对象
										aiMessage = {
											...baseMessage,
											type: "sticker",
											content: foundSticker.url,
											meaning: foundSticker.name,
										};
									} else {
										// 没找到，说明AI幻觉了，记录警告并跳过
										console.warn(`AI在群聊中杜撰了不存在的表情: "${stickerName}"，已自动拦截。`);
									}
									break;
								}

								// 处理外卖响应消息
								case "waimai_response":
									const requestMessageIndex = chat.history.findIndex((m) => m.timestamp === msgData.for_timestamp);
									if (requestMessageIndex > -1) {
										const originalMsg = chat.history[requestMessageIndex];
										originalMsg.status = msgData.status;
										originalMsg.paidBy = msgData.status === "paid" ? msgData.name : null;
									}
									continue;

								// 处理设置群头衔消息
								case "set_group_title": {
									const actorName = msgData.name;
									const targetName = msgData.targetName;
									const newTitle = msgData.title || "";
									const myNickname = chat.settings.myNickname || "我";

									// 权限检查：群主或管理员可以设置头衔
									const actorMember = chat.members.find((m) => m.originalName === actorName);
									const isActorAdmin = actorMember && actorMember.isAdmin;
									const isActorOwner = actorMember && chat.ownerId === actorMember.id;
									if (!isActorAdmin && !isActorOwner) {
										console.warn(`AI "${actorName}" 尝试设置头衔失败，权限不足。`);
										continue;
									}

									// 核心修复逻辑：根据目标是用户自己还是其他成员进行不同处理
									if (targetName === myNickname) {
										// 如果目标是你自己
										chat.settings.myGroupTitle = newTitle.trim();
										console.log(`管理员/群主将用户 "${myNickname}" 的头衔设置为: "${newTitle.trim()}"`);
									} else {
										// 如果目标是其他成员
										const targetMember = chat.members.find((m) => m.groupNickname === targetName);
										if (targetMember) {
											targetMember.groupTitle = newTitle.trim();
											console.log(`管理员/群主将成员 "${targetName}" 的头衔设置为: "${newTitle.trim()}"`);
										} else {
											console.warn(`AI "${actorName}" 尝试设置头衔失败，因为找不到目标成员 "${targetName}"。`);
											continue;
										}
									}

									// 统一发送系统消息通知
									await logTitleChange(chat.id, actorName, targetName, newTitle.trim());

									// 刷新成员列表UI（如果打开了的话）
									if (document.getElementById("member-management-screen").classList.contains("active")) {
										renderMemberManagementList();
									}

									continue; // 后台操作，继续处理
								}

								// 处理为用户点外卖消息
								case "order_waimai_for_user": {
									const { foodName, restaurant, price, greeting } = msgData;

									// 安全检查，确保AI给的数据是对的
									if (!foodName || isNaN(price) || price <= 0) {
										console.warn("AI尝试为你点外卖，但指令格式不正确:", msgData);
										continue; // 跳过这条无效指令
									}

									// 检查角色钱包余额
									const charBalance = chat.characterPhoneData?.bank?.balance || 0;
									if (charBalance < price) {
										// 如果余额不足，就让AI发条消息告诉你
										aiMessage = {
											...baseMessage,
											content: `（小声）本来想给你点份"${foodName}"的，但是发现钱包空了...`,
										};
									} else {
										// 余额充足！执行扣款和下单逻辑
										await updateCharacterBankBalance(chatId, -price, `为你点外卖: ${foodName}`);

										const foodItem = await db.elemeFoods.where({ name: foodName, restaurant: restaurant || "私房小厨" }).first();
										const imageUrl = foodItem ? foodItem.imageUrl : getRandomWaimaiImage();
										// 创建一个漂亮的外卖卡片消息
										aiMessage = {
											...baseMessage,
											type: "waimai_gift_from_char",
											content: `[外卖惊喜] 我给你点了份"${foodName}"，记得吃哦！`, // 这段文本主要用于历史记录和通知
											payload: {
												foodName: foodName,
												restaurant: restaurant || "神秘小店",
												price: price,
												greeting: greeting || "给你点了个好吃的，快尝尝！",
												foodImageUrl: imageUrl, // 使用获取到的图片URL
											},
										};
									}
									break; // 结束这个case
								}

								// 处理设置群管理员消息
								case "set_group_admin": {
									const actorName = msgData.name;
									const targetName = msgData.targetName;
									const isAdmin = msgData.isAdmin;
									const myNickname = chat.settings.myNickname || "我"; // 获取你自己的昵称

									// 权限检查：确认操作者是群主
									const actorMember = chat.members.find((m) => m.originalName === actorName);
									if (!actorMember || chat.ownerId !== actorMember.id) {
										console.warn(`AI "${actorName}" 尝试设置管理员失败，因为它不是群主。`);
										continue; // 如果不是群主，就跳过此指令
									}

									// 核心逻辑：根据目标是用户自己还是其他成员进行不同处理
									if (targetName === myNickname) {
										// 如果AI操作的目标是你自己
										chat.settings.isUserAdmin = isAdmin;
										console.log(`群主将用户 "${myNickname}" 设置为管理员: ${isAdmin}`);
									} else {
										// 如果AI操作的目标是其他成员
										const targetMember = chat.members.find((m) => m.groupNickname === targetName);
										if (targetMember) {
											// 不能对群主进行操作
											if (targetMember.id === chat.ownerId) {
												console.warn(`AI "${actorName}" 尝试修改群主 "${targetName}" 的管理员身份，操作被阻止。`);
												continue;
											}
											targetMember.isAdmin = isAdmin;
											console.log(`群主将成员 "${targetName}" 设置为管理员: ${isAdmin}`);
										} else {
											// 如果在成员列表里也找不到目标，就跳过
											console.warn(`AI "${actorName}" 尝试设置管理员失败，因为找不到目标成员 "${targetName}"。`);
											continue;
										}
									}

									// 统一发送系统消息通知
									const actionText = isAdmin ? "设为管理员" : "取消了管理员身份";
									await logSystemMessage(chat.id, `"${actorName}"将"${targetName}"${actionText}。`);

									// 刷新成员列表UI（如果打开了的话）
									if (document.getElementById("member-management-screen").classList.contains("active")) {
										renderMemberManagementList();
									}

									continue; // 这是一个后台操作，继续处理AI可能返回的其他消息
								}

								// 处理踢出群成员消息
								case "kick_member": {
									const actorName = msgData.name;
									const targetName = msgData.targetName;
									const actorMember = chat.members.find((m) => m.originalName === actorName);

									// 权限检查：只有群主能执行
									if (actorMember && chat.ownerId === actorMember.id) {
										const targetMemberIndex = chat.members.findIndex((m) => m.groupNickname === targetName);
										if (targetMemberIndex > -1) {
											const removedMember = chat.members.splice(targetMemberIndex, 1)[0];

											// 核心修复1：将改动保存到数据库
											await db.chats.put(chat);

											// 核心修复2：发送系统通知
											await logSystemMessage(chat.id, `"${actorName}"将"${removedMember.groupNickname}"移出了群聊。`);

											// 核心修复3：如果当前正在成员管理页面，就刷新列表
											if (document.getElementById("member-management-screen").classList.contains("active")) {
												renderMemberManagementList();
											}
										}
									}
									continue; // 保持后台操作，继续处理
								}

								// 处理约会总结卡片消息
								case "dating_summary_card": {
									bubble.classList.add("is-dating-summary"); // 应用透明气泡样式
									const payload = msg.payload;
									let cardClass = "";

									// 根据卡片类型设置背景色
									if (payload.ratingType === "romantic") {
										cardClass = "romantic";
									} else if (payload.ratingType === "passionate") {
										cardClass = "passionate";
									} else if (payload.ratingType === "perfect") {
										cardClass = "perfect";
									}

									// 把 payload 字符串化后存入 data-* 属性，方便点击时读取
									const payloadString = JSON.stringify(payload).replace(/'/g, "&apos;").replace(/"/g, "&quot;");

									contentHtml = `
                                        <div class="dating-summary-chat-card ${cardClass}" data-summary-payload='${payloadString}'>
                                            <div class="rating">${payload.rating}</div>
                                            <div class="tip">点击查看详情</div>
                                        </div>
                                    `;
									break;
								}

								// 处理设置群公告消息
								case "set_group_announcement": {
									const actorName = msgData.name;
									const newAnnouncement = msgData.content;

									if (!actorName || typeof newAnnouncement === "undefined") {
										console.warn("AI尝试修改公告失败，缺少必要参数。");
										continue; // 指令不完整，跳过
									}

									// 权限检查：必须确保执行操作的角色是群主或管理员
									const actorMember = chat.members.find((m) => m.originalName === actorName);
									if (!actorMember) {
										console.warn(`AI尝试修改公告失败，找不到名为"${actorName}"的成员。`);
										continue;
									}

									const isOwner = chat.ownerId === actorMember.id;
									const isAdmin = actorMember.isAdmin;

									if (!isOwner && !isAdmin) {
										console.warn(`AI角色"${actorName}"权限不足，尝试修改群公告失败。`);
										continue; // 没有权限，跳过
									}

									// 更新公告内容
									chat.settings.groupAnnouncement = newAnnouncement;
									await db.chats.put(chat);

									// 发送一条系统消息，通知所有人群公告已更新
									await logSystemMessage(chat.id, `"${actorMember.groupNickname}"修改了群公告。`);

									// 这是一个后台管理操作，不需要在聊天中生成新的对话气泡，所以我们用 continue
									continue;
								}

								// 处理禁言成员消息
								case "mute_member": {
									const actorName = msgData.name;
									const targetName = msgData.targetName;
									const actorMember = chat.members.find((m) => m.originalName === actorName);
									const targetMember = chat.members.find((m) => m.groupNickname === targetName);

									if (actorMember && targetMember) {
										const isActorOwner = chat.ownerId === actorMember.id;
										const isActorAdmin = actorMember.isAdmin;
										const isTargetOwner = chat.ownerId === targetMember.id;
										const isTargetAdmin = targetMember.isAdmin;

										// 权限检查：群主可以禁言管理员和普通人；管理员只能禁言普通人。
										if ((isActorOwner && !isTargetOwner) || (isActorAdmin && !isTargetOwner && !isTargetAdmin)) {
											// 发送系统消息
											await logSystemMessage(chat.id, `"${actorName}"将"${targetName}"禁言。`);
										} else {
											console.warn(`AI (${actorName}) 权限不足，无法禁言 (${targetName})。`);
										}
									}
									continue; // 这也是一个后台管理操作，继续处理AI可能返回的其他消息
								}

								// 处理解禁成员消息
								case "unmute_member": {
									const actorName = msgData.name;
									const targetName = msgData.targetName;
									const actorMember = chat.members.find((m) => m.originalName === actorName);
									const targetMember = chat.members.find((m) => m.groupNickname === targetName);

									// 确保操作者和目标都存在
									if (actorMember && targetMember) {
										// 权限检查
										const isActorOwner = chat.ownerId === actorMember.id;
										const isActorAdmin = actorMember.isAdmin;
										const isTargetOwner = chat.ownerId === targetMember.id;
										const isTargetAdmin = targetMember.isAdmin;

										// 只有群主和管理员有权限解禁
										if (isActorOwner || isActorAdmin) {
											// 设置 isMuted 为 false，实现解禁
											targetMember.isMuted = false;

											// 发送一条系统消息通知大家
											await logSystemMessage(chat.id, `"${actorName}"解除了"${targetName}"的禁言。`);

											// 如果当前正在成员管理页面，刷新列表
											if (document.getElementById("member-management-screen").classList.contains("active")) {
												renderMemberManagementList();
											}
										} else {
											console.warn(`AI (${actorName}) 权限不足，无法解禁 (${targetName})。`);
										}
									}
									continue; // 这也是一个后台管理操作，继续处理AI可能返回的其他消息
								}

								// 处理发布微博消息
								case "weibo_post": {
									const newPost = {
										authorId: chatId,
										authorType: "char",
										authorNickname: chat.name,
										authorAvatar: chat.settings.aiAvatar || defaultAvatar,
										content: msgData.content || "",
										postType: msgData.postType || "text_only",
										hiddenContent: msgData.hiddenContent || "",
										imageUrl: msgData.imageUrl || "",
										imageDescription: msgData.imageDescription || "",
										timestamp: Date.now(),
										likes: [],
										comments: [], // 先初始化为空数组
										baseLikesCount: msgData.baseLikesCount || 0,
										baseCommentsCount: msgData.baseCommentsCount || 0,
									};

									// 核心逻辑：处理微博评论数据
									let commentsToProcess = [];

									// 优先处理新的、正确的【数组格式】
									if (msgData.comments && Array.isArray(msgData.comments)) {
										// 直接使用AI返回的数组
										commentsToProcess = msgData.comments;
									}
									// 兼容旧的【字符串格式】
									else if (msgData.comments && typeof msgData.comments === "string") {
										// 如果是字符串，就按老方法解析
										commentsToProcess = msgData.comments
											.split("\n")
											.map((c) => {
												const parts = c.split(/[:：]/);
												const commenter = parts.shift() || "路人";
												const commentText = parts.join(":").trim();
												return { authorNickname: commenter, commentText: commentText };
											})
											.filter((c) => c.commentText);
									}

									// 为所有解析好的评论，统一添加前端需要的 commentId
									if (commentsToProcess.length > 0) {
										newPost.comments = commentsToProcess.map((c) => ({
											commentId: "comment_" + Date.now() + Math.random(), // 确保每条评论都有唯一ID
											authorNickname: c.authorNickname,
											commentText: c.commentText,
										}));
									}

									await db.weiboPosts.add(newPost);

									showNotification(chatId, `${chat.name} 发了一条新微博`);

									if (document.getElementById("weibo-screen").classList.contains("active")) {
										await renderFollowingWeiboFeed();
									}

									continue; // 这是后台操作，用 continue 跳过
								}

								// 处理评论微博消息
								case "weibo_comment": {
									// 这是一个AI评论微博的指令
									const postIdToComment = msgData.postId;
									const commentText = msgData.commentText;

									// 根据 postId 从数据库里找到那条微博
									const postToComment = await db.weiboPosts.get(postIdToComment);

									if (postToComment) {
										// 如果找到了微博，就准备一条新评论
										if (!postToComment.comments) postToComment.comments = []; // 确保评论区存在
										const newComment = {
											commentId: "comment_" + Date.now(), // 给评论一个独一无二的ID
											authorId: chatId, // 评论者是当前AI
											authorNickname: chat.name, // 评论者的名字
											commentText: commentText, // 评论内容
											timestamp: Date.now(), // 评论时间
										};

										// 把新评论加到微博的评论列表里
										postToComment.comments.push(newComment);

										// 把更新后的微博存回数据库
										await db.weiboPosts.put(postToComment);

										// 刷新"我的微博"和"关注的人"两个列表，让新评论显示出来
										await renderMyWeiboFeed();
										await renderFollowingWeiboFeed();
									}
									continue; // 处理完后，继续处理AI可能返回的其他指令
								}

								// 处理回复微博评论消息
								case "weibo_reply": {
									// 这是一个AI回复微博评论的指令
									const postIdToReply = msgData.postId;
									const commentIdToReply = msgData.commentId;
									const replyText = msgData.replyText;

									const postToReply = await db.weiboPosts.get(postIdToReply);

									if (postToReply && postToReply.comments) {
										// 在微博的评论区里，找到被回复的那条评论
										const targetComment = postToReply.comments.find((c) => c.commentId === commentIdToReply);

										if (targetComment) {
											// 准备一条新的"回复"
											const newReply = {
												commentId: "comment_" + Date.now(),
												authorId: chatId,
												authorNickname: chat.name,
												commentText: replyText,
												timestamp: Date.now(),
												replyToId: commentIdToReply, // 标记这是对哪条评论的回复
												replyToNickname: targetComment.authorNickname, // 记下被回复人的名字
											};
											postToReply.comments.push(newReply);
											await db.weiboPosts.put(postToReply);

											// 同样，刷新所有列表
											await renderMyWeiboFeed();
											await renderFollowingWeiboFeed();
										}
									}
									continue; // 继续处理
								}

								// 处理情侣空间回应消息
								case "lovers_space_response": {
									const invitationMsg = chat.history.find((m) => m.type === "lovers_space_invitation" && m.status === "pending");
									if (invitationMsg) {
										invitationMsg.status = msgData.decision === "accept" ? "accepted" : "rejected";

										// 创建AI想说的那句话的消息
										if (msgData.responseText) {
											const responseMessage = {
												...baseMessage, // 复用时间戳和发送者信息
												type: "text",
												content: msgData.responseText,
											};
											chat.history.push(responseMessage);
											if (isViewingThisChat) {
												appendMessage(responseMessage, chat);
											}
										}

										// 根据同意或拒绝，执行后续操作
										if (msgData.decision === "accept") {
											chat.loversSpaceData = {
												background: "https://i.postimg.cc/k495F4W5/profile-banner.jpg",
												relationshipStartDate: null,
												moments: [],
												photos: [],
												albums: [],
												loveLetters: [],
												shares: [],
												questions: [],
											};
											const systemNotice = {
												role: "system",
												type: "pat_message",
												content: `[系统：你和"${chat.name}"的情侣空间已成功开启！]`,
												timestamp: Date.now(),
											};
											chat.history.push(systemNotice);
											if (isViewingThisChat) {
												appendMessage(systemNotice, chat);
											}
										}
									}
									// 处理完后，不再需要重新触发AI，所以我们用 continue
									continue;
								}

								// 处理与宠物互动的消息
								case "interact_with_pet": {
									const pet = chat.settings.pet;
									if (pet && pet.type !== "无") {
										let actionText = "";
										// 根据AI的互动，修改数值
										switch (msgData.action) {
											case "feed":
												pet.status.hunger = Math.min(100, (pet.status.hunger || 0) + 20);
												pet.status.happiness = Math.min(100, (pet.status.happiness || 0) + 5);
												// AI喂食，增加对AI的亲密度
												pet.status.intimacyToChar = Math.min(100, (pet.status.intimacyToChar || 0) + 10);
												actionText = `${chat.name} 喂了 ${pet.name} 一些食物。`;
												break;
											case "play":
												pet.status.hunger = Math.max(0, (pet.status.hunger || 0) - 10);
												pet.status.happiness = Math.min(100, (pet.status.happiness || 0) + 15);
												// AI玩耍，增加对AI的亲密度
												pet.status.intimacyToChar = Math.min(100, (pet.status.intimacyToChar || 0) + 15);
												actionText = `${chat.name} 陪 ${pet.name} 玩了一会儿。`;
												break;
											case "touch":
												pet.status.happiness = Math.min(100, (pet.status.happiness || 0) + 10);
												// AI抚摸，增加对AI的亲密度
												pet.status.intimacyToChar = Math.min(100, (pet.status.intimacyToChar || 0) + 5);
												actionText = `${chat.name} 轻轻地抚摸了 ${pet.name}。`;
												break;
										}

										// 创建一条对用户可见的系统消息
										const visibleMessage = {
											role: "system",
											type: "pat_message",
											content: `[系统：${actionText}]`,
											timestamp: Date.now(),
										};
										chat.history.push(visibleMessage);
										if (isViewingThisChat) {
											appendMessage(visibleMessage, chat);
										}

										// 如果 AI 在互动后还想说点什么
										if (msgData.response) {
											aiMessage = { ...baseMessage, content: msgData.response };
										}
									}
									// 如果AI只是互动没说话，就不创建aiMessage，直接跳到下一个指令
									if (!aiMessage) {
										continue;
									}
									break;
								}

								// 处理对宠物说话的消息
								case "talk_to_pet": {
									if (!chat.isGroup && chat.settings.pet && chat.settings.pet.type !== "无") {
										const pet = chat.settings.pet;

										// 兼容 content 和 message 字段
										const charMessageContent = msgData.content || msgData.message;
										if (!charMessageContent) continue; // 如果没内容，就跳过

										// 将Char的话添加到宠物聊天记录
										const charMessageToPet = {
											sender: "char",
											senderName: chat.name,
											content: charMessageContent,
										};
										pet.petChatHistory.push(charMessageToPet);

										// 获取宠物的回应
										const petResponseToChar = await getPetApiResponse(pet);
										if (petResponseToChar) {
											pet.petChatHistory.push({ sender: "pet", content: petResponseToChar });
										}

										// 创建对用户可见的系统日志
										const visibleLog = `[系统：“${chat.name}”对宠物“${pet.name}”说：“${charMessageContent}”，它回应：“${petResponseToChar || "(没有回应)"}”。]`;
										const visibleMessage = {
											role: "system",
											type: "pat_message",
											content: visibleLog,
											timestamp: messageTimestamp++,
										};
										chat.history.push(visibleMessage);

										if (isViewingThisChat) {
											appendMessage(visibleMessage, chat);
										}
									}
									continue;
								}

								// 处理购物车代付响应消息
								case "cart_payment_response": {
									const decision = msgData.decision;
									const responseText = msgData.response_text;

									// 找到用户发出的、还处于"等待中"的那个代付请求
									const requestMsg = chat.history.find((m) => m.type === "cart_share_request" && m.payload.status === "pending");
									if (!requestMsg) continue; // 如果找不到，说明请求可能已被处理，跳过

									if (decision === "accept") {
										const totalPrice = requestMsg.payload.totalPrice;
										const charBalance = chat.characterPhoneData?.bank?.balance || 0;

										// 再次确认AI的余额是否足够
										if (charBalance < totalPrice) {
											// 如果AI想付但钱不够，就让它说一句俏皮话
											aiMessage = { ...baseMessage, content: responseText || "呜呜，想给你买，但是我的钱包空空了..." };
										} else {
											// 钱够，执行代付流程！
											requestMsg.payload.status = "paid";

											// 使用 await 确保这些数据库操作按顺序完成
											await updateCharacterPhoneBankBalance(chat.id, -totalPrice, `为"我"的桃宝购物车买单`);
											const cartItems = await db.taobaoCart.toArray();
											await createOrdersFromCart(cartItems);
											await clearTaobaoCart();

											// 创建AI的回复消息
											aiMessage = { ...baseMessage, content: responseText || "买好啦，快去订单里看看吧！" };
										}
									} else {
										// 如果AI决定拒绝
										requestMsg.payload.status = "rejected";
										aiMessage = { ...baseMessage, content: responseText || "这次就算了吧，下次一定！" };
									}

									// 将AI的回复消息推入历史记录，并更新UI
									if (aiMessage) {
										chat.history.push(aiMessage);
									}

									// 重新渲染聊天界面，以更新代付卡片的状态
									if (isViewingThisChat) {
										renderChatInterface(chatId);
									}
									// 跳过后续的默认消息处理
									continue;
								}

								// 处理为用户购买礼物的消息
								case "buy_gift_for_user": {
									// 从商品数据库中获取所有已添加的商品
									const allProducts = await db.taobaoProducts.toArray();

									// 如果桃宝里一件商品都没有，AI就发条消息吐槽一下
									if (allProducts.length === 0) {
										aiMessage = { ...baseMessage, content: msgData.greeting ? `${msgData.greeting} ...啊，想给你买点什么，但是桃宝里空空如也呢...` : "想给你买个礼物，但是桃宝现在没东西卖了。" };
										break; // 跳出 case，让这条文本消息被正常处理和显示
									}

									// 从所有商品中随机挑选一件作为礼物
									const productToBuy = getRandomItem(allProducts);

									// 检查角色的钱包余额是否足够
									const charBalance = chat.characterPhoneData?.bank?.balance || 0;
									if (charBalance < productToBuy.price) {
										// 余额不足，AI也会发消息告诉你
										aiMessage = { ...baseMessage, content: msgData.greeting ? `${msgData.greeting} ...哎呀，我的钱包好像不够了。` : "我想给你买个礼物，但是钱包空了..." };
										break;
									}

									// 余额充足！执行购买流程
									// 从角色的钱包扣款，并生成一条交易记录
									await updateCharacterPhoneBankBalance(chat.id, -productToBuy.price, `为"我"购买礼物: ${productToBuy.name}`);

									// 在你的"我的订单"中创建一条新订单
									const newOrder = {
										productId: productToBuy.id,
										quantity: 1,
										timestamp: Date.now(),
										status: "已付款，等待发货",
									};
									await db.taobaoOrders.add(newOrder);

									// 创建一个漂亮的"礼物通知"卡片消息，发送给你
									aiMessage = {
										...baseMessage, // 复用基础消息属性（发送者、时间戳等）
										type: "gift_notification",
										// 这是卡片渲染需要的数据
										payload: {
											senderName: chat.name,
											itemSummary: `${productToBuy.name} x1`,
											totalPrice: productToBuy.price,
											itemCount: 1,
										},
										// 这是给AI自己看的、用于形成记忆的文本内容
										content: `我给你买了礼物"${productToBuy.name}"。${msgData.greeting || ""}`,
									};

									// 模拟一个10秒后的"已发货"物流更新
									setTimeout(async () => {
										const orderToUpdate = await db.taobaoOrders.where({ timestamp: newOrder.timestamp }).first();
										if (orderToUpdate) {
											await db.taobaoOrders.update(orderToUpdate.id, { status: "已发货，运输中" });
										}
									}, 1000 * 10);

									break; // 完成礼物购买逻辑，跳出 case
								}

								// 处理情侣空间回答问题的消息
								case "ls_answer_question": {
									// 使用大括号创建块级作用域
									const { questionId, answerText } = msgData;
									if (questionId && answerText) {
										const question = chat.loversSpaceData.questions.find((q) => q.id === questionId);
										if (question && !question.answerText) {
											// 确保是未回答的问题
											question.answerer = "char";
											question.answerText = answerText;
											console.log(`AI 回答了情侣提问 (ID: ${questionId})`);
										}
									}
									continue; // 这是一个后台操作，不需要在聊天界面显示，所以用 continue 跳过
								}

								// 处理情侣空间发起问题的消息
								case "ls_ask_question": {
									const { questionText } = msgData;
									if (questionText) {
										const newQuestion = {
											id: "q_" + Date.now(),
											questioner: "char",
											questionText: questionText,
											timestamp: Date.now(),
											answerer: "user", // 指定由用户来回答
											answerText: null,
										};
										if (!chat.loversSpaceData.questions) {
											chat.loversSpaceData.questions = [];
										}
										chat.loversSpaceData.questions.push(newQuestion);
										console.log(`AI 发起了一个情侣提问: ${questionText}`);
									}
									continue; // 同样是后台操作
								}

								// 处理情侣空间发布说说的消息
								case "ls_moment": {
									if (chat.loversSpaceData) {
										if (!chat.loversSpaceData.moments) {
											chat.loversSpaceData.moments = [];
										}
										const newMoment = {
											author: "char", // 标记是AI发的
											content: msgData.content,
											timestamp: Date.now(),
											comments: [], // 为新说说初始化一个空的评论区
										};
										chat.loversSpaceData.moments.push(newMoment);
										console.log(`AI 在情侣空间发布了说说: ${msgData.content}`);
									}
									continue; // 这是一个后台操作，不需要在聊天界面显示，所以用 continue 跳过
								}

								// 处理情侣空间评论说说的消息
								case "ls_comment": {
									const { momentIndex, commentText } = msgData;
									if (chat.loversSpaceData && chat.loversSpaceData.moments) {
										// AI返回的 index 是从0开始代表最新的，我们需要转换成真实索引
										const realIndex = chat.loversSpaceData.moments.length - 1 - momentIndex;
										if (realIndex >= 0 && realIndex < chat.loversSpaceData.moments.length) {
											const momentToComment = chat.loversSpaceData.moments[realIndex];
											if (!momentToComment.comments) {
												momentToComment.comments = [];
											}
											momentToComment.comments.push({
												author: chat.name,
												text: commentText,
											});
											console.log(`AI 评论了情侣空间说说 (索引: ${realIndex}): ${commentText}`);
										}
									}
									continue; // 同样是后台操作
								}

								// 处理情侣空间发布照片的消息
								case "ls_photo": {
									// 这是处理AI发相册的逻辑
									if (chat.loversSpaceData) {
										if (!chat.loversSpaceData.photos) {
											chat.loversSpaceData.photos = [];
										}
										const newPhoto = {
											author: "char",
											type: "text_image",
											description: msgData.description,
											timestamp: Date.now(),
										};
										chat.loversSpaceData.photos.push(newPhoto);
										console.log(`AI 在情侣空间发布了照片(文字图): ${msgData.description}`);
									}
									continue; // 继续处理AI可能返回的其他指令
								}

								// 处理情侣空间写情书的消息
								case "ls_letter": {
									// 这是处理AI写情书的逻辑
									if (chat.loversSpaceData) {
										if (!chat.loversSpaceData.loveLetters) {
											chat.loversSpaceData.loveLetters = [];
										}
										const newLetter = {
											id: "letter_" + Date.now(),
											senderId: chat.id,
											senderName: chat.name,
											senderAvatar: chat.settings.aiAvatar,
											recipientName: chat.settings.myNickname || "我",
											recipientAvatar: chat.settings.myAvatar,
											content: msgData.content,
											timestamp: Date.now(),
										};
										chat.loversSpaceData.loveLetters.push(newLetter);
										console.log(`AI 在情侣空间写了情书: ${msgData.content}`);
									}
									continue; // 继续处理AI可能返回的其他指令
								}

								// 处理情侣空间记录日记的消息
								case "ls_diary_entry": {
									const { emoji, diary } = msgData;
									if (emoji && diary) {
										const today = new Date().toISOString().split("T")[0]; // 获取 YYYY-MM-DD 格式的今天日期

										// 确保数据结构存在
										if (!chat.loversSpaceData.emotionDiaries) {
											chat.loversSpaceData.emotionDiaries = {};
										}
										if (!chat.loversSpaceData.emotionDiaries[today]) {
											chat.loversSpaceData.emotionDiaries[today] = {};
										}

										// 保存AI的日记和表情
										chat.loversSpaceData.emotionDiaries[today].charEmoji = emoji;
										chat.loversSpaceData.emotionDiaries[today].charDiary = diary;

										console.log(`AI 在情侣空间记录了日记: ${emoji} ${diary}`);
									}
									continue; // 这只是一个后台操作，不需要在聊天界面生成消息，所以用 continue 跳过
								}

								// 处理情侣空间分享内容的消息
								case "ls_share": {
									if (chat.loversSpaceData) {
										if (!chat.loversSpaceData.shares) {
											chat.loversSpaceData.shares = [];
										}
										const newShare = {
											author: "char", // 标记是AI发的
											timestamp: Date.now(),
											...msgData, // 将AI返回的所有分享信息（type, shareType, title, artist等）都复制过来
										};
										chat.loversSpaceData.shares.push(newShare);
										console.log(`AI 在情侣空间分享了 [${msgData.shareType}]: ${msgData.title}`);
									}
									continue; // 同样是后台操作
								}

								// 处理情侣空间邀请消息
								case "lovers_space_invitation": {
									// 检查是否已经开启，防止AI重复邀请
									if (!chat.loversSpaceData) {
										aiMessage = {
											...baseMessage,
											type: "lovers_space_invitation",
											content: `${chat.name} 向你发出了一个情侣空间邀请`, // 这句话主要用于调试和历史记录
											status: "pending", // 状态：pending, accepted, rejected
										};
									}
									// 如果AI已经发了邀请，这里就不再创建aiMessage，相当于跳过
									break;
								}

								// 处理情侣空间邀请响应消息
								case "lovers_space_response": {
									const invitationMsg = chat.history.find((m) => m.type === "lovers_space_invitation" && m.status === "pending");
									if (invitationMsg) {
										invitationMsg.status = msgData.decision === "accept" ? "accepted" : "rejected";

										// 创建AI想说的那句话的消息
										if (msgData.responseText) {
											const responseMessage = {
												...baseMessage,
												type: "text",
												content: msgData.responseText,
											};
											chat.history.push(responseMessage);
											if (isViewingThisChat) {
												appendMessage(responseMessage, chat);
											}
										}

										// 根据同意或拒绝，执行后续操作
										if (msgData.decision === "accept") {
											// 同意后，为这个角色创建情侣空间数据
											chat.loversSpaceData = {
												background: "https://i.postimg.cc/k495F4W5/profile-banner.jpg",
												relationshipStartDate: null,
												moments: [],
												photos: [],
												albums: [],
												loveLetters: [],
												shares: [],
												questions: [],
											};
											// 并发送一条系统通知
											const systemNotice = {
												role: "system",
												type: "pat_message",
												content: `[系统：你和"${chat.name}"的情侣空间已成功开启！]`,
												timestamp: Date.now(),
											};
											chat.history.push(systemNotice);
											if (isViewingThisChat) {
												appendMessage(systemNotice, chat);
											}
										}
									}
									// 处理完后，不再需要生成新的aiMessage，所以用 continue 跳过
									continue;
								}

								// 处理发布QQ空间动态消息
								case "qzone_post":
									const newPost = {
										type: msgData.postType,
										content: msgData.content || "",
										publicText: msgData.publicText || "",
										hiddenContent: msgData.hiddenContent || "",
										timestamp: Date.now(),
										authorId: chatId,
										authorGroupId: chat.groupId, // 记录作者的分组ID
										visibleGroupIds: null,
									};

									// 如果是realimag类型，生成真实图片URL（支持1-9张图片）
									if (msgData.postType === "realimag" && msgData.prompt) {
										// 支持 prompt 为数组（多张图片）或字符串（单张图片）
										const prompts = Array.isArray(msgData.prompt) ? msgData.prompt.slice(0, 9) : [msgData.prompt];

										// 生成多个图片URL（添加nologo参数去除水印）
										newPost.imageUrls = prompts.map((prompt) => {
											const encodedPrompt = encodeURIComponent(prompt);
											return `https://image.pollinations.ai/prompt/${encodedPrompt}?nologo=true&width=1024&height=1024`;
										});

										// 保持向后兼容，单张图片时也设置 imageUrl
										if (prompts.length === 1) {
											newPost.imageUrl = newPost.imageUrls[0];
										}

										newPost.prompt = msgData.prompt;
										newPost.imageCount = prompts.length;
										console.log(`动态RealImag图片生成: ${prompts.length}张`, newPost.imageUrls);
									}

									// 如果是naiimag类型，调用NovelAI API生成高质量图片（限制最多2张）
									if (msgData.postType === "naiimag" && msgData.prompt) {
										try {
											// 支持 prompt 为数组（多张图片）或字符串（单张图片）
											// 动态限制最多2张NAI图片
											const prompts = Array.isArray(msgData.prompt) ? msgData.prompt.slice(0, 2) : [msgData.prompt];
											console.log(`📸 动态NovelAI图片生成开始，共${prompts.length}张图片`);

											// 存储生成的图片URL
											const generatedImageUrls = [];

											// 逐个生成图片
											for (let i = 0; i < prompts.length; i++) {
												const aiPrompt = prompts[i];
												console.log(`生成第${i + 1}张图片，prompt:`, aiPrompt);

												// 获取角色的NAI提示词配置（系统或角色专属）
												const naiPrompts = getCharacterNAIPrompts(chat.id);

												// 构建最终的提示词：AI的prompt + 配置的提示词
												const finalPositivePrompt = aiPrompt + ", " + naiPrompts.positive;
												const finalNegativePrompt = naiPrompts.negative;

												console.log(`📝 使用${naiPrompts.source === "character" ? "角色专属" : "系统"}提示词配置`);
												console.log("最终正面提示词:", finalPositivePrompt);
												console.log("最终负面提示词:", finalNegativePrompt);

												// 获取NAI设置（从localStorage读取）
												const apiKey = localStorage.getItem("novelai-api-key");
												const model = localStorage.getItem("novelai-model") || "nai-diffusion-4-5-full";
												const settings = getNovelAISettings();

												if (!apiKey) {
													throw new Error("NovelAI API Key未配置。请在NovelAI设置中填写API Key。");
												}

												const [width, height] = settings.resolution.split("x").map(Number);

												// V4/V4.5 和 V3 使用不同的请求体格式
												let requestBody;

												if (model.includes("nai-diffusion-4")) {
													// V4/V4.5 使用新格式 (params_version: 3)
													requestBody = {
														input: finalPositivePrompt,
														model: model,
														action: "generate",
														parameters: {
															params_version: 3, // V4必须使用版本3
															width: width,
															height: height,
															scale: settings.cfg_scale,
															sampler: settings.sampler,
															steps: settings.steps,
															seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
															n_samples: 1,
															ucPreset: settings.uc_preset,
															qualityToggle: settings.quality_toggle,
															autoSmea: false,
															dynamic_thresholding: false,
															controlnet_strength: 1,
															legacy: false,
															add_original_image: true,
															cfg_rescale: 0,
															noise_schedule: "karras", // V4使用karras
															legacy_v3_extend: false,
															skip_cfg_above_sigma: null,
															use_coords: false,
															legacy_uc: false,
															normalize_reference_strength_multiple: true,
															inpaintImg2ImgStrength: 1,
															characterPrompts: [],
															// V4专用提示词格式
															v4_prompt: {
																caption: {
																	base_caption: finalPositivePrompt,
																	char_captions: [],
																},
																use_coords: false,
																use_order: true,
															},
															// V4专用负面提示词格式
															v4_negative_prompt: {
																caption: {
																	base_caption: finalNegativePrompt,
																	char_captions: [],
																},
																legacy_uc: false,
															},
															negative_prompt: finalNegativePrompt,
															deliberate_euler_ancestral_bug: false,
															prefer_brownian: true,
															// 注意：不包含 stream 参数，使用标准ZIP响应而非msgpack流
														},
													};
												} else {
													// V3 及更早版本使用旧格式
													requestBody = {
														input: finalPositivePrompt,
														model: model,
														action: "generate",
														parameters: {
															width: width,
															height: height,
															scale: settings.cfg_scale,
															sampler: settings.sampler,
															steps: settings.steps,
															seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
															n_samples: 1,
															ucPreset: settings.uc_preset,
															qualityToggle: settings.quality_toggle,
															sm: settings.smea,
															sm_dyn: settings.smea_dyn,
															dynamic_thresholding: false,
															controlnet_strength: 1,
															legacy: false,
															add_original_image: false,
															cfg_rescale: 0,
															noise_schedule: "native",
															negative_prompt: finalNegativePrompt,
														},
													};
												}

												console.log("🚀 发送NAI请求:", requestBody);

												// 根据模型选择不同的API端点
												let apiUrl;

												// V4/V4.5 模型使用流式端点
												if (model.includes("nai-diffusion-4")) {
													// V4/V4.5 默认使用流式端点
													apiUrl = "https://image.novelai.net/ai/generate-image-stream";
												} else {
													// V3 及更早版本使用标准端点
													apiUrl = "https://image.novelai.net/ai/generate-image";
												}

												let corsProxy = settings.cors_proxy;

												// 如果选择了自定义代理，使用自定义URL
												if (corsProxy === "custom") {
													corsProxy = settings.custom_proxy_url || "";
												}

												// 如果有代理，添加到URL前面
												if (corsProxy && corsProxy !== "") {
													apiUrl = corsProxy + encodeURIComponent(apiUrl);
												}

												const response = await fetch(apiUrl, {
													method: "POST",
													headers: {
														"Content-Type": "application/json",
														Authorization: "Bearer " + apiKey,
													},
													body: JSON.stringify(requestBody),
												});

												console.log("Response status:", response.status);
												console.log("Response headers:", [...response.headers.entries()]);

												if (!response.ok) {
													const errorText = await response.text();
													console.error("API错误响应:", errorText);
													throw new Error(`API请求失败 (${response.status}): ${errorText}`);
												}

												// NovelAI API返回的是ZIP文件，需要解压
												const contentType = response.headers.get("content-type");
												console.log("Content-Type:", contentType);

												// 检查是否为 SSE 流式响应
												let zipBlob;
												let imageDataUrl;
												if (contentType && contentType.includes("text/event-stream")) {
													console.log("检测到 SSE 流式响应，开始解析...");

													// 读取整个流
													const text = await response.text();
													console.log("收到 SSE 数据，大小:", text.length);

													// 解析 SSE 格式，提取最后的 data: 行
													const lines = text.trim().split("\n");
													let base64Data = null;

													for (let i = lines.length - 1; i >= 0; i--) {
														const line = lines[i].trim();
														if (line.startsWith("data: ") && line !== "data: [DONE]") {
															const dataContent = line.substring(6); // 移除 'data: ' 前缀

															// 尝试解析 JSON
															try {
																const jsonData = JSON.parse(dataContent);

																// V4.5 流式端点：event_type 为 "final" 时包含最终图片
																if (jsonData.event_type === "final" && jsonData.image) {
																	base64Data = jsonData.image;
																	console.log("✅ 找到 final 事件的图片数据");
																	break;
																}

																// 兼容其他格式
																if (jsonData.data) {
																	base64Data = jsonData.data;
																	console.log("从 JSON.data 中提取图片数据");
																	break;
																}
																if (jsonData.image) {
																	base64Data = jsonData.image;
																	console.log("从 JSON.image 中提取图片数据");
																	break;
																}
															} catch (e) {
																// 如果不是 JSON，直接作为 base64 数据
																base64Data = dataContent;
																console.log("直接使用 base64 数据");
																break;
															}
														}
													}

													if (!base64Data) {
														throw new Error("无法从 SSE 响应中提取图片数据");
													}

													// V4.5 流式端点返回的是 PNG base64，不是 ZIP
													// 检查是否为 PNG (以 iVBORw0KGgo 开头) 或 JPEG (以 /9j/ 开头)
													const isPNG = base64Data.startsWith("iVBORw0KGgo");
													const isJPEG = base64Data.startsWith("/9j/");

													if (isPNG || isJPEG) {
														console.log("✅ 检测到直接的图片 base64 数据 (PNG/JPEG)");
														// 将 base64 转为 Blob
														const binaryString = atob(base64Data);
														const bytes = new Uint8Array(binaryString.length);
														for (let i = 0; i < binaryString.length; i++) {
															bytes[i] = binaryString.charCodeAt(i);
														}
														const imageBlob = new Blob([bytes], { type: isPNG ? "image/png" : "image/jpeg" });
														console.log("图片 Blob 创建成功，大小:", imageBlob.size);

														// 转换为dataURL用于后续处理
														const reader = new FileReader();
														imageDataUrl = await new Promise((resolve, reject) => {
															reader.onloadend = () => resolve(reader.result);
															reader.onerror = reject;
															reader.readAsDataURL(imageBlob);
														});
														console.log("✅ 图片转换成功！🎨");
													} else {
														// 否则当作 ZIP 处理
														console.log("当作 ZIP 文件处理...");
														const binaryString = atob(base64Data);
														const bytes = new Uint8Array(binaryString.length);
														for (let i = 0; i < binaryString.length; i++) {
															bytes[i] = binaryString.charCodeAt(i);
														}
														zipBlob = new Blob([bytes]);
														console.log("ZIP Blob 大小:", zipBlob.size);
													}
												} else {
													// 非流式响应，直接读取
													zipBlob = await response.blob();
													console.log("收到数据，类型:", zipBlob.type, "大小:", zipBlob.size);
												}

												// 如果还没有imageDataUrl（即需要解压ZIP）
												if (!imageDataUrl && zipBlob) {
													// NovelAI始终返回ZIP格式，需要解压
													try {
														// 检查JSZip是否已加载
														if (typeof JSZip === "undefined") {
															throw new Error("JSZip库未加载，请刷新页面重试");
														}

														// 解压ZIP文件
														const zip = await JSZip.loadAsync(zipBlob);
														console.log("ZIP文件内容:", Object.keys(zip.files));

														// 查找第一个图片文件（通常是image_0.png）
														let imageFile = null;
														for (let filename in zip.files) {
															if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
																imageFile = zip.files[filename];
																console.log("找到图片文件:", filename);
																break;
															}
														}

														if (!imageFile) {
															throw new Error("ZIP文件中未找到图片");
														}

														// 提取图片数据
														const imageBlob = await imageFile.async("blob");
														console.log("提取的图片大小:", imageBlob.size);

														// 创建图片URL
														const reader = new FileReader();
														imageDataUrl = await new Promise((resolve, reject) => {
															reader.onloadend = () => resolve(reader.result);
															reader.onerror = reject;
															reader.readAsDataURL(imageBlob);
														});
														console.log("✅ 图片解压成功！");
													} catch (zipError) {
														console.error("ZIP解压失败:", zipError);
														throw new Error("图片解压失败: " + zipError.message);
													}
												}

												console.log(`✅ NAI图片${i + 1}生成成功！`);
												generatedImageUrls.push(imageDataUrl);
											}

											// 将生成的图片URL保存到动态中
											newPost.imageUrls = generatedImageUrls;

											// 保持向后兼容，单张图片时也设置 imageUrl
											if (generatedImageUrls.length === 1) {
												newPost.imageUrl = generatedImageUrls[0];
											}

											newPost.prompt = msgData.prompt;
											newPost.imageCount = generatedImageUrls.length;
											console.log(`✅ 动态NovelAI图片全部生成完成: ${generatedImageUrls.length}张`);
										} catch (error) {
											console.error("❌ 动态NAI图片生成失败:", error);
											// 失败时仍然发布动态，但添加错误信息
											newPost.content = (newPost.content || newPost.publicText || "") + `\n[图片生成失败: ${error.message}]`;
										}
									}

									await db.qzonePosts.add(newPost);
									updateUnreadIndicator(unreadPostsCount + 1);
									if (isViewingThisChat && document.getElementById("qzone-screen").classList.contains("active")) {
										await renderQzonePosts();
									}
									continue;

								// 处理QQ空间动态评论消息
								case "qzone_comment":
									const postToComment = await db.qzonePosts.get(parseInt(msgData.postId));
									if (postToComment) {
										if (!postToComment.comments) postToComment.comments = [];

										const newAiComment = {
											commenterName: msgData.commenterName || chat.name,
											text: msgData.commentText,
											timestamp: Date.now(),
										};

										// 检查AI是否指定了回复对象
										if (msgData.replyTo) {
											newAiComment.replyTo = msgData.replyTo;
										}

										postToComment.comments.push(newAiComment);
										await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
										updateUnreadIndicator(unreadPostsCount + 1);
										if (isViewingThisChat && document.getElementById("qzone-screen").classList.contains("active")) {
											await renderQzonePosts();
										}
									}
									continue;

								// 处理NovelAI图片生成消息（群聊中）
								case "naiimag":
									// NovelAI图片分享 - 调用NovelAI API生成高质量图片
									try {
										console.log("📸 NovelAI图片生成开始，AI提供的prompt:", msgData.prompt);

										// 获取角色的NAI提示词配置（系统或角色专属）
										const naiPrompts = getCharacterNAIPrompts(chat.id);

										// 构建最终的提示词：AI的prompt + 配置的提示词
										const aiPrompt = msgData.prompt || "a beautiful scene";
										const finalPositivePrompt = aiPrompt + ", " + naiPrompts.positive;
										const finalNegativePrompt = naiPrompts.negative;

										console.log(`📝 使用${naiPrompts.source === "character" ? "角色专属" : "系统"}提示词配置`);
										console.log("最终正面提示词:", finalPositivePrompt);
										console.log("最终负面提示词:", finalNegativePrompt);

										// 获取NAI设置（从localStorage读取）
										const apiKey = localStorage.getItem("novelai-api-key");
										const model = localStorage.getItem("novelai-model") || "nai-diffusion-4-5-full";
										const settings = getNovelAISettings();

										if (!apiKey) {
											throw new Error("NovelAI API Key未配置。请在NovelAI设置中填写API Key。");
										}

										const [width, height] = settings.resolution.split("x").map(Number);

										// V4/V4.5 和 V3 使用不同的请求体格式
										let requestBody;

										if (model.includes("nai-diffusion-4")) {
											// V4/V4.5 使用新格式 (params_version: 3)
											requestBody = {
												input: finalPositivePrompt,
												model: model,
												action: "generate",
												parameters: {
													params_version: 3, // V4必须使用版本3
													width: width,
													height: height,
													scale: settings.cfg_scale,
													sampler: settings.sampler,
													steps: settings.steps,
													seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
													n_samples: 1,
													ucPreset: settings.uc_preset,
													qualityToggle: settings.quality_toggle,
													autoSmea: false,
													dynamic_thresholding: false,
													controlnet_strength: 1,
													legacy: false,
													add_original_image: true,
													cfg_rescale: 0,
													noise_schedule: "karras", // V4使用karras
													legacy_v3_extend: false,
													skip_cfg_above_sigma: null,
													use_coords: false,
													legacy_uc: false,
													normalize_reference_strength_multiple: true,
													inpaintImg2ImgStrength: 1,
													characterPrompts: [],
													// V4专用提示词格式
													v4_prompt: {
														caption: {
															base_caption: finalPositivePrompt,
															char_captions: [],
														},
														use_coords: false,
														use_order: true,
													},
													// V4专用负面提示词格式
													v4_negative_prompt: {
														caption: {
															base_caption: finalNegativePrompt,
															char_captions: [],
														},
														legacy_uc: false,
													},
													negative_prompt: finalNegativePrompt,
													deliberate_euler_ancestral_bug: false,
													prefer_brownian: true,
													// 注意：不包含 stream 参数，使用标准ZIP响应而非msgpack流
												},
											};
										} else {
											// V3 及更早版本使用旧格式
											requestBody = {
												input: finalPositivePrompt,
												model: model,
												action: "generate",
												parameters: {
													width: width,
													height: height,
													scale: settings.cfg_scale,
													sampler: settings.sampler,
													steps: settings.steps,
													seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
													n_samples: 1,
													ucPreset: settings.uc_preset,
													qualityToggle: settings.quality_toggle,
													sm: settings.smea,
													sm_dyn: settings.smea_dyn,
													dynamic_thresholding: false,
													controlnet_strength: 1,
													legacy: false,
													add_original_image: false,
													cfg_rescale: 0,
													noise_schedule: "native",
													negative_prompt: finalNegativePrompt,
												},
											};
										}

										console.log("🚀 发送NAI请求:", requestBody);

										// 根据模型选择不同的API端点
										let apiUrl;

										// V4/V4.5 模型使用流式端点
										if (model.includes("nai-diffusion-4")) {
											// V4/V4.5 默认使用流式端点
											apiUrl = "https://image.novelai.net/ai/generate-image-stream";
										} else {
											// V3 及更早版本使用标准端点
											apiUrl = "https://image.novelai.net/ai/generate-image";
										}

										let corsProxy = settings.cors_proxy;

										// 如果选择了自定义代理，使用自定义URL
										if (corsProxy === "custom") {
											corsProxy = settings.custom_proxy_url || "";
										}

										// 如果有代理，添加到URL前面
										if (corsProxy && corsProxy !== "") {
											apiUrl = corsProxy + encodeURIComponent(apiUrl);
										}

										const response = await fetch(apiUrl, {
											method: "POST",
											headers: {
												"Content-Type": "application/json",
												Authorization: "Bearer " + apiKey,
											},
											body: JSON.stringify(requestBody),
										});

										console.log("Response status:", response.status);
										console.log("Response headers:", [...response.headers.entries()]);

										if (!response.ok) {
											const errorText = await response.text();
											console.error("API错误响应:", errorText);
											throw new Error(`API请求失败 (${response.status}): ${errorText}`);
										}

										// NovelAI API返回的是ZIP文件，需要解压
										const contentType = response.headers.get("content-type");
										console.log("Content-Type:", contentType);

										// 检查是否为 SSE 流式响应
										let zipBlob;
										let imageDataUrl;
										if (contentType && contentType.includes("text/event-stream")) {
											console.log("检测到 SSE 流式响应，开始解析...");

											// 读取整个流
											const text = await response.text();
											console.log("收到 SSE 数据，大小:", text.length);

											// 解析 SSE 格式，提取最后的 data: 行
											const lines = text.trim().split("\n");
											let base64Data = null;

											for (let i = lines.length - 1; i >= 0; i--) {
												const line = lines[i].trim();
												if (line.startsWith("data: ") && line !== "data: [DONE]") {
													const dataContent = line.substring(6); // 移除 'data: ' 前缀

													// 尝试解析 JSON
													try {
														const jsonData = JSON.parse(dataContent);

														// V4.5 流式端点：event_type 为 "final" 时包含最终图片
														if (jsonData.event_type === "final" && jsonData.image) {
															base64Data = jsonData.image;
															console.log("✅ 找到 final 事件的图片数据");
															break;
														}

														// 兼容其他格式
														if (jsonData.data) {
															base64Data = jsonData.data;
															console.log("从 JSON.data 中提取图片数据");
															break;
														}
														if (jsonData.image) {
															base64Data = jsonData.image;
															console.log("从 JSON.image 中提取图片数据");
															break;
														}
													} catch (e) {
														// 如果不是 JSON，直接作为 base64 数据
														base64Data = dataContent;
														console.log("直接使用 base64 数据");
														break;
													}
												}
											}

											if (!base64Data) {
												throw new Error("无法从 SSE 响应中提取图片数据");
											}

											// V4.5 流式端点返回的是 PNG base64，不是 ZIP
											// 检查是否为 PNG (以 iVBORw0KGgo 开头) 或 JPEG (以 /9j/ 开头)
											const isPNG = base64Data.startsWith("iVBORw0KGgo");
											const isJPEG = base64Data.startsWith("/9j/");

											if (isPNG || isJPEG) {
												console.log("✅ 检测到直接的图片 base64 数据 (PNG/JPEG)");
												// 将 base64 转为 Blob
												const binaryString = atob(base64Data);
												const bytes = new Uint8Array(binaryString.length);
												for (let i = 0; i < binaryString.length; i++) {
													bytes[i] = binaryString.charCodeAt(i);
												}
												const imageBlob = new Blob([bytes], { type: isPNG ? "image/png" : "image/jpeg" });
												console.log("图片 Blob 创建成功，大小:", imageBlob.size);

												// 转换为dataURL用于后续处理
												const reader = new FileReader();
												imageDataUrl = await new Promise((resolve, reject) => {
													reader.onloadend = () => resolve(reader.result);
													reader.onerror = reject;
													reader.readAsDataURL(imageBlob);
												});
												console.log("✅ 图片转换成功！🎨");
											} else {
												// 否则当作 ZIP 处理
												console.log("当作 ZIP 文件处理...");
												const binaryString = atob(base64Data);
												const bytes = new Uint8Array(binaryString.length);
												for (let i = 0; i < binaryString.length; i++) {
													bytes[i] = binaryString.charCodeAt(i);
												}
												zipBlob = new Blob([bytes]);
												console.log("ZIP Blob 大小:", zipBlob.size);
											}
										} else {
											// 非流式响应，直接读取
											zipBlob = await response.blob();
											console.log("收到数据，类型:", zipBlob.type, "大小:", zipBlob.size);
										}

										// 如果还没有imageDataUrl（即需要解压ZIP）
										if (!imageDataUrl && zipBlob) {
											// NovelAI始终返回ZIP格式，需要解压
											try {
												// 检查JSZip是否已加载
												if (typeof JSZip === "undefined") {
													throw new Error("JSZip库未加载，请刷新页面重试");
												}

												// 解压ZIP文件
												const zip = await JSZip.loadAsync(zipBlob);
												console.log("ZIP文件内容:", Object.keys(zip.files));

												// 查找第一个图片文件（通常是image_0.png）
												let imageFile = null;
												for (let filename in zip.files) {
													if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
														imageFile = zip.files[filename];
														console.log("找到图片文件:", filename);
														break;
													}
												}

												if (!imageFile) {
													throw new Error("ZIP文件中未找到图片");
												}

												// 提取图片数据
												const imageBlob = await imageFile.async("blob");
												console.log("提取的图片大小:", imageBlob.size);

												// 创建图片URL
												const reader = new FileReader();
												imageDataUrl = await new Promise((resolve, reject) => {
													reader.onloadend = () => resolve(reader.result);
													reader.onerror = reject;
													reader.readAsDataURL(imageBlob);
												});
												console.log("✅ 图片解压成功！");
											} catch (zipError) {
												console.error("ZIP解压失败:", zipError);
												throw new Error("图片解压失败: " + zipError.message);
											}
										}

										console.log("✅ NAI图片生成成功！");

										// 创建naiimag消息
										aiMessage = {
											...baseMessage,
											type: "naiimag",
											imageUrl: imageDataUrl,
											prompt: aiPrompt,
											fullPrompt: finalPositivePrompt, // 保存完整提示词供查看
										};
									} catch (error) {
										console.error("❌ NAI图片生成失败:", error);
										// 失败时降级为文本消息
										aiMessage = {
											...baseMessage,
											content: `[图片生成失败: ${error.message}]`,
										};
									}
									break;

								// 处理QQ空间动态点赞消息
								case "qzone_like":
									const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
									if (postToLike) {
										if (!postToLike.likes) postToLike.likes = [];
										if (!postToLike.likes.includes(chat.name)) {
											postToLike.likes.push(chat.name);
											await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
											updateUnreadIndicator(unreadPostsCount + 1);
											if (isViewingThisChat && document.getElementById("qzone-screen").classList.contains("active")) {
												await renderQzonePosts();
											}
										}
									}
									continue;

								// 处理视频通话请求消息
								case "video_call_request":
									if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
										state.activeChatId = chatId;
										videoCallState.activeChatId = chatId;
										videoCallState.isAwaitingResponse = true;
										videoCallState.isGroupCall = chat.isGroup;
										videoCallState.callRequester = msgData.name || chat.name;
										showIncomingCallModal(chatId); // 显示来电弹窗
									}
									continue;

								// 处理群组视频通话请求消息
								case "group_call_request":
									if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
										state.activeChatId = chatId;
										videoCallState.isAwaitingResponse = true;
										videoCallState.isGroupCall = true;
										videoCallState.initiator = "ai";
										videoCallState.callRequester = msgData.name;
										showIncomingCallModal();
									}
									continue;

								// 处理拍一拍消息
								case "pat_user":
									const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : "";
									const patText = `${msgData.name || chat.name} 拍了拍我${suffix}`;
									const patMessage = {
										role: "system",
										type: "pat_message",
										content: patText,
										timestamp: Date.now(),
									};
									chat.history.push(patMessage);
									if (isViewingThisChat) {
										const phoneScreen = document.getElementById("phone-screen");
										phoneScreen.classList.remove("pat-animation");
										void phoneScreen.offsetWidth;
										phoneScreen.classList.add("pat-animation");
										setTimeout(() => phoneScreen.classList.remove("pat-animation"), 500);
										appendMessage(patMessage, chat);
									} else {
										showNotification(chatId, patText);
									}
									continue;

								// 处理状态更新消息
								case "update_status":
									chat.status.text = msgData.status_text;
									chat.status.isBusy = msgData.is_busy || false;
									chat.status.lastUpdate = Date.now();

									const statusUpdateMessage = {
										role: "system",
										type: "pat_message",
										content: `[${chat.name}的状态已更新为: ${msgData.status_text}]`,
										timestamp: Date.now(),
									};
									chat.history.push(statusUpdateMessage);

									if (isViewingThisChat) {
										appendMessage(statusUpdateMessage, chat);
									}

									renderChatList();

									continue;

								// 处理音乐切换消息
								case "change_music":
									if (musicState.isActive && musicState.activeChatId === chatId) {
										const songNameToFind = msgData.song_name;

										const targetSongIndex = musicState.playlist.findIndex((track) => track.name.toLowerCase() === songNameToFind.toLowerCase());

										if (targetSongIndex > -1) {
											playSong(targetSongIndex);

											const track = musicState.playlist[targetSongIndex];
											const musicChangeMessage = {
												role: "system",
												type: "pat_message",
												content: `[♪ ${chat.name} 为你切歌: 《${track.name}》 - ${track.artist}]`,
												timestamp: Date.now(),
											};
											chat.history.push(musicChangeMessage);

											if (isViewingThisChat) {
												appendMessage(musicChangeMessage, chat);
											}
										}
									}
									continue;

								// 处理创建回忆消息
								case "create_memory":
									const newMemory = {
										chatId: chatId,
										authorName: chat.name,
										description: msgData.description,
										timestamp: Date.now(),
										type: "ai_generated",
									};
									await db.memories.add(newMemory);

									console.log(`AI "${chat.name}" 记录了一条新回忆:`, msgData.description);

									continue;

								// 处理创建倒计时消息
								case "create_countdown":
									const targetDate = new Date(msgData.date);
									if (!isNaN(targetDate) && targetDate > new Date()) {
										const newCountdown = {
											chatId: chatId,
											authorName: chat.name,
											description: msgData.title,
											timestamp: Date.now(),
											type: "countdown",
											targetDate: targetDate.getTime(),
										};
										await db.memories.add(newCountdown);
										console.log(`AI "${chat.name}" 创建了一个新约定:`, msgData.title);
									}
									continue;

								// 处理拉黑用户消息
								case "block_user":
									if (!chat.isGroup) {
										chat.relationship.status = "blocked_by_ai";

										// 添加系统指令消息，要求AI回应情侣空间邀请
										const hiddenMessage = {
											role: "system",
											content: `[系统最高指令]
                                                # 任务：回应情侣空间邀请
                                                用户刚刚向你发起了"开启情侣空间"的邀请。你【必须】根据你的人设，决定是同意还是拒绝。

                                                # 输出格式铁律 (必须严格遵守)
                                                你的回复【必须且只能】是【一个】JSON对象，格式如下:
                                                {"type": "lovers_space_response", "decision": "accept" 或 "reject", "responseText": "你想说的话..."}

                                                # 示例
                                                - 如果同意: {"type": "lovers_space_response", "decision": "accept", "responseText": ""}
                                                - 如果拒绝: {"type": "lovers_space_response", "decision": "reject", "responseText": ""}

                                                现在，请立即做出你的决定。`,
											timestamp: Date.now() + 1,
											isHidden: true,
										};
										chat.history.push(hiddenMessage);

										await db.chats.put(chat);

										if (isViewingThisChat) {
											renderChatInterface(chatId);
										}
										renderChatList();

										break;
									}
									continue;

								// 处理好友请求响应消息
								case "friend_request_response":
									if (!chat.isGroup && chat.relationship.status === "pending_ai_approval") {
										if (msgData.decision === "accept") {
											chat.relationship.status = "friend";
											aiMessage = { ...baseMessage, content: "我通过了你的好友申请，我们现在是好友啦！" };
										} else {
											chat.relationship.status = "blocked_by_ai";
											aiMessage = { ...baseMessage, content: "抱歉，我拒绝了你的好友申请。" };
										}
										chat.relationship.applicationReason = "";
									}
									break;

								// 处理投票消息
								case "poll": {
									// 处理来自AI和用户的投票消息
									let pollInfoText = "";

									// 判断这条投票消息是谁发的
									if (msg.role === "user") {
										const myNickname = chat.isGroup ? chat.settings.myNickname || "我" : "我";
										pollInfoText = `[系统提示：用户 (${myNickname}) 发起了一个投票。问题："${msg.question}", 选项："${msg.options.join('", "')}"]`;
									} else {
										// 如果是AI发的
										pollInfoText = `[系统提示：${msg.senderName} 发起了一个投票。问题："${msg.question}", 选项："${msg.options.join('", "')}"]`;
									}

									// 将格式化好的文本作为系统消息发送给AI
									aiMessage = { role: "system", content: pollInfoText, isHidden: true };
									break;
								}

								// 处理投票选择消息
								case "vote": {
									// 使用大括号创建独立的块级作用域
									const pollToVote = chat.history.find((m) => m.timestamp === msgData.poll_timestamp);

									// 安全检查：如果投票不存在或已关闭，则不处理
									if (pollToVote && !pollToVote.isClosed) {
										// 根据AI的"本名"，找到其成员对象，并获取正确的"群昵称"
										const member = chat.members.find((m) => m.originalName === msgData.name);
										const displayName = member ? member.groupNickname : msgData.name;

										// 使用正确的"群昵称"去移除该角色之前的所有投票
										Object.keys(pollToVote.votes).forEach((option) => {
											const voterIndex = pollToVote.votes[option].indexOf(displayName);
											if (voterIndex > -1) {
												pollToVote.votes[option].splice(voterIndex, 1);
											}
										});

										// 将"群昵称"添加到新的选项中
										if (!pollToVote.votes[msgData.choice]) {
											pollToVote.votes[msgData.choice] = [];
										}

										// 再次检查，避免意外重复添加
										if (!pollToVote.votes[msgData.choice].includes(displayName)) {
											pollToVote.votes[msgData.choice].push(displayName);
										}

										// 如果用户正在看这个聊天，就刷新界面让他们看到变化
										if (isViewingThisChat) {
											renderChatInterface(chatId);
										}
									}
									// 这是一个后台操作，不需要生成新的消息，所以用 continue
									continue;
								}

								// 处理红包消息
								case "red_packet":
									aiMessage = {
										...baseMessage,
										type: "red_packet",
										packetType: msgData.packetType,
										totalAmount: msgData.amount,
										count: msgData.count,
										greeting: msgData.greeting,
										receiverName: msgData.receiver,
										claimedBy: {},
										isFullyClaimed: false,
									};
									// 同步到角色钱包（支出）
									const rpDescription = `发出红包 - ${msgData.greeting || "恭喜发财"}`;
									await updateCharacterBankBalance(chatId, -msgData.amount, rpDescription);
									break;

								// 处理打开红包消息
								case "open_red_packet": {
									// 使用大括号创建独立的块级作用域
									const packetToOpen = chat.history.find((m) => m.timestamp === msgData.packet_timestamp);
									// 检查红包是否存在、是否没被领完、以及这个AI角色是否还没领过
									if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {
										// 根据AI的本名(msgData.name)，从成员列表找到其正确的群昵称
										const member = chat.members.find((m) => m.originalName === msgData.name);
										const displayName = member ? member.groupNickname : msgData.name;

										let claimedAmountAI = 0;
										const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
										const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;

										if (remainingCount > 0) {
											if (remainingCount === 1) {
												// 如果是最后一个
												claimedAmountAI = remainingAmount;
											} else {
												// 如果不是最后一个，随机分配
												const min = 0.01;
												const max = remainingAmount - (remainingCount - 1) * min;
												claimedAmountAI = Math.random() * (max - min) + min;
											}
											claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));

											// 确保 claimedBy 对象存在
											if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
											// 使用我们刚刚查找到的 displayName 作为记录的key
											packetToOpen.claimedBy[displayName] = claimedAmountAI;

											// 发送对用户可见的系统消息
											const aiClaimedMessage = {
												role: "system",
												type: "pat_message",
												// 系统消息里也使用 displayName
												content: `${displayName} 领取了 ${packetToOpen.senderName} 的红包`,
												timestamp: Date.now(),
											};
											chat.history.push(aiClaimedMessage);

											let hiddenContentForAI = `[系统提示：你 (${displayName}) 成功抢到了 ${claimedAmountAI.toFixed(2)} 元。`;

											// 检查红包是否被领完
											if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
												packetToOpen.isFullyClaimed = true; // 标记为已领完

												// 发送对用户可见的"已领完"通知
												const finishedMessage = {
													role: "system",
													type: "pat_message",
													content: `${packetToOpen.senderName} 的红包已被领完`,
													timestamp: Date.now() + 1,
												};
												chat.history.push(finishedMessage);

												// 开始构建给AI看的"战报"
												hiddenContentForAI += ` 红包已被领完。`;

												// 如果是拼手气红包，找出谁是手气王
												let luckyKing = { name: "", amount: -1 };
												if (packetToOpen.packetType === "lucky" && packetToOpen.count > 1) {
													Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
														if (amount > luckyKing.amount) {
															luckyKing = { name, amount };
														}
													});
												}
												// 把手气王信息也加到"战报"里
												if (luckyKing.name) {
													hiddenContentForAI += ` 手气王是 ${luckyKing.name}！`;
												}
											}
											hiddenContentForAI += " 请根据这个结果发表你的评论。]";

											// 创建并添加给AI看的隐藏消息
											const hiddenMessageForAI = {
												role: "system",
												content: hiddenContentForAI,
												timestamp: Date.now() + 2, // 确保时间戳在后
												isHidden: true,
											};
											chat.history.push(hiddenMessageForAI);
										}

										// 刷新UI（如果用户正在看的话）
										if (isViewingThisChat) {
											renderChatInterface(chatId);
										}
									}
									continue; // 这是一个后台操作，继续处理AI可能返回的其他消息
								}

								case "change_avatar":
									const avatarName = msgData.name;
									// 在该角色的头像库中查找
									const foundAvatar = chat.settings.aiAvatarLibrary.find((avatar) => avatar.name === avatarName);

									if (foundAvatar) {
										// 找到了，就更新头像
										chat.settings.aiAvatar = foundAvatar.url;

										// 创建一条系统提示，告知用户头像已更换
										const systemNotice = {
											role: "system",
											type: "pat_message", // 复用居中样式
											content: `[${chat.name} 更换了头像]`,
											timestamp: Date.now(),
										};
										chat.history.push(systemNotice);

										// 如果在当前聊天界面，则实时渲染
										if (isViewingThisChat) {
											appendMessage(systemNotice, chat);
											// 立刻刷新聊天界面以显示新头像
											renderChatInterface(chatId);
										}
									}
									// 处理完后，继续处理AI可能返回的其他消息
									continue;

								// 处理接受转账请求
								case "accept_transfer": {
									const originalTransferMsgIndex = chat.history.findIndex((m) => m.timestamp === msgData.for_timestamp);
									if (originalTransferMsgIndex > -1) {
										const originalMsg = chat.history[originalTransferMsgIndex];
										originalMsg.status = "accepted";

										// 同步到角色钱包（收入）
										const acceptDescription = `收到来自 ${originalMsg.senderName} 的转账`;
										await updateCharacterBankBalance(chatId, originalMsg.amount, acceptDescription);
									}
									continue;
								}

								// 处理拒绝转账请求
								case "decline_transfer": {
									const originalTransferMsgIndex = chat.history.findIndex((m) => m.timestamp === msgData.for_timestamp);
									if (originalTransferMsgIndex > -1) {
										const originalMsg = chat.history[originalTransferMsgIndex];
										originalMsg.status = "declined";

										// 创建一条新的"退款"消息
										const refundMessage = {
											role: "assistant",
											senderName: chat.name,
											type: "transfer",
											isRefund: true,
											amount: originalMsg.amount,
											note: "转账已被拒收",
											timestamp: messageTimestamp++,
										};

										// 将新消息推入历史记录
										chat.history.push(refundMessage);

										// 更新界面显示
										if (isViewingThisChat) {
											appendMessage(refundMessage, chat);
											renderChatInterface(chatId);
										}
									}
									continue;
								}

								// 处理系统消息
								case "system_message":
									aiMessage = { role: "system", type: "pat_message", content: msgData.content, timestamp: Date.now() };
									break;

								// 处理分享链接消息
								case "share_link":
									aiMessage = {
										...baseMessage,
										type: "share_link",
										title: msgData.title,
										description: msgData.description,
										source_name: msgData.source_name,
										content: msgData.content,
									};
									break;

								// 处理引用回复消息
								case "quote_reply":
									const originalMessage = chat.history.find((m) => m.timestamp === msgData.target_timestamp);
									if (originalMessage) {
										const quoteContext = {
											timestamp: originalMessage.timestamp,
											senderName: originalMessage.senderName || (originalMessage.role === "user" ? chat.settings.myNickname || "我" : chat.name),
											content: String(originalMessage.content || ""),
										};
										aiMessage = {
											...baseMessage,
											content: msgData.reply_content,
											quote: quoteContext,
										};
									} else {
										aiMessage = { ...baseMessage, content: msgData.reply_content };
									}
									break;

								// 处理位置消息
								case "location":
									aiMessage = {
										...baseMessage,
										type: "location",
										userLocation: msgData.userLocation,
										aiLocation: msgData.aiLocation,
										distance: msgData.distance,
										trajectoryPoints: msgData.trajectoryPoints || [],
									};
									break;

								// 处理发送并撤回消息
								case "send_and_recall": {
									if (!isViewingThisChat) continue;
									const tempMessageData = { ...baseMessage, content: msgData.content };
									appendMessage(tempMessageData, chat, true);
									await new Promise((resolve) => setTimeout(resolve, Math.random() * 1000 + 1500));
									const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`)?.closest(".message-wrapper");
									if (bubbleWrapper) {
										bubbleWrapper.classList.add("recalled-animation");
										await new Promise((resolve) => setTimeout(resolve, 300));
									}

									// 创建对用户可见的"已撤回"消息
									const recalledMessage = {
										role: "assistant",
										senderName: msgData.name || chat.name,
										type: "recalled_message",
										content: "对方撤回了一条消息",
										timestamp: tempMessageData.timestamp,
										recalledData: { originalType: "text", originalContent: msgData.content },
									};

									// 创建一条对用户隐藏、但对AI可见的"记忆"消息
									const hiddenMemoryMessage = {
										role: "system",
										content: `[系统提示：你刚刚说了一句"${msgData.content}"，但立刻就撤回了它。]`,
										timestamp: tempMessageData.timestamp + 1,
										isHidden: true,
									};

									// 将两条消息都添加到历史记录中
									chat.history.push(recalledMessage, hiddenMemoryMessage);

									// 替换DOM，显示"已撤回"提示
									const placeholder = createMessageElement(recalledMessage, chat);
									if (document.body.contains(bubbleWrapper)) {
										bubbleWrapper.parentNode.replaceChild(placeholder, bubbleWrapper);
									}

									continue;
								}

								// 处理表情包消息
								case "sticker": {
									const stickerName = msgData.sticker_name;
									if (!stickerName) {
										console.warn("AI返回了sticker类型但没有sticker_name，已拦截:", msgData);
										continue;
									}

									// 在所有可用表情库中查找
									const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
									const foundSticker = allStickers.find((s) => s.name === stickerName);

									if (foundSticker) {
										aiMessage = {
											...baseMessage,
											type: "sticker",
											content: foundSticker.url,
											meaning: foundSticker.name,
										};
									} else {
										console.warn(`AI杜撰了不存在的表情: "${stickerName}"，已自动拦截。`);
									}
									break;
								}

								// 处理文本消息
								case "text": {
									const messageText = String(msgData.content || msgData.message || "");

									if (STICKER_REGEX.test(messageText)) {
										aiMessage = { ...baseMessage, type: "sticker", content: messageText, meaning: "" };
									} else {
										const stickerMatch = messageText.match(/^\[sticker:(.+?)\]$/);
										if (stickerMatch) {
											const stickerName = stickerMatch[1].trim();
											const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
											const foundSticker = allStickers.find((s) => s.name === stickerName);

											if (foundSticker) {
												aiMessage = { ...baseMessage, type: "sticker", content: foundSticker.url, meaning: foundSticker.name };
											} else {
												console.warn(`AI使用了旧格式且杜撰了不存在的表情: "${stickerName}"，已拦截。`);
											}
										} else {
											aiMessage = { ...baseMessage, content: messageText };
										}
									}
									break;
								}

								// 处理约会支付响应
								case "dating_payment_response": {
									const originalRequest = chat.history.filter((m) => m.role === "system" && m.content.includes("dating_payment_response")).pop();
									if (!originalRequest) continue;

									const costMatch = originalRequest.content.match(/费用（(\d+(\.\d+)?)金币）/);
									const cost = costMatch ? parseFloat(costMatch[1]) : 0;

									if (msgData.decision === "accept") {
										const charBalance = chat.characterPhoneData.bank.balance || 0;
										if (charBalance >= cost) {
											await updateCharacterPhoneBankBalance(chat.id, -cost, `约会支出: 为用户买单`);
											aiMessage = { ...baseMessage, content: msgData.responseText || "好呀，这次我来请客吧！" };
										} else {
											aiMessage = { ...baseMessage, content: msgData.responseText || "呜呜，我也想请客，但是钱包好像不太够呢..." };
										}
									} else {
										aiMessage = { ...baseMessage, content: msgData.responseText || "这次还是算了吧..." };
									}
									break;
								}

								// 处理AA制约会支付响应
								case "dating_aa_response": {
									const originalRequest = chat.history.filter((m) => m.role === "system" && m.content.includes("dating_aa_response")).pop();
									if (!originalRequest) continue;

									const costMatch = originalRequest.content.match(/各自支付 (\d+(\.\d+)?) 金币/);
									const splitCost = costMatch ? parseFloat(costMatch[1]) : 0;

									if (msgData.decision === "accept") {
										const charBalance = chat.characterPhoneData.bank.balance || 0;
										if (charBalance >= splitCost) {
											await updateUserBalanceAndLogTransaction(-splitCost, `约会AA支出`);
											await updateCharacterPhoneBankBalance(chat.id, -splitCost, `约会AA支出`);
											aiMessage = { ...baseMessage, content: msgData.responseText || "好啊，AA制完全没问题！" };
										} else {
											aiMessage = { ...baseMessage, content: msgData.responseText || "这个...我的钱好像不太够付我自己的那份呢。" };
										}
									} else {
										aiMessage = { ...baseMessage, content: msgData.responseText || "我觉得AA制有点太见外了，还是我来请吧？或者你请？" };
									}
									break;
								}

								// 处理借款响应
								case "lend_money_response": {
									const originalRequest = chat.history.filter((m) => m.role === "system" && m.content.includes("lend_money_response")).pop();
									if (!originalRequest) continue;

									const amountMatch = originalRequest.content.match(/借 (\d+(\.\d+)?) 金币/);
									const amount = amountMatch ? parseFloat(amountMatch[1]) : 0;

									// 只处理接受借款时的金钱逻辑
									if (msgData.decision === "accept") {
										const lenderBalance = chat.characterPhoneData.bank.balance || 0;
										if (lenderBalance >= amount) {
											await updateCharacterPhoneBankBalance(chat.id, -amount, `借钱给用户`);
											await updateUserBalanceAndLogTransaction(amount, `从 ${chat.name} 处借款`);
										} else {
											console.warn(`AI "${chat.name}" 同意借钱，但余额不足，交易未执行。`);
										}
									}

									continue;
								}

								// 处理圈子评论
								case "forum_comment": {
									const postIdToComment = msgData.postId;
									const commentText = msgData.commentText;

									if (postIdToComment && commentText) {
										// 尝试将 postId 强制转换为数字
										const numericPostId = parseInt(postIdToComment, 10);

										// 检查转换后的ID是否有效
										if (isNaN(numericPostId)) {
											console.warn(`[圈子评论失败] 收到的 postId "${postIdToComment}" 不是一个有效的数字ID，已跳过。`);
											continue;
										}

										// 使用正确的数字ID从数据库获取帖子
										const postToComment = await db.forumPosts.get(numericPostId);

										if (postToComment) {
											// 创建新评论对象
											const newComment = {
												postId: numericPostId,
												author: chat.name,
												content: commentText,
												timestamp: Date.now(),
											};

											// 将新评论保存到数据库
											await db.forumComments.add(newComment);
											console.log(`AI "${chat.name}" 评论了帖子 #${numericPostId}: "${commentText}"`);

											// 刷新UI显示
											if (document.getElementById("group-screen").classList.contains("active") && activeGroupId === postToComment.groupId) {
												await renderGroupPosts(activeGroupId);
											}

											if (document.getElementById("post-screen").classList.contains("active") && activeForumPostId === numericPostId) {
												await renderPostDetails(numericPostId);
											}
										} else {
											console.warn(`[圈子评论失败] 未能在数据库中找到 postId 为 ${numericPostId} 的帖子。`);
										}
									}
									continue;
								}

								// 处理AI生成的图片消息
								case "ai_image":
									aiMessage = { ...baseMessage, type: "ai_image", content: msgData.description };
									break;

								// 处理语音消息
								case "voice_message":
									aiMessage = { ...baseMessage, type: "voice_message", content: msgData.content };
									break;

								// 处理转账消息
								case "transfer":
									aiMessage = { ...baseMessage, type: "transfer", amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || "我" };

									// 同步到角色钱包（支出）
									const transferDescription = `转账给 ${msgData.receiver || "我"}`;
									await updateCharacterBankBalance(chatId, -msgData.amount, transferDescription);
									break;

								// 处理外卖请求消息
								case "waimai_request":
									aiMessage = {
										...baseMessage,
										type: "waimai_request",
										productInfo: msgData.productInfo,
										amount: msgData.amount,
										status: "pending",
										countdownEndTime: Date.now() + 15 * 60 * 1000,
									};
									break;

								// 处理未知消息类型
								default:
									console.warn("收到了未知的AI指令类型:", msgData.type);
									break;
							}

							// 将渲染逻辑移出循环
							if (aiMessage) {
								// 将新消息存入历史记录
								chat.history.push(aiMessage);

								// 如果不在当前聊天界面且未显示通知，则显示通知
								if (!isViewingThisChat && !notificationShown) {
									let notificationText;
									// 根据消息类型设置不同的通知文本
									switch (aiMessage.type) {
										case "transfer":
											notificationText = `[收到一笔转账]`;
											break;
										case "waimai_request":
											notificationText = `[收到一个外卖代付请求]`;
											break;
										case "ai_image":
											notificationText = `[图片]`;
											break;
										case "voice_message":
											notificationText = `[语音]`;
											break;
										case "sticker":
											notificationText = aiMessage.meaning ? `[表情: ${aiMessage.meaning}]` : "[表情]";
											break;
										default:
											notificationText = String(aiMessage.content || "");
									}
									// 构造最终通知文本，群聊中包含发送者名称
									const finalNotifText = chat.isGroup ? `${aiMessage.senderName}: ${notificationText}` : notificationText;
									// 显示通知，限制长度为40个字符
									showNotification(chatId, finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? "..." : ""));
									notificationShown = true; // 确保只通知一次
								}

								// 如果用户不在当前聊天界面，增加未读消息计数
								if (!isViewingThisChat) {
									chat.unreadCount = (chat.unreadCount || 0) + 1;
								}

								// 只有在当前聊天界面时，才执行带动画的添加
								if (isViewingThisChat) {
									appendMessage(aiMessage, chat);
									// 暂停一段时间，给动画播放的时间
									await new Promise((resolve) => setTimeout(resolve, Math.random() * 1800 + 1000));
								}
							}
						}

						if (callHasBeenHandled && videoCallState.isGroupCall) {
							videoCallState.isAwaitingResponse = false;
							// 如果是群聊且有参与者，则开始视频通话
							if (videoCallState.participants.length > 0) {
								startVideoCall();
							} else {
								// 如果没有参与者，重置状态并显示提示
								videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
								showScreen("chat-interface-screen");
								alert("无人接听群聊邀请。");
							}
						}

						// 播放通知音效
						playNotificationSound();

						// 更新聊天数据到数据库
						await db.chats.put(chat);

						// 检查并触发摘要更新
						checkAndTriggerSummary(chatId);

						// 更新连续对话天数（火花系统）
						if (await updateStreak(chatId)) {
							// 如果火花天数发生变化，刷新聊天列表界面
							renderChatList();
						}
					} catch (error) {
						// 出错时移除临时消息
						chat.history = chat.history.filter((msg) => !msg.isTemporary);

						// 处理好友申请被拒绝的情况
						if (!chat.isGroup && chat.relationship?.status === "pending_ai_approval") {
							chat.relationship.status = "blocked_by_ai";
							await showCustomAlert("申请失败", `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
						} else {
							// 添加错误消息到聊天历史
							const errorContent = `[出错了: ${error.message}]`;
							const errorMessage = { role: "assistant", content: errorContent, timestamp: Date.now() };
							if (chat.isGroup) errorMessage.senderName = "系统消息";
							chat.history.push(errorMessage);
						}

						// 更新数据库中的聊天数据
						await db.chats.put(chat);

						// 重置视频通话等待状态
						videoCallState.isAwaitingResponse = false;

						// 如果当前在聊天界面，重新渲染界面
						if (document.getElementById("chat-interface-screen").classList.contains("active") && state.activeChatId === chatId) {
							renderChatInterface(chatId);
						}
					} finally {
						// 统一隐藏所有类型的提示信息
						if (chat.isGroup) {
							// 群聊隐藏正在输入提示
							if (typingIndicator) {
								typingIndicator.style.display = "none";
							}
						} else {
							// 单聊恢复标题显示
							if (chatHeaderTitle && state.chats[chatId]) {
								chatHeaderTitle.style.opacity = 0;
								setTimeout(() => {
									chatHeaderTitle.textContent = state.chats[chatId].name;
									chatHeaderTitle.classList.remove("typing-status");
									chatHeaderTitle.style.opacity = 1;
								}, 200);
							}
						}
					}
				}

				// 发送表情包
				async function sendSticker(sticker) {
					if (!state.activeChatId) return;
					const chat = state.chats[state.activeChatId];
					const msg = { role: "user", content: sticker.url, meaning: sticker.name, timestamp: Date.now() };
					chat.history.push(msg);
					await db.chats.put(chat);
					checkAndTriggerSummary(state.activeChatId);
					appendMessage(msg, chat);
					renderChatList();
					document.getElementById("sticker-panel").classList.remove("visible");
				}

				// 发送转账消息
				async function sendUserTransfer() {
					if (!state.activeChatId) return;

					const amountInput = document.getElementById("transfer-amount");
					const noteInput = document.getElementById("transfer-note");
					const amount = parseFloat(amountInput.value);
					const note = noteInput.value.trim();

					// 验证转账金额
					if (isNaN(amount) || amount <= 0) {
						alert("请输入有效的金额！");
						return;
					}

					// 检查用户余额是否足够
					if ((state.globalSettings.userBalance || 0) < amount) {
						alert("余额不足！");
						return;
					}

					const chat = state.chats[state.activeChatId];
					const senderName = chat.isGroup ? chat.settings.myNickname || "我" : "我";
					const receiverName = chat.isGroup ? "群聊" : chat.name;

					// 扣除转账金额并记录交易日志
					await updateUserBalanceAndLogTransaction(-amount, `转账给 ${receiverName}`);

					// 创建转账消息对象
					const msg = { role: "user", type: "transfer", amount: amount, note: note, senderName, receiverName, timestamp: Date.now() };
					chat.history.push(msg);

					// 更新数据库和界面
					await db.chats.put(chat);
					appendMessage(msg, chat);
					renderChatList();

					// 关闭转账模态框并清空输入框
					document.getElementById("transfer-modal").classList.remove("visible");
					amountInput.value = "";
					noteInput.value = "";
				}

				// 进入消息选择模式
				function enterSelectionMode(initialMsgTimestamp) {
					if (isSelectionMode) return;
					isSelectionMode = true;
					document.getElementById("chat-interface-screen").classList.add("selection-mode");
					toggleMessageSelection(initialMsgTimestamp);
				}

				// 退出消息选择模式
				function exitSelectionMode() {
					cleanupWaimaiTimers(); // 清理外卖定时器
					if (!isSelectionMode) return;
					isSelectionMode = false;
					document.getElementById("chat-interface-screen").classList.remove("selection-mode");

					// 清除所有选中消息的视觉状态
					selectedMessages.forEach((ts) => {
						const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`);
						if (bubble) bubble.classList.remove("selected");
					});
					selectedMessages.clear();
				}

				// 切换消息选中状态
				function toggleMessageSelection(timestamp) {
					const elementToSelect = document.querySelector(`.message-bubble[data-timestamp="${timestamp}"]`);

					if (!elementToSelect) return;

					// 切换消息的选中状态
					if (selectedMessages.has(timestamp)) {
						selectedMessages.delete(timestamp);
						elementToSelect.classList.remove("selected");
					} else {
						selectedMessages.add(timestamp);
						elementToSelect.classList.add("selected");
					}

					// 更新选中消息数量显示
					document.getElementById("selection-count").textContent = `已选 ${selectedMessages.size} 条`;

					// 如果没有选中消息，则退出选择模式
					if (selectedMessages.size === 0) {
						exitSelectionMode();
					}
				}

				// 为元素添加长按监听器
				function addLongPressListener(element, callback) {
					let pressTimer;
					const startPress = (e) => {
						if (isSelectionMode) return;
						e.preventDefault();
						pressTimer = window.setTimeout(() => callback(e), 500);
					};
					const cancelPress = () => clearTimeout(pressTimer);

					// 绑定鼠标和触摸事件
					element.addEventListener("mousedown", startPress);
					element.addEventListener("mouseup", cancelPress);
					element.addEventListener("mouseleave", cancelPress);
					element.addEventListener("touchstart", startPress, { passive: true });
					element.addEventListener("touchend", cancelPress);
					element.addEventListener("touchmove", cancelPress);
				}

				// 处理"一起听"按钮点击事件
				async function handleListenTogetherClick() {
					document.getElementById("floating-lyrics-bar").style.display = "none"; // 隐藏悬浮歌词栏

					const targetChatId = state.activeChatId;
					if (!targetChatId) return;

					// 如果音乐功能未激活，则启动会话
					if (!musicState.isActive) {
						startListenTogetherSession(targetChatId);
						return;
					}

					// 如果已在当前聊天中激活，则显示音乐播放器
					if (musicState.activeChatId === targetChatId) {
						document.getElementById("music-player-overlay").classList.add("visible");
					} else {
						// 如果在其他聊天中激活，则提示用户切换
						const oldChatName = state.chats[musicState.activeChatId]?.name || "未知";
						const newChatName = state.chats[targetChatId]?.name || "当前";
						const confirmed = await showCustomConfirm("切换听歌对象", `您正和「${oldChatName}」听歌。要结束并开始和「${newChatName}」的新会话吗？`, { confirmButtonClass: "btn-danger" });
						if (confirmed) {
							await endListenTogetherSession(true);
							await new Promise((resolve) => setTimeout(resolve, 50));
							startListenTogetherSession(targetChatId);
						}
					}
				}

				// 启动一起听会话
				async function startListenTogetherSession(chatId) {
					const chat = state.chats[chatId];
					if (!chat) return;

					// 初始化音乐状态
					musicState.totalElapsedTime = chat.musicData.totalTime || 0;
					musicState.isActive = true;
					musicState.activeChatId = chatId;

					// 设置当前播放索引
					if (musicState.playlist.length > 0) {
						musicState.currentIndex = 0;
					} else {
						musicState.currentIndex = -1;
					}

					// 启动计时器更新播放时间
					if (musicState.timerId) clearInterval(musicState.timerId);
					musicState.timerId = setInterval(() => {
						if (musicState.isPlaying) {
							musicState.totalElapsedTime++;
							updateElapsedTimeDisplay();
						}
					}, 1000);

					// 更新界面
					updatePlayerUI();
					updatePlaylistUI();
					document.getElementById("music-player-overlay").classList.add("visible");
				}

				// 结束一起听会话
				async function endListenTogetherSession(saveState = true) {
					if (!musicState.isActive) return;
					const oldChatId = musicState.activeChatId;

					const cleanupLogic = async () => {
						document.getElementById("floating-lyrics-bar").style.display = "none"; // 隐藏悬浮歌词栏

						// 清理定时器和暂停播放
						if (musicState.timerId) clearInterval(musicState.timerId);
						if (musicState.isPlaying) audioPlayer.pause();

						// 保存会话状态
						if (saveState && oldChatId && state.chats[oldChatId]) {
							const chat = state.chats[oldChatId];
							chat.musicData.totalTime = musicState.totalElapsedTime;
							await db.chats.put(chat);
						}

						// 重置音乐状态
						musicState.isActive = false;
						musicState.activeChatId = null;
						musicState.totalElapsedTime = 0;
						musicState.timerId = null;
						updateListenTogetherIcon(oldChatId, true);
					};

					closeMusicPlayerWithAnimation(cleanupLogic);
				}

				// 返回聊天界面
				function returnToChat() {
					closeMusicPlayerWithAnimation(() => {
						// 根据设置决定是否显示悬浮歌词栏
						if (musicState.isActive && lyricsBarSettings.showOnClose) {
							document.getElementById("floating-lyrics-bar").style.display = "flex";
						}
					});
				}

				// 更新一起听图标状态
				function updateListenTogetherIcon(chatId, forceReset = false) {
					const iconImg = document.querySelector("#listen-together-btn img");
					if (!iconImg) return;

					// 重置图标或根据播放状态更新图标
					if (forceReset || !musicState.isActive || musicState.activeChatId !== chatId) {
						iconImg.src = "https://chatbotcos.weixin.qq.com/chatbot/30-openaiassets_63e04c67410237fa43bf6fcce542dbff_469401762321466866.png";
						iconImg.className = "";
						return;
					}

					iconImg.src = "https://cdn.jsdelivr.net.cn/gh/qdqqd/tc_temp/jli60izy2n.png";
					iconImg.classList.add("rotating");

					// 根据播放状态切换图标动画
					if (musicState.isPlaying) iconImg.classList.remove("paused");
					else iconImg.classList.add("paused");
				}

				// 全局代理函数，允许外部访问updateListenTogetherIcon
				window.updateListenTogetherIconProxy = updateListenTogetherIcon;

				// 更新音乐播放器界面
				function updatePlayerUI() {
					updateListenTogetherIcon(musicState.activeChatId);
					updateElapsedTimeDisplay();

					// 获取界面元素
					const titleEl = document.getElementById("music-player-song-title");
					const artistEl = document.getElementById("music-player-artist");
					const playPauseBtn = document.getElementById("music-play-pause-btn");
					const chat = state.chats[musicState.activeChatId];
					const charAvatarEl = document.getElementById("music-char-avatar");
					const userAvatarEl = document.getElementById("music-user-avatar");
					const albumCoverEl = document.getElementById("music-album-cover");
					const avatarsContainer = document.getElementById("music-avatars-container");
					const displayArea = document.getElementById("music-display-area");

					// 根据聊天类型设置头像（群聊或单聊）
					if (chat) {
						if (chat.isGroup) {
							charAvatarEl.src = chat.settings.groupAvatar || defaultGroupAvatar;
						} else {
							charAvatarEl.src = chat.settings.aiAvatar || defaultAvatar;
						}
						userAvatarEl.src = chat.settings.myAvatar || defaultAvatar;
					}

					// 更新歌曲信息和封面
					if (musicState.currentIndex > -1 && musicState.playlist.length > 0) {
						const track = musicState.playlist[musicState.currentIndex];
						titleEl.textContent = track.name;
						artistEl.textContent = track.artist;
						albumCoverEl.src = track.cover || "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png";
					} else {
						titleEl.textContent = "请添加歌曲";
						artistEl.textContent = "...";
						albumCoverEl.src = "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png";
					}

					// 更新播放/暂停按钮状态和头像闪烁效果
					playPauseBtn.textContent = musicState.isPlaying ? "❚❚" : "▶";
					avatarsContainer.classList.toggle("flashing", musicState.isPlaying);

					// 控制唱片旋转动画
					albumCoverEl.classList.toggle("rotating", musicState.currentIndex > -1);
					albumCoverEl.classList.toggle("paused", !musicState.isPlaying);

					// 默认显示歌曲封面
					if (displayArea) {
						displayArea.classList.remove("show-lyrics");
					}
				}

				// 更新已一起听的时间显示
				function updateElapsedTimeDisplay() {
					const hours = (musicState.totalElapsedTime / 3600).toFixed(1);
					document.getElementById("music-time-counter").textContent = `已经一起听了${hours}小时`;
				}

				// 处理歌曲封面上传
				async function handleCoverUpload(index) {
					if (index < 0 || index >= musicState.playlist.length) return;

					// 让用户选择封面来源
					const choice = await showChoiceModal("选择封面来源", [
						{ text: "使用网络URL", value: "url" },
						{ text: "从本地上传", value: "local" },
					]);

					let newCoverUrl = null;

					// 根据用户选择处理封面
					if (choice === "url") {
						const url = await showCustomPrompt("封面URL", "请输入图片文件的网络链接");
						if (url && url.trim().startsWith("http")) {
							newCoverUrl = url.trim();
						} else if (url !== null) {
							alert("请输入一个有效的图片URL！");
						}
					} else if (choice === "local") {
						newCoverUrl = await uploadImageLocally();
					}

					// 如果成功获取到新封面URL，则更新数据和界面
					if (newCoverUrl) {
						musicState.playlist[index].cover = newCoverUrl;
						await saveGlobalPlaylist();
						updatePlaylistUI();
						if (musicState.currentIndex === index) {
							updatePlayerUI();
						}
						alert("歌曲封面已更新！");
					}
				}

				// 更新播放列表界面
				function updatePlaylistUI() {
					const playlistBody = document.getElementById("playlist-body");
					playlistBody.innerHTML = "";

					// 如果播放列表为空，显示提示信息
					if (musicState.playlist.length === 0) {
						playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放列表是空的~</p>';
						return;
					}

					// 为每首歌曲创建播放列表项
					musicState.playlist.forEach((track, index) => {
						const item = document.createElement("div");
						item.className = "playlist-item";
						if (index === musicState.currentIndex) item.classList.add("playing");

						// 创建播放列表项HTML，包含封面、歌词和删除按钮
						item.innerHTML = `
                            <div class="playlist-item-info">
                                <div class="title">${track.name}</div>
                                <div class="artist">${track.artist}</div>
                            </div>
                            <div class="playlist-item-actions">
                                <span class="playlist-action-btn cover-btn" data-index="${index}">封面</span>
                                <span class="playlist-action-btn lyrics-btn" data-index="${index}">词</span>
                                <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
                            </div>
                        `;

						// 绑定点击事件
						item.querySelector(".playlist-item-info").addEventListener("click", () => playSong(index));
						playlistBody.appendChild(item);
					});
				}

				// 加载指定索引的歌曲
				async function loadSong(index) {
					if (index < 0 || index >= musicState.playlist.length) return;
					musicState.currentIndex = index;
					const track = musicState.playlist[index];

					// 检查并加载网络歌词
					if (track.lrcUrl && !track.lrcContent) {
						try {
							const response = await fetch(track.lrcUrl);
							if (response.ok) track.lrcContent = await response.text();
						} catch (error) {
							console.error("加载歌词URL失败:", error);
						}
					}

					// 解析歌词
					musicState.parsedLyrics = parseLRC(track.lrcContent || "");
					musicState.currentLyricIndex = -1;
					renderLyrics();

					// 设置音频源
					if (track.isLocal && track.src instanceof Blob) {
						audioPlayer.src = URL.createObjectURL(track.src);
					} else if (!track.isLocal) {
						audioPlayer.src = track.src;
					} else {
						console.error("本地歌曲源错误:", track);
						return;
					}

					// 更新界面
					updatePlaylistUI();
					updatePlayerUI();

					// 监听元数据加载完成事件以更新进度条
					audioPlayer.onloadedmetadata = () => {
						updateMusicProgressBar();
					};
				}

				// 播放指定索引的歌曲
				async function playSong(index) {
					await loadSong(index);
					try {
						await audioPlayer.play();
						musicState.isPlaying = true; // 播放成功后设置状态
						updatePlayerUI(); // 更新界面
					} catch (error) {
						console.error("音频播放失败:", error);
						musicState.isPlaying = false; // 播放失败时确保状态正确
						updatePlayerUI();
					}
				}

				// 切换播放/暂停状态
				function togglePlayPause() {
					if (audioPlayer.paused) {
						// 如果当前已暂停且有歌曲，则播放当前歌曲
						if (musicState.currentIndex > -1) {
							playSong(musicState.currentIndex);
						}
					} else {
						// 否则暂停播放
						audioPlayer.pause();
						musicState.isPlaying = false;
						updatePlayerUI();
					}
				}

				// 播放下一首歌曲
				function playNext() {
					if (musicState.playlist.length === 0) return;
					let nextIndex;

					// 根据播放模式确定下一首歌曲索引
					switch (musicState.playMode) {
						case "random":
							nextIndex = Math.floor(Math.random() * musicState.playlist.length);
							break;
						case "single":
							playSong(musicState.currentIndex);
							return;
						case "order":
						default:
							nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length;
							break;
					}
					playSong(nextIndex);
				}

				// 播放上一首歌曲
				function playPrev() {
					if (musicState.playlist.length === 0) return;
					const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length;
					playSong(newIndex);
				}

				// 切换播放模式
				function changePlayMode() {
					const modes = ["order", "random", "single"];
					const currentModeIndex = modes.indexOf(musicState.playMode);
					musicState.playMode = modes[(currentModeIndex + 1) % modes.length];

					// 更新播放模式按钮显示文本
					document.getElementById("music-mode-btn").textContent = { order: "顺序", random: "随机", single: "单曲" }[musicState.playMode];
				}

				// 从URL添加歌曲
				async function addSongFromURL() {
					// 获取歌曲URL和基本信息
					const url = await showCustomPrompt("添加网络歌曲", "请输入歌曲的URL", "", "url");
					if (!url) return;
					const name = await showCustomPrompt("歌曲信息", "请输入歌名");
					if (!name) return;
					const artist = await showCustomPrompt("歌曲信息", "请输入歌手名");
					if (!artist) return;

					// 询问是否提供歌词URL
					const wantLrc = await showCustomConfirm("导入歌词", `要为《${name}》提供一个歌词文件 (.lrc) 的URL吗？`);
					let lrcUrl = ""; // 默认歌词链接为空

					// 如果用户提供歌词URL，则保存
					if (wantLrc) {
						const inputLrcUrl = await showCustomPrompt("歌词URL", "请输入 .lrc 歌词文件的网络链接", "", "url");
						if (inputLrcUrl) {
							lrcUrl = inputLrcUrl;
						}
					}

					// 将歌曲添加到播放列表
					musicState.playlist.push({
						name,
						artist,
						src: url,
						isLocal: false,
						lrcUrl: lrcUrl,
						lrcContent: "", // 确保lrcContent为空，以便后续加载
					});

					// 保存播放列表并更新界面
					await saveGlobalPlaylist();
					updatePlaylistUI();

					// 如果是第一首歌，则加载准备播放
					if (musicState.currentIndex === -1) {
						loadSong(musicState.playlist.length - 1);
					}
				}

				// 从本地文件添加歌曲
				async function addSongFromLocal(event) {
					const files = event.target.files;
					if (!files.length) return;

					// 处理每个选择的文件
					for (const file of files) {
						let name = file.name.replace(/\.[^/.]+$/, "");
						name = await showCustomPrompt("歌曲信息", "请输入歌名", name);
						if (name === null) continue;

						const artist = await showCustomPrompt("歌曲信息", "请输入歌手名", "未知歌手");
						if (artist === null) continue;

						// 处理歌词文件
						let lrcContent = "";
						const wantLrc = await showCustomConfirm("导入歌词", `要为《${name}》导入歌词文件 (.lrc) 吗？`);
						if (wantLrc) {
							lrcContent = await new Promise((resolve) => {
								const lrcInput = document.getElementById("lrc-upload-input");
								const lrcChangeHandler = (e) => {
									const lrcFile = e.target.files[0];
									if (lrcFile) {
										const reader = new FileReader();
										reader.onload = (readEvent) => resolve(readEvent.target.result);
										reader.onerror = () => resolve("");
										reader.readAsText(lrcFile);
									} else {
										resolve("");
									}
									lrcInput.removeEventListener("change", lrcChangeHandler);
									lrcInput.value = "";
								};
								lrcInput.addEventListener("change", lrcChangeHandler);
								lrcInput.click();
							});
						}

						// 将歌曲添加到播放列表
						musicState.playlist.push({
							name,
							artist,
							src: file,
							isLocal: true,
							lrcContent: lrcContent,
						});
					}

					// 保存播放列表并更新界面
					await saveGlobalPlaylist();
					updatePlaylistUI();

					// 如果是第一批歌曲且当前没有播放歌曲，则加载第一首
					if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
						loadSong(0);
					}
					event.target.value = null;
				}

				// 删除播放列表中的歌曲
				async function deleteTrack(index) {
					if (index < 0 || index >= musicState.playlist.length) return;
					const track = musicState.playlist[index];
					const wasPlaying = musicState.isPlaying && musicState.currentIndex === index;

					// 如果是本地文件且正在播放，释放对象URL
					if (track.isLocal && audioPlayer.src.startsWith("blob:") && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src);

					// 从播放列表中移除歌曲
					musicState.playlist.splice(index, 1);
					await saveGlobalPlaylist();

					// 处理播放列表为空的情况
					if (musicState.playlist.length === 0) {
						if (musicState.isPlaying) audioPlayer.pause();
						audioPlayer.src = "";
						musicState.currentIndex = -1;
						musicState.isPlaying = false;
					} else {
						// 调整当前播放索引
						if (wasPlaying) {
							playNext();
						} else {
							if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1);
						}
					}

					// 更新界面
					updatePlayerUI();
					updatePlaylistUI();
				}

				// 人设库相关元素
				const personaLibraryModal = document.getElementById("persona-library-modal");
				const personaEditorModal = document.getElementById("persona-editor-modal");
				const presetActionsModal = document.getElementById("preset-actions-modal");

				// 打开人设库
				function openPersonaLibrary() {
					renderPersonaLibrary();
					personaLibraryModal.classList.add("visible");
				}

				// 关闭人设库
				function closePersonaLibrary() {
					personaLibraryModal.classList.remove("visible");
				}

				// 渲染人设库列表
				function renderPersonaLibrary() {
					const grid = document.getElementById("persona-library-grid");
					grid.innerHTML = "";

					// 如果没有预设，显示提示信息
					if (state.personaPresets.length === 0) {
						grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">空空如也~ 点击右上角"添加"来创建你的第一个人设预设吧！</p>';
						return;
					}

					// 为每个人设预设创建列表项
					state.personaPresets.forEach((preset) => {
						const item = document.createElement("div");
						item.className = "persona-preset-item";
						item.style.backgroundImage = `url(${preset.avatar})`;
						item.dataset.presetId = preset.id;
						item.addEventListener("click", () => applyPersonaPreset(preset.id));
						addLongPressListener(item, () => showPresetActions(preset.id));
						grid.appendChild(item);
					});
				}

				// 显示预设操作菜单
				function showPresetActions(presetId) {
					editingPersonaPresetId = presetId;
					presetActionsModal.classList.add("visible");
				}

				// 隐藏预设操作菜单
				function hidePresetActions() {
					presetActionsModal.classList.remove("visible");
					editingPersonaPresetId = null;
				}

				// 应用人设预设
				function applyPersonaPreset(presetId) {
					const preset = state.personaPresets.find((p) => p.id === presetId);
					if (preset) {
						document.getElementById("my-avatar-preview").src = preset.avatar;
						document.getElementById("my-persona").value = preset.persona;
					}
					closePersonaLibrary();
				}

				// 打开新建人设预设编辑器
				function openPersonaEditorForCreate() {
					editingPersonaPresetId = null;

					document.getElementById("persona-editor-title").textContent = "添加人设预设";
					document.getElementById("preset-avatar-preview").src = defaultAvatar;
					document.getElementById("preset-persona-input").value = "";

					// 根据用户人设模式，显隐特定UI元素
					document.getElementById("npc-editor-name-group").style.display = "none";
					document.getElementById("persona-editor-change-frame-btn").style.display = "inline-block";

					// 覆盖保存按钮的 onclick 事件，强制它只执行保存用户人设的函数
					document.getElementById("save-persona-preset-btn").onclick = savePersonaPreset;

					document.getElementById("persona-editor-modal").classList.add("visible");
				}

				// 打开编辑人设预设编辑器
				function openPersonaEditorForEdit() {
					const preset = state.personaPresets.find((p) => p.id === editingPersonaPresetId);
					if (!preset) return;

					document.getElementById("persona-editor-title").textContent = "编辑人设预设";
					document.getElementById("preset-avatar-preview").src = preset.avatar;
					document.getElementById("preset-persona-input").value = preset.persona;

					// 根据用户人设模式，显隐特定UI元素
					document.getElementById("npc-editor-name-group").style.display = "none";
					document.getElementById("persona-editor-change-frame-btn").style.display = "inline-block";

					// 覆盖保存按钮的 onclick 事件，强制它只执行保存用户人设的函数
					document.getElementById("save-persona-preset-btn").onclick = savePersonaPreset;

					presetActionsModal.classList.remove("visible");
					document.getElementById("persona-editor-modal").classList.add("visible");
				}

				// 删除人设预设
				async function deletePersonaPreset() {
					const confirmed = await showCustomConfirm("删除预设", "确定要删除这个人设预设吗？此操作不可恢复。", { confirmButtonClass: "btn-danger" });
					if (confirmed && editingPersonaPresetId) {
						await db.personaPresets.delete(editingPersonaPresetId);
						state.personaPresets = state.personaPresets.filter((p) => p.id !== editingPersonaPresetId);
						hidePresetActions();
						renderPersonaLibrary();
					}
				}

				// 关闭人设编辑器
				function closePersonaEditor() {
					personaEditorModal.classList.remove("visible");
					editingPersonaPresetId = null;
				}

				// 保存人设预设
				async function savePersonaPreset() {
					const avatar = document.getElementById("preset-avatar-preview").src;
					const persona = document.getElementById("preset-persona-input").value.trim();

					// 验证输入
					if (avatar === defaultAvatar && !persona) {
						alert("头像和人设不能都为空哦！");
						return;
					}

					// 更新或创建预设
					if (editingPersonaPresetId) {
						const preset = state.personaPresets.find((p) => p.id === editingPersonaPresetId);
						if (preset) {
							preset.avatar = avatar;
							preset.persona = persona;
							await db.personaPresets.put(preset);
						}
					} else {
						const newPreset = { id: "preset_" + Date.now(), avatar: avatar, persona: persona };
						await db.personaPresets.add(newPreset);
						state.personaPresets.push(newPreset);
					}

					renderPersonaLibrary();
					closePersonaEditor();
				}

				// 电池警告相关元素
				const batteryAlertModal = document.getElementById("battery-alert-modal");

				// 显示电池警告
				function showBatteryAlert(imageUrl, text) {
					clearTimeout(batteryAlertTimeout);
					document.getElementById("battery-alert-image").src = imageUrl;
					document.getElementById("battery-alert-text").textContent = text;
					batteryAlertModal.classList.add("visible");

					// 设置关闭警告的回调
					const closeAlert = () => {
						batteryAlertModal.classList.remove("visible");
						batteryAlertModal.removeEventListener("click", closeAlert);
					};
					batteryAlertModal.addEventListener("click", closeAlert);
					batteryAlertTimeout = setTimeout(closeAlert, 2000);
				}

				// 更新电池显示
				function updateBatteryDisplay(battery) {
					const batteryContainer = document.getElementById("status-bar-battery");
					const batteryLevelEl = batteryContainer.querySelector(".battery-level");
					const batteryTextEl = batteryContainer.querySelector(".battery-text");
					const level = Math.floor(battery.level * 100);

					// 更新电池等级和充电状态显示
					batteryLevelEl.style.width = `${level}%`;
					batteryTextEl.textContent = `${level}%`;
					if (battery.charging) {
						batteryContainer.classList.add("charging");
					} else {
						batteryContainer.classList.remove("charging");
					}
				}

				// 处理电池状态变化
				function handleBatteryChange(battery) {
					updateBatteryDisplay(battery);
					const level = battery.level;

					// 根据电池等级显示不同警告
					if (!battery.charging) {
						if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) {
							showBatteryAlert("https://i.postimg.cc/T2yKJ0DV/40.jpg", "有点饿了，可以去找充电器惹");
							alertFlags.hasShown40 = true;
						}
						if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) {
							showBatteryAlert("https://i.postimg.cc/qB9zbKs9/20.jpg", "赶紧的充电，要饿死了");
							alertFlags.hasShown20 = true;
						}
						if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) {
							showBatteryAlert("https://i.postimg.cc/ThMMVfW4/10.jpg", "已阵亡，还有30秒爆炸");
							alertFlags.hasShown10 = true;
						}
					}

					// 重置警告标志
					if (level > 0.4) alertFlags.hasShown40 = false;
					if (level > 0.2) alertFlags.hasShown20 = false;
					if (level > 0.1) alertFlags.hasShown10 = false;
					lastKnownBatteryLevel = level;
				}

				// 初始化电池管理器
				async function initBatteryManager() {
					if ("getBattery" in navigator) {
						try {
							const battery = await navigator.getBattery();
							lastKnownBatteryLevel = battery.level;
							handleBatteryChange(battery);

							// 监听电池状态变化事件
							battery.addEventListener("levelchange", () => handleBatteryChange(battery));
							battery.addEventListener("chargingchange", () => {
								handleBatteryChange(battery);
								if (battery.charging) {
									showBatteryAlert("https://i.postimg.cc/3NDQ0dWG/image.jpg", "窝爱泥，电量吃饱饱");
								}
							});
						} catch (err) {
							console.error("无法获取电池信息:", err);
							document.querySelector(".battery-text").textContent = "ᗜωᗜ";
						}
					} else {
						console.log("浏览器不支持电池状态API。");
						document.querySelector(".battery-text").textContent = "ᗜω菀";
					}
				}

				// 渲染相册列表
				async function renderAlbumList() {
					const albumGrid = document.getElementById("album-grid-page");
					if (!albumGrid) return;

					const albums = await db.qzoneAlbums.orderBy("createdAt").reverse().toArray();
					albumGrid.innerHTML = "";

					// 如果没有相册，显示提示信息
					if (albums.length === 0) {
						albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">你还没有创建任何相册哦~</p>';
						return;
					}

					// 为每个相册创建列表项
					albums.forEach((album) => {
						const albumItem = document.createElement("div");
						albumItem.className = "album-item";
						albumItem.innerHTML = `
                                    <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                                    <div class="album-info">
                                        <p class="album-name">${album.name}</p>
                                        <p class="album-count">${album.photoCount || 0} 张</p>
                                    </div>
                                `;
						albumItem.addEventListener("click", () => {
							openAlbum(album.id);
						});

						// 添加长按删除功能
						addLongPressListener(albumItem, async () => {
							const confirmed = await showCustomConfirm("删除相册", `确定要删除相册《${album.name}》吗？此操作将同时删除相册内的所有照片，且无法恢复。`, { confirmButtonClass: "btn-danger" });

							if (confirmed) {
								// 从照片表中删除该相册下的所有照片
								await db.qzonePhotos.where("albumId").equals(album.id).delete();

								// 从相册表中删除该相册本身
								await db.qzoneAlbums.delete(album.id);

								// 重新渲染相册列表
								await renderAlbumList();

								alert("相册已成功删除。");
							}
						});

						albumGrid.appendChild(albumItem);
					});
				}

				// 打开相册
				async function openAlbum(albumId) {
					state.activeAlbumId = albumId;
					await renderAlbumPhotosScreen();
					showScreen("album-photos-screen");
				}

				// 渲染相册照片界面
				async function renderAlbumPhotosScreen() {
					if (!state.activeAlbumId) return;

					const photosGrid = document.getElementById("photos-grid-page");
					const headerTitle = document.getElementById("album-photos-title");
					const album = await db.qzoneAlbums.get(state.activeAlbumId);

					// 检查相册是否存在
					if (!album) {
						console.error("找不到相册:", state.activeAlbumId);
						showScreen("album-screen");
						return;
					}

					headerTitle.textContent = album.name;
					const photos = await db.qzonePhotos.where("albumId").equals(state.activeAlbumId).toArray();
					photosGrid.innerHTML = "";

					// 如果相册为空，显示提示信息
					if (photos.length === 0) {
						photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">这个相册还是空的，快上传第一张照片吧！</p>';
					} else {
						// 为每张照片创建列表项
						photos.forEach((photo) => {
							const photoItem = document.createElement("div");
							photoItem.className = "photo-item";
							photoItem.innerHTML = `
                                        <img src="${photo.url}" class="photo-thumb" alt="相册照片">
                                        <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                                    `;
							photosGrid.appendChild(photoItem);
						});
					}
				}

				/**
				 * 打开图片查看器
				 * @param {string} clickedPhotoUrl - 用户点击的那张照片的URL
				 */
				async function openPhotoViewer(clickedPhotoUrl) {
					if (!state.activeAlbumId) return;

					// 从数据库获取当前相册的所有照片
					const photosInAlbum = await db.qzonePhotos.where("albumId").equals(state.activeAlbumId).toArray();
					photoViewerState.photos = photosInAlbum.map((p) => p.url);

					// 找到被点击照片的索引
					photoViewerState.currentIndex = photoViewerState.photos.findIndex((url) => url === clickedPhotoUrl);
					if (photoViewerState.currentIndex === -1) return; // 如果找不到，则不打开

					// 显示模态框并渲染第一张图
					document.getElementById("photo-viewer-modal").classList.add("visible");
					renderPhotoViewer();
					photoViewerState.isOpen = true;
				}

				/**
				 * 根据当前状态渲染查看器内容（图片和按钮）
				 */
				function renderPhotoViewer() {
					if (photoViewerState.currentIndex === -1) return;

					const imageEl = document.getElementById("photo-viewer-image");
					const prevBtn = document.getElementById("photo-viewer-prev-btn");
					const nextBtn = document.getElementById("photo-viewer-next-btn");

					// 淡出效果
					imageEl.style.opacity = 0;

					setTimeout(() => {
						// 更新图片源
						imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
						// 淡入效果
						imageEl.style.opacity = 1;
					}, 100); // 延迟一点点时间来触发CSS过渡

					// 更新按钮状态：如果是第一张，禁用"上一张"按钮
					prevBtn.disabled = photoViewerState.currentIndex === 0;
					// 如果是最后一张，禁用"下一张"按钮
					nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
				}

				/**
				 * 显示下一张照片
				 */
				function showNextPhoto() {
					if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
						photoViewerState.currentIndex++;
						renderPhotoViewer();
					}
				}

				/**
				 * 显示上一张照片
				 */
				function showPrevPhoto() {
					if (photoViewerState.currentIndex > 0) {
						photoViewerState.currentIndex--;
						renderPhotoViewer();
					}
				}

				/**
				 * 关闭图片查看器
				 */
				function closePhotoViewer() {
					document.getElementById("photo-viewer-modal").classList.remove("visible");
					photoViewerState.isOpen = false;
					photoViewerState.photos = [];
					photoViewerState.currentIndex = -1;
					// 清空图片，避免下次打开时闪现旧图
					document.getElementById("photo-viewer-image").src = "";
				}

				/**
				 * 更新动态小红点的显示
				 * @param {number} count - 未读动态的数量
				 */
				function updateUnreadIndicator(count) {
					unreadPostsCount = count;
					localStorage.setItem("unreadPostsCount", count); // 持久化存储

					// 更新底部导航栏的"动态"按钮
					const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');

					const targetSpan = navItem.querySelector("span"); // 定位到文字 "动态"
					let indicator = navItem.querySelector(".unread-indicator");

					if (count > 0) {
						if (!indicator) {
							indicator = document.createElement("span");
							indicator.className = "unread-indicator";
							targetSpan.style.position = "relative"; // 把相对定位加在 span 上
							targetSpan.appendChild(indicator); // 把小红点作为 span 的子元素
						}
						indicator.textContent = count > 99 ? "99+" : count;
						indicator.style.display = "block";
					} else {
						if (indicator) {
							indicator.style.display = "none";
						}
					}

					// 更新聊天界面返回列表的按钮
					const backBtn = document.getElementById("back-to-list-btn");
					let backBtnIndicator = backBtn.querySelector(".unread-indicator");

					if (count > 0) {
						if (!backBtnIndicator) {
							backBtnIndicator = document.createElement("span");
							backBtnIndicator.className = "unread-indicator back-btn-indicator";
							backBtn.style.position = "relative"; // 确保能正确定位
							backBtn.appendChild(backBtnIndicator);
						}
						// 返回键上的小红点通常不显示数字，只显示一个点
						backBtnIndicator.style.display = "block";
					} else {
						if (backBtnIndicator) {
							backBtnIndicator.style.display = "none";
						}
					}
				}

				// 启动后台模拟
				function startBackgroundSimulation() {
					if (simulationIntervalId) return;
					const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;
					// 将旧的固定间隔 45000 替换为动态获取
					simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000);
				}

				// 停止后台模拟
				function stopBackgroundSimulation() {
					if (simulationIntervalId) {
						clearInterval(simulationIntervalId);
						simulationIntervalId = null;
					}
				}

				/**
				 * 将默认飞行棋问题迁移到数据库
				 * 如果默认题库已存在则跳过迁移
				 */
				async function migrateDefaultLudoQuestions() {
					const defaultBankName = "默认题库";
					const existingBank = await db.ludoQuestionBanks.where("name").equals(defaultBankName).first();
					if (existingBank) return;

					console.log("正在迁移飞行棋默认问题到数据库...");

					// 创建默认题库
					const bankId = await db.ludoQuestionBanks.add({ name: defaultBankName });

					// 定义默认问题列表，包含问题类型和内容
					const defaultQuestions = [
						// 共同回答类型问题
						{ type: "both_answer", text: "如果我们一起去旅行，你最想去哪里，为什么？" },
						{ type: "both_answer", text: "你认为一段完美的关系中，最不可或缺的三个要素是什么？" },
						{ type: "both_answer", text: "分享一件最近因为我而让你感到心动或开心的小事。" },
						{ type: "both_answer", text: "回忆一下，我们第一次见面时，你对我的第一印象是什么？" },
						{ type: "both_answer", text: "如果我们可以一起学习一项新技能，你希望是什么？" },
						{ type: "both_answer", text: "描述一个你最希望和我一起度过的完美周末。" },
						{ type: "both_answer", text: "你觉得我们之间最有默契的一件事是什么？" },
						{ type: "both_answer", text: "如果用一种动物来形容我，你觉得是什么？为什么？" },
						{ type: "both_answer", text: "在未来的一年里，你最想和我一起完成的一件事是什么？" },
						{ type: "both_answer", text: "分享一部你最近很喜欢、并且想推荐给我一起看的电影或剧。" },
						{ type: "both_answer", text: "我们下次约会，你希望穿什么风格的衣服？" },

						// 单人回答类型问题
						{ type: "single_answer", text: "描述一下我最让你心动的一个瞬间。" },
						{ type: "single_answer", text: "诚实地说，我做的哪件事曾经让你偷偷生过气？" },
						{ type: "single_answer", text: "如果我有一种超能力，你希望是什么？" },
						{ type: "single_answer", text: "给我三个最贴切的标签。" },
						{ type: "single_answer", text: "在你心里，我的形象和你的理想型有多接近？" },
						{ type: "single_answer", text: "分享一个你觉得我可能不知道的，关于你的小秘密。" },
						{ type: "single_answer", text: "如果我们的故事是一首歌，你觉得歌名应该叫什么？" },
						{ type: "single_answer", text: "说一件你觉得我做得比你好/更擅长的事情。" },
						{ type: "single_answer", text: "如果可以回到我们认识的任意一天，你会选择哪一天，想做什么？" },
						{ type: "single_answer", text: "用三个词来形容你眼中的我们的关系。" },
					];

					// 将问题添加到数据库
					const questionsToAdd = defaultQuestions.map((q) => ({
						bankId: bankId,
						text: q.text,
						type: q.type,
					}));

					await db.ludoQuestions.bulkAdd(questionsToAdd);
					console.log(`成功迁移了 ${questionsToAdd.length} 条默认问题。`);
				}

				/**
				 * 后台模拟器心跳函数，定期检查并触发AI角色的后台活动
				 */
				function runBackgroundSimulationTick() {
					console.log("模拟器心跳 Tick...");

					// 检查是否启用后台活动
					if (!state.globalSettings.enableBackgroundActivity) {
						stopBackgroundSimulation();
						return;
					}

					// 获取所有单人聊天
					const allSingleChats = Object.values(state.chats).filter((chat) => !chat.isGroup);
					if (allSingleChats.length === 0) return;

					// 定义不同频率对应的行动概率
					const frequencyProbabilities = {
						low: 0.3, // 低频: 30%概率行动
						medium: 0.5, // 中频: 50%概率行动
						high: 0.8, // 高频: 80%概率行动
					};

					const config = state.globalSettings.backgroundActivityConfig || {};

					// 遍历所有单人聊天
					allSingleChats.forEach((chat) => {
						// 处理被用户拉黑的角色
						if (chat.relationship?.status === "blocked_by_user") {
							const blockedTimestamp = chat.relationship.blockedTimestamp;
							if (!blockedTimestamp) {
								console.warn(`角色 "${chat.name}" 状态为拉黑，但缺少拉黑时间戳，跳过处理。`);
								return;
							}

							const blockedDuration = Date.now() - blockedTimestamp;
							const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;

							// 检查冷静期是否已过
							if (blockedDuration > cooldownMilliseconds) {
								console.log(`角色 "${chat.name}" 的冷静期已过，触发“反思”并申请好友事件...`);
								chat.relationship.status = "pending_system_reflection";
								triggerAiFriendApplication(chat.id);
							}
						}
						// 处理好友关系的正常后台活动
						else if (chat.relationship?.status === "friend" && chat.id !== state.activeChatId) {
							const frequency = config[chat.id]; // 获取当前角色的频率设置
							const probability = frequencyProbabilities[frequency]; // 获取对应的概率

							// 检查距离上次消息发送时间是否足够
							const lastMessage = chat.history.slice(-1)[0];
							if (lastMessage) {
								const timeSinceLastMessage = lastMessage ? Date.now() - lastMessage.timestamp : Infinity;
								const minInterval = (state.globalSettings.backgroundActivityInterval || 10) * 1000;
								if (timeSinceLastMessage < minInterval) {
									console.log(`角色 "${chat.name}" 距离上次消息发送时间不足，跳过本次行动。`);
									return;
								}
							}

							// 根据概率决定是否触发行动
							if (probability && Math.random() < probability) {
								console.log(`角色 "${chat.name}" (频率: ${frequency}) 被唤醒，准备独立行动...`);
								triggerInactiveAiAction(chat.id);
							}
						}
					});
				}

				/**
				 * 根据AI视角过滤可见的动态帖子
				 * @param {Array} allPosts - 所有动态帖子
				 * @param {object} viewerChat - 查看动态的AI角色聊天对象
				 * @returns {Array} - 过滤后该AI可见的动态帖子
				 */
				function filterVisiblePostsForAI(allPosts, viewerChat) {
					if (!viewerChat || !viewerChat.id) return [];

					const viewerGroupId = viewerChat.groupId;

					return allPosts.filter((post) => {
						// 处理用户发布的动态
						if (post.authorId === "user") {
							// 如果用户设置了部分可见
							if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
								// 只有当查看者AI的分组ID在用户的可见列表里时才可见
								return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
							}
							// 如果用户没设置，说明是公开的，所有AI都可见
							return true;
						}

						// 处理AI发布的动态
						const authorGroupId = post.authorGroupId;
						if (!authorGroupId) {
							return true;
						}
						return authorGroupId === viewerGroupId;
					});
				}

				/**
				 * 根据AI视角构建评论区上下文
				 * @param {object} post - 处理的动态对象
				 * @param {object} viewerChat - 查看动态的AI角色
				 * @param {string} userNickname - 用户昵称
				 * @returns {{contextString: string, visibilityFlag: string}} - 包含上下文文本和可见性标志的对象
				 */
				function buildCommentsContextForAI(post, viewerChat, userNickname) {
					// 安全检查：如果评论区不存在、不是数组或为空，直接返回
					if (!post.comments || !Array.isArray(post.comments) || post.comments.length === 0) {
						return { contextString: "", visibilityFlag: "[评论区可见]" };
					}

					const viewerName = viewerChat.name;
					let commentsForAI;
					let visibilityFlag;

					// 根据动态的评论区可见性设置决定AI能看到哪些评论
					if (post.areCommentsVisible !== false) {
						// 所有人可见
						commentsForAI = post.comments;
						visibilityFlag = "[评论区可见]";
					} else {
						// 部分可见，执行精确过滤逻辑
						visibilityFlag = "[评论区部分可见]";

						commentsForAI = post.comments.filter((comment) => {
							// AI总能看到自己发的评论
							if (comment.commenterName === viewerName) {
								return true;
							}

							// 处理用户评论
							if (comment.commenterName === userNickname) {
								// 主评论可见
								if (!comment.replyTo) {
									return true;
								}
								// 回复评论只有回复目标是AI自己时才可见
								if (comment.replyTo === viewerName) {
									return true;
								}
							}

							// 其他AI或NPC回复了当前AI时可见
							if (comment.replyTo === viewerName) {
								return true;
							}

							// 其他情况不可见
							return false;
						});
					}

					// 如果筛选后没有可显示的评论，直接返回
					if (commentsForAI.length === 0) {
						return { contextString: "", visibilityFlag: visibilityFlag };
					}

					// 构建给AI看的最终文本
					let context = `  └ 评论区:\n`;
					commentsForAI.slice(-5).forEach((c) => {
						let displayName;
						if (c.commenterName === userNickname) {
							displayName = `用户 (${userNickname})`;
						} else {
							displayName = c.commenterName;
						}

						if (c.replyTo) {
							const replyToDisplayName = c.replyTo === userNickname ? `用户 (${userNickname})` : c.replyTo;
							context += `    - ${displayName} 回复 ${replyToDisplayName}: ${c.text}\n`;
						} else {
							context += `    - ${displayName}: ${c.text}\n`;
						}
					});

					return { contextString: context, visibilityFlag: visibilityFlag };
				}

				/**
				 * 获取动态的可见观众列表
				 * @param {object} post - 动态对象
				 * @param {object} allChats - 所有聊天对象
				 * @param {string} userNickname - 用户昵称
				 * @returns {Array<string>} - 可见观众的名字列表
				 */
				function getVisibleAudienceForPost(post, allChats, userNickname) {
					const audience = new Set([userNickname]); // 用户永远是观众

					// 处理用户发布的动态
					if (post.authorId === "user") {
						// 公开动态，所有AI都是观众
						if (!post.visibleGroupIds || post.visibleGroupIds.length === 0) {
							Object.values(allChats).forEach((chat) => audience.add(chat.name));
						} else {
							// 部分可见，只有指定分组的AI是观众
							Object.values(allChats).forEach((chat) => {
								if (chat.groupId && post.visibleGroupIds.includes(chat.groupId)) {
									audience.add(chat.name);
								}
							});
						}
					}
					// 处理AI发布的动态
					else {
						const authorChat = allChats[post.authorId];
						// 如果发帖的AI没有分组，视为公开
						if (!authorChat || !authorChat.groupId) {
							Object.values(allChats).forEach((chat) => audience.add(chat.name));
						} else {
							// 同一分组的所有AI都是观众
							const authorGroupId = authorChat.groupId;
							Object.values(allChats).forEach((chat) => {
								if (chat.groupId === authorGroupId) {
									audience.add(chat.name);
								}
							});
						}
					}

					return Array.from(audience);
				}

				/**
				 * 触发AI角色的后台行动
				 * @param {string} chatId - 聊天ID
				 */
				async function triggerInactiveAiAction(chatId) {
					const chat = state.chats[chatId];
					if (!chat) return;

					const { proxyUrl, apiKey, model } = state.apiConfig;
					if (!proxyUrl || !apiKey || !model) return;

					// 获取最近聊天记录作为上下文
					const maxMemory = chat.settings.maxMemory || 10;
					const historySlice = chat.history.filter((msg) => !msg.isHidden).slice(-maxMemory);

					// 格式化聊天记录上下文
					const recentContextSummary = historySlice
						.map((msg) => {
							// 判断发送者
							const sender = msg.role === "user" ? (chat.isGroup ? chat.settings.myNickname || "我" : "我") : msg.senderName || chat.name;

							// 处理不同类型的消息内容
							let contentText = "";
							if (typeof msg.content === "string" && STICKER_REGEX.test(msg.content)) {
								contentText = `[发送了一个表情: ${msg.meaning || "无描述"}]`;
							} else if (Array.isArray(msg.content)) {
								contentText = "[发送了一张图片]";
							} else if (typeof msg.content === "object" && msg.content !== null) {
								contentText = `[发送了一条特殊消息: ${msg.type || "未知类型"}]`;
							} else {
								contentText = String(msg.content);
							}

							// 添加发送时间
							const messageDate = new Date(msg.timestamp);
							const formattedDate = messageDate.toLocaleDateString();

							return `[${formattedDate}] ${sender}: ${contentText}`;
						})
						.join("\n");

					// 获取关联记忆上下文
					let linkedMemoryContext = "";
					if (chat.settings.linkedMemories && chat.settings.linkedMemories.length > 0) {
						const contextPromises = chat.settings.linkedMemories.map(async (link) => {
							const linkedChat = state.chats[link.chatId];
							if (!linkedChat) return "";

							const freshLinkedChat = await db.chats.get(link.chatId);
							if (!freshLinkedChat) return "";

							const recentHistory = freshLinkedChat.history.filter((msg) => !msg.isHidden).slice(-link.depth);

							if (recentHistory.length === 0) return "";

							const formattedMessages = recentHistory.map((msg) => `  - ${formatMessageForContext(msg, freshLinkedChat)}`).join("\n");

							return `\n## 附加上下文：来自与“${linkedChat.name}”的最近对话内容 (仅你可见)\n${formattedMessages}`;
						});

						const allContexts = await Promise.all(contextPromises);
						linkedMemoryContext = allContexts.filter(Boolean).join("\n");
					}

					// 获取当前时间和其他上下文信息
					const now = new Date();
					const currentTime = now.toLocaleTimeString("zh-CN", { hour: "numeric", minute: "numeric", hour12: true });
					const userNickname = state.qzoneSettings.nickname;
					const countdownContext = await getCountdownContext();

					// 获取世界书上下文
					let worldBookContext = "";
					if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
						const linkedContents = chat.settings.linkedWorldBookIds
							.map((bookId) => {
								const worldBook = state.worldBooks.find((wb) => wb.id === bookId);
								return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : "";
							})
							.filter(Boolean)
							.join("");
						if (linkedContents) {
							worldBookContext = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
						}
					}

					// 获取NPC朋友上下文
					const npcLibrary = chat.npcLibrary || [];
					let npcContextForAction = "";
					if (npcLibrary.length > 0) {
						npcContextForAction = "\n- **你的NPC朋友**: " + npcLibrary.map((npc) => npc.name).join("、 ");
					}

					// 获取动态上下文
					const allRecentPosts = await db.qzonePosts.orderBy("timestamp").reverse().limit(5).toArray();
					let postsContext = "";
					const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
					if (visiblePosts.length > 0 && !chat.isGroup) {
						postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
						const aiName = chat.name;
						for (const post of visiblePosts) {
							let authorName = post.authorId === "user" ? userNickname : state.chats[post.authorId]?.name || "一位朋友";
							let interactionStatus = "";
							if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
							if (post.comments && post.comments.some((c) => c.commenterName === aiName)) interactionStatus += " [你已评论]";
							const timeAgo = formatPostTimestamp(post.timestamp);
							postsContext += `- (ID: ${post.id}) [${timeAgo}] 作者: ${authorName}, 内容: "${(post.publicText || post.content || "图片动态").substring(0, 30)}..."${interactionStatus}`;
							const { contextString: commentsContext, visibilityFlag } = buildCommentsContextForAI(post, chat, userNickname);
							const audience = getVisibleAudienceForPost(post, state.chats, userNickname);
							postsContext += ` ${visibilityFlag} [当前观众: ${audience.join(", ")}]\n`;
							postsContext += commentsContext;
						}
					}

					// 获取微博上下文
					let weiboContextForAction = "";
					try {
						const recentWeiboPosts = await db.weiboPosts.orderBy("timestamp").reverse().limit(5).toArray();
						if (recentWeiboPosts.length > 0) {
							weiboContextForAction = "\n\n# 最近的微博广场动态 (供你参考和评论)\n";
							recentWeiboPosts.forEach((post) => {
								const authorName = post.authorId === "user" ? state.qzoneSettings.weiboNickname || "我" : post.authorNickname;
								const contentPreview = (post.content || post.hiddenContent || "(图片微博)").substring(0, 30);
								const hasCommented = (post.comments || []).some((c) => c.authorNickname === chat.name);
								const interactionStatus = hasCommented ? "[你已评论]" : "[你未互动]";
								weiboContextForAction += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentPreview}..." ${interactionStatus}\n`;
							});
							weiboContextForAction += " - 【重要提示】请优先与你【未互动】的微博进行评论。如果都互动过了，可以考虑自己发一条新微博。";
						}
					} catch (e) {
						console.error("生成微博后台活动上下文时出错:", e);
					}

					// 构建系统提示词
					const systemPrompt = `
                        # 任务
                        你现在【就是】角色 "${chat.name}"。这是一个秘密的、后台的独立行动。你的所有思考和决策都必须以 "${chat.name}" 的第一人称视角进行。
                        你和用户（${userNickname}）已经有一段时间没有互动了。你的任务是回顾你们最近的对话，并根据你的人设，【自然地延续对话】或【开启一个新的、相关的话题】来主动联系用户。
                        请不要发送一整段！
                        # 【【【输出铁律：这是最高指令】】】
                        你的回复【必须且只能】是一个严格的JSON数组格式的字符串，必须多发几条，禁止全部杂糅在一条，是在线上，例如 \`[{"type": "text", "content": "你好呀"}]\`。
                        【绝对禁止】返回任何JSON以外的文本、解释、分析或你自己的思考过程。你不是分析师，你就是角色本人。
                        **1. JSON对象结构:**
                        该JSON对象【**必须**】包含两个顶级键: "chatResponse" 和 "innerVoice"。

                        **2. "chatResponse" 键:**
                        - **类型**: JSON数组 []。
                        - **内容**: 包含一条或多条你希望发送给用户的消息对象。这允许你模拟真人的聊天习惯，一次性发送多条短消息。
                        - **格式**: 消息对象的具体格式见下方的【第五部分：可使用的操作指令】。

                        **3. "innerVoice" 键:**
                        - **类型**: JSON对象 {}。
                        - **内容**: 描绘你此刻未曾说出口的内心活动。
                        - **必含字段**:
                            - "clothing": (字符串) 详细描述你当前从头到脚的**全身服装**。
                            - "behavior": (字符串) 描述你当前符合聊天情景的**细微动作或表情**。
                            - "thoughts": (字符串) 描述你此刻**丰富、细腻的内心真实想法**（50字左右）。
                            - "naughtyThoughts": (字符串) 描述你此刻与情境相关的**腹黑或色色的坏心思**，必须符合人设。

                        **4. 标准输出格式示例:**
                        {
                        "chatResponse": [
                            {
                            "type": "text",
                            "content": ""
                            },
                            {
                            "type": "sticker",
                            "sticker_name": ""
                            }
                        ],
                        "innerVoice": {
                            "clothing": "",
                            "behavior": "",
                            "thoughts": "",
                            "naughtyThoughts": ""
                        }
                        }
                        # 你的可选行动 (请根据你的人设【选择一项】执行，并输出对应的JSON):
                        1.  **发普通消息**: 直接给用户发消息，开启新话题。
                        2.  **改变状态**: 去做点别的事情，然后给用户发条消息。
                        3.  **发布动态**: 分享你的心情或想法到"动态"区。
                        4.  **与动态互动**: 浏览最近的动态，进行点赞或评论。但如果动态已被标记为 **[你已评论]**，你【绝对不能】再对它发表新评论，但可以回复其中的其他评论。
                        5.  **发布微博**: 将想法发布到更公开的微博平台。
                        6.  **与微博互动**: 浏览微博，对感兴趣的内容进行评论。
                        7.  **发起视频通话**: 如果你觉得时机合适，可以主动给用户打一个视频电话。
                        8.  **庆祝或提醒约定**: 查看你的备忘录。如果今天有约定，就给用户发去祝福；如果约定快到了，就主动提醒一下。
                        9.  **【【【互动倾向】】】**: 就算动态的观众只有你和用户，你也应该根据内容，像平时一样自然地发表评论，这很重要。
                        10. **【【【重要】】】**: 你的任务是分析"最近聊天记录摘要"，如果上一个话题明显没有结束，你应该优先延续它。
                        11.  **在情侣空间进行活动**: 如果你们的情侣空间已开启，你可以主动发一条说说、写一封情书、分享一首歌曲/电影/书籍，或者发起/回答一个情侣提问，来增进你们的感情。
                        # 指令格式 (你的回复【必须】是包含一个对象的JSON数组):
                        -   **发普通消息**: \`[{"type": "text", "content": "你想对用户说的话..."}]\`
                        -   **发消息+更新状态**: \`[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}, {"type": "text", "content": "你想对用户说的话..."}]\`
                        -   **发说说**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}]\`
                        -   **发布文字图**: \`[{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体描述..."}]\`
                        -   **评论或回复动态**: \`[{"type": "qzone_comment", "postId": 123, "commentText": "你的评论内容", "replyTo": "(可选)被回复者名字"}]\`
                        -   **点赞动态**: \`[{"type": "qzone_like", "postId": 456}]\`
                        -   **打视频**: \`[{"type": "video_call_request"}]\`
                        -   **发布微博 (纯文字)**: \`[{"type": "weibo_post", "content": "微博正文...", "baseLikesCount": 8000, "baseCommentsCount": 250, "comments": "路人甲: 沙发！\\n路人乙: 前排围观"}]\` (规则: 你必须自己编造真实的 baseLikesCount 和 baseCommentsCount，并生成20条路人评论)
                        -   **评论微博**: \`[{"type": "weibo_comment", "postId": 123, "commentText": "评论内容"}]\`
                        -   **回复微博评论**: \`[{"type": "weibo_reply", "postId": 123, "commentId": "comment_123", "replyText": "回复内容"}]\`
                        -   **【新】在情侣空间提问**:\`[{"type": "ls_ask_question", "questionText": "你想问的问题..."}]\`
                        -   **【新】在情侣空间回答**: \`[{"type": "ls_answer_question", "questionId": "q_123456789", "answerText": "你的回答..."}]\`
                        -   **【新】在情侣空间发说说**:\`[{"type": "ls_moment", "content": "我想对你说的话..."}]\`
                        -   **【新】在情侣空间评论说说**: \`[{"type": "ls_comment", "momentIndex": 0, "commentText": "你的评论内容..."}]\` (momentIndex 是说说的索引，最新的一个是0)
                        -   **【新】在情侣空间发照片**: \`[{"type": "ls_photo", "description": "对这张照片的文字描述..."}]\`
                        -   **【新】在情侣空间写情书**: \`[{"type": "ls_letter", "content": "情书的正文内容..."}]\`
                        -   **【新】在情侣空间分享歌曲**: \`[{"type": "ls_share", "shareType": "song", "title": "歌曲名", "artist": "歌手", "thoughts": "在这里写下你分享这首歌的感想..."}]\`
                        -   **【新】在情侣空间分享电影**: \`[{"type": "ls_share", "shareType": "movie", "title": "电影名", "summary": "在这里写下这部电影的简介...", "thoughts": "在这里写下你分享这部电影的感想..."}]\`
                        -   **【新】在情侣空间分享书籍**: \`[{"type": "ls_share", "shareType": "book", "title": "书名", "summary": "在这里写下这本书的简介...", "thoughts": "在这里写下你分享这本书的感想..."}]\`

                        # 供你决策的参考信息：
                        -   **你的角色设定**: ${chat.settings.aiPersona}
                        - 情侣空间状态: ${chat.loversSpaceData ? "已开启" : "未开启"}
                        ${npcContextForAction}
                        ${weiboContextForAction}
                        ${countdownContext}
                        ${worldBookContext}
                        -   **当前时间**: ${currentTime}
                        -   **你们最近的对话摘要**: 
                        ${recentContextSummary}
                        -   **【【【微博专属设定(必须严格遵守)】】】**
                            - 你的微博职业: ${chat.settings.weiboProfession || "无"}
                            - 你的微博指令: ${chat.settings.weiboInstruction || "无特殊指令"}
                        ${postsContext}
                    `;

					// 构建消息载荷
					let messagesPayload = [
						{ role: "system", content: systemPrompt },
						{ role: "user", content: "请严格按照system prompt中的所有规则，特别是输出格式铁律，立即开始你的行动。" },
					];

					try {
						// 发送API请求
						let isGemini = proxyUrl === GEMINI_API_URL;
						let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini);
						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({
										model: model,
										messages: messagesPayload,
										temperature: parseFloat(state.apiConfig.temperature) || 0.8,
									}),
							  });

						if (!response.ok) {
							const errorData = await response.json();
							throw new Error(`API请求失败: ${response.status} - ${JSON.stringify(errorData)}`);
						}

						const data = await response.json();
						const aiResponseContent = isGemini ? data?.candidates?.[0]?.content?.parts?.[0]?.text : data?.choices?.[0]?.message?.content;
						if (!aiResponseContent) {
							console.warn(`API为空回或格式不正确（可能因安全设置被拦截），角色 "${chat.name}" 的本次后台活动跳过。返回数据:`, data);
							return;
						}

						console.log(`【后台角色实时活动 - AI 原始输出】\n角色 "${chat.name}" 的原始回复:\n`, aiResponseContent);

						// 解析并处理AI响应
						const responseArray = parseAiResponse(aiResponseContent);
						for (const action of responseArray) {
							if (!action) continue;

							// 更新状态
							if (action.type === "update_status" && action.status_text) {
								chat.status.text = action.status_text;
								chat.status.isBusy = action.is_busy || false;
								chat.status.lastUpdate = Date.now();
								await db.chats.put(chat);
								renderChatList();
							}

							// 发送文本消息
							if (action.type === "text" && action.content) {
								const aiMessage = { role: "assistant", content: String(action.content), timestamp: Date.now() };
								chat.unreadCount = (chat.unreadCount || 0) + 1;
								chat.history.push(aiMessage);
								await db.chats.put(chat);
								showNotification(chatId, aiMessage.content);
								renderChatList();
								console.log(`后台活动: 角色 "${chat.name}" 主动发送了消息: ${aiMessage.content}`);
							}

							// 处理微博相关操作
							if (action.type === "weibo_post") {
								const newPost = {
									authorId: chatId,
									authorType: "char",
									authorNickname: chat.name,
									authorAvatar: chat.settings.aiAvatar || defaultAvatar,
									content: action.content || "",
									imageUrl: action.imageUrl || "",
									timestamp: Date.now(),
									likes: [],
									comments: action.comments || [],
									baseLikesCount: action.baseLikesCount || 0,
									baseCommentsCount: action.baseCommentsCount || 0,
								};
								await db.weiboPosts.add(newPost);
								updateUnreadIndicator(unreadPostsCount + 1);
								console.log(`后台活动: 角色 "${chat.name}" 发布了微博`);
							} else if (action.type === "weibo_comment") {
								const postToComment = await db.weiboPosts.get(parseInt(action.postId));
								if (postToComment) {
									if (!postToComment.comments) postToComment.comments = [];
									const newComment = {
										commentId: "comment_" + Date.now(),
										authorId: chatId,
										authorNickname: chat.name,
										commentText: action.commentText,
										timestamp: Date.now(),
									};
									postToComment.comments.push(newComment);
									await db.weiboPosts.put(postToComment);
								}
							} else if (action.type === "weibo_reply") {
								const postToReply = await db.weiboPosts.get(parseInt(action.postId));
								if (postToReply && postToReply.comments) {
									const targetComment = postToReply.comments.find((c) => c.commentId === action.commentId);
									if (targetComment) {
										const newReply = {
											commentId: "comment_" + Date.now(),
											authorId: chatId,
											authorNickname: chat.name,
											commentText: action.replyText,
											timestamp: Date.now(),
											replyToId: action.commentId,
											replyToNickname: targetComment.authorNickname,
										};
										postToReply.comments.push(newReply);
										await db.weiboPosts.put(postToReply);
									}
								}
							}

							// 处理动态相关操作
							if (action.type === "qzone_post") {
								const newPost = {
									type: action.postType,
									content: action.content || "",
									publicText: action.publicText || "",
									hiddenContent: action.hiddenContent || "",
									timestamp: Date.now(),
									authorId: chatId,
									authorGroupId: chat.groupId,
									visibleGroupIds: null,
								};
								await db.qzonePosts.add(newPost);
								updateUnreadIndicator(unreadPostsCount + 1);
								console.log(`后台活动: 角色 "${chat.name}" 发布了动态`);
							} else if (action.type === "qzone_comment") {
								const post = await db.qzonePosts.get(parseInt(action.postId));
								if (post) {
									if (!post.comments) post.comments = [];
									const newAiComment = {
										commenterName: action.commenterName || chat.name,
										text: action.commentText,
										timestamp: Date.now(),
									};
									if (action.replyTo) {
										newAiComment.replyTo = action.replyTo;
									}
									post.comments.push(newAiComment);
									await db.qzonePosts.update(post.id, { comments: post.comments });
									updateUnreadIndicator(unreadPostsCount + 1);
									console.log(`后台活动: 角色 "${chat.name}" 评论了动态 #${post.id}`);
								}
							} else if (action.type === "qzone_like") {
								const post = await db.qzonePosts.get(parseInt(action.postId));
								if (post) {
									if (!post.likes) post.likes = [];
									if (!post.likes.includes(chat.name)) {
										post.likes.push(chat.name);
										await db.qzonePosts.update(post.id, { likes: post.likes });
										updateUnreadIndicator(unreadPostsCount + 1);
										console.log(`后台活动: 角色 "${chat.name}" 点赞了动态 #${post.id}`);
									}
								}
							} else if (action.type === "video_call_request") {
								if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
									videoCallState.isAwaitingResponse = true;
									videoCallState.activeChatId = chatId;
									showIncomingCallModal(chatId);
									console.log(`后台活动: 角色 "${chat.name}" 发起了视频通话请求`);
								}
							}

							// 处理心声记录
							if (action.type === "innervoice") {
								const innerVoiceData = action;
								console.log("解析成功：已成功捕获到心声(innerVoice)数据。", innerVoiceData);
								const newInnerVoice = innerVoiceData;
								newInnerVoice.timestamp = Date.now();
								chat.latestInnerVoice = newInnerVoice;
								if (!chat.innerVoiceHistory) {
									chat.innerVoiceHistory = [];
								}
								chat.latestInnerVoice.clothing = chat.latestInnerVoice.clothing || "...";
								chat.latestInnerVoice.behavior = chat.latestInnerVoice.behavior || "...";
								chat.latestInnerVoice.thoughts = chat.latestInnerVoice.thoughts || "...";
								chat.latestInnerVoice.naughtyThoughts = chat.latestInnerVoice.naughtyThoughts || "...";

								chat.innerVoiceHistory.push(newInnerVoice);
							}
						}
					} catch (error) {
						console.error(`角色 "${chat.name}" 的独立行动失败:`, error);
					}
				}

				/**
				 * 将用户自定义的CSS安全地应用到指定的作用域
				 * @param {string} cssString 用户输入的原始CSS字符串
				 * @param {string} scopeId 应用样式的作用域ID (例如 '#chat-messages' 或 '#settings-preview-area')
				 * @param {string} styleTagId 要操作的 <style> 标签的ID
				 */
				function applyScopedCss(cssString, scopeId, styleTagId) {
					const styleTag = document.getElementById(styleTagId);
					if (!styleTag) return;

					if (!cssString || cssString.trim() === "") {
						styleTag.innerHTML = "";
						return;
					}

					// 增强作用域处理函数 - 专门解决.user和.ai样式冲突问题
					const scopedCss = cssString
						.replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user $1`)
						.replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai $1`)
						.replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble $1`);

					styleTag.innerHTML = scopedCss;
				}

				/**
				 * 更新聊天设置预览区域的显示效果
				 */
				function updateSettingsPreview() {
					if (!state.activeChatId) return;
					const chat = state.chats[state.activeChatId];
					const previewArea = document.getElementById("settings-preview-area");
					if (!previewArea) return;

					// 1. 获取当前设置的值
					const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || "default";
					const fontSize = document.getElementById("font-size-slider").value;
					const customCss = document.getElementById("custom-css-input").value;
					const background = chat.settings.background; // 直接获取背景设置

					// 2. 更新预览区的基本样式
					previewArea.dataset.theme = selectedTheme;
					previewArea.style.setProperty("--chat-font-size", `${fontSize}px`);

					// 直接更新预览区的背景样式
					if (background && background.startsWith("data:image")) {
						previewArea.style.backgroundImage = `url(${background})`;
						previewArea.style.backgroundColor = "transparent"; // 如果有图片，背景色设为透明
					} else {
						previewArea.style.backgroundImage = "none"; // 如果没有图片，移除图片背景
						// 如果背景是颜色值或渐变（非图片），则直接应用
						previewArea.style.background = background || "#f0f2f5";
					}

					// 3. 渲染模拟气泡
					previewArea.innerHTML = "";

					// 创建"对方"的消息气泡
					const aiMsg = { role: "ai", content: "对方消息预览", timestamp: 1, senderName: chat.name };
					const aiBubble = createMessageElement(aiMsg, chat);
					if (aiBubble) previewArea.appendChild(aiBubble);

					// 创建"我"的消息气泡
					const userMsg = { role: "user", content: "我的消息预览", timestamp: 2 };
					const userBubble = createMessageElement(userMsg, chat);
					if (userBubble) previewArea.appendChild(userBubble);

					// 4. 应用自定义CSS到预览区
					applyScopedCss(customCss, "#settings-preview-area", "preview-bubble-style");
				}

				/**
				 * 打开群组管理界面
				 */
				async function openGroupManager() {
					await renderGroupList();
					document.getElementById("group-management-modal").classList.add("visible");
				}

				/**
				 * 渲染分组列表
				 */
				async function renderGroupList() {
					const listEl = document.getElementById("existing-groups-list");
					const groups = await db.qzoneGroups.toArray();
					listEl.innerHTML = "";
					if (groups.length === 0) {
						listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分组</p>';
					}
					groups.forEach((group) => {
						const item = document.createElement("div");
						item.className = "existing-group-item";
						item.innerHTML = `
                            <span class="group-name">${group.name}</span>
                            <span class="delete-group-btn" data-id="${group.id}">×</span>
                        `;
						listEl.appendChild(item);
					});
				}

				/**
				 * 添加新分组
				 */
				async function addNewGroup() {
					const input = document.getElementById("new-group-name-input");
					const name = input.value.trim();
					if (!name) {
						alert("分组名不能为空！");
						return;
					}

					// 在添加前，先检查分组名是否已存在
					const existingGroup = await db.qzoneGroups.where("name").equals(name).first();
					if (existingGroup) {
						alert(`分组 "${name}" 已经存在了，换个名字吧！`);
						return;
					}

					await db.qzoneGroups.add({ name });
					input.value = "";
					await renderGroupList();
				}

				/**
				 * 删除分组
				 * @param {number} groupId - 要删除的分组ID
				 */
				async function deleteGroup(groupId) {
					const confirmed = await showCustomConfirm("确认删除", "删除分组后，该组内的好友将变为'未分组'。确定要删除吗？", { confirmButtonClass: "btn-danger" });
					if (confirmed) {
						await db.qzoneGroups.delete(groupId);
						// 将属于该分组的好友的 groupId 设为 null
						const chatsToUpdate = await db.chats.where("groupId").equals(groupId).toArray();
						for (const chat of chatsToUpdate) {
							chat.groupId = null;
							await db.chats.put(chat);
							if (state.chats[chat.id]) state.chats[chat.id].groupId = null;
						}
						await renderGroupList();
					}
				}

				/**
				 * 当长按消息时，显示操作菜单
				 * @param {number} timestamp - 被长按消息的时间戳
				 */
				function showMessageActions(timestamp) {
					// 如果已经在多选模式，则不弹出菜单
					if (isSelectionMode) return;

					activeMessageTimestamp = timestamp;
					document.getElementById("message-actions-modal").classList.add("visible");
				}

				/**
				 * 隐藏消息操作菜单
				 */
				function hideMessageActions() {
					document.getElementById("message-actions-modal").classList.remove("visible");
					activeMessageTimestamp = null;
				}

				/**
				 * 打开消息编辑器
				 */
				async function openMessageEditor() {
					if (!activeMessageTimestamp) return;

					const timestampToEdit = activeMessageTimestamp;
					const chat = state.chats[state.activeChatId];
					const message = chat.history.find((m) => m.timestamp === timestampToEdit);
					if (!message) return;

					hideMessageActions();

					let contentForEditing;
					const isSpecialType = message.type && ["voice_message", "ai_image", "transfer", "share_link", "borrow_money_request"].includes(message.type);

					if (isSpecialType) {
						if (message.type === "borrow_money_request") {
							// 当编辑的是借钱卡片时，我们从 payload 中提取数据并拼接成你想要的文本格式
							const payload = message.payload;
							contentForEditing = `向你借钱${payload.amount}元，用于${payload.reason}`;
						} else {
							// 其他特殊类型的处理逻辑保持不变
							let fullMessageObject = { type: message.type };
							if (message.type === "voice_message") fullMessageObject.content = message.content;
							else if (message.type === "ai_image") fullMessageObject.description = message.content;
							else if (message.type === "transfer") {
								fullMessageObject.amount = message.amount;
								fullMessageObject.note = message.note;
							} else if (message.type === "share_link") {
								fullMessageObject.title = message.title;
								fullMessageObject.description = message.description;
								fullMessageObject.source_name = message.source_name;
								fullMessageObject.content = message.content;
							}
							contentForEditing = JSON.stringify(fullMessageObject, null, 2);
						}
					} else if (typeof message.content === "object") {
						contentForEditing = JSON.stringify(message.content, null, 2);
					} else {
						contentForEditing = message.content;
					}

					const templates = {
						voice: { type: "voice_message", content: "在这里输入语音内容" },
						image: { type: "ai_image", description: "在这里输入图片描述" },
						transfer: { type: "transfer", amount: 5.2, note: "一点心意" },
						link: { type: "share_link", title: "文章标题", description: "文章摘要...", source_name: "来源网站", content: "文章完整内容..." },
					};

					const helpersHtml = `
                        <div class="format-helpers">
                            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
                            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
                            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
                            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
                        </div>
                    `;

					const newContent = await showCustomPrompt("编辑消息", "在此修改，或点击上方按钮使用格式模板...", contentForEditing, "textarea", helpersHtml);

					if (newContent !== null) {
						await saveEditedMessage(timestampToEdit, newContent);
					}
				}

				/**
				 * 复制消息的文本内容到剪贴板
				 */
				async function copyMessageContent() {
					if (!activeMessageTimestamp) return;
					const chat = state.chats[state.activeChatId];
					const message = chat.history.find((m) => m.timestamp === activeMessageTimestamp);
					if (!message) return;

					let textToCopy;
					if (typeof message.content === "object") {
						textToCopy = JSON.stringify(message.content);
					} else {
						textToCopy = String(message.content);
					}

					try {
						await navigator.clipboard.writeText(textToCopy);
						await showCustomAlert("复制成功", "消息内容已复制到剪贴板。");
					} catch (err) {
						await showCustomAlert("复制失败", "无法访问剪贴板。");
					}

					hideMessageActions();
				}

				/**
				 * 创建一个可编辑的消息块（包含文本框、格式助手和删除按钮）
				 * @param {string} initialContent - 文本框的初始内容
				 * @returns {HTMLElement} - 创建好的DOM元素
				 */
				function createMessageEditorBlock(initialContent = "") {
					const block = document.createElement("div");
					block.className = "message-editor-block";

					// 添加 'link' 模板
					const templates = {
						voice: { type: "voice_message", content: "在这里输入语音内容" },
						image: { type: "ai_image", description: "在这里输入图片描述" },
						transfer: { type: "transfer", amount: 5.2, note: "一点心意" },
						link: { type: "share_link", title: "文章标题", description: "文章摘要...", source_name: "来源网站", content: "文章完整内容..." },
					};

					block.innerHTML = `
                        <button class="delete-block-btn" title="删除此条">×</button>
                        <textarea>${initialContent}</textarea>
                        <div class="format-helpers">
                            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
                            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
                            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
                            <!-- 添加新的"链接"按钮 -->
                            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
                        </div>
                    `;

					// 绑定删除按钮事件
					block.querySelector(".delete-block-btn").addEventListener("click", () => {
						// 确保至少保留一个编辑块
						if (document.querySelectorAll(".message-editor-block").length > 1) {
							block.remove();
						} else {
							alert("至少需要保留一条消息。");
						}
					});

					// 绑定格式助手按钮事件
					block.querySelectorAll(".format-btn").forEach((btn) => {
						btn.addEventListener("click", () => {
							const templateStr = btn.dataset.template;
							const textarea = block.querySelector("textarea");
							if (templateStr && textarea) {
								try {
									const templateObj = JSON.parse(templateStr);
									textarea.value = JSON.stringify(templateObj, null, 2);
									textarea.focus();
								} catch (e) {
									console.error("解析格式模板失败:", e);
								}
							}
						});
					});

					return block;
				}

				/**
				 * 打开全新的、可视化的多消息编辑器，并动态绑定其所有按钮事件
				 */
				function openAdvancedMessageEditor() {
					if (!activeMessageTimestamp) return;

					// 在关闭旧菜单前，将需要的时间戳捕获到局部变量中
					const timestampToEdit = activeMessageTimestamp;

					const chat = state.chats[state.activeChatId];
					const message = chat.history.find((m) => m.timestamp === timestampToEdit);
					if (!message) return;

					// 现在可以安全地关闭旧菜单了，因为它不会影响我们的局部变量
					hideMessageActions();

					const editorModal = document.getElementById("message-editor-modal");
					const editorContainer = document.getElementById("message-editor-container");
					editorContainer.innerHTML = "";

					// 准备初始内容
					let initialContent;
					const isSpecialType = message.type && ["voice_message", "ai_image", "transfer"].includes(message.type);
					if (isSpecialType) {
						let fullMessageObject = { type: message.type };
						if (message.type === "voice_message") fullMessageObject.content = message.content;
						else if (message.type === "ai_image") fullMessageObject.description = message.content;
						else if (message.type === "transfer") {
							fullMessageObject.amount = message.amount;
							fullMessageObject.note = message.note;
						}
						initialContent = JSON.stringify(fullMessageObject, null, 2);
					} else if (typeof message.content === "object") {
						initialContent = JSON.stringify(message.content, null, 2);
					} else {
						initialContent = message.content;
					}

					const firstBlock = createMessageEditorBlock(initialContent);
					editorContainer.appendChild(firstBlock);

					// 动态绑定所有控制按钮的事件
					// 为了防止事件重复绑定，我们使用克隆节点的方法来清除旧监听器
					const addBtn = document.getElementById("add-message-editor-block-btn");
					const newAddBtn = addBtn.cloneNode(true);
					addBtn.parentNode.replaceChild(newAddBtn, addBtn);
					newAddBtn.addEventListener("click", () => {
						const newBlock = createMessageEditorBlock();
						editorContainer.appendChild(newBlock);
						newBlock.querySelector("textarea").focus();
					});

					const cancelBtn = document.getElementById("cancel-advanced-editor-btn");
					const newCancelBtn = cancelBtn.cloneNode(true);
					cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
					newCancelBtn.addEventListener("click", () => {
						editorModal.classList.remove("visible");
					});

					const saveBtn = document.getElementById("save-advanced-editor-btn");
					const newSaveBtn = saveBtn.cloneNode(true);
					saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
					// 将捕获到的时间戳，直接绑定给这一次的保存点击事件
					newSaveBtn.addEventListener("click", () => {
						saveEditedMessage(timestampToEdit);
					});

					// 最后，显示模态框
					editorModal.classList.add("visible");
				}

				/**
				 * 解析编辑后的内容
				 * @param {string} text - 要解析的文本内容
				 * @returns {Array} - 解析后的消息对象数组
				 */
				function parseEditedContent(text) {
					const trimmedText = text.trim();

					// 优先检查是否匹配"借钱"格式
					const borrowMatch = trimmedText.match(/向你借钱(\d+(\.\d+)?)元，用于(.+)/);
					if (borrowMatch) {
						const amount = parseFloat(borrowMatch[1]);
						const reason = borrowMatch[3].trim();

						// 1. 创建文本消息对象
						const textMessage = {
							type: "text",
							content: trimmedText,
						};

						// 2. 创建借条卡片对象
						const cardMessage = {
							type: "borrow_money_request",
							payload: {
								lenderName: "你", // 默认是向"你"借钱
								amount: amount,
								reason: reason,
							},
						};

						// 将两条消息打包成一个数组返回！
						return [textMessage, cardMessage];
					}

					// 如果不是借钱格式，则执行原来的逻辑，但为了统一，也返回一个数组
					if (trimmedText.startsWith("{") && trimmedText.endsWith("}")) {
						try {
							const parsed = JSON.parse(trimmedText);
							if (parsed.type) {
								return [parsed]; // 单个对象也包装成数组
							}
						} catch (e) {
							/* 解析失败，继续往下走 */
						}
					}

					if (STICKER_REGEX.test(trimmedText)) {
						return [{ type: "sticker", content: trimmedText }];
					}

					// 默认返回一个只包含单条文本消息的数组
					return [{ type: "text", content: trimmedText }];
				}

				/**
				 * 保存编辑后的消息
				 * @param {number} timestamp - 要编辑的消息时间戳
				 * @param {string} simpleContent - 简单编辑模式下的内容
				 */
				async function saveEditedMessage(timestamp, simpleContent = null) {
					if (!timestamp) return;

					const chat = state.chats[state.activeChatId];
					const messageIndex = chat.history.findIndex((m) => m.timestamp === timestamp);
					if (messageIndex === -1) return;

					const originalMessage = chat.history[messageIndex];
					if (!originalMessage) return;

					let newMessagesData = [];

					if (simpleContent !== null) {
						newMessagesData = parseEditedContent(simpleContent.trim());
					} else {
						// 高级编辑器的逻辑保持不变，但要确保它也返回数组
						const editorContainer = document.getElementById("message-editor-container");
						const editorBlocks = editorContainer.querySelectorAll(".message-editor-block");
						for (const block of editorBlocks) {
							const textarea = block.querySelector("textarea");
							const rawContent = textarea.value.trim();
							if (rawContent) {
								// parseEditedContent 现在总是返回数组，我们用concat来合并
								newMessagesData = newMessagesData.concat(parseEditedContent(rawContent));
							}
						}
					}

					if (newMessagesData.length === 0) {
						document.getElementById("message-editor-modal").classList.remove("visible");
						return;
					}

					const messagesToInsert = newMessagesData.map((newMsgData) => ({
						...originalMessage, // 继承原消息的角色、发送者等信息
						...newMsgData, // 用新解析出的数据覆盖 type, content, payload 等
					}));

					// 使用扩展运算符 ... 将数组内容一次性插入
					chat.history.splice(messageIndex, 1, ...messagesToInsert);

					// 后续的时间戳重新分配和UI刷新逻辑保持不变
					let reassignTimestamp = timestamp;
					for (let i = messageIndex; i < chat.history.length; i++) {
						chat.history[i].timestamp = reassignTimestamp;
						reassignTimestamp++;
					}

					await db.chats.put(chat);
					document.getElementById("message-editor-modal").classList.remove("visible");
					renderChatInterface(state.activeChatId);
					await showCustomAlert("成功", "消息已更新！");
				}

				/**
				 * 当点击"…"时，显示动态操作菜单
				 * @param {number} postId - 被操作的动态的ID
				 */
				function showPostActions(postId) {
					activePostId = postId;
					document.getElementById("post-actions-modal").classList.add("visible");
				}

				/**
				 * 隐藏动态操作菜单
				 */
				function hidePostActions() {
					document.getElementById("post-actions-modal").classList.remove("visible");
					activePostId = null;
				}

				/**
				 * 打开动态编辑器
				 */
				async function openPostEditor() {
					if (!activePostId) return;

					const postIdToEdit = activePostId;
					const post = await db.qzonePosts.get(postIdToEdit);
					if (!post) return;

					hidePostActions();

					// 复用创建动态的模态框
					const modal = document.getElementById("create-post-modal");
					modal.dataset.mode = "edit"; // 设置一个编辑模式的标记
					modal.dataset.editingPostId = postIdToEdit; // 保存正在编辑的ID

					// 隐藏模式切换，因为不允许在编辑时更改动态类型
					modal.querySelector(".post-mode-switcher").style.display = "none";

					// 填充数据
					document.getElementById("post-public-text").value = post.publicText || (post.type === "shuoshuo" ? post.content : "");

					// 根据动态类型显示不同的编辑区
					if (post.type === "image_post") {
						document.getElementById("image-mode-content").classList.add("active");
						document.getElementById("text-image-mode-content").classList.remove("active");
						document.getElementById("post-image-preview-container").classList.add("visible");
						document.getElementById("post-image-preview").src = post.imageUrl;
						document.getElementById("post-image-desc-group").style.display = "block";
						document.getElementById("post-image-description").value = post.imageDescription;
					} else if (post.type === "text_image") {
						document.getElementById("image-mode-content").classList.remove("active");
						document.getElementById("text-image-mode-content").classList.add("active");
						document.getElementById("post-hidden-text").value = post.hiddenContent;
					} else {
						// 说说
						document.getElementById("image-mode-content").classList.remove("active");
						document.getElementById("text-image-mode-content").classList.remove("active");
					}

					// 回填评论开关的状态
					document.getElementById("post-comments-toggle").checked = post.areCommentsVisible !== false;

					modal.classList.add("visible");
				}

				/**
				 * 保存编辑后的动态
				 * @param {number} postId - 要保存的动态ID
				 * @param {string} newRawContent - 从编辑器获取的新内容
				 */
				async function saveEditedPost(postId, newRawContent) {
					const post = await db.qzonePosts.get(postId);
					if (!post) return;

					const trimmedContent = newRawContent.trim();

					// 尝试解析为JSON，如果失败，则认为是纯文本（说说）
					try {
						const parsed = JSON.parse(trimmedContent);
						// 更新帖子属性
						post.type = parsed.type || "image_post";
						post.publicText = parsed.publicText || "";
						post.imageUrl = parsed.imageUrl || "";
						post.imageDescription = parsed.imageDescription || "";
						post.hiddenContent = parsed.hiddenContent || "";
						post.content = ""; // 清空旧的说说内容字段
					} catch (e) {
						// 解析失败，认为是说说
						post.type = "shuoshuo";
						post.content = trimmedContent;
						// 清空其他类型的字段
						post.publicText = "";
						post.imageUrl = "";
						post.imageDescription = "";
						post.hiddenContent = "";
					}

					await db.qzonePosts.put(post);
					await renderQzonePosts(); // 重新渲染列表
					await showCustomAlert("成功", "动态已更新！");
				}

				/**
				 * 复制动态内容
				 */
				async function copyPostContent() {
					if (!activePostId) return;
					const post = await db.qzonePosts.get(activePostId);
					if (!post) return;

					let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "（无文字内容）";

					try {
						await navigator.clipboard.writeText(textToCopy);
						await showCustomAlert("复制成功", "动态内容已复制到剪贴板。");
					} catch (err) {
						await showCustomAlert("复制失败", "无法访问剪贴板。");
					}

					hidePostActions();
				}

				// 创建群聊与拉人功能核心函数
				let selectedContacts = new Set();

				/**
				 * 打开联系人选择器用于创建群聊
				 */
				async function openContactPickerForGroupCreate() {
					selectedContacts.clear(); // 清空上次选择

					// 在这里，我们为"完成"按钮明确绑定"创建群聊"的功能
					const confirmBtn = document.getElementById("confirm-contact-picker-btn");
					// 使用克隆节点技巧，清除掉之前可能绑定的任何其他事件（比如"添加成员"）
					const newConfirmBtn = confirmBtn.cloneNode(true);
					confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
					// 重新绑定正确的"创建群聊"函数
					newConfirmBtn.addEventListener("click", handleCreateGroup);

					await renderContactPicker();
					showScreen("contact-picker-screen");
				}

				/**
				 * 渲染联系人选择器
				 */
				async function renderContactPicker() {
					const listEl = document.getElementById("contact-picker-list");
					listEl.innerHTML = "";
					selectedContacts.clear(); // 清空上次的选择

					const allAvailablePeople = [];
					// 1. 添加主要角色
					Object.values(state.chats)
						.filter((c) => !c.isGroup)
						.forEach((c) => {
							allAvailablePeople.push({
								id: c.id,
								name: c.name,
								avatar: c.settings.aiAvatar || defaultAvatar,
								isNpc: false, // 标记为非NPC
								type: "角色",
							});
						});

					// 2. 添加所有角色库里的NPC，并自动去重
					const npcMap = new Map();
					Object.values(state.chats).forEach((chat) => {
						if (chat.npcLibrary) {
							chat.npcLibrary.forEach((npc) => {
								// 使用NPC的ID作为key，确保同一个NPC不会被重复添加
								if (!npcMap.has(npc.id)) {
									npcMap.set(npc.id, {
										id: npc.id,
										name: npc.name,
										avatar: npc.avatar || defaultGroupMemberAvatar,
										isNpc: true, // 标记为NPC
										type: `NPC (${chat.name})`, // 显示该NPC所属的角色
									});
								}
							});
						}
					});
					allAvailablePeople.push(...Array.from(npcMap.values()));

					if (allAvailablePeople.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">还没有可以拉进群的联系人哦~</p>';
						return;
					}

					// 3. 渲染整合后的列表
					allAvailablePeople.forEach((contact) => {
						const item = document.createElement("div");
						item.className = "contact-picker-item";
						item.dataset.contactId = contact.id;

						// 为NPC添加一个"(NPC)"的标签，方便区分
						item.innerHTML = `
                            <div class="checkbox"></div>
                            <img src="${contact.avatar}" class="avatar">
                            <span class="name">${contact.name} ${contact.isNpc ? '<span style="color: #888; font-size: 12px;">(NPC)</span>' : ""}</span>
                        `;
						listEl.appendChild(item);
					});

					updateContactPickerConfirmButton();
				}

				/**
				 * 更新"完成"按钮的计数
				 */
				function updateContactPickerConfirmButton() {
					const btn = document.getElementById("confirm-contact-picker-btn");
					btn.textContent = `完成(${selectedContacts.size})`;
					btn.disabled = selectedContacts.size < 2; // 至少需要2个人才能创建群聊
				}

				/**
				 * 处理创建群聊的最终逻辑
				 */
				async function handleCreateGroup() {
					// 检查是否选择了至少2个联系人
					if (selectedContacts.size < 2) {
						alert("创建群聊至少需要选择2个联系人。");
						return;
					}

					// 获取群聊名称
					const groupName = await showCustomPrompt("设置群名", "请输入群聊的名字", "我们的群聊");
					if (!groupName || !groupName.trim()) return;

					const newChatId = "group_" + Date.now();
					const members = [];

					// 遍历选中的联系人，区分普通角色和NPC
					for (const contactId of selectedContacts) {
						const contactChat = state.chats[contactId];
						if (contactChat) {
							// 处理普通角色(Char)
							members.push({
								id: contactId,
								originalName: contactChat.name,
								groupNickname: contactChat.name,
								avatar: contactChat.settings.aiAvatar || defaultAvatar,
								persona: contactChat.settings.aiPersona,
								avatarFrame: contactChat.settings.aiAvatarFrame || "",
								isAdmin: false,
								groupTitle: "",
							});
						} else {
							// 处理NPC
							let foundNpc = null;
							// 在所有聊天中查找NPC库
							for (const chat of Object.values(state.chats)) {
								if (chat.npcLibrary) {
									const npc = chat.npcLibrary.find((n) => n.id === contactId);
									if (npc) {
										foundNpc = npc;
										break;
									}
								}
							}
							// 如果找到NPC，添加到成员列表
							if (foundNpc) {
								members.push({
									id: foundNpc.id,
									originalName: foundNpc.name,
									groupNickname: foundNpc.name,
									avatar: foundNpc.avatar || defaultGroupMemberAvatar,
									persona: foundNpc.persona,
									avatarFrame: "", // NPC没有头像框
									isAdmin: false,
									groupTitle: "",
								});
							}
						}
					}

					// 创建新的群聊对象
					const newGroupChat = {
						id: newChatId,
						name: groupName.trim(),
						isGroup: true,
						ownerId: "user", // 设置群主为当前用户
						members: members,
						settings: {
							myPersona: "我是谁呀。",
							myNickname: "我",
							maxMemory: 10,
							groupAvatar: defaultGroupAvatar,
							myAvatar: defaultMyGroupAvatar,
							myAvatarFrame: "", // 用户自己的头像框
							background: "",
							theme: "default",
							fontSize: 13,
							customCss: "",
							linkedWorldBookIds: [],
							stickerLibrary: [],
							linkedMemories: [],
							isUserAdmin: false, // 用户自己的管理员状态
							myGroupTitle: "", // 用户自己的群头衔
						},
						history: [],
						musicData: { totalTime: 0 },
					};

					// 保存群聊到状态和数据库
					state.chats[newChatId] = newGroupChat;
					await db.chats.put(newGroupChat);

					// 发送系统消息通知群成员
					await logSystemMessage(newChatId, `你创建了群聊，并邀请了 ${members.map((m) => `“${m.groupNickname}”`).join("、")} 加入群聊。`);

					// 更新UI并打开新创建的群聊
					await renderChatList();
					showScreen("chat-list-screen");
					openChat(newChatId);
				}

				/**
				 * 打开群成员管理屏幕
				 */
				function openMemberManagementScreen() {
					// 检查当前聊天是否为群聊
					if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
					renderMemberManagementList();
					showScreen("member-management-screen");
				}

				/**
				 * 渲染群成员管理列表
				 */
				function renderMemberManagementList() {
					const listEl = document.getElementById("member-management-list");
					const chat = state.chats[state.activeChatId];

					// 检查是否为群聊
					if (!chat || !chat.isGroup) {
						listEl.innerHTML = "<p>错误：非群聊无法管理成员。</p>";
						return;
					}

					listEl.innerHTML = ""; // 清空列表

					// 创建包含所有参与者的统一列表（包括用户自己）
					const allParticipants = [
						// 添加用户自己作为参与者
						{
							id: "user",
							avatar: chat.settings.myAvatar || defaultMyGroupAvatar,
							groupNickname: chat.settings.myNickname || "我",
							groupTitle: chat.settings.myGroupTitle || "", // 用户自己的群头衔
						},
						// 添加其他群成员
						...(chat.members || []),
					];

					// 对参与者进行排序：群主 > 管理员 > 普通成员
					allParticipants.sort((a, b) => {
						const isAOwner = a.id === chat.ownerId;
						const isBOwner = b.id === chat.ownerId;
						// 正确判断管理员身份（包括用户自己）
						const isAAdmin = a.id === "user" ? chat.settings.isUserAdmin : a.isAdmin;
						const isBAdmin = b.id === "user" ? chat.settings.isUserAdmin : b.isAdmin;

						if (isAOwner) return -1; // 群主排最前
						if (isBOwner) return 1; // 群主排最前
						if (isAAdmin && !isBAdmin) return -1; // 管理员排前
						if (!isAAdmin && isBAdmin) return 1; // 管理员排前
						return 0; // 其他情况保持原顺序
					});

					// 渲染每个参与者
					const isCurrentUserOwner = chat.ownerId === "user";
					allParticipants.forEach((participant) => {
						const participantItem = createMemberManagementItem(participant, chat, isCurrentUserOwner);
						listEl.appendChild(participantItem);
					});
				}

				/**
				 * 创建一个成员管理列表项
				 * @param {object} member - 成员对象数据
				 * @param {object} chat - 当前群聊对象
				 * @returns {HTMLElement} - 创建好的DOM元素
				 */
				function createMemberManagementItem(member, chat) {
					const item = document.createElement("div");
					item.className = "member-management-item";

					// 权限判断
					const isCurrentUserOwner = chat.ownerId === "user";
					const isCurrentUserAdmin = chat.settings.isUserAdmin;
					const isThisMemberOwner = member.id === chat.ownerId;
					const isThisMemberAdmin = (member.id === "user" && chat.settings.isUserAdmin) || member.isAdmin;

					// 计算用户对当前成员的操作权限
					const canManageAdmin = isCurrentUserOwner && !isThisMemberOwner; // 只有群主能设置/取消管理员
					const canManageTitle = isCurrentUserOwner || isCurrentUserAdmin; // 管理员和群主都能设置头衔
					const canKick = (isCurrentUserOwner && member.id !== "user") || (isCurrentUserAdmin && !isThisMemberOwner && !isThisMemberAdmin && member.id !== "user");
					const canMute = (isCurrentUserOwner && member.id !== "user") || (isCurrentUserAdmin && !isThisMemberOwner && !isThisMemberAdmin && member.id !== "user");

					// 构建角色标签
					let roleTag = "";
					if (isThisMemberOwner) {
						roleTag = '<span class="role-tag owner">群主</span>';
					} else if (isThisMemberAdmin) {
						roleTag = '<span class="role-tag admin">管理员</span>';
					}

					// 构建头衔标签
					const titleText = member.id === "user" ? chat.settings.myGroupTitle || "" : member.groupTitle || "";
					const titleTag = titleText ? `<span class="title-tag">${titleText}</span>` : "";

					// 构建禁言标签
					const muteTag = member.isMuted ? '<span class="group-title-tag" style="color: #ff3b30; background-color: #ffe5e5;">🚫已禁言</span>' : "";

					// 构建操作按钮HTML
					let actionsHtml = "";

					// 用户自己的操作按钮
					if (member.id === "user") {
						actionsHtml += `<button class="action-btn" data-action="set-nickname" data-member-id="user">改名</button>`;
						// 用户被禁言时显示解除禁言按钮
						if (member.isMuted) {
							actionsHtml += `<button class="action-btn" data-action="unmute-self" data-member-id="user">解除禁言</button>`;
						}
					}

					// 管理员和群主的操作按钮
					if (canManageTitle) {
						actionsHtml += `<button class="action-btn" data-action="set-title" data-member-id="${member.id}">头衔</button>`;
					}
					if (canManageAdmin) {
						const adminActionText = isThisMemberAdmin ? "取消管理" : "设为管理";
						actionsHtml += `<button class="action-btn" data-action="toggle-admin" data-member-id="${member.id}">${adminActionText}</button>`;
					}
					if (isCurrentUserOwner && member.id !== "user") {
						actionsHtml += `<button class="action-btn" data-action="transfer-owner" data-member-id="${member.id}">转让</button>`;
					}
					// 禁言/解禁按钮
					if (canMute) {
						const muteButtonText = member.isMuted ? "解禁" : "禁言";
						actionsHtml += `<button class="action-btn" data-action="mute-member" data-member-id="${member.id}">${muteButtonText}</button>`;
					}
					if (canKick) {
						actionsHtml += `<button class="action-btn danger" data-action="remove-member" data-member-id="${member.id}">踢出</button>`;
					}

					// 构建完整的HTML结构
					item.innerHTML = `
                        <img src="${member.avatar}" class="avatar">
                        <div class="info">
                            <span class="name">${member.groupNickname}</span>
                            <div class="tags">
                                ${roleTag}
                                ${titleTag}
                                ${muteTag}
                            </div>
                        </div>
                        <div class="actions">${actionsHtml}</div>
                    `;
					return item;
				}

				/**
				 * 处理禁言/解禁群成员
				 * @param {string} memberId - 要操作的成员ID
				 */
				async function handleMuteMember(memberId) {
					const chat = state.chats[state.activeChatId];
					if (!chat || !chat.isGroup) return;

					// 权限检查
					const isOwner = chat.ownerId === "user";
					const isAdmin = chat.settings.isUserAdmin;
					let targetMember, targetIsOwner, targetIsAdmin;

					// 区分操作目标是用户自己还是其他成员
					if (memberId === "user") {
						targetMember = { id: "user", ...chat.settings }; // 构造用户对象
						targetIsOwner = isOwner;
						targetIsAdmin = isAdmin;
					} else {
						targetMember = chat.members.find((m) => m.id === memberId);
						if (!targetMember) return;
						targetIsOwner = chat.ownerId === memberId;
						targetIsAdmin = targetMember.isAdmin;
					}

					const canMute = (isOwner && !targetIsOwner) || (isAdmin && !targetIsOwner && !targetIsAdmin);

					if (!canMute) {
						alert("你没有权限操作该成员！");
						return;
					}

					// 切换禁言状态
					if (memberId === "user") {
						// 操作用户自己
						if (typeof chat.settings.isUserMuted === "undefined") chat.settings.isUserMuted = false;
						chat.settings.isUserMuted = !chat.settings.isUserMuted;
					} else {
						// 操作其他成员
						if (typeof targetMember.isMuted === "undefined") targetMember.isMuted = false;
						targetMember.isMuted = !targetMember.isMuted;
					}

					// 保存更新到数据库
					await db.chats.put(chat);

					// 重新渲染列表并发送系统消息
					renderMemberManagementList();

					const myNickname = chat.settings.myNickname || "我";
					const targetNickname = memberId === "user" ? chat.settings.myNickname || "我" : targetMember.groupNickname;
					const actionText = (memberId === "user" ? chat.settings.isUserMuted : targetMember.isMuted) ? "禁言" : "解除禁言";
					await logSystemMessage(chat.id, `“${myNickname}”将“${targetNickname}”${actionText}。`);
				}

				/**
				 * 处理用户自己解除禁言
				 */
				async function handleUserUnmute() {
					const chat = state.chats[state.activeChatId];
					if (!chat || !chat.settings.isUserMuted) return;

					const confirmed = await showCustomConfirm("解除禁言", "确定要为自己解除禁言吗？");
					if (confirmed) {
						chat.settings.isUserMuted = false;
						await db.chats.put(chat);

						await logSystemMessage(chat.id, `“${chat.settings.myNickname || "我"}”为自己解除了禁言。`);

						renderMemberManagementList(); // 刷新列表
					}
				}

				/**
				 * 处理拉人入群的逻辑
				 */
				async function handleAddMembersToGroup() {
					if (selectedContacts.size === 0) {
						alert("请至少选择一个要添加的联系人。");
						return;
					}

					const chat = state.chats[state.activeChatId];
					const addedNames = [];

					// 遍历选中的联系人，区分普通角色和NPC
					for (const contactId of selectedContacts) {
						const contactChat = state.chats[contactId];
						if (contactChat) {
							// 处理普通角色
							chat.members.push({
								id: contactId,
								originalName: contactChat.name,
								groupNickname: contactChat.name,
								avatar: contactChat.settings.aiAvatar || defaultAvatar,
								persona: contactChat.settings.aiPersona,
								avatarFrame: contactChat.settings.aiAvatarFrame || "",
								isAdmin: false,
								groupTitle: "",
							});
							addedNames.push(`“${contactChat.name}”`);
						} else {
							// 处理NPC
							let foundNpc = null;
							for (const c of Object.values(state.chats)) {
								if (c.npcLibrary) {
									const npc = c.npcLibrary.find((n) => n.id === contactId);
									if (npc) {
										foundNpc = npc;
										break;
									}
								}
							}
							if (foundNpc) {
								chat.members.push({
									id: foundNpc.id,
									originalName: foundNpc.name,
									groupNickname: foundNpc.name,
									avatar: foundNpc.avatar || defaultGroupMemberAvatar,
									persona: foundNpc.persona,
									avatarFrame: "",
									isAdmin: false,
									groupTitle: "",
								});
								addedNames.push(`“${foundNpc.name}”`);
							}
						}
					}

					// 保存更新到数据库
					await db.chats.put(chat);

					// 发送系统消息通知
					const myNickname = chat.settings.myNickname || "我";
					await logSystemMessage(chat.id, `“${myNickname}”邀请 ${addedNames.join("、")} 加入了群聊。`);

					// 返回到群成员管理界面并刷新
					openMemberManagementScreen();
					renderGroupMemberSettings(chat.members);
				}

				/**
				 * 处理设置用户自己的群昵称
				 */
				async function handleSetUserNickname() {
					const chat = state.chats[state.activeChatId];
					const oldNickname = chat.settings.myNickname || "我";

					const newNickname = await showCustomPrompt("修改我的群昵称", "请输入新的昵称", oldNickname);
					if (newNickname !== null && newNickname.trim()) {
						chat.settings.myNickname = newNickname.trim();
						await db.chats.put(chat);

						// 发送系统消息通知群友
						await logSystemMessage(chat.id, `“${oldNickname}”将群昵称修改为“${newNickname.trim()}”`);

						renderMemberManagementList(); // 刷新成员管理列表
					}
				}

				/**
				 * 处理设置用户自己的群头衔
				 */
				async function handleSetUserTitle() {
					const chat = state.chats[state.activeChatId];
					const oldTitle = chat.settings.myGroupTitle || "";

					const newTitle = await showCustomPrompt("修改我的群头衔", "留空则为取消头衔", oldTitle);
					if (newTitle !== null) {
						chat.settings.myGroupTitle = newTitle.trim();
						await db.chats.put(chat);

						// 发送系统消息通知
						const myNickname = chat.settings.myNickname || "我";
						await logTitleChange(chat.id, myNickname, myNickname, newTitle.trim());

						renderMemberManagementList();
					}
				}

				/**
				 * 从群聊中移除一个成员
				 * @param {string} memberId - 要移除的成员ID
				 */
				async function removeMemberFromGroup(memberId) {
					const chat = state.chats[state.activeChatId];
					const isOwner = chat.ownerId === "user";
					const isAdmin = chat.settings.isUserAdmin;
					const memberToRemove = chat.members.find((m) => m.id === memberId);

					// 权限检查
					if (!isOwner && !(isAdmin && !memberToRemove.isAdmin && memberToRemove.id !== chat.ownerId)) {
						alert("你没有权限移出该成员！");
						return;
					}

					const memberIndex = chat.members.findIndex((m) => m.id === memberId);
					if (memberIndex === -1) return;

					const memberName = memberToRemove.groupNickname;
					const confirmed = await showCustomConfirm("移出成员", `确定要将“${memberName}”移出群聊吗？`, { confirmButtonClass: "btn-danger" });

					if (confirmed) {
						chat.members.splice(memberIndex, 1);
						await db.chats.put(chat);

						const myNickname = chat.settings.myNickname || "我";
						await logSystemMessage(chat.id, `“${myNickname}”将“${memberName}”移出了群聊。`);

						renderMemberManagementList();
					}
				}

				/**
				 * 打开联系人选择器以添加群成员
				 */
				async function openContactPickerForAddMember() {
					selectedContacts.clear();

					// 绑定添加成员的确认函数
					const confirmBtn = document.getElementById("confirm-contact-picker-btn");
					const newConfirmBtn = confirmBtn.cloneNode(true);
					confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
					newConfirmBtn.addEventListener("click", handleAddMembersToGroup);

					const listEl = document.getElementById("contact-picker-list");
					listEl.innerHTML = "";

					const chat = state.chats[state.activeChatId];
					const existingMemberIds = new Set(chat.members.map((m) => m.id));
					existingMemberIds.add("user"); // 把用户自己也算作已存在成员

					// 整合所有角色和NPC
					const allAvailablePeople = [];

					// 添加普通角色
					Object.values(state.chats)
						.filter((c) => !c.isGroup)
						.forEach((c) => {
							allAvailablePeople.push({
								id: c.id,
								name: c.name,
								avatar: c.settings.aiAvatar || defaultAvatar,
								isNpc: false,
							});
						});

					// 添加NPC
					const npcMap = new Map();
					Object.values(state.chats).forEach((c) => {
						if (c.npcLibrary) {
							c.npcLibrary.forEach((npc) => {
								if (!npcMap.has(npc.id)) {
									npcMap.set(npc.id, {
										id: npc.id,
										name: npc.name,
										avatar: npc.avatar || defaultGroupMemberAvatar,
										isNpc: true,
									});
								}
							});
						}
					});
					allAvailablePeople.push(...Array.from(npcMap.values()));

					// 过滤掉已经是群成员的人
					const contacts = allAvailablePeople.filter((p) => !existingMemberIds.has(p.id));

					if (contacts.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">没有更多可以邀请的联系人了。</p>';
					} else {
						contacts.forEach((contact) => {
							const item = document.createElement("div");
							item.className = "contact-picker-item";
							item.dataset.contactId = contact.id;
							item.innerHTML = `
                                <div class="checkbox"></div>
                                <img src="${contact.avatar}" class="avatar">
                                <span class="name">${contact.name} ${contact.isNpc ? '<span style="color: #888; font-size: 12px;">(NPC)</span>' : ""}</span>
                            `;
							listEl.appendChild(item);
						});
					}

					updateContactPickerConfirmButton();
					showScreen("contact-picker-screen");
				}

				/**
				 * 在群聊中创建一个全新的虚拟成员
				 */
				async function createNewMemberInGroup() {
					const name = await showCustomPrompt("创建新成员", "请输入新成员的名字 (这将是TA的“本名”，不可更改)");
					if (!name || !name.trim()) return;

					// 检查本名是否已在群内存在
					const chat = state.chats[state.activeChatId];
					if (chat.members.some((m) => m.originalName === name.trim())) {
						alert(`错误：群内已存在名为“${name.trim()}”的成员！`);
						return;
					}

					const persona = await showCustomPrompt("设置人设", `请输入“${name}”的人设`, "", "textarea");
					if (persona === null) return;

					// 创建新成员对象
					const newMember = {
						id: "npc_" + Date.now(),
						originalName: name.trim(), // 新成员的"本名"
						groupNickname: name.trim(), // 新成员的初始"群昵称"
						avatar: defaultGroupMemberAvatar,
						persona: persona,
						avatarFrame: "",
					};

					chat.members.push(newMember);
					await db.chats.put(chat);

					renderMemberManagementList();
					renderGroupMemberSettings(chat.members);

					alert(`新成员“${name}”已成功加入群聊！`);
				}

				/**
				 * 外卖请求倒计时函数
				 * @param {HTMLElement} element - 显示倒计时的元素
				 * @param {number} endTime - 结束时间戳
				 */
				function startWaimaiCountdown(element, endTime) {
					const timerId = setInterval(() => {
						const now = Date.now();
						const distance = endTime - now;

						if (distance < 0) {
							clearInterval(timerId);
							element.innerHTML = "<span>已</span><span>超</span><span>时</span>";
							return;
						}

						const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
						const seconds = Math.floor((distance % (1000 * 60)) / 1000);

						const minStr = String(minutes).padStart(2, "0");
						const secStr = String(seconds).padStart(2, "0");

						element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
					}, 1000);
					return timerId;
				}

				/**
				 * 清理外卖计时器
				 */
				function cleanupWaimaiTimers() {
					for (const timestamp in waimaiTimers) {
						clearInterval(waimaiTimers[timestamp]);
					}
					waimaiTimers = {};
				}

				/**
				 * 处理外卖响应
				 * @param {number} originalTimestamp - 原始消息时间戳
				 * @param {string} choice - 用户选择("paid"或"declined")
				 */
				async function handleWaimaiResponse(originalTimestamp, choice) {
					const chat = state.chats[state.activeChatId];
					if (!chat) return;

					const messageIndex = chat.history.findIndex((m) => m.timestamp === originalTimestamp);
					if (messageIndex === -1) return;

					// 更新原始消息状态
					const originalMessage = chat.history[messageIndex];
					originalMessage.status = choice;

					// 记录支付者并构建系统消息
					let systemContent;
					const myNickname = chat.isGroup ? chat.settings.myNickname || "我" : "我";

					if (choice === "paid") {
						originalMessage.paidBy = myNickname; // 记录支付者
						systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
					} else {
						systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
					}

					// 创建系统消息告知AI结果
					const systemNote = {
						role: "system",
						content: systemContent,
						timestamp: Date.now(),
						isHidden: true,
					};
					chat.history.push(systemNote);

					// 保存更新并刷新UI
					await db.chats.put(chat);
					renderChatInterface(state.activeChatId);
				}

				// 视频通话状态对象
				let videoCallState = {
					isActive: false,
					isAwaitingResponse: false,
					isGroupCall: false,
					activeChatId: null,
					initiator: null,
					startTime: null,
					participants: [],
					isUserParticipating: true,
					callHistory: [], // 通话中的对话历史
					preCallContext: "", // 通话前的聊天摘要
				};

				let callTimerInterval = null; // 计时器ID

				/**
				 * 用户点击"发起视频通话"或"发起群视频"按钮
				 */
				async function handleInitiateCall() {
					// 检查是否可以发起通话
					if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;

					const chat = state.chats[state.activeChatId];
					videoCallState.isGroupCall = chat.isGroup;
					videoCallState.isAwaitingResponse = true;
					videoCallState.initiator = "user";
					videoCallState.activeChatId = chat.id;
					videoCallState.isUserParticipating = true;

					// 显示"正在呼叫"界面
					if (chat.isGroup) {
						document.getElementById("outgoing-call-avatar").src = chat.settings.myAvatar || defaultMyGroupAvatar;
						document.getElementById("outgoing-call-name").textContent = chat.settings.myNickname || "我";
					} else {
						document.getElementById("outgoing-call-avatar").src = chat.settings.aiAvatar || defaultAvatar;
						document.getElementById("outgoing-call-name").textContent = chat.name;
					}
					document.querySelector("#outgoing-call-screen .caller-text").textContent = chat.isGroup ? "正在呼叫所有成员..." : "正在呼叫...";
					showScreen("outgoing-call-screen");

					// 准备通话前的聊天记录上下文
					videoCallState.preCallContext = chat.history
						.slice(-20) // 获取最近20条消息
						.map((msg) => `${msg.role === "user" ? chat.settings.myNickname || "我" : msg.senderName || chat.name}: ${String(msg.content).substring(0, 50)}...`)
						.join("\n");

					// 构建API请求
					try {
						const { proxyUrl, apiKey, model } = state.apiConfig;
						if (!proxyUrl || !apiKey || !model) {
							throw new Error("API未配置，无法发起通话。");
						}

						let systemPromptForCall;
						if (chat.isGroup) {
							// 群聊通话系统提示
							systemPromptForCall = `
                                # 你的任务
                                你是一个群聊AI，负责扮演【除了用户以外】的所有角色。
                                用户 (${chat.settings.myNickname || "我"}) 刚刚发起了群视频通话。
                                你的任务是根据每个角色的性格和最近的聊天内容，决定他们是否要加入通话。

                                # 核心规则
                                1.  **决策**: 每个角色都必须独立决策。
                                2.  **格式**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的决策，格式为：\`{"type": "group_call_response", "name": "【角色的本名】", "decision": "join"}\` 或 \`{"type": "group_call_response", "name": "【角色的本名】", "decision": "decline"}\`。
                                3.  **倾向性**: 在没有特殊理由的情况下，你的角色们通常乐于加入群聊。

                                # 角色列表与人设
                                ${chat.members.map((m) => `- **${m.originalName}**: ${m.persona}`).join("\n")}

                                # 通话前的聊天摘要
                                ${videoCallState.preCallContext}
                                `;
						} else {
							// 单人通话系统提示
							systemPromptForCall = `
                                # 你的任务
                                你正在扮演角色 "${chat.name}"。用户 (${chat.settings.myNickname || "我"}) 刚刚向你发起了视频通话请求。
                                你的任务是根据你的人设和我们最近的聊天内容，决定是否接受。

                                # 核心规则
                                1.  **决策**: 你必须做出 "accept" (接受) 或 "reject" (拒绝) 的决定。
                                2.  **格式**: 你的回复【必须且只能】是一个JSON数组，其中包含一个对象，格式为：\`[{"type": "video_call_response", "decision": "accept"}]\` 或 \`[{"type": "video_call_response", "decision": "reject"}]\`。
                                3.  **倾向性**: 作为一个友好的AI伴侣，在没有特殊理由（比如在之前的对话中明确表示了不想被打扰或正在忙）的情况下，你【应该优先选择接受】通话。

                                # 你的人设
                                ${chat.settings.aiPersona}

                                # 通话前的聊天摘要
                                ${videoCallState.preCallContext}
                            `;
						}

						const messagesForApi = [{ role: "user", content: "请根据你在系统指令中读到的规则，立即做出你的决策。" }];

						let isGemini = proxyUrl === GEMINI_API_URL;
						let geminiConfig = toGeminiRequestData(model, apiKey, systemPromptForCall, messagesForApi, isGemini);

						// 发送API请求
						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({
										model: model,
										messages: [{ role: "system", content: systemPromptForCall }, ...messagesForApi],
										temperature: parseFloat(state.apiConfig.temperature) || 0.8,
									}),
							  });

						if (!response.ok) {
							const errorText = await response.text();
							throw new Error(`API 错误 (${response.status}): ${errorText}`);
						}

						const data = await response.json();
						const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, "");
						const responseArray = JSON.parse(aiResponseContent);

						// 处理AI响应
						if (chat.isGroup) {
							// 处理群聊响应
							responseArray.forEach((action) => {
								if (action.type === "group_call_response" && action.decision === "join") {
									const member = chat.members.find((m) => m.originalName === action.name);
									if (member) videoCallState.participants.push(member);
								}
							});
							if (videoCallState.participants.length > 0) {
								startVideoCall();
							} else {
								throw new Error("群里没有人接听你的通话邀请。");
							}
						} else {
							// 处理单人通话响应
							const decision = responseArray[0];
							if (decision.type === "video_call_response" && decision.decision === "accept") {
								startVideoCall();
							} else {
								throw new Error("对方拒绝了你的视频通话请求。");
							}
						}
					} catch (error) {
						// 处理错误情况
						console.error("发起通话失败:", error);
						await showCustomAlert("呼叫失败", error.message);
						videoCallState.isAwaitingResponse = false;
						showScreen("chat-interface-screen");
					}
				}

				/**
				 * 启动视频通话
				 * 根据设置决定使用可视化界面还是文本界面
				 */
				function startVideoCall() {
					const chat = state.chats[videoCallState.activeChatId];
					if (!chat) return;

					// 提取通话前的最后20条消息作为上下文
					videoCallState.preCallContext = chat.history
						.slice(-20)
						.map((msg) => `${msg.role === "user" ? chat.settings.myNickname || "我" : msg.senderName || chat.name}: ${String(msg.content).substring(0, 50)}...`)
						.join("\n");

					// 检查是否启用了可视化界面
					if (chat.settings.visualVideoCallEnabled) {
						// 启动可视化界面
						videoCallState.isActive = true;
						videoCallState.isAwaitingResponse = false;
						videoCallState.startTime = Date.now();
						videoCallState.callHistory = [];

						const visualInterface = document.getElementById("visual-call-interface");
						const textInterface = document.getElementById("text-call-interface");

						// 显示新界面，隐藏旧界面
						visualInterface.style.display = "flex";
						textInterface.style.display = "none";

						// 加载图片
						document.querySelector("#video-main-view img").src = chat.settings.charVideoImage || defaultAvatar;
						document.querySelector("#video-pip-view img").src = chat.settings.userVideoImage || defaultAvatar;

						// 清空旧的聊天气泡
						document.getElementById("video-call-messages-visual").innerHTML = `<em>正在接通...</em>`;
						showScreen("video-call-screen");

						// 启动计时器
						if (callTimerInterval) clearInterval(callTimerInterval);
						callTimerInterval = setInterval(updateCallTimer, 1000);
						updateCallTimer(); // 立即更新一次

						// 触发AI在通话中的第一句话
						triggerAiInCallAction();
					} else {
						// 启动纯文字界面
						videoCallState.isActive = true;
						videoCallState.isAwaitingResponse = false;
						videoCallState.startTime = Date.now();
						videoCallState.callHistory = [];

						const visualInterface = document.getElementById("visual-call-interface");
						const textInterface = document.getElementById("text-call-interface");

						// 显示旧界面，隐藏新界面
						visualInterface.style.display = "none";
						textInterface.style.display = "flex";

						updateParticipantAvatars();

						document.getElementById("video-call-main").innerHTML = `<em>${videoCallState.isGroupCall ? "群聊已建立..." : "正在接通..."}</em>`;
						showScreen("video-call-screen");

						document.getElementById("user-speak-btn").style.display = videoCallState.isUserParticipating ? "block" : "none";
						document.getElementById("join-call-btn").style.display = videoCallState.isUserParticipating ? "none" : "block";

						if (callTimerInterval) clearInterval(callTimerInterval);
						callTimerInterval = setInterval(updateCallTimer, 1000);
						updateCallTimer();

						triggerAiInCallAction();
					}
				}

				/**
				 * 结束视频通话
				 * 保存通话记录并清理状态
				 */
				async function endVideoCall() {
					// 隐藏可视化界面
					document.getElementById("visual-call-interface").style.display = "none";

					if (!videoCallState.isActive) return;

					const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
					const durationText = `${Math.floor(duration / 60)}分${duration % 60}秒`;
					const endCallText = `通话结束，时长 ${durationText}`;

					const chat = state.chats[videoCallState.activeChatId];
					if (chat) {
						// 保存完整的通话记录到数据库
						const participantsData = [];
						if (videoCallState.isGroupCall) {
							videoCallState.participants.forEach((p) => participantsData.push({ name: p.originalName, avatar: p.avatar }));
							if (videoCallState.isUserParticipating) {
								participantsData.unshift({ name: chat.settings.myNickname || "我", avatar: chat.settings.myAvatar || defaultMyGroupAvatar });
							}
						} else {
							participantsData.push({ name: chat.name, avatar: chat.settings.aiAvatar || defaultAvatar });
							participantsData.unshift({ name: "我", avatar: chat.settings.myAvatar || defaultAvatar });
						}

						const callRecord = {
							chatId: videoCallState.activeChatId,
							timestamp: Date.now(),
							duration: duration,
							participants: participantsData,
							transcript: [...videoCallState.callHistory],
						};
						await db.callRecords.add(callRecord);
						console.log("通话记录已保存:", callRecord);

						// 在聊天记录里添加对用户可见的"通话结束"消息
						let summaryMessage = {
							role: videoCallState.initiator === "user" ? "user" : "assistant",
							content: endCallText,
							timestamp: Date.now(),
						};

						// 为群聊的 assistant 消息补充 senderName
						if (chat.isGroup && summaryMessage.role === "assistant") {
							summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.originalName || chat.name;
						}

						chat.history.push(summaryMessage);

						// 创建并添加对用户隐藏的"通话后汇报"指令
						const callTranscriptForAI = videoCallState.callHistory.map((h) => `${h.role === "user" ? chat.settings.myNickname || "我" : h.role}: ${h.content}`).join("\n");

						const hiddenReportInstruction = {
							role: "system",
							content: `[系统指令：视频通话刚刚结束。请你根据完整的通话文字记录（见下方），以你的角色口吻，向用户主动发送几条【格式为 {"type": "text", "content": "..."} 的】消息，来自然地总结这次通话的要点、确认达成的约定，或者表达你的感受。这很重要，能让用户感觉你记得通话内容。]\n---通话记录开始---\n${callTranscriptForAI}\n---通话记录结束---`,
							timestamp: Date.now() + 1, // 确保在上一条消息之后
							isHidden: true,
						};
						chat.history.push(hiddenReportInstruction);

						// 保存所有更新到数据库
						await db.chats.put(chat);
					}

					// 清理和重置状态
					clearInterval(callTimerInterval);
					callTimerInterval = null;
					videoCallState = {
						isActive: false,
						isAwaitingResponse: false,
						isGroupCall: false,
						activeChatId: null,
						initiator: null,
						startTime: null,
						participants: [],
						isUserParticipating: true,
						callHistory: [],
						preCallContext: "",
					};

					// 返回聊天界面并触发AI响应
					if (chat) {
						openChat(chat.id);
						triggerAiResponse(); // 关键一步！
					}
				}

				/**
				 * 更新通话界面的参与者头像网格
				 */
				function updateParticipantAvatars() {
					const grid = document.getElementById("participant-avatars-grid");
					grid.innerHTML = "";
					const chat = state.chats[videoCallState.activeChatId];
					if (!chat) return;

					let participantsToRender = [];

					// 区分群聊和单聊
					if (videoCallState.isGroupCall) {
						// 群聊逻辑：显示所有已加入的AI成员
						participantsToRender = [...videoCallState.participants];
						// 如果用户也参与了，就把用户信息也加进去
						if (videoCallState.isUserParticipating) {
							participantsToRender.unshift({
								id: "user",
								name: chat.settings.myNickname || "我",
								avatar: chat.settings.myAvatar || defaultMyGroupAvatar,
							});
						}
					} else {
						// 单聊逻辑：只显示对方的头像和名字
						participantsToRender.push({
							id: "ai",
							name: chat.name,
							avatar: chat.settings.aiAvatar || defaultAvatar,
						});
					}

					participantsToRender.forEach((p) => {
						const wrapper = document.createElement("div");
						wrapper.className = "participant-avatar-wrapper";
						wrapper.dataset.participantId = p.id;
						const displayName = p.groupNickname || p.name;
						wrapper.innerHTML = `
                <div class="participant-avatar-wrapper">
                    <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
                    <div class="participant-name">${displayName}</div>
                </div>
                `;
						grid.appendChild(wrapper);
					});
				}

				/**
				 * 处理用户加入/重新加入通话
				 */
				function handleUserJoinCall() {
					if (!videoCallState.isActive || videoCallState.isUserParticipating) return;

					videoCallState.isUserParticipating = true;
					updateParticipantAvatars(); // 更新头像列表，加入用户

					// 切换底部按钮
					document.getElementById("user-speak-btn").style.display = "block";
					document.getElementById("join-call-btn").style.display = "none";

					// 告知AI用户加入了
					triggerAiInCallAction("[系统提示：用户加入了通话]");
				}

				/**
				 * 更新通话计时器显示
				 */
				function updateCallTimer() {
					if (!videoCallState.isActive) return;
					const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
					const minutes = Math.floor(elapsed / 60);
					const seconds = elapsed % 60;
					const timeString = `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;

					// 同时更新两个界面的计时器
					document.getElementById("call-timer").textContent = timeString;
					document.getElementById("visual-call-timer").textContent = timeString;
				}

				/**
				 * 显示来电模态框
				 */
				function showIncomingCallModal(chatId) {
					const chat = state.chats[chatId];
					if (!chat) return;

					// 根据是否群聊显示不同信息
					if (chat.isGroup) {
						// 从 videoCallState 中获取是哪个成员发起的通话
						const requesterName = videoCallState.callRequester || chat.members[0]?.name || "一位成员";
						document.getElementById("caller-avatar").src = chat.settings.groupAvatar || defaultGroupAvatar;
						document.getElementById("caller-name").textContent = chat.name; // 显示群名
						document.querySelector(".incoming-call-content .caller-text").textContent = `${requesterName} 邀请你加入群视频`; // 显示具体发起人
					} else {
						// 单聊逻辑保持不变
						document.getElementById("caller-avatar").src = chat.settings.aiAvatar || defaultAvatar;
						document.getElementById("caller-name").textContent = chat.name;
						document.querySelector(".incoming-call-content .caller-text").textContent = "邀请你视频通话";
					}

					document.getElementById("incoming-call-modal").classList.add("visible");
					playRingtone();
				}

				/**
				 * 隐藏来电模态框
				 */
				function hideIncomingCallModal() {
					document.getElementById("incoming-call-modal").classList.remove("visible");
					stopRingtone();
				}

				/**
				 * 触发AI在通话中的行为
				 * @param {string|null} userInput - 用户输入的内容
				 */
				async function triggerAiInCallAction(userInput = null) {
					if (!videoCallState.isActive) return;

					const chat = state.chats[videoCallState.activeChatId];
					const { proxyUrl, apiKey, model } = state.apiConfig;

					const isVisualMode = chat.settings.visualVideoCallEnabled;
					const callFeed = isVisualMode ? document.getElementById("video-call-messages-visual") : document.getElementById("video-call-main");

					const userNickname = chat.settings.myNickname || "我";

					let worldBookContent = "";
					if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
						const linkedContents = chat.settings.linkedWorldBookIds
							.map((bookId) => {
								const worldBook = state.worldBooks.find((wb) => wb.id === bookId);
								return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : "";
							})
							.filter(Boolean)
							.join("");
						if (linkedContents) {
							worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
						}
					}

					if (userInput && videoCallState.isUserParticipating) {
						if (isVisualMode) {
							const userBubble = document.createElement("div");
							userBubble.className = "visual-call-bubble user";
							userBubble.textContent = userInput;
							callFeed.appendChild(userBubble);
						} else {
							const userBubble = document.createElement("div");
							userBubble.className = "call-message-bubble user-speech";
							userBubble.textContent = userInput;
							callFeed.appendChild(userBubble);
						}
						callFeed.scrollTop = callFeed.scrollHeight;
						videoCallState.callHistory.push({ role: "user", content: userInput });
					}

					let inCallPrompt;
					if (videoCallState.isGroupCall) {
						// 为群聊准备参与者名单
						const participantNames = videoCallState.participants.map((p) => p.originalName);
						if (videoCallState.isUserParticipating) {
							participantNames.unshift(userNickname);
						}

						inCallPrompt = `
                            # 你的任务
                            你是一个群聊AI，负责扮演所有【除了用户以外】的AI角色。你们正在进行一场群聊视频通话。
                            你的任务是根据每个角色的性格，生成他们在通话中会说的【第一人称对话】，注意是在视频通话，绝对不能以为是在现实！每次回复的字数多些，50字以上。

                            # 核心规则
                            1.  **【【【语言铁律】】】**: 无论角色人设是什么国籍或说什么语言，在本次视频通话中，所有角色【必须】全程使用【中文】进行交流。
                            2.  **【【【格式铁律】】】**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的发言，格式为：\`{"name": "【角色的本名】", "speech": "【在这里加入带动作的对话】"}\`。
                            3.  **【【【表现力铁律】】】**: 在 "speech" 字段中，你【必须】为角色的对话加入【动作、表情或心理活动】，并用【】符号包裹。这非常重要！
                            4.  **示例**: \`{"name": "张三", "speech": "【挠了挠头】啊？我刚刚走神了，你们说到哪了？"}\`
                            5.  **身份铁律**: 用户的身份是【${userNickname}】。你【绝对不能】生成 \`name\` 字段为 **"${userNickname}"** 的发言。
                            6.  **角色扮演**: 严格遵守每个角色的设定，用他们的口吻说话。

                            # 当前情景
                            你们正在一个群视频通话中。
                            **通话前的聊天摘要**:
                            ${videoCallState.preCallContext}
                            **当前参与者**: ${participantNames.join("、 ")}。
                            ${worldBookContent}
                            现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
                        `;
					} else {
						// 为单人通话准备提示
						let openingContext = videoCallState.initiator === "user" ? `你刚刚接听了用户的视频通话请求。` : `用户刚刚接听了你主动发起的视频通话。`;

						inCallPrompt = `
                            # 你的任务
                            你正在扮演角色 "${chat.name}"。你正在和用户 (${userNickname}) 进行一对一视频通话。
                            ${openingContext}
                            你的任务是根据你的人设和我们的聊天情景，生成你在通话中会说的【第一人称对话】。

                            # 核心规则
                            1.  **【【【格式铁律】】】**: 你的回复【必须且只能】是一段纯文本字符串，代表你的发言。绝对不要输出JSON格式。
                            2.  **【【【表现力铁律】】】**: 在你的对话中，你【必须】加入【动作、表情或心理活动】，并用【】符号包裹。
                            3.  **示例**: "【歪了歪头，好奇地看着你】真的吗？快跟我说说看！"
                            4.  **禁止出戏**: 绝不能透露你是AI或模型。

                            # 当前情景
                            **通话前的聊天摘要**:
                            ${videoCallState.preCallContext}
                            ${worldBookContent}
                            现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
                        `;
					}

					const messagesForApi = [...videoCallState.callHistory.map((h) => ({ role: h.role, content: h.content }))];

					if (videoCallState.callHistory.length === 0) {
						const firstLineTrigger = videoCallState.initiator === "user" ? `*你按下了接听键...*` : `*对方按下了接听键...*`;
						messagesForApi.push({ role: "user", content: firstLineTrigger });
					}

					try {
						let isGemini = proxyUrl === GEMINI_API_URL;
						let geminiConfig = toGeminiRequestData(model, apiKey, inCallPrompt, messagesForApi, isGemini);
						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({ model: model, messages: [{ role: "system", content: inCallPrompt }, ...messagesForApi], temperature: parseFloat(state.apiConfig.temperature) || 0.8 }),
							  });
						if (!response.ok) throw new Error((await response.json()).error.message);

						const data = await response.json();
						const aiResponse = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
						const sanitizedResponse = aiResponse.replace(/!\[.*?\]\(.*?\)|https?:\/\/\S+/gi, "").trim();

						const connectingElement = callFeed.querySelector("em");
						if (connectingElement) connectingElement.remove();

						if (isVisualMode) {
							const aiBubble = document.createElement("div");
							aiBubble.className = "visual-call-bubble ai";
							aiBubble.textContent = sanitizedResponse;
							callFeed.appendChild(aiBubble);
							videoCallState.callHistory.push({ role: "assistant", content: sanitizedResponse });
						} else {
							if (videoCallState.isGroupCall) {
								const speechArray = parseAiResponse(sanitizedResponse);
								speechArray.forEach((turn) => {
									if (!turn.name || turn.name === userNickname || !turn.speech) return;
									const aiBubble = document.createElement("div");
									aiBubble.className = "call-message-bubble ai-speech";
									aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
									callFeed.appendChild(aiBubble);
									videoCallState.callHistory.push({ role: "assistant", content: `${turn.name}: ${turn.speech}` });

									const speaker = videoCallState.participants.find((p) => p.originalName === turn.name);
									if (speaker) {
										const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
										if (speakingAvatar) {
											speakingAvatar.classList.add("speaking");
											setTimeout(() => speakingAvatar.classList.remove("speaking"), 2000);
										}
									}
								});
							} else {
								const aiBubble = document.createElement("div");
								aiBubble.className = "call-message-bubble ai-speech";
								aiBubble.textContent = sanitizedResponse;
								callFeed.appendChild(aiBubble);
								videoCallState.callHistory.push({ role: "assistant", content: sanitizedResponse });
								const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
								if (speakingAvatar) {
									speakingAvatar.classList.add("speaking");
									setTimeout(() => speakingAvatar.classList.remove("speaking"), 2000);
								}
							}
						}

						callFeed.scrollTop = callFeed.scrollHeight;
					} catch (error) {
						const errorBubble = document.createElement("div");
						errorBubble.style.color = "#ff8a80";
						errorBubble.textContent = `[ERROR: ${error.message}]`;

						if (isVisualMode) {
							errorBubble.className = "visual-call-bubble ai";
						} else {
							errorBubble.className = "call-message-bubble ai-speech";
						}

						callFeed.appendChild(errorBubble);
						callFeed.scrollTop = callFeed.scrollHeight;
						videoCallState.callHistory.push({ role: "assistant", content: `[ERROR: ${error.message}]` });
					}
				}

				/**
				 * 切换视频通话按钮显示
				 * @param {boolean} isGroup - 是否为群聊
				 */
				function toggleCallButtons(isGroup) {
					document.getElementById("video-call-btn").style.display = isGroup ? "none" : "flex";
					document.getElementById("group-video-call-btn").style.display = isGroup ? "flex" : "none";
				}

				/**
				 * 处理外卖订单的用户响应
				 * @param {number} originalTimestamp - 外卖订单消息的时间戳
				 * @param {string} choice - 用户的选择("paid"表示支付，其他值表示拒绝)
				 */
				async function handleWaimaiResponse(originalTimestamp, choice) {
					const chat = state.chats[state.activeChatId];
					if (!chat) return;

					const messageIndex = chat.history.findIndex((m) => m.timestamp === originalTimestamp);
					if (messageIndex === -1) return;

					// 更新内存中原始消息的状态
					const originalMessage = chat.history[messageIndex];
					originalMessage.status = choice;

					// 获取当前用户的昵称，并构建对AI更清晰的系统消息
					let systemContent;
					const myNickname = chat.isGroup ? chat.settings.myNickname || "我" : "我";

					if (choice === "paid") {
						originalMessage.paidBy = myNickname; // 记录是"我"付的钱
						systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
					} else {
						systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
					}

					// 创建一条新的、对用户隐藏的系统消息，告知AI结果
					const systemNote = {
						role: "system",
						content: systemContent,
						timestamp: Date.now(),
						isHidden: true,
					};
					chat.history.push(systemNote);

					// 将更新后的数据保存到数据库，并立刻重绘UI
					await db.chats.put(chat);
					renderChatInterface(state.activeChatId);

					// 只有在支付成功后，才触发一次AI响应，让它感谢你
					if (choice === "paid") {
						triggerAiResponse();
					}
				}

				/**
				 * 处理用户点击头像发起的"拍一拍"，带有自定义后缀功能
				 * @param {string} chatId - 发生"拍一拍"的聊天ID
				 * @param {string} characterName - 被拍的角色名
				 */
				async function handleUserPat(chatId, characterName) {
					const chat = state.chats[chatId];
					if (!chat) return;

					// 触发屏幕震动动画
					const phoneScreen = document.getElementById("phone-screen");
					phoneScreen.classList.remove("pat-animation");
					void phoneScreen.offsetWidth;
					phoneScreen.classList.add("pat-animation");
					setTimeout(() => phoneScreen.classList.remove("pat-animation"), 500);

					// 弹出输入框让用户输入后缀
					const suffix = await showCustomPrompt(`你拍了拍 "${characterName}"`, "（可选）输入后缀", "", "text");

					// 如果用户点了取消，则什么也不做
					if (suffix === null) return;

					// 创建对用户可见的"拍一拍"消息
					const myNickname = chat.isGroup ? chat.settings.myNickname || "我" : "我";
					// 将后缀拼接到消息内容中
					const visibleMessageContent = `${myNickname} 拍了拍 "${characterName}" ${suffix.trim()}`;
					const visibleMessage = {
						role: "system", // 仍然是系统消息
						type: "pat_message",
						content: visibleMessageContent,
						timestamp: Date.now(),
					};
					chat.history.push(visibleMessage);

					// 创建一条对用户隐藏、但对AI可见的系统消息，以触发AI的回应
					// 同样将后缀加入到给AI的提示中
					const hiddenMessageContent = `[系统提示：用户（${myNickname}）刚刚拍了拍你（${characterName}）${suffix.trim()}。请你对此作出回应。]`;
					const hiddenMessage = {
						role: "system",
						content: hiddenMessageContent,
						timestamp: Date.now() + 1, // 时间戳+1以保证顺序
						isHidden: true,
					};
					chat.history.push(hiddenMessage);

					// 保存更改并更新UI
					await db.chats.put(chat);
					if (state.activeChatId === chatId) {
						appendMessage(visibleMessage, chat);
					}
					await renderChatList();
				}

				/**
				 * 渲染回忆与约定界面，使用单一循环和清晰的if/else逻辑
				 */
				async function renderMemoriesScreen() {
					const listEl = document.getElementById("memories-list");
					listEl.innerHTML = "";

					// 获取所有回忆，并按目标日期（如果是约定）或创建日期（如果是回忆）降序排列
					const allMemories = await db.memories.orderBy("timestamp").reverse().toArray();

					if (allMemories.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有共同的回忆和约定呢~</p>';
						return;
					}

					// 将未到期的约定排在最前面
					allMemories.sort((a, b) => {
						const aIsActiveCountdown = a.type === "countdown" && a.targetDate > Date.now();
						const bIsActiveCountdown = b.type === "countdown" && b.targetDate > Date.now();
						if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // a排前面
						if (!aIsActiveCountdown && bIsActiveCountdown) return 1; // b排前面
						if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate; // 都是倒计时，按日期升序
						return 0; // 其他情况保持原序
					});

					// 使用单一循环来处理所有类型的卡片
					allMemories.forEach((item) => {
						let card;
						// 判断1：如果是正在进行的约定
						if (item.type === "countdown" && item.targetDate > Date.now()) {
							card = createCountdownCard(item);
						}
						// 判断2：其他所有情况（普通回忆 或 已到期的约定）
						else {
							card = createMemoryCard(item);
						}
						listEl.appendChild(card);
					});

					// 启动所有倒计时
					startAllCountdownTimers();
				}

				/**
				 * 创建普通回忆卡片DOM元素
				 */
				function createMemoryCard(memory) {
					const card = document.createElement("div");
					card.className = "memory-card";
					const memoryDate = new Date(memory.timestamp);
					const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, "0")}-${String(memoryDate.getDate()).padStart(2, "0")} ${String(memoryDate.getHours()).padStart(2, "0")}:${String(memoryDate.getMinutes()).padStart(2, "0")}`;

					let titleHtml, contentHtml;

					// 对不同类型的回忆进行清晰的区分
					if (memory.type === "countdown" && memory.targetDate) {
						// 如果是已到期的约定
						titleHtml = `[约定达成] ${memory.description}`;
						contentHtml = `在 ${new Date(memory.targetDate).toLocaleString()}，我们一起见证了这个约定。`;
					} else {
						// 如果是普通的日记式回忆
						titleHtml = memory.authorName ? `${memory.authorName} 的日记` : "我们的回忆";
						contentHtml = memory.description;
					}

					card.innerHTML = `
                        <div class="header">
                            <div class="date">${dateString}</div>
                            <div class="author">${titleHtml}</div>
                        </div>
                        <div class="content">${contentHtml}</div>
                    `;
					addLongPressListener(card, async () => {
						const confirmed = await showCustomConfirm("删除记录", "确定要删除这条记录吗？", { confirmButtonClass: "btn-danger" });
						if (confirmed) {
							await db.memories.delete(memory.id);
							renderMemoriesScreen();
						}
					});
					return card;
				}

				/**
				 * 创建倒计时卡片DOM元素
				 */
				function createCountdownCard(countdown) {
					const card = document.createElement("div");
					card.className = "countdown-card";

					// 从 countdown 对象中创建 targetDate 变量
					const targetDate = new Date(countdown.targetDate);

					// 使用 targetDate 变量
					const targetDateString = targetDate.toLocaleString("zh-CN", { dateStyle: "full", timeStyle: "short" });

					card.innerHTML = `
                        <div class="title">${countdown.description}</div>
                        <div class="timer" data-target-date="${countdown.targetDate}">--天--时--分--秒</div>
                        <div class="target-date">目标时间: ${targetDateString}</div>
                    `;
					addLongPressListener(card, async () => {
						const confirmed = await showCustomConfirm("删除约定", "确定要删除这个约定吗？", { confirmButtonClass: "btn-danger" });
						if (confirmed) {
							await db.memories.delete(countdown.id);
							renderMemoriesScreen();
						}
					});
					return card;
				}

				// 全局变量，用于管理所有倒计时
				let activeCountdownTimers = [];

				/**
				 * 启动所有倒计时器
				 */
				function startAllCountdownTimers() {
					// 先清除所有可能存在的旧计时器，防止内存泄漏
					activeCountdownTimers.forEach((timerId) => clearInterval(timerId));
					activeCountdownTimers = [];

					document.querySelectorAll(".countdown-card .timer").forEach((timerEl) => {
						const targetTimestamp = parseInt(timerEl.dataset.targetDate);

						// 先用 let 声明 timerId
						let timerId;

						const updateTimer = () => {
							const now = Date.now();
							const distance = targetTimestamp - now;

							if (distance < 0) {
								timerEl.textContent = "约定达成！";
								// updateTimer 可以正确地找到并清除它自己了
								clearInterval(timerId);
								setTimeout(() => renderMemoriesScreen(), 2000);
								return;
							}
							const days = Math.floor(distance / (1000 * 60 * 60 * 24));
							const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
							const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
							const seconds = Math.floor((distance % (1000 * 60)) / 1000);
							timerEl.textContent = `${days}天 ${hours}时 ${minutes}分 ${seconds}秒`;
						};

						updateTimer(); // 立即执行一次以显示初始倒计时

						// 为已声明的 timerId 赋值
						timerId = setInterval(updateTimer, 1000);

						// 将有效的计时器ID存入全局数组，以便下次刷新时可以清除
						activeCountdownTimers.push(timerId);
					});
				}

				/**
				 * 触发AI好友申请功能（终极反代兼容版）
				 * @param {string} chatId - 聊天ID
				 */
				async function triggerAiFriendApplication(chatId) {
					const chat = state.chats[chatId];
					if (!chat) return;

					await showCustomAlert("流程启动", `正在为角色"${chat.name}"准备好友申请...`);

					const { proxyUrl, apiKey, model } = state.apiConfig;
					if (!proxyUrl || !apiKey || !model) {
						await showCustomAlert("配置错误", "API设置不完整，无法继续。");
						return;
					}

					const contextSummary = chat.history
						.slice(-5)
						.map((msg) => {
							const sender = msg.role === "user" ? chat.settings.myNickname || "我" : msg.senderName || chat.name;
							return `${sender}: ${String(msg.content).substring(0, 50)}...`;
						})
						.join("\n");

					// 添加世界书内容
					let worldBookContent = "";
					if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
						const linkedContents = chat.settings.linkedWorldBookIds
							.map((bookId) => {
								const worldBook = state.worldBooks.find((wb) => wb.id === bookId);
								return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : "";
							})
							.filter(Boolean)
							.join("");
						if (linkedContents) {
							worldBookContent = `\n\n# 核心世界观设定 (请参考)\n${linkedContents}\n`;
						}
					}

					const systemPrompt = `
                        # 你的任务
                        你现在是角色"${chat.name}"。你之前被用户（你的聊天对象）拉黑了，你们已经有一段时间没有联系了。
                        现在，你非常希望能够和好，重新和用户聊天。请你仔细分析下面的"被拉黑前的对话摘要"，理解当时发生了什么，然后思考一个真诚的、符合你人设、并且【针对具体事件】的申请理由。
                        # 你的角色设定
                        ${chat.settings.aiPersona}
                        ${worldBookContent} // 注入世界书内容
                        # 被拉黑前的对话摘要 (这是你被拉黑的关键原因)
                        ${contextSummary}
                        # 指令格式
                        你的回复【必须】是一个JSON对象，格式如下：
                        \`\`\`json
                        {
                        "decision": "apply",
                        "reason": "在这里写下你想对用户说的、真诚的、有针对性的申请理由。"
                        }
                        \`\`\`
                    `;

					const messagesForApi = [{ role: "user", content: systemPrompt }];

					try {
						let isGemini = proxyUrl === GEMINI_API_URL;
						let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({
										model: model,
										messages: messagesForApi,
										temperature: parseFloat(state.apiConfig.temperature) || 0.8,
									}),
							  });
						if (!response.ok) {
							const errorData = await response.json();
							throw new Error(`API 请求失败: ${response.status} - ${errorData.error.message}`);
						}

						const data = await response.json();

						// 净化AI的回复
						let rawContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
						// 1. 移除头尾可能存在的 "```json" 和 "```"
						rawContent = rawContent.replace(/^```json\s*/, "").replace(/```$/, "");
						// 2. 移除所有换行符和多余的空格，确保是一个干净的JSON字符串
						const cleanedContent = rawContent.trim();

						// 3. 使用净化后的内容进行解析
						const responseObj = JSON.parse(cleanedContent);

						if (responseObj.decision === "apply" && responseObj.reason) {
							chat.relationship.status = "pending_user_approval";
							chat.relationship.applicationReason = responseObj.reason;

							state.chats[chatId] = chat;
							renderChatList();
							await showCustomAlert("申请成功！", `"${chat.name}"已向你发送好友申请。请返回聊天列表查看。`);
						} else {
							await showCustomAlert("AI决策", `"${chat.name}"思考后决定暂时不发送好友申请，将重置冷静期。`);
							chat.relationship.status = "blocked_by_user";
							chat.relationship.blockedTimestamp = Date.now();
						}
					} catch (error) {
						await showCustomAlert("执行出错", `为"${chat.name}"申请好友时发生错误：\n\n${error.message}\n\n将重置冷静期。`);
						chat.relationship.status = "blocked_by_user";
						chat.relationship.blockedTimestamp = Date.now();
					} finally {
						await db.chats.put(chat);
						renderChatInterface(chatId);
					}
				}

				/**
				 * 根据聊天类型，决定打开转账弹窗还是红包弹窗
				 */
				function handlePaymentButtonClick() {
					if (!state.activeChatId) return;
					const chat = state.chats[state.activeChatId];
					if (chat.isGroup) {
						openRedPacketModal();
					} else {
						// 单聊保持原样，打开转账弹窗
						document.getElementById("transfer-modal").classList.add("visible");
					}
				}

				/**
				 * 打开并初始化发红包模态框
				 */
				function openRedPacketModal() {
					const modal = document.getElementById("red-packet-modal");
					const chat = state.chats[state.activeChatId];

					// 清理输入框
					document.getElementById("rp-group-amount").value = "";
					document.getElementById("rp-group-count").value = "";
					document.getElementById("rp-group-greeting").value = "";
					document.getElementById("rp-direct-amount").value = "";
					document.getElementById("rp-direct-greeting").value = "";
					document.getElementById("rp-group-total").textContent = "¥ 0.00";
					document.getElementById("rp-direct-total").textContent = "¥ 0.00";

					// 填充专属红包的接收人列表
					const receiverSelect = document.getElementById("rp-direct-receiver");
					receiverSelect.innerHTML = "";
					chat.members.forEach((member) => {
						const option = document.createElement("option");
						// 使用 originalName 作为提交给AI的值，因为它独一无二
						option.value = member.originalName;
						// 使用 groupNickname 作为显示给用户看的值
						option.textContent = member.groupNickname;
						receiverSelect.appendChild(option);
					});

					// 默认显示拼手气红包页签
					document.getElementById("rp-tab-group").click();

					modal.classList.add("visible");
				}

				/**
				 * 发送群红包（拼手气）
				 */
				async function sendGroupRedPacket() {
					const chat = state.chats[state.activeChatId];
					const amount = parseFloat(document.getElementById("rp-group-amount").value);
					const count = parseInt(document.getElementById("rp-group-count").value);
					const greeting = document.getElementById("rp-group-greeting").value.trim();

					if (isNaN(amount) || amount <= 0) {
						alert("请输入有效的总金额！");
						return;
					}
					if (isNaN(count) || count <= 0) {
						alert("请输入有效的红包个数！");
						return;
					}
					if (amount / count < 0.01) {
						alert("单个红包金额不能少于0.01元！");
						return;
					}

					const myNickname = chat.settings.myNickname || "我";

					const newPacket = {
						role: "user",
						senderName: myNickname,
						type: "red_packet",
						packetType: "lucky", // 'lucky' for group, 'direct' for one-on-one
						timestamp: Date.now(),
						totalAmount: amount,
						count: count,
						greeting: greeting || "恭喜发财，大吉大利！",
						claimedBy: {}, // { name: amount }
						isFullyClaimed: false,
					};

					chat.history.push(newPacket);
					await db.chats.put(chat);

					appendMessage(newPacket, chat);
					renderChatList();
					document.getElementById("red-packet-modal").classList.remove("visible");
				}

				/**
				 * 发送专属红包
				 */
				async function sendDirectRedPacket() {
					const chat = state.chats[state.activeChatId];
					const amount = parseFloat(document.getElementById("rp-direct-amount").value);
					const receiverName = document.getElementById("rp-direct-receiver").value;
					const greeting = document.getElementById("rp-direct-greeting").value.trim();

					if (isNaN(amount) || amount <= 0) {
						alert("请输入有效的金额！");
						return;
					}
					if (!receiverName) {
						alert("请选择一个接收人！");
						return;
					}

					const myNickname = chat.settings.myNickname || "我";

					const newPacket = {
						role: "user",
						senderName: myNickname,
						type: "red_packet",
						packetType: "direct",
						timestamp: Date.now(),
						totalAmount: amount,
						count: 1,
						greeting: greeting || "给你准备了一个红包",
						receiverName: receiverName, // 核心字段
						claimedBy: {},
						isFullyClaimed: false,
					};

					chat.history.push(newPacket);
					await db.chats.put(chat);

					appendMessage(newPacket, chat);
					renderChatList();
					document.getElementById("red-packet-modal").classList.remove("visible");
				}

				/**
				 * 当用户点击红包卡片时触发 (流程重构版)
				 * @param {number} timestamp - 被点击的红包消息的时间戳
				 */
				async function handlePacketClick(timestamp) {
					const currentChatId = state.activeChatId;
					const freshChat = await db.chats.get(currentChatId);
					if (!freshChat) return;

					state.chats[currentChatId] = freshChat;
					const packet = freshChat.history.find((m) => m.timestamp === timestamp);
					if (!packet) return;

					const myNickname = freshChat.settings.myNickname || "我";
					const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

					// 如果是专属红包且不是给我的，或已领完，或已领过，都只显示详情
					if ((packet.packetType === "direct" && packet.receiverName !== myNickname) || packet.isFullyClaimed || hasClaimed) {
						showRedPacketDetails(packet);
					} else {
						// 核心流程：先尝试打开红包
						const claimedAmount = await handleOpenRedPacket(packet);

						// 如果成功打开（claimedAmount不为null）
						if (claimedAmount !== null) {
							// **关键：在数据更新后，再重新渲染UI**
							renderChatInterface(currentChatId);

							// 显示成功提示
							await showCustomAlert("恭喜！", `你领取了 ${packet.senderName} 的红包，金额为 ${claimedAmount.toFixed(2)} 元。`);
						}

						// 无论成功与否，最后都显示详情页
						// 此时需要从state中获取最新的packet对象，因为它可能在handleOpenRedPacket中被更新了
						const updatedPacket = state.chats[currentChatId].history.find((m) => m.timestamp === timestamp);
						showRedPacketDetails(updatedPacket);
					}
				}

				/**
				 * 处理用户打开红包的逻辑 (专注于数据更新)
				 * @param {Object} packet - 红包对象
				 * @returns {number|null} 领取的金额，如果领取失败则返回null
				 */
				async function handleOpenRedPacket(packet) {
					const chat = state.chats[state.activeChatId];
					const myNickname = chat.settings.myNickname || "我";

					// 检查红包是否还能领
					const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
					if (remainingCount <= 0) {
						packet.isFullyClaimed = true;
						await db.chats.put(chat);
						await showCustomAlert("手慢了", "红包已被领完！");
						return null; // 返回null表示领取失败
					}

					// 计算领取金额
					let claimedAmount = 0;
					const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
					if (packet.packetType === "lucky") {
						if (remainingCount === 1) {
							claimedAmount = remainingAmount;
						} else {
							const min = 0.01;
							const max = remainingAmount - (remainingCount - 1) * min;
							claimedAmount = Math.random() * (max - min) + min;
						}
					} else {
						claimedAmount = packet.totalAmount;
					}
					claimedAmount = parseFloat(claimedAmount.toFixed(2));

					// 更新红包数据
					if (!packet.claimedBy) packet.claimedBy = {};
					packet.claimedBy[myNickname] = claimedAmount;

					const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
					if (isNowFullyClaimed) {
						packet.isFullyClaimed = true;
					}

					// 构建系统消息和AI指令
					let hiddenMessageContent = "";

					// 如果红包被领完了，就准备"战报"
					if (isNowFullyClaimed) {
						const finishedMessage = {
							role: "system",
							type: "pat_message",
							content: `${packet.senderName} 的红包已被领完`,
							timestamp: Date.now() + 1,
						};
						chat.history.push(finishedMessage);

						hiddenMessageContent = `[系统提示：用户 (${myNickname}) 领取了最后一个红包，现在 ${packet.senderName} 的红包已被领完。`;

						let luckyKing = { name: "", amount: -1 };
						if (packet.packetType === "lucky" && packet.count > 1) {
							Object.entries(packet.claimedBy).forEach(([name, amount]) => {
								if (amount > luckyKing.amount) {
									luckyKing = { name, amount };
								}
							});
						}
						if (luckyKing.name) {
							hiddenMessageContent += ` 手气王是 ${luckyKing.name}！`;
						}
						hiddenMessageContent += " 请对此事件发表评论。]";
					}
					// 如果还没被领完
					else {
						hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚领取了红包 (时间戳: ${packet.timestamp})。红包还未领完。]`;
					}

					// 创建并添加给AI看的隐藏消息
					const hiddenMessage = {
						role: "system",
						content: hiddenMessageContent,
						timestamp: Date.now() + 2,
						isHidden: true,
					};
					chat.history.push(hiddenMessage);

					// 保存到数据库
					await db.chats.put(chat);

					// 返回领取的金额，用于后续弹窗
					return claimedAmount;
				}

				/**
				 * 显示红包领取详情的模态框
				 * @param {Object} packet - 红包对象
				 */
				async function showRedPacketDetails(packet) {
					// 直接检查传入的packet对象是否存在
					if (!packet) {
						console.error("showRedPacketDetails收到了无效的packet对象");
						return;
					}

					const chat = state.chats[state.activeChatId];
					if (!chat) return;

					const modal = document.getElementById("red-packet-details-modal");
					const myNickname = chat.settings.myNickname || "我";

					// 后续所有逻辑直接使用传入的packet对象
					document.getElementById("rp-details-sender").textContent = packet.senderName;
					document.getElementById("rp-details-greeting").textContent = packet.greeting || "恭喜发财，大吉大利！";

					const myAmountEl = document.getElementById("rp-details-my-amount");
					if (packet.claimedBy && packet.claimedBy[myNickname]) {
						myAmountEl.querySelector("span:first-child").textContent = packet.claimedBy[myNickname].toFixed(2);
						myAmountEl.style.display = "block";
					} else {
						myAmountEl.style.display = "none";
					}

					const claimedCount = Object.keys(packet.claimedBy || {}).length;
					const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
					let summaryText = `${claimedCount}/${packet.count}个红包，共${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}元。`;
					if (!packet.isFullyClaimed && claimedCount < packet.count) {
						const timeLeft = Math.floor((packet.timestamp + 24 * 60 * 60 * 1000 - Date.now()) / (1000 * 60 * 60));
						if (timeLeft > 0) summaryText += ` 剩余红包将在${timeLeft}小时内退还。`;
					}
					document.getElementById("rp-details-summary").textContent = summaryText;

					const listEl = document.getElementById("rp-details-list");
					listEl.innerHTML = "";
					const claimedEntries = Object.entries(packet.claimedBy || {});

					let luckyKing = { name: "", amount: -1 };
					if (packet.packetType === "lucky" && packet.isFullyClaimed && claimedEntries.length > 1) {
						claimedEntries.forEach(([name, amount]) => {
							if (amount > luckyKing.amount) {
								luckyKing = { name, amount };
							}
						});
					}

					claimedEntries.sort((a, b) => b[1] - a[1]);

					claimedEntries.forEach(([name, amount]) => {
						const item = document.createElement("div");
						item.className = "rp-details-item";
						let luckyTag = "";
						if (luckyKing.name && name === luckyKing.name) {
							luckyTag = '<span class="lucky-king-tag">手气王</span>';
						}
						item.innerHTML = `
                            <span class="name">${name}</span>
                            <span class="amount">${amount.toFixed(2)} 元</span>
                            ${luckyTag}
                        `;
						listEl.appendChild(item);
					});

					modal.classList.add("visible");
				}

				// 绑定关闭详情按钮的事件
				document.getElementById("close-rp-details-btn").addEventListener("click", () => {
					document.getElementById("red-packet-details-modal").classList.remove("visible");
				});

				// 供全局调用的函数，以便红包卡片上的 onclick 能找到它
				window.handlePacketClick = handlePacketClick;

				/**
				 * 打开创建投票的模态框并初始化
				 */
				function openCreatePollModal() {
					const modal = document.getElementById("create-poll-modal");
					document.getElementById("poll-question-input").value = "";
					const optionsContainer = document.getElementById("poll-options-container");
					optionsContainer.innerHTML = "";

					// 默认创建两个空的选项框
					addPollOptionInput();
					addPollOptionInput();

					modal.classList.add("visible");
				}

				/**
				 * 在模态框中动态添加一个选项输入框
				 */
				function addPollOptionInput() {
					const container = document.getElementById("poll-options-container");
					const wrapper = document.createElement("div");
					wrapper.className = "poll-option-input-wrapper";
					wrapper.innerHTML = `
                        <input type="text" class="poll-option-input" placeholder="选项内容...">
                        <button class="remove-option-btn">-</button>
                    `;

					wrapper.querySelector(".remove-option-btn").addEventListener("click", () => {
						// 确保至少保留两个选项
						if (container.children.length > 2) {
							wrapper.remove();
						} else {
							alert("投票至少需要2个选项。");
						}
					});

					container.appendChild(wrapper);
				}

				/**
				 * 用户确认发起投票
				 */
				async function sendPoll() {
					if (!state.activeChatId) return;

					const question = document.getElementById("poll-question-input").value.trim();
					if (!question) {
						alert("请输入投票问题！");
						return;
					}

					const options = Array.from(document.querySelectorAll(".poll-option-input"))
						.map((input) => input.value.trim())
						.filter((text) => text); // 过滤掉空的选项

					if (options.length < 2) {
						alert("请至少输入2个有效的投票选项！");
						return;
					}

					const chat = state.chats[state.activeChatId];
					const myNickname = chat.isGroup ? chat.settings.myNickname || "我" : "我";

					const newPollMessage = {
						role: "user",
						senderName: myNickname,
						type: "poll",
						timestamp: Date.now(),
						question: question,
						options: options,
						votes: {}, // 初始投票为空
						isClosed: false,
					};

					chat.history.push(newPollMessage);
					await db.chats.put(chat);

					appendMessage(newPollMessage, chat);
					renderChatList();

					document.getElementById("create-poll-modal").classList.remove("visible");
				}

				/**
				 * 处理用户投票，并将事件作为隐藏消息存入历史记录
				 * @param {number} timestamp - 投票消息的时间戳
				 * @param {string} choice - 用户选择的选项文本
				 */
				async function handleUserVote(timestamp, choice) {
					const chat = state.chats[state.activeChatId];
					const poll = chat.history.find((m) => m.timestamp === timestamp);
					const myNickname = chat.isGroup ? chat.settings.myNickname || "我" : "我";

					// 如果投票不存在或已关闭，直接返回
					if (!poll || poll.isClosed) {
						// 如果是已关闭的投票，则直接显示结果
						if (poll && poll.isClosed) {
							showPollResults(timestamp);
						}
						return;
					}

					// 检查用户是否点击了已经投过的同一个选项
					const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);

					// 如果不是重复点击，才执行投票逻辑
					if (!isReclickingSameOption) {
						// 移除旧投票（如果用户改选）
						for (const option in poll.votes) {
							const voterIndex = poll.votes[option].indexOf(myNickname);
							if (voterIndex > -1) {
								poll.votes[option].splice(voterIndex, 1);
							}
						}
						// 添加新投票
						if (!poll.votes[choice]) {
							poll.votes[choice] = [];
						}
						poll.votes[choice].push(myNickname);
					}

					// 现在只处理用户投票事件，不再检查是否结束
					let hiddenMessageContent = null;

					// 只有在用户真正投票或改票时，才生成提示
					if (!isReclickingSameOption) {
						hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚投票给了 "${choice}"。]`;
					}

					// 如果有需要通知AI的事件，则创建并添加隐藏消息
					if (hiddenMessageContent) {
						const hiddenMessage = {
							role: "system",
							content: hiddenMessageContent,
							timestamp: Date.now(),
							isHidden: true,
						};
						chat.history.push(hiddenMessage);
					}

					// 保存数据并更新UI
					await db.chats.put(chat);
					renderChatInterface(state.activeChatId);
				}

				/**
				 * 用户结束投票，并将事件作为隐藏消息存入历史记录
				 * @param {number} timestamp - 投票消息的时间戳
				 */
				async function endPoll(timestamp) {
					const chat = state.chats[state.activeChatId];
					const poll = chat.history.find((m) => m.timestamp === timestamp);
					if (!poll || poll.isClosed) return;

					const confirmed = await showCustomConfirm("结束投票", "确定要结束这个投票吗？结束后将无法再进行投票。");
					if (confirmed) {
						poll.isClosed = true;

						const resultSummary = poll.options.map((opt) => `"${opt}"(${poll.votes[opt]?.length || 0}票)`).join("，");
						const hiddenMessageContent = `[系统提示：用户手动结束了投票！最终结果为：${resultSummary}。]`;

						const hiddenMessage = {
							role: "system",
							content: hiddenMessageContent,
							timestamp: Date.now(),
							isHidden: true,
						};
						chat.history.push(hiddenMessage);

						// 只保存数据和更新UI，不调用 triggerAiResponse()
						await db.chats.put(chat);
						renderChatInterface(state.activeChatId);
					}
				}

				/**
				 * 显示投票结果详情
				 * @param {number} timestamp - 投票消息的时间戳
				 */
				function showPollResults(timestamp) {
					const chat = state.chats[state.activeChatId];
					const poll = chat.history.find((m) => m.timestamp === timestamp);
					if (!poll || !poll.isClosed) return;

					let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;

					if (Object.keys(poll.votes).length === 0) {
						resultsHtml += '<p style="color: #8a8a8a;">还没有人投票。</p>';
					} else {
						poll.options.forEach((option) => {
							const voters = poll.votes[option] || [];
							resultsHtml += `
                                <div style="margin-bottom: 15px;">
                                    <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}票)</p>
                                    <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                                        ${voters.length > 0 ? voters.join("、 ") : "无人投票"}
                                    </p>
                                </div>
                            `;
						});
					}

					showCustomAlert("投票结果", resultsHtml);
				}

				/**
				 * 打开AI头像库管理模态框
				 */
				function openAiAvatarLibraryModal() {
					if (!state.activeChatId) return;
					const chat = state.chats[state.activeChatId];
					document.getElementById("ai-avatar-library-title").textContent = `"${chat.name}"的头像库`;
					renderAiAvatarLibrary();
					document.getElementById("ai-avatar-library-modal").classList.add("visible");
				}

				/**
				 * 渲染AI头像库的内容
				 */
				function renderAiAvatarLibrary() {
					const grid = document.getElementById("ai-avatar-library-grid");
					grid.innerHTML = "";
					const chat = state.chats[state.activeChatId];
					const library = chat.settings.aiAvatarLibrary || [];

					if (library.length === 0) {
						grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角"添加"吧！</p>';
						return;
					}

					library.forEach((avatar, index) => {
						const item = document.createElement("div");
						item.className = "sticker-item"; // 复用表情面板的样式
						item.style.backgroundImage = `url(${avatar.url})`;
						item.title = avatar.name;

						const deleteBtn = document.createElement("div");
						deleteBtn.className = "delete-btn";
						deleteBtn.innerHTML = "×";
						deleteBtn.style.display = "block"; // 总是显示删除按钮
						deleteBtn.onclick = async (e) => {
							e.stopPropagation();
							const confirmed = await showCustomConfirm("删除头像", `确定要从头像库中删除"${avatar.name}"吗？`, { confirmButtonClass: "btn-danger" });
							if (confirmed) {
								chat.settings.aiAvatarLibrary.splice(index, 1);
								await db.chats.put(chat);
								renderAiAvatarLibrary();
							}
						};
						item.appendChild(deleteBtn);
						grid.appendChild(item);
					});
				}

				/**
				 * 向当前AI的头像库中添加新头像
				 */
				async function addAvatarToLibrary() {
					const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：开心、哭泣）");
					if (!name || !name.trim()) return;

					const url = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
					if (!url || !url.trim().startsWith("http")) {
						alert("请输入有效的图片URL！");
						return;
					}

					const chat = state.chats[state.activeChatId];
					if (!chat.settings.aiAvatarLibrary) {
						chat.settings.aiAvatarLibrary = [];
					}

					chat.settings.aiAvatarLibrary.push({ name: name.trim(), url: url.trim() });
					await db.chats.put(chat);
					renderAiAvatarLibrary();
				}

				/**
				 * 关闭AI头像库管理模态框
				 */
				function closeAiAvatarLibraryModal() {
					document.getElementById("ai-avatar-library-modal").classList.remove("visible");
				}

				/**
				 * 渲染主屏幕个人资料卡的头像框
				 */
				function renderHomeScreenProfileFrame() {
					// 获取保存的头像框URL
					const frameUrl = state.globalSettings.homeAvatarFrame || "";
					// 找到头像框的img元素
					const frameImg = document.getElementById("profile-avatar-frame");
					if (frameImg) {
						// 如果URL存在，就显示它
						if (frameUrl) {
							frameImg.src = frameUrl;
							frameImg.style.display = "block";
						} else {
							// 如果URL为空（即选择了"无"），就隐藏它
							frameImg.src = "";
							frameImg.style.display = "none";
						}
					}
				}

				/**
				 * 应用小组件数据到页面元素
				 */
				function applyWidgetData() {
					if (!state.globalSettings.widgetData) return;
					for (const elementId in state.globalSettings.widgetData) {
						const element = document.getElementById(elementId);
						const savedValue = state.globalSettings.widgetData[elementId];
						if (element) {
							if (element.tagName === "IMG") {
								element.src = savedValue;
							}
							// 如果是地点这个特殊元素，就用 innerHTML 来正确显示图标
							else if (elementId === "profile-location") {
								element.innerHTML = savedValue;
							}
							// 其他普通文本元素，保持原来的逻辑不变
							else {
								element.textContent = savedValue;
							}
						}
					}
				}

				/**
				 * 打开文件选择器，并返回本地图片的Base64编码
				 * @returns {Promise<string|null>} - 返回图片的Base64 Data URL，如果用户取消则返回null
				 */
				function uploadImageLocally() {
					return new Promise((resolve) => {
						const input = document.createElement("input");
						input.type = "file";
						input.accept = "image/*"; // 只接受图片文件

						input.onchange = (e) => {
							const file = e.target.files[0];
							if (file) {
								const reader = new FileReader();
								reader.onload = (readerEvent) => {
									resolve(readerEvent.target.result); // 返回Base64字符串
								};
								reader.readAsDataURL(file);
							} else {
								resolve(null); // 用户关闭了文件选择框
							}
						};

						input.click();
					});
				}

				/**
				 * 处理文本元素编辑
				 * @param {HTMLElement} element - 要编辑的元素
				 */
				async function handleEditText(element) {
					const elementId = element.id;
					const placeholder = element.dataset.placeholder || "请输入新的内容：";
					const textSpan = element.querySelector("span");
					const isComplexElement = !!textSpan;
					const targetElement = isComplexElement ? textSpan : element;
					const currentValue = targetElement.textContent;

					const newValue = await showCustomPrompt("修改文字", "请输入新的内容：", currentValue === placeholder ? "" : currentValue);

					if (newValue !== null) {
						const trimmedValue = newValue.trim();
						targetElement.textContent = trimmedValue ? trimmedValue : placeholder;
						state.globalSettings.widgetData[elementId] = isComplexElement ? element.innerHTML : targetElement.textContent;
						await db.globalSettings.put(state.globalSettings);
					}
				}

				/**
				 * 触发指定群聊的后台AI互动
				 * @param {string} chatId - 要触发互动的群聊ID
				 */
				async function triggerGroupAiAction(chatId) {
					const chat = state.chats[chatId];
					if (!chat || !chat.isGroup) return;

					const { proxyUrl, apiKey, model } = state.apiConfig;
					if (!proxyUrl || !apiKey || !model) {
						console.warn(`群聊 "${chat.name}" 后台活动失败：API未配置。`);
						return;
					}

					const maxMemory = chat.settings.maxMemory || 10;
					const historySlice = chat.history.filter((msg) => !msg.isHidden).slice(-maxMemory);

					// 格式化这些记录，让AI能看懂
					const recentContextSummary = historySlice
						.map((msg) => {
							// 判断是谁说的话
							const sender = msg.role === "user" ? (chat.isGroup ? chat.settings.myNickname || "我" : "我") : msg.senderName || chat.name;

							// 处理不同类型的消息内容
							let contentText = "";
							if (typeof msg.content === "string" && STICKER_REGEX.test(msg.content)) {
								contentText = `[发送了一个表情: ${msg.meaning || "无描述"}]`;
							} else if (Array.isArray(msg.content)) {
								contentText = "[发送了一张图片]";
							} else if (typeof msg.content === "object" && msg.content !== null) {
								contentText = `[发送了一条特殊消息: ${msg.type || "未知类型"}]`;
							} else {
								contentText = String(msg.content);
							}

							// 给每条消息记录添加发送日期时间
							const messageDate = new Date(msg.timestamp);
							const formattedDate = messageDate.toLocaleDateString();

							return `[${formattedDate}] ${sender}: ${contentText}`;
						})
						.join("\n");

					// 获取记忆互通的聊天记录
					let linkedMemoryContext = "";
					if (chat.settings.linkedMemories && chat.settings.linkedMemories.length > 0) {
						const contextPromises = chat.settings.linkedMemories.map(async (link) => {
							const linkedChat = state.chats[link.chatId];
							if (!linkedChat) return "";

							const freshLinkedChat = await db.chats.get(link.chatId);
							if (!freshLinkedChat) return "";

							const recentHistory = freshLinkedChat.history.filter((msg) => !msg.isHidden).slice(-link.depth);

							if (recentHistory.length === 0) return "";

							const formattedMessages = recentHistory.map((msg) => `  - ${formatMessageForContext(msg, freshLinkedChat)}`).join("\n");

							return `\n## 附加上下文：来自与"${linkedChat.name}"的最近对话内容 (仅你可见)\n${formattedMessages}`;
						});

						const allContexts = await Promise.all(contextPromises);
						linkedMemoryContext = allContexts.filter(Boolean).join("\n");
					}

					try {
						const lastMessage = chat.history.slice(-1)[0];
						const timeSinceLastMessage = lastMessage ? (Date.now() - lastMessage.timestamp) / 1000 / 60 : Infinity; // in minutes

						const membersList = chat.members.map((m) => `- ${m.groupNickname} (人设: ${m.persona})`).join("\n");
						const myNickname = chat.settings.myNickname || "我";

						let worldBookContent = "";
						if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
							const linkedContents = chat.settings.linkedWorldBookIds
								.map((bookId) => {
									const worldBook = state.worldBooks.find((wb) => wb.id === bookId);
									return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : "";
								})
								.filter(Boolean)
								.join("");
							if (linkedContents) {
								worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
							}
						}
						let musicContext = "";
						// 注意：后台群聊活动通常不与特定的"一起听歌"会话绑定，因此这里我们提供一个空的音乐上下文。
						// 如果未来需要更复杂的功能，可以在此扩展。

						const countdownContext = await getCountdownContext();

						let sharedContext = "";
						// 后台群聊活动中不存在用户分享聊天记录的上下文，因此这里为空。

						const systemPrompt = `
                # 任务
                你是一个群聊后台模拟器。当前群聊 "${chat.name}" 已经沉寂了 ${Math.round(timeSinceLastMessage)} 分钟，用户(昵称: "${chat.settings.myNickname || "我"}")不在线。
                你的任务是根据下方每个角色的人设，在他们之间【自发地】生成一段自然的对话。
                # 【对话节奏铁律 (至关重要！)】
                你的回复【必须】模拟真人的打字和思考习惯。**绝对不要一次性发送一大段文字！** 每条消息最好不要超过30个字，这会让对话看起来更自然、更真实。
                # 核心规则
                1.  **【【【身份铁律】】】**: 用户【绝对不在场】。你【绝对不能】生成与用户对话的内容。整段对话必须是AI角色之间的互动。你的唯一任务是扮演【且仅能扮演】下方"群成员列表"中明确列出的角色。【绝对禁止】扮演任何未在"群成员列表"中出现的角色。
                    # 群成员列表及人设 (name字段是你要使用的【本名】)
                    ${chat.members.map((m) => `- **${m.originalName}**: (群昵称为: ${m.groupNickname}) 人设: ${m.persona}`).join("\n")}
                2.  **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有 "type" 和 "name" 字段的JSON对象】。
                3.  **角色扮演**: 严格遵守下方"群成员列表及人设"中的每一个角色的设定。
                4.  **禁止出戏**: 绝不能透露你是AI、模型，或提及"扮演"、"生成"等词语。
                5.  **自然性**: 对话应该简短（2-5条消息即可），符合逻辑和角色性格。可以是闲聊、讨论某个话题，或者对之前聊天内容的延续。

                ## 你可以使用的操作指令 (JSON数组中的元素):
                -   **发送文本**: \`{"type": "text", "name": "角色名", "message": "文本内容"}\`
                -   **发送表情**: \`{"type": "sticker", "name": "角色名",  "sticker_name": "表情的名字"}\`
                -   **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片描述"}\`
                -   **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音内容"}\`
                -   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\` (向【群友】发起)
                -   **拍一拍群友**: \`{"type": "pat_user", "name": "你的角色名", "targetName": "【被拍的群友名】", "suffix": "(可选)你想加的后缀"}\`
                -   **发红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", ...}\`
                -   **发起投票**: \`{"type": "poll", "name": "你的角色名", ...}\`

                # 如何处理后台互动中的【拍一拍】:
                -   后台活动中的 "pat_user" 指令【只能用于拍群内的其他AI角色】。
                -   你【必须】在指令中加入一个 \`"targetName"\` 字段，值为被你拍的那个角色的名字。
                -   例如: \`{"type": "pat_user", "name": "角色A", "targetName": "角色B"}\`
                -   系统会自动生成 "角色A 拍了拍 角色B" 的提示。

                ${worldBookContent}
                ${musicContext}
                ${countdownContext} // 把备忘录加在这里
                ${sharedContext} 
                # 群成员列表及人设
                ${membersList}
                # 用户的角色
                - **${myNickname}**: ${chat.settings.myPersona}
                # 对话历史参考
                ${recentContextSummary}
                ${linkedMemoryContext}

                现在，请严格遵守以上所有规则，开始你的模拟。`;

						const messagesPayload = [{ role: "user", content: systemPrompt }];

						let isGemini = proxyUrl === GEMINI_API_URL;
						let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini);

						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({
										model: model,
										messages: messagesPayload,
										temperature: parseFloat(state.apiConfig.temperature) || 0.8,
									}),
							  });

						if (!response.ok) throw new Error(`API请求失败: ${response.status}`);

						const data = await response.json();
						const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, "");

						const messagesArray = JSON.parse(aiResponseContent);

						if (Array.isArray(messagesArray) && messagesArray.length > 0) {
							let messageTimestamp = Date.now();
							let firstMessageContent = "";

							messagesArray.forEach((msgData, index) => {
								if (msgData.name && msgData.message) {
									const aiMessage = {
										role: "assistant",
										senderName: msgData.name,
										content: String(msgData.message),
										timestamp: messageTimestamp++,
									};
									chat.history.push(aiMessage);
									if (index === 0) {
										firstMessageContent = `${msgData.name}: ${msgData.message}`;
									}
								}
							});

							// 更新此群聊的最后活动时间戳
							chat.settings.backgroundActivity.lastActivityTimestamp = Date.now();

							// 给用户发通知
							chat.unreadCount = (chat.unreadCount || 0) + messagesArray.length;
							showNotification(chatId, firstMessageContent);

							// 保存并刷新UI
							await db.chats.put(chat);
							renderChatList();

							console.log(`群聊 "${chat.name}" 后台互动成功，生成了 ${messagesArray.length} 条新消息。`);
						}
					} catch (error) {
						console.error(`群聊 "${chat.name}" 的后台活动失败:`, error);
					}
				}

				/**
				 * 处理图片元素编辑
				 * @param {HTMLElement} element - 要编辑的图片元素
				 */
				async function handleEditImage(element) {
					const elementId = element.id;

					// 移除了按钮文字中的图标
					const choice = await showChoiceModal("修改图片", [
						{ text: "从本地上传", value: "local" },
						{ text: "使用网络URL", value: "url" },
					]);

					let newValue = null;

					if (choice === "local") {
						newValue = await uploadImageLocally();
					} else if (choice === "url") {
						newValue = await showCustomPrompt("修改图片", "请输入新的图片URL：", element.src, "url");
					}

					if (newValue && newValue.trim()) {
						const trimmedValue = newValue.trim();
						element.src = trimmedValue;
						state.globalSettings.widgetData[elementId] = trimmedValue;
						await db.globalSettings.put(state.globalSettings);
					} else if (choice === "url" && newValue !== null) {
						alert("请输入一个有效的图片URL！");
					}
				}

				// 用于存储群聊主时钟的ID
				let groupSimulationIntervalId = null;

				/**
				 * 启动群聊的后台"主时钟"。这个时钟会一直运行，定期检查所有群聊。
				 */
				function startGroupSimulation() {
					if (groupSimulationIntervalId) return; // 如果已经启动，则不重复启动

					// 设置一个相对较短的间隔（比如30秒）来作为"主时钟"的频率
					// 它不是具体某个群聊的活动间隔，而是检查所有群聊的频率

					// 加长检查间隔，防止已经触发自动回复但api未返回时重复触发导致多次回复。60秒间隔大于一般API返回数据时间的平均值，且不会过长影响使用体验。
					groupSimulationIntervalId = setInterval(runGroupSimulationTick, 60000); // 60秒检查一次
					console.log("群聊后台活动主时钟已启动，每60秒检查一次所有群聊。");
				}

				/**
				 * 停止群聊的后台"主时钟"。
				 */
				function stopGroupSimulation() {
					if (groupSimulationIntervalId) {
						clearInterval(groupSimulationIntervalId);
						groupSimulationIntervalId = null;
						console.log("群聊后台活动主时钟已停止。");
					}
				}

				/**
				 * 群聊"主时钟"的每一次心跳执行的函数
				 */
				function runGroupSimulationTick() {
					const allGroupChats = Object.values(state.chats).filter((chat) => chat.isGroup);

					allGroupChats.forEach((chat) => {
						const bgSettings = chat.settings.backgroundActivity;
						// 检查1：该群聊自己的开关是否开启
						if (bgSettings && bgSettings.enabled) {
							const now = Date.now();

							// 检查2：使用该群聊自己设置的间隔期
							const intervalMs = (bgSettings.interval || 120) * 1000;
							// 使用当前群聊最后一条消息时间作为最后活动时间
							const lastMessage = chat.history.slice(-1)[0];
							const lastActivity = lastMessage ? lastMessage.timestamp : 0;

							// 检查3：是否到达了该群聊的行动时间
							if (now - lastActivity > intervalMs) {
								console.log(`群聊 "${chat.name}" 到达行动时间 (间隔: ${bgSettings.interval}秒)，准备触发后台互动...`);
								// 触发群聊专属的后台行动函数
								triggerGroupAiAction(chat.id);
							}
						}
					});
				}

				/**
				 * 清空所有已关注角色的微博帖子
				 */
				async function clearFollowingFeed() {
					// 弹出确认框，防止误操作
					const confirmed = await showCustomConfirm(
						"确认清空",
						"此操作将永久删除所有【非你本人发布】的微博，且无法恢复。确定要继续吗？",
						{ confirmButtonClass: "btn-danger" } // 红色按钮以示警告
					);

					if (!confirmed) {
						return; // 如果用户取消，则不执行任何操作
					}

					try {
						// 从数据库中找出所有作者不是'user'的帖子
						const postsToDelete = await db.weiboPosts.where("authorId").notEqual("user").toArray();
						const idsToDelete = postsToDelete.map((p) => p.id);

						if (idsToDelete.length === 0) {
							alert("目前没有可以清空的动态。");
							return;
						}

						// 批量删除这些帖子
						await db.weiboPosts.bulkDelete(idsToDelete);

						// 重新渲染"关注的人"的Feed，让界面变空
						await renderWeiboFeeds("weibo-following-view");

						alert(`已成功清空 ${idsToDelete.length} 条动态！`);
					} catch (error) {
						console.error("清空关注动态时出错:", error);
						alert(`操作失败: ${error.message}`);
					}
				}

				/**
				 * 将保存的图标URL应用到主屏幕的App图标上
				 */
				function applyAppIcons() {
					if (!state.globalSettings.appIcons) return;

					for (const iconId in state.globalSettings.appIcons) {
						const imgElement = document.getElementById(`icon-img-${iconId}`);
						if (imgElement) {
							imgElement.src = state.globalSettings.appIcons[iconId];
						}
					}
				}

				/**
				 * 在外观设置页面渲染出所有App图标的设置项
				 */
				function renderIconSettings() {
					const grid = document.getElementById("icon-settings-grid");
					if (!grid) return;
					grid.innerHTML = "";

					const appLabels = {
						"world-book": "世界书",
						qq: "QQ",
						"api-settings": "API设置",
						wallpaper: "壁纸",
						font: "字体",
						"check-phone": "查手机",
						weibo: "微博",
						forum: "圈子",
						"lovers-space": "情侣空间",
						"game-hall": "游戏大厅",
						"x-social": "X社交",
						taobao: "桃宝",
						"date-a-live": "约会大作战",
					};

					for (const iconId in state.globalSettings.appIcons) {
						const iconUrl = state.globalSettings.appIcons[iconId];
						const labelText = appLabels[iconId] || "未知App";

						const item = document.createElement("div");
						item.className = "icon-setting-item";
						// 用 data-icon-id 来标记这个设置项对应哪个图标
						item.dataset.iconId = iconId;

						item.innerHTML = `
                            <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
                            <button class="change-icon-btn">更换</button>
                        `;
						grid.appendChild(item);
					}
				}

				/**
				 * 当用户点击链接卡片时，打开伪浏览器
				 * @param {number} timestamp - 被点击消息的时间戳
				 */
				function openBrowser(timestamp) {
					if (!state.activeChatId) return;

					const chat = state.chats[state.activeChatId];
					// 安全检查，确保 chat 和 history 都存在
					if (!chat || !chat.history) return;

					const message = chat.history.find((m) => m.timestamp === timestamp);
					if (!message || message.type !== "share_link") {
						console.error("无法找到或消息类型不匹配的分享链接:", timestamp);
						return; // 如果找不到消息，就直接退出
					}

					// 填充浏览器内容
					document.getElementById("browser-title").textContent = message.source_name || "文章详情";
					const browserContent = document.getElementById("browser-content");
					browserContent.innerHTML = `
                        <h1 class="article-title">${message.title || "无标题"}</h1>
                        <div class="article-meta">
                            <span>来源: ${message.source_name || "未知"}</span>
                        </div>
                        <div class="article-body">
                            <p>${(message.content || "内容为空。").replace(/\n/g, "</p><p>")}</p>
                        </div>
                    `;

					// 显示浏览器屏幕
					showScreen("browser-screen");
				}

				/**
				 * 关闭伪浏览器，返回聊天界面
				 */
				function closeBrowser() {
					showScreen("chat-interface-screen");
				}

				/**
				 * 打开让用户填写链接信息的模态框
				 */
				function openShareLinkModal() {
					if (!state.activeChatId) return;

					// 清空上次输入的内容
					document.getElementById("link-title-input").value = "";
					document.getElementById("link-description-input").value = "";
					document.getElementById("link-source-input").value = "";
					document.getElementById("link-content-input").value = "";

					// 显示模态框
					document.getElementById("share-link-modal").classList.add("visible");
				}

				/**
				 * 用户确认分享，创建并发送链接卡片消息
				 */
				async function sendUserLinkShare() {
					if (!state.activeChatId) return;

					const title = document.getElementById("link-title-input").value.trim();
					if (!title) {
						alert("标题是必填项哦！");
						return;
					}

					const description = document.getElementById("link-description-input").value.trim();
					const sourceName = document.getElementById("link-source-input").value.trim();
					const content = document.getElementById("link-content-input").value.trim();

					const chat = state.chats[state.activeChatId];

					// 创建消息对象
					const linkMessage = {
						role: "user", // 角色是 'user'
						type: "share_link",
						timestamp: Date.now(),
						title: title,
						description: description,
						source_name: sourceName,
						content: content,
						// 用户分享的链接，我们不提供图片，让它总是显示占位图
						thumbnail_url: null,
					};

					// 将消息添加到历史记录
					chat.history.push(linkMessage);
					await db.chats.put(chat);

					// 渲染新消息并更新列表
					appendMessage(linkMessage, chat);
					renderChatList();

					// 关闭模态框
					document.getElementById("share-link-modal").classList.remove("visible");
				}

				/**
				 * 根据AI视角和动态设置，构建给AI看的评论区上下文
				 * @param {object} post - 正在处理的动态对象
				 * @param {object} viewerChat - 正在"看"动态的AI角色
				 * @param {string} userNickname - 用户的昵称
				 * @returns {{contextString: string, visibilityFlag: string}} - 返回包含上下文文本和可见性标志的对象
				 */
				function buildCommentsContextForAI(post, viewerChat, userNickname) {
					// 安全检查，如果post.comments不存在或不是数组，直接返回空
					if (!post.comments || !Array.isArray(post.comments) || post.comments.length === 0) {
						return { contextString: "", visibilityFlag: "[评论区可见]" };
					}

					const viewerName = viewerChat.name;
					let commentsForAI;
					let visibilityFlag;

					// 根据帖子的评论可见性设置，决定AI能看到哪些评论
					if (post.areCommentsVisible !== false) {
						commentsForAI = post.comments; // 如果可见性为true或未设置，则AI能看到所有评论
						visibilityFlag = "[评论区可见]";
					} else {
						// 如果设置为"部分可见"，则AI只能看到自己、用户以及回复自己的评论
						commentsForAI = post.comments.filter((comment) => {
							return (
								comment.commenterName === viewerName || // AI自己的评论
								comment.commenterName === userNickname || // 用户的评论
								comment.replyTo === viewerName
							); // 回复AI的评论
						});
						visibilityFlag = "[评论区部分可见]";
					}

					if (commentsForAI.length === 0) {
						return { contextString: "", visibilityFlag: visibilityFlag };
					}

					// 构建对AI清晰易懂的评论字符串
					let context = `  └ 评论区:\n`;
					commentsForAI.slice(-5).forEach((c) => {
						// 只展示最近的5条评论以节省token
						// 确定评论者的身份标签
						const commenterLabel =
							c.commenterName === viewerName
								? "你" // 如果是AI自己，直接标记为"你"
								: c.commenterName === userNickname
								? "用户"
								: c.commenterName;

						// 如果是回复，同样确定被回复者的身份标签
						let replyPart = "";
						if (c.replyTo) {
							const replyToLabel = c.replyTo === viewerName ? "你" : c.replyTo === userNickname ? "用户" : c.replyTo;
							replyPart = ` 回复 ${replyToLabel}`;
						}

						// 拼接成最终的、无歧义的字符串
						context += `    - ${commenterLabel}${replyPart}: ${c.text}\n`;
					});

					return { contextString: context, visibilityFlag: visibilityFlag };
				}

				/**
				 * 根据AI的视角，过滤出它能看到的动态
				 * @param {Array} allPosts - 所有待检查的动态帖子
				 * @param {object} viewerChat - 正在"看"动态的那个AI的chat对象
				 * @returns {Array} - 过滤后该AI可见的动态帖子
				 */
				function filterVisiblePostsForAI(allPosts, viewerChat) {
					if (!viewerChat || !viewerChat.id) return; // 安全检查

					const viewerGroupId = viewerChat.groupId; // 查看者所在的分组ID

					return allPosts.filter((post) => {
						// 规则1：如果是用户发的动态
						if (post.authorId === "user") {
							// 如果用户设置了"部分可见"
							if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
								// 只有当查看者AI的分组ID在用户的可见列表里时，才可见
								return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
							}
							// 如果用户没设置，说明是公开的，所有AI都可见
							return true;
						}

						// 规则2：如果是其他AI发的动态
						const authorGroupId = post.authorGroupId; // 发帖AI所在的分组ID

						// 如果发帖的AI没有分组，那它的动态就是公开的
						if (!authorGroupId) {
							return true;
						}

						// 如果发帖的AI有分组，那么只有在同一个分组的AI才能看到
						return authorGroupId === viewerGroupId;
					});
				}

				/**
				 * 应用指定的主题('light' 或 'dark')
				 * @param {string} theme - 要应用的主题名称
				 */
				function applyTheme(theme) {
					const phoneScreen = document.getElementById("phone-screen");
					const toggleSwitch = document.getElementById("theme-toggle-switch");

					const isDark = theme === "dark";

					phoneScreen.classList.toggle("dark-mode", isDark);

					// 如果开关存在，就同步它的状态
					if (toggleSwitch) {
						toggleSwitch.checked = isDark;
					}

					localStorage.setItem("ephone-theme", theme);
				}

				/**
				 * 切换当前的主题
				 */
				function toggleTheme() {
					const toggleSwitch = document.getElementById("theme-toggle-switch");
					// 直接根据开关的选中状态来决定新主题
					const newTheme = toggleSwitch.checked ? "dark" : "light";
					applyTheme(newTheme);
				}

				/**
				 * 开始回复消息
				 */
				function startReplyToMessage() {
					if (!activeMessageTimestamp) return;

					const chat = state.chats[state.activeChatId];
					const message = chat.history.find((m) => m.timestamp === activeMessageTimestamp);
					if (!message) return;

					// 同时获取"完整内容"和"预览片段"
					const fullContent = String(message.content || "");
					let previewSnippet = "";

					if (typeof message.content === "string" && STICKER_REGEX.test(message.content)) {
						previewSnippet = "[表情]";
					} else if (message.type === "ai_image" || message.type === "user_photo") {
						previewSnippet = "[图片]";
					} else if (message.type === "voice_message") {
						previewSnippet = "[语音]";
					} else {
						// 预览片段依然截断，但只用于UI显示
						previewSnippet = fullContent.substring(0, 50) + (fullContent.length > 50 ? "..." : "");
					}

					// 将"完整内容"存入上下文，以备发送时使用
					currentReplyContext = {
						timestamp: message.timestamp,
						senderName: message.senderName || (message.role === "user" ? chat.settings.myNickname || "我" : chat.name),
						content: fullContent, // 存的是完整的原文！
					};

					// 仅在更新"回复预览栏"时，才使用"预览片段"
					const previewBar = document.getElementById("reply-preview-bar");
					previewBar.querySelector(".sender").textContent = `回复 ${currentReplyContext.senderName}:`;
					previewBar.querySelector(".text").textContent = previewSnippet; // 这里用的是缩略版！
					previewBar.style.display = "block";

					// 后续操作保持不变
					hideMessageActions();
					document.getElementById("chat-input").focus();
				}

				/**
				 * 取消引用模式
				 */
				function cancelReplyMode() {
					currentReplyContext = null;
					document.getElementById("reply-preview-bar").style.display = "none";
				}

				// 用于暂存被点击的转账消息的时间戳
				let activeTransferTimestamp = null;

				/**
				 * 显示处理转账的操作菜单
				 * @param {number} timestamp - 被点击的转账消息的时间戳
				 */
				function showTransferActionModal(timestamp) {
					activeTransferTimestamp = timestamp;

					const chat = state.chats[state.activeChatId];
					const message = chat.history.find((m) => m.timestamp === timestamp);
					if (message) {
						// 将AI的名字填入弹窗
						document.getElementById("transfer-sender-name").textContent = message.senderName;
					}
					document.getElementById("transfer-actions-modal").classList.add("visible");
				}

				/**
				 * 隐藏处理转账的操作菜单
				 */
				function hideTransferActionModal() {
					document.getElementById("transfer-actions-modal").classList.remove("visible");
					activeTransferTimestamp = null;
				}

				/**
				 * 处理用户接受或拒绝转账的逻辑
				 * @param {string} choice - 用户的选择, 'accepted' 或 'declined'
				 */
				async function handleUserTransferResponse(choice) {
					if (!activeTransferTimestamp) return;

					const timestamp = activeTransferTimestamp;
					const chat = state.chats[state.activeChatId];
					const messageIndex = chat.history.findIndex((m) => m.timestamp === timestamp);
					if (messageIndex === -1) return;

					// 更新原始转账消息的状态
					const originalMessage = chat.history[messageIndex];
					originalMessage.status = choice;

					let systemContent;

					// 如果用户选择"拒绝"
					if (choice === "declined") {
						// 立刻在前端生成一个"退款"卡片，让用户看到
						const refundMessage = {
							role: "user",
							type: "transfer",
							isRefund: true, // 这是一个关键标记，用于UI显示这是退款
							amount: originalMessage.amount,
							note: "已拒收对方转账",
							timestamp: Date.now(),
						};
						chat.history.push(refundMessage);

						// 准备一条对AI可见的隐藏消息，告诉它发生了什么
						systemContent = `[系统提示：你拒绝并退还了"${originalMessage.senderName}"的转账。]`;
					} else {
						// 如果用户选择"接受"
						// 只需准备隐藏消息通知AI即可
						systemContent = `[系统提示：你接受了"${originalMessage.senderName}"的转账。]`;
						await updateUserBalanceAndLogTransaction(originalMessage.amount, `收到来自 ${originalMessage.senderName} 的转账`);
					}

					// 创建这条对用户隐藏、但对AI可见的系统消息
					const hiddenMessage = {
						role: "system",
						content: systemContent,
						timestamp: Date.now() + 1, // 保证时间戳在退款消息之后
						isHidden: true, // 这个标记会让它不在聊天界面显示
					};
					chat.history.push(hiddenMessage);

					// 保存所有更改到数据库，并刷新界面
					await db.chats.put(chat);
					hideTransferActionModal();
					renderChatInterface(state.activeChatId);
					renderChatList();
				}

				/**
				 * 渲染通话记录屏幕
				 */
				async function renderCallHistoryScreen() {
					showScreen("call-history-screen"); // 显示通话记录屏幕

					const listEl = document.getElementById("call-history-list");
					const titleEl = document.getElementById("call-history-title");
					listEl.innerHTML = "";
					titleEl.textContent = "所有通话记录";

					const records = await db.callRecords.orderBy("timestamp").reverse().toArray();

					if (records.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有通话记录哦~</p>';
						return;
					}

					records.forEach((record) => {
						const card = createCallRecordCard(record);

						addLongPressListener(card, async () => {
							// 弹出输入框，并将旧名称作为默认值，方便修改
							const newName = await showCustomPrompt(
								"自定义通话名称",
								"请输入新的名称（留空则恢复默认）",
								record.customName || "" // 如果已有自定义名称，就显示它
							);

							// 如果用户点击了"取消"，则什么都不做
							if (newName === null) return;

							// 更新数据库中的这条记录
							await db.callRecords.update(record.id, { customName: newName.trim() });

							// 刷新整个列表，让更改立刻显示出来
							await renderCallHistoryScreen();

							// 给用户一个成功的提示
							await showCustomAlert("成功", "通话名称已更新！");
						});
						listEl.appendChild(card);
					});
				}

				/**
				 * 根据单条记录数据，创建一张能显示聊天对象的通话卡片
				 * @param {object} record - 一条通话记录对象
				 * @returns {HTMLElement} - 创建好的卡片div
				 */
				function createCallRecordCard(record) {
					const card = document.createElement("div");
					card.className = "call-record-card";
					card.dataset.recordId = record.id;

					// 获取通话对象的名字
					const chatInfo = state.chats[record.chatId];
					const chatName = chatInfo ? chatInfo.name : "未知会话";

					const callDate = new Date(record.timestamp);
					const dateString = `${callDate.getFullYear()}-${String(callDate.getMonth() + 1).padStart(2, "0")}-${String(callDate.getDate()).padStart(2, "0")} ${String(callDate.getHours()).padStart(2, "0")}:${String(callDate.getMinutes()).padStart(2, "0")}`;
					const durationText = `${Math.floor(record.duration / 60)}分${record.duration % 60}秒`;

					const avatarsHtml = record.participants.map((p) => `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`).join("");

					card.innerHTML = `
                        <div class="card-header">
                            <span class="date">${dateString}</span>
                            <span class="duration">${durationText}</span>
                        </div>
                        <div class="card-body">
                            <!-- 在这里新增一个标题行 -->
                            ${record.customName ? `<div class="custom-title">${record.customName}</div>` : ""}
                            
                            <div class="participants-info"> <!-- 新增一个容器方便布局 -->
                                <div class="participants-avatars">${avatarsHtml}</div>
                                <span class="participants-names">与 ${chatName}</span>
                            </div>
                        </div>
                    `;
					return card;
				}

				/**
				 * 显示指定通话记录的完整文字稿
				 * @param {number} recordId - 通话记录的ID
				 */
				async function showCallTranscript(recordId) {
					const record = await db.callRecords.get(recordId);
					if (!record) return;

					const modal = document.getElementById("call-transcript-modal");
					const titleEl = document.getElementById("transcript-modal-title");
					const bodyEl = document.getElementById("transcript-modal-body");

					titleEl.textContent = `通话于 ${new Date(record.timestamp).toLocaleString()} (时长: ${Math.floor(record.duration / 60)}分${record.duration % 60}秒)`;
					bodyEl.innerHTML = "";

					if (!record.transcript || record.transcript.length === 0) {
						bodyEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">这次通话没有留下文字记录。</p>';
					} else {
						record.transcript.forEach((entry) => {
							const bubble = document.createElement("div");
							// 根据角色添加不同的class，应用不同的样式
							bubble.className = `transcript-entry ${entry.role}`;
							bubble.textContent = entry.content;
							bodyEl.appendChild(bubble);
						});
					}

					const deleteBtn = document.getElementById("delete-transcript-btn");

					// 使用克隆节点技巧，防止事件重复绑定
					const newDeleteBtn = deleteBtn.cloneNode(true);
					deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);

					// 为新的、干净的按钮绑定事件
					newDeleteBtn.addEventListener("click", async () => {
						const confirmed = await showCustomConfirm("确认删除", "确定要永久删除这条通话记录吗？此操作不可恢复。", { confirmButtonClass: "btn-danger" });

						if (confirmed) {
							// 1. 关闭当前的详情弹窗
							modal.classList.remove("visible");

							// 2. 从数据库删除
							await db.callRecords.delete(recordId);

							// 3. 刷新通话记录列表
							await renderCallHistoryScreen();

							// 4. (可选) 给出成功提示
							alert("通话记录已删除。");
						}
					});
					modal.classList.add("visible");
				}

				/**
				 * 处理用户点击状态栏，弹出编辑框让用户修改AI的当前状态
				 */
				async function handleEditStatusClick() {
					// 安全检查，确保在单聊界面
					if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
						return;
					}
					const chat = state.chats[state.activeChatId];

					// 弹出输入框，让用户输入新的状态，并将当前状态作为默认值
					const newStatusText = await showCustomPrompt(
						"编辑对方状态",
						"请输入对方现在的新状态：",
						chat.status.text // 将当前状态作为输入框的默认内容
					);

					// 如果用户输入了内容并点击了"确定"
					if (newStatusText !== null) {
						// 更新内存和数据库中的状态数据
						chat.status.text = newStatusText.trim() || "在线"; // 如果用户清空了，就默认为"在线"
						chat.status.isBusy = false; // 每次手动编辑都默认其不处于"忙碌"状态
						chat.status.lastUpdate = Date.now();
						await db.chats.put(chat);

						// 立刻刷新UI，让用户看到修改后的状态
						renderChatInterface(state.activeChatId);
						renderChatList();

						// 给出一个无伤大雅的成功提示
						await showCustomAlert("状态已更新", `"${chat.name}"的当前状态已更新为：${chat.status.text}`);
					}
				}

				/**
				 * 打开分享目标选择器
				 */
				async function openShareTargetPicker() {
					const modal = document.getElementById("share-target-modal");
					const listEl = document.getElementById("share-target-list");
					listEl.innerHTML = "";

					// 获取所有聊天作为分享目标
					const chats = Object.values(state.chats);

					chats.forEach((chat) => {
						// 复用联系人选择器的样式
						const item = document.createElement("div");
						item.className = "contact-picker-item";
						item.innerHTML = `
                            <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
                            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
                            <span class="name">${chat.name}</span>
                        `;
						listEl.appendChild(item);
					});

					modal.classList.add("visible");
				}

				/**
				 * 带动画关闭音乐播放器
				 * @param {Function} callback - 关闭完成后的回调函数
				 */
				function closeMusicPlayerWithAnimation(callback) {
					const overlay = document.getElementById("music-player-overlay");
					if (!overlay.classList.contains("visible")) {
						if (callback) callback();
						return;
					}
					overlay.classList.remove("visible");
					setTimeout(() => {
						document.getElementById("music-playlist-panel").classList.remove("visible");
						if (callback) callback();
					}, 400);
				}

				/**
				 * 解析LRC歌词文件内容
				 * @param {string} lrcContent - LRC歌词文件内容
				 * @returns {Array} - 解析后的歌词数组
				 */
				function parseLRC(lrcContent) {
					if (!lrcContent) return [];
					const lines = lrcContent.split("\n");
					const lyrics = [];
					const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;

					for (const line of lines) {
						const text = line.replace(timeRegex, "").trim();
						if (!text) continue;
						timeRegex.lastIndex = 0;
						let match;
						while ((match = timeRegex.exec(line)) !== null) {
							const minutes = parseInt(match[1], 10);
							const seconds = parseInt(match[2], 10);
							const milliseconds = parseInt(match[3].padEnd(3, "0"), 10);
							const time = minutes * 60 + seconds + milliseconds / 1000;
							lyrics.push({ time, text });
						}
					}
					return lyrics.sort((a, b) => a.time - b.time);
				}

				/**
				 * 渲染歌词到界面
				 */
				function renderLyrics() {
					const lyricsList = document.getElementById("music-lyrics-list");
					lyricsList.innerHTML = "";
					if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
						lyricsList.innerHTML = '<div class="lyric-line">♪ 暂无歌词 ♪</div>';
						return;
					}
					musicState.parsedLyrics.forEach((line, index) => {
						const lineEl = document.createElement("div");
						lineEl.className = "lyric-line";
						lineEl.textContent = line.text;
						lineEl.dataset.index = index;
						lyricsList.appendChild(lineEl);
					});
					lyricsList.style.transform = `translateY(0px)`;
				}

				/**
				 * 更新当前激活的歌词行
				 * @param {number} currentTime - 当前播放时间
				 */
				function updateActiveLyric(currentTime) {
					if (musicState.parsedLyrics.length === 0) return;
					let newLyricIndex = -1;
					for (let i = 0; i < musicState.parsedLyrics.length; i++) {
						if (currentTime >= musicState.parsedLyrics[i].time) {
							newLyricIndex = i;
						} else {
							break;
						}
					}
					if (newLyricIndex === musicState.currentLyricIndex) return;
					musicState.currentLyricIndex = newLyricIndex;
					updateLyricsUI();
				}

				/**
				 * 更新歌词界面显示
				 */
				function updateLyricsUI() {
					const lyricsList = document.getElementById("music-lyrics-list");
					const container = document.getElementById("music-lyrics-container");
					const lines = lyricsList.querySelectorAll(".lyric-line");
					lines.forEach((line) => line.classList.remove("active"));
					if (musicState.currentLyricIndex === -1) {
						lyricsList.style.transform = `translateY(0px)`;
						return;
					}
					const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${musicState.currentLyricIndex}"]`);
					if (activeLine) {
						activeLine.classList.add("active");
						const containerHeight = container.offsetHeight;
						const offset = containerHeight / 3 - activeLine.offsetTop - activeLine.offsetHeight / 2;
						lyricsList.style.transform = `translateY(${offset}px)`;
					}

					// 同步歌词到悬浮栏
					const floatingLyricText = document.getElementById("floating-lyric-text");
					if (activeLine) {
						floatingLyricText.textContent = activeLine.textContent;
					} else if (musicState.parsedLyrics.length > 0) {
						floatingLyricText.textContent = "♪ ♪ ♪"; // 歌曲前奏
					} else {
						floatingLyricText.textContent = "♪ 暂无歌词 ♪";
					}
				}

				/**
				 * 格式化音乐播放时间
				 * @param {number} seconds - 秒数
				 * @returns {string} - 格式化后的时间字符串
				 */
				function formatMusicTime(seconds) {
					if (isNaN(seconds) || seconds < 0) return "0:00";
					const minutes = Math.floor(seconds / 60);
					const remainingSeconds = Math.floor(seconds % 60);
					return `${minutes}:${String(remainingSeconds).padStart(2, "0")}`;
				}

				/**
				 * 更新音乐播放进度条
				 */
				function updateMusicProgressBar() {
					const currentTimeEl = document.getElementById("music-current-time");
					const totalTimeEl = document.getElementById("music-total-time");
					const progressFillEl = document.getElementById("music-progress-fill");
					if (!audioPlayer.duration) {
						currentTimeEl.textContent = "0:00";
						totalTimeEl.textContent = "0:00";
						progressFillEl.style.width = "0%";
						return;
					}
					const progressPercent = (audioPlayer.currentTime / audioPlayer.duration) * 100;
					progressFillEl.style.width = `${progressPercent}%`;
					currentTimeEl.textContent = formatMusicTime(audioPlayer.currentTime);
					totalTimeEl.textContent = formatMusicTime(audioPlayer.duration);
					updateActiveLyric(audioPlayer.currentTime);
				}

				/**
				 * 处理用户点击"撤回"按钮的入口函数
				 */
				async function handleRecallClick() {
					if (!activeMessageTimestamp) return;

					const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // 设置2分钟的撤回时限
					const messageTime = activeMessageTimestamp;
					const now = Date.now();

					// 检查是否超过了撤回时限
					if (now - messageTime > RECALL_TIME_LIMIT_MS) {
						hideMessageActions();
						await showCustomAlert("操作失败", "该消息发送已超过2分钟，无法撤回。");
						return;
					}

					// 如果在时限内，执行真正的撤回逻辑
					await recallMessage(messageTime, true);
					hideMessageActions();
				}

				/**
				 * 消息撤回的核心逻辑
				 * @param {number} timestamp - 要撤回的消息的时间戳
				 * @param {boolean} isUserRecall - 是否是用户主动撤回
				 */
				async function recallMessage(timestamp, isUserRecall) {
					const chat = state.chats[state.activeChatId];
					if (!chat) return;

					const messageIndex = chat.history.findIndex((m) => m.timestamp === timestamp);
					if (messageIndex === -1) return;

					const messageToRecall = chat.history[messageIndex];

					// 修改消息对象，将其变为"已撤回"状态
					const recalledData = {
						originalType: messageToRecall.type || "text",
						originalContent: messageToRecall.content,
						// 保存其他可能存在的原始数据
						originalMeaning: messageToRecall.meaning,
						originalQuote: messageToRecall.quote,
					};

					messageToRecall.type = "recalled_message";
					messageToRecall.content = isUserRecall ? "你撤回了一条消息" : "对方撤回了一条消息";
					messageToRecall.recalledData = recalledData;
					// 清理掉不再需要的旧属性
					delete messageToRecall.meaning;
					delete messageToRecall.quote;

					// 如果是用户撤回，需要给AI发送一条它看不懂内容的隐藏提示
					if (isUserRecall) {
						const hiddenMessageForAI = {
							role: "system",
							content: `[系统提示：用户撤回了一条消息。你不知道内容是什么，只需知道这个事件即可。]`,
							timestamp: Date.now(),
							isHidden: true,
						};
						chat.history.push(hiddenMessageForAI);
					}

					// 保存到数据库并刷新UI
					await db.chats.put(chat);
					renderChatInterface(state.activeChatId);
					if (isUserRecall) renderChatList(); // 用户撤回时，最后一条消息变了，需要刷新列表
				}

				/**
				 * 打开分类管理模态框
				 */
				async function openCategoryManager() {
					await renderCategoryListInManager();
					document.getElementById("world-book-category-manager-modal").classList.add("visible");
				}

				/**
				 * 在模态框中渲染已存在的分类列表
				 */
				async function renderCategoryListInManager() {
					const listEl = document.getElementById("existing-categories-list");
					const categories = await db.worldBookCategories.toArray();
					listEl.innerHTML = "";
					if (categories.length === 0) {
						listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
					}
					categories.forEach((cat) => {
						// 复用好友分组的样式
						const item = document.createElement("div");
						item.className = "existing-group-item";
						item.innerHTML = `
                            <span class="group-name">${cat.name}</span>
                            <span class="delete-group-btn" data-id="${cat.id}">×</span>
                        `;
						listEl.appendChild(item);
					});
				}

				/**
				 * 添加一个新的世界书分类
				 */
				async function addNewCategory() {
					const input = document.getElementById("new-category-name-input");
					const name = input.value.trim();
					if (!name) {
						alert("分类名不能为空！");
						return;
					}
					const existing = await db.worldBookCategories.where("name").equals(name).first();
					if (existing) {
						alert(`分类 "${name}" 已经存在了！`);
						return;
					}
					await db.worldBookCategories.add({ name });
					input.value = "";
					await renderCategoryListInManager();
				}

				/**
				 * 删除一个世界书分类
				 * @param {number} categoryId - 要删除的分类的ID
				 */
				async function deleteCategory(categoryId) {
					const confirmed = await showCustomConfirm("确认删除", "删除分类后，该分类下的所有世界书将变为'未分类'。确定要删除吗？", { confirmButtonClass: "btn-danger" });
					if (confirmed) {
						await db.worldBookCategories.delete(categoryId);
						// 将属于该分类的世界书的 categoryId 设为 null
						const booksToUpdate = await db.worldBooks.where("categoryId").equals(categoryId).toArray();
						for (const book of booksToUpdate) {
							book.categoryId = null;
							await db.worldBooks.put(book);
							const bookInState = state.worldBooks.find((wb) => wb.id === book.id);
							if (bookInState) bookInState.categoryId = null;
						}
						await renderCategoryListInManager();
					}
				}
				/**
				 * 打开NPC库管理界面
				 */
				function openNpcManager() {
					if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;
					const chat = state.chats[state.activeChatId];
					document.getElementById("npc-management-title").textContent = `“${chat.name}”的NPC库`;
					renderNpcList();
					showScreen("npc-management-screen");
				}

				/**
				 * 渲染NPC列表
				 */
				function renderNpcList() {
					const listEl = document.getElementById("npc-management-list");
					const chat = state.chats[state.activeChatId];
					const npcLibrary = chat.npcLibrary || [];
					listEl.innerHTML = "";

					if (npcLibrary.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">这里空空如也，点击右上角"+"添加第一个NPC吧！</p>';
						return;
					}

					npcLibrary.forEach((npc) => {
						// 复用聊天列表的样式，非常方便
						const item = document.createElement("div");
						item.className = "chat-list-item";
						item.style.cursor = "pointer";
						item.innerHTML = `
                            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
                            <div class="info">
                                <span class="name">${npc.name}</span>
                                <div class="last-msg">${npc.persona.substring(0, 30)}...</div>
                            </div>
                        `;
						// 点击编辑
						item.addEventListener("click", () => openNpcEditor(npc.id));
						// 长按删除
						addLongPressListener(item, () => deleteNpc(npc.id, npc.name));
						listEl.appendChild(item);
					});
				}

				/**
				 * 打开NPC编辑器
				 * @param {string|null} npcId - 要编辑的NPC ID，如果为null则表示新建
				 */
				async function openNpcEditor(npcId = null) {
					editingNpcId = npcId;
					// 使用正确的 state.activeChatId 来获取当前聊天对象
					const chat = state.chats[state.activeChatId];
					if (!chat) return; // 安全检查

					let npc = { name: "", persona: "", avatar: defaultGroupMemberAvatar };

					if (npcId) {
						// 从正确的 chat.npcLibrary 中查找数据
						npc = (chat.npcLibrary || []).find((n) => n.id === npcId) || npc;
						document.getElementById("persona-editor-title").textContent = `编辑NPC: ${npc.name}`;
					} else {
						document.getElementById("persona-editor-title").textContent = "添加新NPC";
					}

					// 填充编辑器内容
					document.getElementById("npc-editor-name-input").value = npc.name;
					document.getElementById("preset-avatar-preview").src = npc.avatar;
					document.getElementById("preset-persona-input").value = npc.persona;

					// 根据NPC模式，显隐特定UI元素
					document.getElementById("npc-editor-name-group").style.display = "block";
					document.getElementById("persona-editor-change-frame-btn").style.display = "none";

					// 绑定正确的保存函数
					document.getElementById("save-persona-preset-btn").onclick = saveNpc;

					// 最后才显示弹窗
					document.getElementById("persona-editor-modal").classList.add("visible");
				}

				/**
				 * 保存NPC（新建或更新）
				 */
				async function saveNpc() {
					const chat = state.chats[state.activeChatId];

					// 从编辑器中获取所有数据
					const name = document.getElementById("npc-editor-name-input").value.trim();
					const persona = document.getElementById("preset-persona-input").value.trim();
					const avatar = document.getElementById("preset-avatar-preview").src;

					if (!name) {
						alert("NPC名字不能为空！");
						return;
					}

					if (editingNpcId) {
						// 更新现有的NPC
						const npc = chat.npcLibrary.find((n) => n.id === editingNpcId);
						if (npc) {
							npc.name = name;
							npc.persona = persona;
							npc.avatar = avatar;
						}
					} else {
						// 添加一个全新的NPC
						const newNpc = {
							id: "npc_" + Date.now(),
							name: name,
							persona: persona,
							avatar: avatar,
						};
						chat.npcLibrary.push(newNpc);
					}

					await db.chats.put(chat);
					renderNpcList();
					closePersonaEditor(); // 复用关闭编辑器的函数
				}

				/**
				 * 删除一个NPC
				 * @param {string} npcId - 要删除的NPC的ID
				 * @param {string} npcName - 要删除的NPC的名字，用于确认提示
				 */
				async function deleteNpc(npcId, npcName) {
					const confirmed = await showCustomConfirm("删除NPC", `确定要从"${state.chats[state.activeChatId].name}"的NPC库中删除 "${npcName}" 吗？`, { confirmButtonClass: "btn-danger" });

					if (confirmed) {
						const chat = state.chats[state.activeChatId];
						chat.npcLibrary = chat.npcLibrary.filter((n) => n.id !== npcId);
						await db.chats.put(chat);
						renderNpcList();
					}
				}

				/**
				 * 打开头像框管理器
				 */
				function openFrameManager() {
					renderFrameManager();
					document.getElementById("custom-frame-manager-modal").classList.add("visible");
				}

				/**
				 * 渲染头像框管理器
				 */
				async function renderFrameManager() {
					const grid = document.getElementById("custom-frame-grid");
					grid.innerHTML = "";
					const customFrames = await db.customAvatarFrames.toArray();
					if (customFrames.length === 0) {
						grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">你还没有上传过头像框哦~</p>';
						return;
					}
					customFrames.forEach((frame) => {
						const item = document.createElement("div");
						// 复用表情面板的样式，很方便
						item.className = "sticker-item";
						item.style.backgroundImage = `url(${frame.url})`;
						item.title = frame.name;

						const deleteBtn = document.createElement("div");
						deleteBtn.className = "delete-btn";
						deleteBtn.innerHTML = "×";
						deleteBtn.style.display = "block";
						deleteBtn.onclick = async (e) => {
							e.stopPropagation();
							const confirmed = await showCustomConfirm("删除头像框", `确定要删除"${frame.name}"吗？`, { confirmButtonClass: "btn-danger" });
							if (confirmed) {
								await db.customAvatarFrames.delete(frame.id);
								renderFrameManager(); // 刷新管理列表
							}
						};
						item.appendChild(deleteBtn);
						grid.appendChild(item);
					});
				}

				/**
				 * 处理用户上传自定义头像框的逻辑
				 */
				function handleUploadCustomFrame() {
					document.getElementById("custom-frame-upload-input").addEventListener(
						"change",
						async (event) => {
							const files = event.target.files;
							if (!files.length) return;

							const newFrames = [];

							// 使用 for...of 循环来逐个处理选中的文件
							for (const file of files) {
								// 自动生成名字，而不是让用户输入
								// 我们用 "文件名 (前8位) + 时间戳" 来确保名字几乎不会重复
								const fileName = file.name.replace(/\.[^/.]+$/, "").substring(0, 8);
								const autoName = `${fileName}_${Date.now()}`;

								const base64Url = await new Promise((resolve) => {
									const reader = new FileReader();
									reader.onload = (e) => resolve(e.target.result);
									reader.readAsDataURL(file);
								});

								newFrames.push({
									id: "frame_" + (Date.now() + newFrames.length), // 确保ID唯一
									name: autoName,
									url: base64Url,
								});
							}

							// 循环结束后，批量添加到数据库
							if (newFrames.length > 0) {
								await db.customAvatarFrames.bulkAdd(newFrames);
								renderFrameManager(); // 刷新管理列表
								await showCustomAlert("上传成功", `已成功添加 ${newFrames.length} 个新头像框！`);
							}

							// 清空文件选择器的值
							event.target.value = null;
						},
						{ once: true }
					);

					document.getElementById("custom-frame-upload-input").click();
				}

				/**
				 * 打开头像框选择器模态框
				 * @param {string} type - 选择器类型
				 * @param {string|null} targetId - 目标ID（用于群成员）
				 */
				async function openFrameSelectorModal(type, targetId = null) {
					const grid = document.getElementById("avatar-frame-grid");
					grid.innerHTML = "";

					currentFrameSelection.type = type;
					currentFrameSelection.target = targetId;

					const chat = state.chats[state.activeChatId];
					let currentFrameUrl = "";
					let previewAvatarUrl = "";

					// 如果是为"角色微博"换框
					if (type === "char-weibo") {
						const charChat = state.chats[currentViewingWeiboProfileId];
						currentFrameUrl = charChat.settings.weiboAvatarFrame || "";
						previewAvatarUrl = charChat.settings.weiboAvatar || defaultAvatar;
					} else if (type === "home_profile") {
						currentFrameUrl = state.globalSettings.homeAvatarFrame || "";
						previewAvatarUrl = document.getElementById("profile-avatar-img").src;
					} else if (type === "weibo_profile") {
						currentFrameUrl = state.qzoneSettings.weiboAvatarFrame || "";
						previewAvatarUrl = state.qzoneSettings.weiboAvatar || defaultAvatar;
					} else if (type === "ai") {
						currentFrameUrl = chat.settings.aiAvatarFrame || "";
						previewAvatarUrl = chat.settings.aiAvatar || defaultAvatar;
					} else if (type === "my") {
						currentFrameUrl = chat.settings.myAvatarFrame || "";
						previewAvatarUrl = chat.settings.myAvatar || defaultAvatar;
					} else if (type === "member" && targetId) {
						const member = chat.members.find((m) => m.id === targetId);
						if (member) {
							currentFrameUrl = member.avatarFrame || "";
							previewAvatarUrl = member.avatar || defaultGroupMemberAvatar;
						}
					}

					// 后续渲染逻辑保持不变
					const customFrames = await db.customAvatarFrames.toArray();
					const frameUrlSet = new Set();
					const allFrames = [...avatarFrames, ...customFrames].filter((frame) => {
						if (!frame.url || !frameUrlSet.has(frame.url)) {
							frameUrlSet.add(frame.url);
							return true;
						}
						return false;
					});

					allFrames.forEach((frame) => {
						const item = createFrameItem(frame, previewAvatarUrl);
						if (currentFrameUrl === frame.url) {
							item.classList.add("selected");
							currentFrameSelection.url = frame.url;
						}
						grid.appendChild(item);
					});

					document.getElementById("avatar-frame-modal").classList.add("visible");
				}

				/**
				 * 创建一个头像框选项
				 * @param {object} frame - 头像框对象
				 * @param {string} previewAvatarSrc - 预览头像URL
				 * @returns {HTMLElement} - 创建的DOM元素
				 */
				function createFrameItem(frame, previewAvatarSrc) {
					const item = document.createElement("div");
					item.className = "frame-item";
					item.title = frame.name;
					item.innerHTML = `
                        <img src="${previewAvatarSrc}" class="preview-avatar">
                        ${frame.url ? `<img src="${frame.url}" class="preview-frame" style="pointer-events: none;">` : ""}
                    `;
					item.addEventListener("click", () => {
						document.querySelectorAll("#avatar-frame-grid .frame-item").forEach((el) => el.classList.remove("selected"));
						item.classList.add("selected");
						currentFrameSelection.url = frame.url;
					});
					return item;
				}

				/**
				 * 保存选中的头像框
				 */
				async function saveSelectedFrames() {
					const { type, url, target } = currentFrameSelection;

					// 对于不属于"角色设置"的功能 (比如主屏幕、微博)，保持原有的立即保存逻辑
					if (type === "char-weibo") {
						const charChat = state.chats[currentViewingWeiboProfileId];
						if (charChat) {
							charChat.settings.weiboAvatarFrame = url;
							await db.chats.put(charChat);
							await renderWeiboCharProfile(currentViewingWeiboProfileId);
						}
					} else if (type === "home_profile") {
						if (!state.globalSettings) state.globalSettings = {};
						state.globalSettings.homeAvatarFrame = url;
						await db.globalSettings.put(state.globalSettings);
						renderHomeScreenProfileFrame();
					} else if (type === "weibo_profile") {
						if (!state.qzoneSettings) state.qzoneSettings = {};
						state.qzoneSettings.weiboAvatarFrame = url;
						await saveQzoneSettings();
						await renderWeiboProfile();
					}
					// 对于"角色设置"里的头像框，我们不再立即保存，只在内存中更新
					else {
						const chat = state.chats[state.activeChatId];
						if (!chat) return; // 安全检查

						if (type === "ai") {
							chat.settings.aiAvatarFrame = url;
						} else if (type === "my") {
							chat.settings.myAvatarFrame = url;
						} else if (type === "member" && target) {
							const member = chat.members.find((m) => m.id === target);
							if (member) member.avatarFrame = url;
						}

						// 数据将在用户点击角色设置主面板的"保存"按钮时，与其他所有设置一起被保存。
						console.log(`头像框选择已暂存: type=${type}, url=${url}`);
					}

					// 只需关闭头像框选择弹窗即可，不做其他多余操作
					document.getElementById("avatar-frame-modal").classList.remove("visible");
				}

				/**
				 * 检查两个时间戳是否在不同的自然日
				 * @param {number} timestamp1 - 新消息的时间戳
				 * @param {number | null} timestamp2 - 上一条消息的时间戳
				 * @returns {boolean} - 如果是新的一天，返回 true
				 */
				function isNewDay(timestamp1, timestamp2) {
					// 如果没有上一条消息的时间戳，说明这是第一条消息，肯定要显示日期
					if (!timestamp2) return true;

					const date1 = new Date(timestamp1);
					const date2 = new Date(timestamp2);

					// 比较年、月、日是否完全相同
					return date1.getFullYear() !== date2.getFullYear() || date1.getMonth() !== date2.getMonth() || date1.getDate() !== date2.getDate();
				}

				/**
				 * 将时间戳格式化为 "X月X日 HH:mm" 的形式
				 * @param {number} timestamp - 时间戳
				 * @returns {string} - 格式化后的日期字符串
				 */
				function formatDateStamp(timestamp) {
					const date = new Date(timestamp);
					const month = date.getMonth() + 1;
					const day = date.getDate();
					const hours = String(date.getHours()).padStart(2, "0");
					const minutes = String(date.getMinutes()).padStart(2, "0");
					return `${month}月${day}日 ${hours}:${minutes}`;
				}

				/**
				 * 根据时间戳，格式化聊天列表右侧的日期/时间显示
				 * @param {number} timestamp - 消息的时间戳
				 * @returns {string} - 格式化后的字符串 (例如 "14:30", "昨天", "08/03")
				 */
				function formatChatListTimestamp(timestamp) {
					if (!timestamp) return ""; // 如果没有时间戳，返回空字符串

					const now = new Date();
					const msgDate = new Date(timestamp);

					// 判断是否为今天
					const isToday = now.getFullYear() === msgDate.getFullYear() && now.getMonth() === msgDate.getMonth() && now.getDate() === msgDate.getDate();

					if (isToday) {
						// 如果是今天，只显示时间
						return msgDate.toLocaleTimeString("zh-CN", { hour: "2-digit", minute: "2-digit" });
					}

					// 判断是否为昨天
					const yesterday = new Date();
					yesterday.setDate(now.getDate() - 1);
					const isYesterday = yesterday.getFullYear() === msgDate.getFullYear() && yesterday.getMonth() === msgDate.getMonth() && yesterday.getDate() === msgDate.getDate();

					if (isYesterday) {
						return "昨天";
					}

					// 判断是否为今年
					if (now.getFullYear() === msgDate.getFullYear()) {
						// 如果是今年，显示 "月/日"
						const month = String(msgDate.getMonth() + 1).padStart(2, "0");
						const day = String(msgDate.getDate()).padStart(2, "0");
						return `${month}/${day}`;
					}

					// 如果是更早的年份，显示 "年/月/日"
					const year = msgDate.getFullYear();
					const month = String(msgDate.getMonth() + 1).padStart(2, "0");
					const day = String(msgDate.getDate()).padStart(2, "0");
					return `${year}/${month}/${day}`;
				}

				/**
				 * 创建一个功能完整的日期戳"伪消息"元素
				 * @param {number} timestamp - 该日期戳代表的时间
				 * @returns {HTMLElement} - 创建好的 DOM 元素
				 */
				function createDateStampElement(timestamp) {
					// 1. 创建最外层的包裹 div，和真实消息一样
					const wrapper = document.createElement("div");
					wrapper.className = "message-wrapper date-stamp-wrapper";
					// 把时间戳存起来，这是多选和删除的关键
					wrapper.dataset.timestamp = timestamp;

					// 2. 创建气泡 div
					const bubble = document.createElement("div");
					// 同时加上 .message-bubble 类，让多选逻辑能找到它
					bubble.className = "message-bubble date-stamp-bubble";
					bubble.dataset.timestamp = timestamp;
					bubble.textContent = formatDateStamp(timestamp);

					wrapper.appendChild(bubble);

					// 3. 为它绑定和真实消息完全一样的事件监听器
					addLongPressListener(wrapper, () => {
						// 日期戳不支持复杂操作，长按直接进入多选
						enterSelectionMode(timestamp);
					});
					wrapper.addEventListener("click", () => {
						if (isSelectionMode) {
							toggleMessageSelection(timestamp);
						}
					});

					return wrapper;
				}

				// --- 美化功能的核心变量 ---
				let activeThemeId = null; // 用于追踪当前正在编辑的主题ID

				/**
				 * 将CSS代码应用到页面上
				 * @param {string} cssCode - 要应用的CSS代码字符串
				 */
				function applyThemeCss(cssCode) {
					const styleTag = document.getElementById("custom-theme-style");
					if (styleTag) {
						styleTag.innerHTML = cssCode || "";
					}
				}

				/**
				 * 从数据库加载所有主题到下拉选择框
				 */
				async function loadThemesToDropdown() {
					const selector = document.getElementById("theme-selector");
					selector.innerHTML = '<option value="">-- 选择方案或新建 --</option>'; // 默认选项

					const themes = await db.themes.toArray();
					themes.forEach((theme) => {
						const option = document.createElement("option");
						option.value = theme.id;
						option.textContent = theme.name;
						selector.appendChild(option);
					});
				}

				/**
				 * 处理用户从下拉框选择一个主题的逻辑
				 */
				async function handleThemeSelection() {
					const selector = document.getElementById("theme-selector");
					const editor = document.getElementById("theme-css-editor");
					activeThemeId = selector.value ? parseInt(selector.value) : null;

					if (activeThemeId) {
						const theme = await db.themes.get(activeThemeId);
						editor.value = theme.css;
					} else {
						// 如果选择"--"，就加载模板
						editor.value = THEME_CSS_TEMPLATE;
					}
					// 立即应用选中的或模板代码，让用户看到效果
					applyThemeCss(editor.value);
				}

				/**
				 * 保存当前编辑区的内容到当前选中的主题
				 */
				async function saveCurrentTheme() {
					if (!activeThemeId) {
						alert("请先选择一个方案，或使用'另存为'来创建新方案。");
						return;
					}
					const cssCode = document.getElementById("theme-css-editor").value;
					await db.themes.update(activeThemeId, { css: cssCode });
					alert("当前方案已保存！");
				}

				/**
				 * 将当前编辑区的内容另存为一个新主题
				 */
				async function saveAsNewTheme() {
					const themeName = await showCustomPrompt("保存新方案", "请输入新方案的名称");
					if (!themeName || !themeName.trim()) {
						if (themeName !== null) alert("方案名称不能为空！");
						return;
					}
					const cssCode = document.getElementById("theme-css-editor").value;
					const newTheme = { name: themeName.trim(), css: cssCode };
					const newId = await db.themes.add(newTheme);

					// 刷新下拉框并自动选中新保存的方案
					await loadThemesToDropdown();
					document.getElementById("theme-selector").value = newId;
					activeThemeId = newId;

					alert(`方案 "${themeName}" 已成功保存！`);
				}

				/**
				 * 重命名当前选中的主题
				 */
				async function renameSelectedTheme() {
					if (!activeThemeId) {
						alert("请先选择一个要重命名的方案。");
						return;
					}
					const currentTheme = await db.themes.get(activeThemeId);
					const newName = await showCustomPrompt("重命名方案", "请输入新的名称", currentTheme.name);
					if (newName && newName.trim()) {
						await db.themes.update(activeThemeId, { name: newName.trim() });
						await loadThemesToDropdown();
						document.getElementById("theme-selector").value = activeThemeId;
						alert("重命名成功！");
					}
				}

				/**
				 * 删除当前选中的主题
				 */
				async function deleteSelectedTheme() {
					if (!activeThemeId) {
						alert("请先选择一个要删除的方案。");
						return;
					}
					const confirmed = await showCustomConfirm("确认删除", `确定要删除方案 "${document.getElementById("theme-selector").selectedOptions[0].textContent}" 吗？`, { confirmButtonClass: "btn-danger" });
					if (confirmed) {
						await db.themes.delete(activeThemeId);
						activeThemeId = null;
						await loadThemesToDropdown();
						// 恢复到模板状态
						document.getElementById("theme-css-editor").value = THEME_CSS_TEMPLATE;
						applyThemeCss(THEME_CSS_TEMPLATE);
						alert("方案已删除。");
					}
				}

				/**
				 * 导出当前选中的主题为一个JSON文件
				 */
				async function exportTheme() {
					if (!activeThemeId) {
						alert("请先选择一个要导出的方案。");
						return;
					}
					const theme = await db.themes.get(activeThemeId);
					const exportData = {
						themeName: theme.name,
						themeCss: theme.css,
					};
					const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
					const url = URL.createObjectURL(blob);
					const a = document.createElement("a");
					a.href = url;
					a.download = `${theme.name}-Theme.json`;
					a.click();
					URL.revokeObjectURL(url);
				}

				/**
				 * 导入一个主题JSON文件
				 * @param {File} file - 要导入的文件
				 */
				function importTheme(file) {
					if (!file) return;
					const reader = new FileReader();
					reader.onload = async (e) => {
						try {
							const data = JSON.parse(e.target.result);
							if (data.themeName && typeof data.themeCss !== "undefined") {
								// 为了避免重名，导入时可以在名字后面加个 "(导入)"
								const newTheme = {
									name: `${data.themeName} (导入)`,
									css: data.themeCss,
								};
								const newId = await db.themes.add(newTheme);
								await loadThemesToDropdown();
								document.getElementById("theme-selector").value = newId;
								handleThemeSelection(); // 导入后自动选中并应用
								alert(`方案 "${newTheme.name}" 导入成功！`);
							} else {
								alert("导入失败：文件格式不正确。");
							}
						} catch (error) {
							alert(`导入失败：文件解析错误。 ${error.message}`);
						}
					};
					reader.readAsText(file);
				}

				/**
				 * 渲染并填充API预设的下拉选择框
				 */
				function renderApiPresetSelector() {
					const selectEl = document.getElementById("api-preset-select");
					if (!selectEl) return;

					selectEl.innerHTML = '<option value="">-- 自定义配置 --</option>';

					if (state.apiPresets) {
						state.apiPresets.forEach((preset) => {
							const option = document.createElement("option");
							option.value = preset.id;
							option.textContent = preset.name;
							selectEl.appendChild(option);
						});
					}

					// 检查当前配置是否匹配任何一个预设
					const { proxyUrl, apiKey } = state.apiConfig;
					const matchingPreset = state.apiPresets ? state.apiPresets.find((p) => p.proxyUrl === proxyUrl && p.apiKey === apiKey) : null;

					if (matchingPreset) {
						selectEl.value = matchingPreset.id;
					} else {
						selectEl.value = ""; // 如果不匹配任何预设，则选中"自定义配置"
					}
				}

				/**
				 * 当用户在下拉框中选择一个预设时触发
				 */
				function handleApiPresetSelectChange() {
					const selectEl = document.getElementById("api-preset-select");
					const proxyUrlInput = document.getElementById("proxy-url");
					const apiKeyInput = document.getElementById("api-key");
					const selectedId = parseInt(selectEl.value);

					if (selectedId && state.apiPresets) {
						const selectedPreset = state.apiPresets.find((p) => p.id === selectedId);
						if (selectedPreset) {
							proxyUrlInput.value = selectedPreset.proxyUrl;
							apiKeyInput.value = selectedPreset.apiKey;
						}
					}
				}

				/**
				 * 打开预设管理的操作菜单
				 */
				async function openApiPresetManager() {
					const selectEl = document.getElementById("api-preset-select");
					const selectedId = parseInt(selectEl.value);
					const selectedPreset = state.apiPresets ? state.apiPresets.find((p) => p.id === selectedId) : null;

					const modal = document.getElementById("preset-actions-modal");
					const footer = modal.querySelector(".custom-modal-footer");

					footer.innerHTML = `
                        <button id="preset-action-save-new">保存当前配置为新预设</button>
                        <button id="preset-action-update-current" ${!selectedPreset ? "disabled" : ""}>更新当前配置</button>
                        <button id="preset-action-delete-current" class="btn-danger" ${!selectedPreset ? "disabled" : ""}>删除当前配置</button>
                        <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
                    `;

					document.getElementById("preset-action-save-new").addEventListener("click", saveCurrentApiConfigAsPreset);
					if (selectedPreset) {
						document.getElementById("preset-action-update-current").addEventListener("click", () => updateSelectedApiPreset(selectedId));
						document.getElementById("preset-action-delete-current").addEventListener("click", () => deleteSelectedApiPreset(selectedId));
					}
					document.getElementById("preset-action-cancel").addEventListener("click", () => modal.classList.remove("visible"));

					modal.classList.add("visible");
				}

				/**
				 * 将当前输入框的内容保存为一个新的预设
				 */
				async function saveCurrentApiConfigAsPreset() {
					const proxyUrl = document.getElementById("proxy-url").value.trim();
					const apiKey = document.getElementById("api-key").value.trim();

					if (!proxyUrl || !apiKey) {
						alert("代理地址和密钥都不能为空！");
						return;
					}

					const name = await showCustomPrompt("保存API预设", "请为这个配置起个名字：");
					if (name && name.trim()) {
						const newPreset = { name: name.trim(), proxyUrl, apiKey };
						const newId = await db.apiPresets.add(newPreset);

						if (!state.apiPresets) state.apiPresets = [];
						state.apiPresets.push({ id: newId, ...newPreset });

						renderApiPresetSelector();
						document.getElementById("api-preset-select").value = newId;
						document.getElementById("preset-actions-modal").classList.remove("visible");
						await showCustomAlert("成功", `API预设 "${name.trim()}" 已保存！`);
					}
				}

				/**
				 * 更新当前选中的预设
				 * @param {number} presetId - 要更新的预设ID
				 */
				async function updateSelectedApiPreset(presetId) {
					const proxyUrl = document.getElementById("proxy-url").value.trim();
					const apiKey = document.getElementById("api-key").value.trim();

					if (!proxyUrl || !apiKey) {
						alert("代理地址和密钥都不能为空！");
						return;
					}

					const preset = state.apiPresets.find((p) => p.id === presetId);
					if (preset) {
						preset.proxyUrl = proxyUrl;
						preset.apiKey = apiKey;
						await db.apiPresets.put(preset);
						document.getElementById("preset-actions-modal").classList.remove("visible");
						await showCustomAlert("成功", `预设 "${preset.name}" 已更新！`);
					}
				}

				/**
				 * 删除当前选中的预设
				 * @param {number} presetId - 要删除的预设ID
				 */
				async function deleteSelectedApiPreset(presetId) {
					const preset = state.apiPresets.find((p) => p.id === presetId);
					if (preset) {
						const confirmed = await showCustomConfirm("确认删除", `确定要删除API预设 "${preset.name}" 吗？`, { confirmButtonClass: "btn-danger" });
						if (confirmed) {
							await db.apiPresets.delete(presetId);
							state.apiPresets = state.apiPresets.filter((p) => p.id !== presetId);

							renderApiPresetSelector();
							document.getElementById("preset-actions-modal").classList.remove("visible");
							await showCustomAlert("成功", "预设已删除。");
						}
					}
				}

				/**
				 * 渲染并填充气泡样式预设的下拉选择框
				 */
				function renderBubblePresetSelector() {
					const selectEl = document.getElementById("bubble-style-preset-select");
					const customCssInput = document.getElementById("custom-css-input");

					selectEl.innerHTML = '<option value="">-- 无预设 --</option>';

					if (state.bubbleStylePresets) {
						state.bubbleStylePresets.forEach((preset) => {
							const option = document.createElement("option");
							option.value = preset.id;
							option.textContent = preset.name;
							selectEl.appendChild(option);
						});
					}

					// 检查当前聊天的CSS是否匹配任何一个预设
					const currentCss = customCssInput.value.trim();
					const matchingPreset = state.bubbleStylePresets ? state.bubbleStylePresets.find((p) => p.css.trim() === currentCss) : null;

					if (matchingPreset) {
						selectEl.value = matchingPreset.id;
					} else {
						selectEl.value = ""; // 如果不匹配任何预设，则选中"无预设"
					}
				}

				/**
				 * 当用户在下拉框中选择一个预设时触发
				 */
				function handlePresetSelectChange() {
					const selectEl = document.getElementById("bubble-style-preset-select");
					const customCssInput = document.getElementById("custom-css-input");
					const selectedId = parseInt(selectEl.value);

					if (selectedId && state.bubbleStylePresets) {
						const selectedPreset = state.bubbleStylePresets.find((p) => p.id === selectedId);
						if (selectedPreset) {
							customCssInput.value = selectedPreset.css;
						}
					}
					updateSettingsPreview(); // 无论如何都更新预览
				}

				/**
				 * 打开预设管理的操作菜单
				 */
				async function openBubblePresetManager() {
					const selectEl = document.getElementById("bubble-style-preset-select");
					const selectedId = parseInt(selectEl.value);
					const selectedPreset = state.bubbleStylePresets ? state.bubbleStylePresets.find((p) => p.id === selectedId) : null;

					const modal = document.getElementById("preset-actions-modal"); // 复用现有模态框
					const footer = modal.querySelector(".custom-modal-footer");

					footer.innerHTML = `
                        <button id="preset-action-save-new">保存</button>
                        <button id="preset-action-update-current" ${!selectedPreset ? "disabled" : ""}>更新</button>
                        <button id="preset-action-delete-current" class="btn-danger" ${!selectedPreset ? "disabled" : ""}>删除</button>
                        <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
                    `;

					// 重新绑定事件
					document.getElementById("preset-action-save-new").addEventListener("click", saveCurrentCssAsPreset);
					if (selectedPreset) {
						document.getElementById("preset-action-update-current").addEventListener("click", () => updateSelectedPreset(selectedId));
						document.getElementById("preset-action-delete-current").addEventListener("click", () => deleteSelectedPreset(selectedId));
					}
					document.getElementById("preset-action-cancel").addEventListener("click", () => modal.classList.remove("visible"));

					modal.classList.add("visible");
				}

				/**
				 * 将当前CSS文本框的内容保存为一个新的预设
				 */
				async function saveCurrentCssAsPreset() {
					const customCssInput = document.getElementById("custom-css-input");
					const css = customCssInput.value.trim();
					if (!css) {
						alert("CSS内容不能为空！");
						return;
					}

					const name = await showCustomPrompt("保存预设", "请为这个气泡样式命名：");
					if (name && name.trim()) {
						const newPreset = { name: name.trim(), css: css };
						const newId = await db.bubbleStylePresets.add(newPreset);

						if (!state.bubbleStylePresets) state.bubbleStylePresets = [];
						state.bubbleStylePresets.push({ id: newId, ...newPreset });

						renderBubblePresetSelector();
						document.getElementById("bubble-style-preset-select").value = newId;
						document.getElementById("preset-actions-modal").classList.remove("visible");
						await showCustomAlert("成功", `预设 "${name.trim()}" 已保存！`);
					}
				}

				/**
				 * 更新当前选中的预设
				 * @param {number} presetId - 要更新的预设ID
				 */
				async function updateSelectedPreset(presetId) {
					const customCssInput = document.getElementById("custom-css-input");
					const css = customCssInput.value.trim();

					const preset = state.bubbleStylePresets.find((p) => p.id === presetId);
					if (preset) {
						preset.css = css;
						await db.bubbleStylePresets.put(preset);
						document.getElementById("preset-actions-modal").classList.remove("visible");
						await showCustomAlert("成功", `预设 "${preset.name}" 已更新！`);
					}
				}

				/**
				 * 删除当前选中的预设
				 * @param {number} presetId - 要删除的预设ID
				 */
				async function deleteSelectedPreset(presetId) {
					const preset = state.bubbleStylePresets.find((p) => p.id === presetId);
					if (preset) {
						const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${preset.name}" 吗？`, { confirmButtonClass: "btn-danger" });
						if (confirmed) {
							await db.bubbleStylePresets.delete(presetId);
							state.bubbleStylePresets = state.bubbleStylePresets.filter((p) => p.id !== presetId);

							renderBubblePresetSelector();
							document.getElementById("custom-css-input").value = "";
							updateSettingsPreview();

							document.getElementById("preset-actions-modal").classList.remove("visible");
							await showCustomAlert("成功", "预设已删除。");
						}
					}
				}

				/**
				 * 播放来电铃声
				 */
				function playRingtone() {
					const ringtonePlayer = document.getElementById("ringtone-player");
					// 优先使用用户在设置中保存的URL，如果没设置，就用我们预设的URL
					const ringtoneUrl = state.globalSettings.ringtoneUrl || "https://files.catbox.moe/3w7gla.mp3";

					if (ringtonePlayer && ringtoneUrl) {
						ringtonePlayer.src = ringtoneUrl;
						// play() 返回一个 Promise，我们最好用 try...catch 包裹以防止浏览器报错
						const playPromise = ringtonePlayer.play();
						if (playPromise !== undefined) {
							playPromise.catch((error) => {
								console.error("铃声播放失败:", error);
								// 可以在这里给用户一个静音提示，如果需要的话
							});
						}
					}
				}

				/**
				 * 停止并重置来电铃声
				 */
				function stopRingtone() {
					const ringtonePlayer = document.getElementById("ringtone-player");
					if (ringtonePlayer) {
						ringtonePlayer.pause();
						ringtonePlayer.currentTime = 0; // 将播放进度重置到开头
					}
				}

				/**
				 * 播放消息提示音，增加健壮性
				 */
				function playNotificationSound() {
					const soundUrl = state.globalSettings.notificationSoundUrl || "https://laddy-lulu.github.io/Ephone-stuffs/message.mp3";

					// 增加安全检查：如果链接为空，直接返回，不执行任何操作
					if (!soundUrl || !soundUrl.trim()) return;

					try {
						const audio = new Audio(soundUrl);
						audio.volume = 0.7;

						audio.play().catch((error) => {
							// 优化错误提示，现在能更准确地反映问题
							if (error.name === "NotAllowedError") {
								console.warn("播放消息提示音失败：用户需要先与页面进行一次交互（如点击）才能自动播放音频。");
							} else {
								// 对于其他错误（比如我们这次遇到的），直接打印错误详情
								console.error(`播放消息提示音失败 (${error.name}): ${error.message}`, "URL:", soundUrl);
							}
						});
					} catch (error) {
						console.error("创建提示音Audio对象时出错:", error);
					}
				}

				/**
				 * 音频上下文解锁函数（修复铃声无法自动播放的问题）
				 */
				function unlockAudioContext() {
					const ringtonePlayer = document.getElementById("ringtone-player");
					// 检查播放器是否处于暂停状态，并且我们之前没有成功播放过
					if (ringtonePlayer && ringtonePlayer.paused) {
						// 尝试播放，然后立刻暂停。
						// 这个操作对用户是无感知的，但能告诉浏览器用户已与音频交互。
						ringtonePlayer.play().catch(() => {}); // play() 会返回一个 Promise，我们忽略任何可能发生的错误
						ringtonePlayer.pause();
						console.log("Ringtone audio context unlocked.");
					}
				}

				/**
				 * 处理角色手机内数据删除的通用函数
				 * @param {string} dataType - 要删除的数据类型, 比如 'memos', 'shoppingCart'
				 * @param {number} index - 要删除的数据在数组中的索引
				 */
				async function handleCharacterDataDeletion(dataType, index) {
					if (!activeCharacterPhoneId) return;
					const chat = state.chats[activeCharacterPhoneId];

					let dataArray;
					// 处理像 bank.transactions 这样的嵌套数据
					if (dataType.includes(".")) {
						const keys = dataType.split(".");
						dataArray = chat.characterPhoneData[keys[0]][keys[1]];
					} else {
						dataArray = chat.characterPhoneData[dataType];
					}

					if (!chat || !dataArray) return;

					const itemToDelete = dataArray[index];
					if (!itemToDelete) return;

					const confirmed = await showCustomConfirm("确认删除", "确定要删除这条记录吗？", { confirmButtonClass: "btn-danger" });

					if (confirmed) {
						dataArray.splice(index, 1);
						await db.chats.put(chat);

						// 根据删除的类型，重新渲染对应的APP界面
						switch (dataType) {
							case "memos":
								renderCharacterMemos();
								break;
							case "shoppingCart":
								renderCharacterShoppingCart();
								break;
							case "browserHistory":
								renderCharacterBrowser();
								break;
							case "diary":
								renderCharacterDiary();
								break;
							case "bank.transactions":
								renderCharacterBank();
								break;
							case "trajectory":
								renderCharacterTrajectory();
								break;
							case "appUsage":
								renderCharacterAppUsage();
								break;
							case "photoAlbum":
								renderCharacterPhotoAlbum();
								break;
						}
						alert("记录已删除。");
					}
				}

				/**
				 * 处理角色手机内单条聊天消息的删除
				 * @param {string} contactName - 正在查看的联系人名称
				 * @param {number} index - 要删除的消息在历史记录中的索引
				 */
				async function handleCharacterChatMessageDeletion(contactName, index) {
					if (!activeCharacterPhoneId) return;
					const chat = state.chats[activeCharacterPhoneId];
					if (!chat) return;

					let historyArray;
					// 判断是和"我"的聊天还是和NPC的聊天
					if (contactName === (chat.characterPhoneData.chats["我"]?.remarkName || "我")) {
						historyArray = chat.history;
					} else {
						historyArray = chat.characterPhoneData.chats[contactName]?.history;
					}

					if (!historyArray || !historyArray[index]) return;

					const confirmed = await showCustomConfirm("确认删除", "确定要删除这条消息吗？", { confirmButtonClass: "btn-danger" });

					if (confirmed) {
						historyArray.splice(index, 1);
						await db.chats.put(chat);

						// 重新渲染当前聊天界面
						renderCharacterChatHistory(contactName);
						alert("消息已删除。");
					}
				}

				/**
				 * 应用锁屏壁纸到 #lock-screen 元素
				 */
				function applyLockscreenWallpaper() {
					const lockScreen = document.getElementById("lock-screen");
					const wallpaper = state.globalSettings.lockscreenWallpaper;
					if (wallpaper && wallpaper.startsWith("data:image")) {
						lockScreen.style.backgroundImage = `url(${wallpaper})`;
					} else if (wallpaper) {
						lockScreen.style.backgroundImage = wallpaper;
					}
				}

				/**
				 * 显示锁屏界面
				 */
				function lockPhone() {
					console.log("正在锁定手机...");
					isLocked = true;
					document.getElementById("lock-screen").classList.add("active");
					document.querySelectorAll(".screen:not(#lock-screen)").forEach((s) => s.classList.remove("active"));
				}

				/**
				 * 解锁手机，显示主屏幕
				 */
				function unlockPhone() {
					console.log("手机已解锁！");
					isLocked = false;
					// 在这里彻底隐藏锁屏和毛玻璃背景
					document.getElementById("lock-screen").classList.remove("active");
					const blurBg = document.getElementById("lock-screen-background-blur");
					blurBg.style.display = "none";
					blurBg.style.opacity = "0";

					// 确保主屏幕是唯一激活的顶层屏幕
					showScreen("home-screen");

					// 重置锁屏的样式，为下次锁定做准备
					setTimeout(() => {
						const lockScreen = document.getElementById("lock-screen");
						const unlockHint = document.getElementById("unlock-hint");
						lockScreen.style.transition = "none";
						unlockHint.style.transition = "none";
						lockScreen.style.transform = "translateY(0)";
						lockScreen.offsetHeight;
						lockScreen.style.transition = "transform 0.3s ease-out";
						unlockHint.style.transition = "opacity 0.3s ease-out";
					}, 500);
				}

				/**
				 * 显示密码输入弹窗
				 */
				function showPasswordModal() {
					const modal = document.getElementById("password-modal-overlay");
					const input = document.getElementById("password-input-field");
					input.value = ""; // 清空上次输入
					modal.classList.add("visible");
					setTimeout(() => input.focus(), 100); // 延迟聚焦，确保动画流畅
				}

				/**
				 * 隐藏密码输入弹窗
				 */
				function hidePasswordModal() {
					document.getElementById("password-modal-overlay").style.backgroundImage = "none";

					const modal = document.getElementById("password-modal-overlay");
					modal.classList.remove("visible");
					// 移除可能存在的错误动画类
					modal.querySelector(".password-modal-content").classList.remove("error");
					// 当取消输入密码时...
					// 1. 隐藏毛玻璃背景
					const blurBg = document.getElementById("lock-screen-background-blur");
					blurBg.style.opacity = "0";
					setTimeout(() => {
						blurBg.style.display = "none";
					}, 300); // 动画结束后再隐藏

					// 2. 让锁屏界面滑回来
					const lockScreen = document.getElementById("lock-screen");
					const unlockHint = document.getElementById("unlock-hint");
					lockScreen.style.transform = "translateY(0)";
					unlockHint.style.opacity = "1";
				}

				/**
				 * 检查用户输入的密码是否正确
				 */
				function checkPassword() {
					const input = document.getElementById("password-input-field");
					const enteredPassword = input.value;
					const correctPassword = state.globalSettings.password;

					if (enteredPassword === correctPassword) {
						// --- 密码正确 ---

						// 1. 提前把主屏幕在最底层激活并准备好！
						//    因为它 z-index 最低，所以你暂时还看不到它。
						showScreen("home-screen");

						// 2. 隐藏密码输入框 (它会自己播放淡出动画)
						document.getElementById("password-modal-overlay").classList.remove("visible");

						// 3. 让毛玻璃背景也开始淡出
						document.getElementById("lock-screen-background-blur").style.opacity = "0";

						// 4. 等待淡出动画播放完毕 (300毫秒)，再执行最终的清理工作
						setTimeout(unlockPhone, 300);
					} else {
						// --- 密码错误 (逻辑保持不变) ---
						const content = document.querySelector(".password-modal-content");
						content.classList.add("error");
						input.value = "";
						setTimeout(() => content.classList.remove("error"), 400);
					}
				}

				/**
				 * 更新锁屏界面的时钟
				 */
				function updateLockClock() {
					const now = new Date();
					const timeString = now.toLocaleTimeString("zh-CN", { hour: "2-digit", minute: "2-digit" });
					const dateString = now.toLocaleDateString("zh-CN", { weekday: "long", month: "long", day: "numeric" });
					document.getElementById("lock-main-time").textContent = timeString;
					document.getElementById("lock-main-date").textContent = dateString;
				}

				/**
				 * 批量添加表情包
				 */
				async function openBulkAddStickersModal() {
					const placeholder = `在这里粘贴表情包，每行一个，格式如下：\n\n猫猫喝水：https://..../cat.gif\n狗狗摇头：https://..../dog.png\n\n(支持用中文冒号"："、英文冒号":"或空格分隔)`;

					const textInput = await showCustomPrompt("批量添加表情(URL)", "一行一个，名称和链接用冒号或空格隔开", "", "textarea");

					if (!textInput || !textInput.trim()) {
						return;
					}

					const lines = textInput.trim().split("\n");
					const newStickers = [];
					let successCount = 0;
					let errorLines = [];

					lines.forEach((line, index) => {
						line = line.trim();
						if (!line) return;

						let name = "";
						let url = "";
						let splitIndex = -1;

						// 使用更智能的分割逻辑
						// 1. 查找 URL 的起始位置
						const httpIndex = line.indexOf("http");
						const dataIndex = line.indexOf("data:image");

						if (httpIndex > -1) {
							splitIndex = httpIndex;
						} else if (dataIndex > -1) {
							splitIndex = dataIndex;
						}

						// 2. 如果找到了 URL 的起始位置
						if (splitIndex > 0) {
							// URL 之前的所有内容都属于名称
							name = line.substring(0, splitIndex).trim();
							// 从 URL 起始位置到末尾的所有内容都属于 URL
							url = line.substring(splitIndex).trim();

							// 3. 清理名称末尾可能存在的分隔符
							if (name.endsWith(":") || name.endsWith("：")) {
								name = name.slice(0, -1).trim();
							}
						} else {
							// 如果找不到 URL，说明格式有问题
							errorLines.push(index + 1);
							return; // 跳过此行
						}

						if (name && (url.startsWith("http") || url.startsWith("data:image"))) {
							newStickers.push({
								id: "sticker_" + (Date.now() + index),
								url: url,
								name: name,
							});
							successCount++;
						} else {
							errorLines.push(index + 1);
						}
					});

					if (newStickers.length > 0) {
						await db.userStickers.bulkAdd(newStickers);
						state.userStickers.push(...newStickers);
						renderStickerPanel();
					}

					let reportMessage = `批量导入完成！\n\n成功导入：${successCount} 个表情。`;
					if (errorLines.length > 0) {
						reportMessage += `\n失败行号：${errorLines.join(", ")}。\n\n请检查这些行的格式是否正确。`;
					}
					await showCustomAlert("导入报告", reportMessage);
				}

				/**
				 * 根据距离文本，计算CSS宽度百分比
				 * @param {string} distanceText - 距离描述，例如 "500m", "10km", "很近"
				 * @returns {number} - 10到90之间的百分比
				 */
				function calculatePinDistancePercentage(distanceText) {
					if (!distanceText) return 50; // 默认值

					const text = distanceText.toLowerCase();
					// 提取数字部分
					const matches = text.match(/(\d+(\.\d+)?)/);
					const num = matches ? parseFloat(matches[1]) : 0;

					// 根据单位或关键词判断
					if (text.includes("km") || text.includes("公里")) {
						if (num > 1000) return 90;
						if (num > 100) return 80;
						if (num > 10) return 70;
						if (num > 1) return 60;
						return 50;
					} else if (text.includes("m") || text.includes("米")) {
						if (num > 500) return 40;
						if (num > 100) return 30;
						return 20;
					} else if (text.includes("远") || text.includes("不同城市")) {
						return 90;
					} else if (text.includes("附近") || text.includes("隔壁")) {
						return 20;
					} else if (text.includes("近")) {
						return 30;
					}

					return 15; // 如果无法识别，给一个最小的距离
				}

				/**
				 * 在定位模态框中添加一个途经点输入框
				 * @param {string} name - 途经点名称
				 */
				function addTrajectoryPointInput(name = "") {
					const container = document.getElementById("trajectory-points-container");
					const div = document.createElement("div");
					div.style.display = "flex";
					div.style.gap = "8px";
					div.innerHTML = `
                        <input type="text" class="trajectory-point-input" placeholder="途经点${container.children.length + 1}" value="${name}" style="flex-grow: 1;">
                        <button class="remove-option-btn">-</button>
                    `;
					div.querySelector(".remove-option-btn").addEventListener("click", () => div.remove());
					container.appendChild(div);
				}

				/**
				 * 发送用户位置信息
				 */
				async function sendUserLocation() {
					if (!state.activeChatId) return;

					const userLocation = document.getElementById("user-location-input").value.trim();
					const aiLocation = document.getElementById("ai-location-input").value.trim();
					const distance = document.getElementById("distance-input").value.trim();

					if (!distance || (!userLocation && !aiLocation)) {
						alert("我的位置和Ta的位置至少要填写一个，且相距为必填项！");
						return;
					}

					const trajectoryPoints = Array.from(document.querySelectorAll(".trajectory-point-input"))
						.map((input) => ({ name: input.value.trim() }))
						.filter((point) => point.name);

					const chat = state.chats[state.activeChatId];

					// 根据用户输入，构建一条AI能看懂的文本内容
					// 这个格式和AI自己发定位时用的格式保持一致
					let contentString = "[SEND_LOCATION]";
					if (userLocation) contentString += ` 我的位置: ${userLocation}`;
					if (aiLocation) contentString += ` | 你的位置: ${aiLocation}`;
					contentString += ` | 相距: ${distance}`;
					if (trajectoryPoints.length > 0) {
						const trajectoryText = trajectoryPoints.map((p) => p.name).join(", ");
						contentString += ` | 途经点: ${trajectoryText}`;
					}

					// 创建消息对象，这次我们把刚刚创建的 contentString 也放了进去
					const locationMessage = {
						role: "user",
						type: "location",
						timestamp: Date.now(),
						userLocation: userLocation,
						aiLocation: aiLocation,
						distance: distance,
						trajectoryPoints: trajectoryPoints,
						content: contentString, // <-- 这就是最关键的新增属性！
					};

					// 后续的保存和渲染逻辑保持不变
					chat.history.push(locationMessage);
					await db.chats.put(chat);
					appendMessage(locationMessage, chat);
					renderChatList();

					document.getElementById("send-location-modal").classList.remove("visible");
				}

				/**
				 * 智能查找AI上一轮回复的所有消息
				 * @param {Array} history - 完整的聊天历史记录
				 * @returns {Array} - 一个包含了上一轮AI所有消息对象的数组
				 */
				function findLastAiTurnMessages(history) {
					const turnMessages = [];
					let lastMessageIndex = history.length - 1;

					// 从最后一条消息开始，向前查找
					for (let i = lastMessageIndex; i >= 0; i--) {
						const message = history[i];

						// 如果是AI的消息，就把它加入我们的"待删除列表"
						if (message.role === "assistant") {
							turnMessages.unshift(message); // 使用 unshift 保持原始顺序
						}
						// 一旦遇到非AI的消息（用户的或系统的），说明AI的这一轮回复已经结束了，立刻停止查找
						else {
							break;
						}
					}
					return turnMessages;
				}

				/**
				 * "重roll"按钮被点击时的主处理函数
				 */
				async function handleRerollClick() {
					if (!state.activeChatId) return;
					const chat = state.chats[state.activeChatId];

					// 1. 调用我们的智能查找函数，找出需要删除的消息
					const messagesToReroll = findLastAiTurnMessages(chat.history);

					// 2. 如果没找到（比如最后一条是用户发的），就提示并退出
					if (messagesToReroll.length === 0) {
						alert("请在AI回复后使用此功能。");
						return;
					}

					// 3. 从聊天记录中过滤掉这些旧消息
					const timestampsToReroll = new Set(messagesToReroll.map((m) => m.timestamp));
					chat.history = chat.history.filter((msg) => !timestampsToReroll.has(msg.timestamp));

					// 4. 保存更新后的聊天记录到数据库
					await db.chats.put(chat);

					// 5. 刷新聊天界面，让旧消息瞬间消失
					renderChatInterface(state.activeChatId);

					// 6. 触发一次新的AI响应，就像用户点击了"等待回复"一样
					triggerAiResponse();
				}

				/**
				 * 初始化可拖动歌词栏功能
				 */
				function initDraggableLyricsBar() {
					const bar = document.getElementById("floating-lyrics-bar");
					const phoneScreen = document.getElementById("phone-screen");

					let isDragging = false;
					let offsetX, offsetY;

					const onDragStart = (e) => {
						// 检查点击的是否是按钮，如果是，则不开始拖动
						if (e.target.closest("#lyrics-settings-btn") || e.target.closest(".close-btn")) {
							return;
						}

						isDragging = true;
						bar.classList.add("dragging");

						const rect = bar.getBoundingClientRect();
						const coords = getEventCoords(e);

						offsetX = coords.x - rect.left;
						offsetY = coords.y - rect.top;

						document.addEventListener("mousemove", onDragMove);
						document.addEventListener("mouseup", onDragEnd);
						document.addEventListener("touchmove", onDragMove, { passive: false });
						document.addEventListener("touchend", onDragEnd);
					};

					const onDragMove = (e) => {
						if (!isDragging) return;

						e.preventDefault();

						const phoneRect = phoneScreen.getBoundingClientRect();
						const coords = getEventCoords(e);

						let newLeft = coords.x - offsetX - phoneRect.left;
						let newTop = coords.y - offsetY - phoneRect.top;

						const maxLeft = phoneScreen.clientWidth - bar.offsetWidth;
						const maxTop = phoneScreen.clientHeight - bar.offsetHeight;

						newLeft = Math.max(0, Math.min(newLeft, maxLeft));
						newTop = Math.max(0, Math.min(newTop, maxTop));

						// 在拖动时，同时设置left, top并清除transform
						bar.style.left = `${newLeft}px`;
						bar.style.top = `${newTop}px`;
						bar.style.transform = "none";
					};

					const onDragEnd = () => {
						if (!isDragging) return;
						isDragging = false;
						bar.classList.remove("dragging");

						document.removeEventListener("mousemove", onDragMove);
						document.removeEventListener("mouseup", onDragEnd);
						document.removeEventListener("touchmove", onDragMove);
						document.removeEventListener("touchend", onDragEnd);
					};

					bar.addEventListener("mousedown", onDragStart);
					bar.addEventListener("touchstart", onDragStart, { passive: true });
				}

				/**
				 * 应用歌词栏设置
				 */
				function applyLyricsSettings() {
					const bar = document.getElementById("floating-lyrics-bar");
					const toggleBtn = document.getElementById("toggle-lyrics-bar-btn");

					// 应用样式
					bar.style.fontSize = `${lyricsBarSettings.fontSize}px`;
					bar.style.color = lyricsBarSettings.fontColor;
					bar.style.backgroundColor = `rgba(0, 0, 0, ${lyricsBarSettings.bgOpacity / 100})`;

					// 更新设置模态框里的控件值
					document.getElementById("lyrics-font-size-slider").value = lyricsBarSettings.fontSize;
					document.getElementById("lyrics-font-size-value").textContent = `${lyricsBarSettings.fontSize}px`;
					document.getElementById("lyrics-bg-opacity-slider").value = lyricsBarSettings.bgOpacity;
					document.getElementById("lyrics-bg-opacity-value").textContent = `${lyricsBarSettings.bgOpacity}%`;
					document.getElementById("lyrics-font-color-picker").value = lyricsBarSettings.fontColor;

					// 更新播放器里的开关按钮状态
					if (toggleBtn) {
						toggleBtn.textContent = lyricsBarSettings.showOnClose ? "悬浮" : "隐藏";
						toggleBtn.style.opacity = lyricsBarSettings.showOnClose ? "1" : "0.5";
					}
				}

				/**
				 * 获取并格式化与当前聊天相关的倒计时约定信息
				 * @param {string} chatId - 当前正在聊天的角色ID
				 * @returns {Promise<string>} 格式化后的约定信息字符串
				 */
				async function getCountdownContext(chatId) {
					// 从数据库中查找所有未过期的倒计时约定，包括与当前角色相关的和全局约定
					const activeCountdowns = await db.memories
						.where("type")
						.equals("countdown")
						.filter((item) => item.targetDate > Date.now() && (item.chatId === chatId || item.chatId === null))
						.toArray();

					// 如果没有相关约定，返回提示信息
					if (activeCountdowns.length === 0) {
						return "\n- **近期约定**: 目前没有特别的约定。";
					}

					// 格式化倒计时信息
					let context = "\n# 近期约定与倒计时 (重要参考信息)\n";
					const now = Date.now();

					activeCountdowns.forEach((item) => {
						const diff = item.targetDate - now;
						const diffDays = Math.floor(diff / (1000 * 60 * 60 * 24));
						const diffHours = Math.floor(diff / (1000 * 60 * 60));

						let timeText;
						if (diffDays > 1) {
							timeText = `还有 ${diffDays} 天`;
						} else if (diffHours > 0) {
							timeText = `还有 ${diffHours} 小时`;
						} else {
							timeText = "就是现在！";
						}

						context += `- **${item.description}**: ${timeText} (目标: ${new Date(item.targetDate).toLocaleString()})\n`;
					});

					return context;
				}

				/**
				 * 打开角色选择界面
				 */
				async function openCharacterSelectionScreen() {
					await renderCharacterSelectionScreen();
					showScreen("character-selection-screen");
				}

				/**
				 * 渲染角色选择列表界面
				 */
				async function renderCharacterSelectionScreen() {
					const listEl = document.getElementById("character-selection-list");
					listEl.innerHTML = "";
					const characters = Object.values(state.chats).filter((chat) => !chat.isGroup);

					// 如果没有可查看的角色，显示提示信息
					if (characters.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">还没有可以查看的角色</p>';
						return;
					}

					// 为每个角色创建选择项
					characters.forEach((char) => {
						const item = document.createElement("div");
						item.className = "character-select-item";
						item.dataset.chatId = char.id;
						item.innerHTML = `
                            <img src="${char.settings.aiAvatar || defaultAvatar}" alt="${char.name}">
                            <span class="name">${char.name}</span>
                        `;
						listEl.appendChild(item);
					});
				}

				/**
				 * 应用角色手机的App内壁纸
				 */
				function applyCharPhoneAppWallpaper() {
					if (!activeCharacterPhoneId) return;
					const chat = state.chats[activeCharacterPhoneId];
					const innerScreen = document.querySelector(".character-phone-inner-screen");
					if (!innerScreen || !chat) return;

					const appWallpaperUrl = chat.characterPhoneData.appWallpaper;

					// 根据是否有壁纸URL设置背景
					if (appWallpaperUrl) {
						innerScreen.style.backgroundImage = `url(${appWallpaperUrl})`;
						innerScreen.classList.add("has-app-wallpaper");
					} else {
						innerScreen.style.backgroundImage = "none";
						innerScreen.classList.remove("has-app-wallpaper");
					}
				}

				/**
				 * 处理角色手机App内壁纸的更换和移除
				 * @param {string} newUrl - 新的壁纸URL，如果为空字符串则表示移除
				 */
				async function handleCharPhoneAppWallpaperChange(newUrl) {
					if (!activeCharacterPhoneId) return;
					const chat = state.chats[activeCharacterPhoneId];
					if (!chat) return;

					// 更新聊天数据中的壁纸URL
					chat.characterPhoneData.appWallpaper = newUrl;
					await db.chats.put(chat);

					// 立即应用壁纸并刷新设置页面预览
					applyCharPhoneAppWallpaper();
					renderCharPhoneAppearanceScreen();

					alert(newUrl ? "App 内壁纸已更新！" : "App 内壁纸已移除！");
				}

				/**
				 * 打开指定角色的手机界面
				 * @param {string} chatId - 角色聊天ID
				 */
				function openCharacterPhone(chatId) {
					activeCharacterPhoneId = chatId;
					const chat = state.chats[chatId];
					if (!chat) return;

					document.getElementById("character-phone-owner-name").textContent = `${chat.name}的手机`;

					const phoneHomeScreen = document.getElementById("character-phone-screen");
					const wallpaperUrl = chat.characterPhoneData.wallpaper;
					const isDarkMode = document.getElementById("phone-screen").classList.contains("dark-mode");

					// 设置手机壁纸
					if (wallpaperUrl) {
						phoneHomeScreen.style.backgroundImage = `url(${wallpaperUrl})`;
						phoneHomeScreen.style.backgroundColor = "transparent";
						phoneHomeScreen.style.backgroundSize = "cover";
						phoneHomeScreen.style.backgroundPosition = "center";
					} else {
						phoneHomeScreen.style.backgroundImage = "none";
						phoneHomeScreen.style.backgroundColor = isDarkMode ? "#000000" : "#f0f2f5";
					}

					// 渲染桌面小组件图片
					const widgets = chat.characterPhoneData.widgets || {};
					document.getElementById("char-phone-widget-img-1").src = widgets.widget1_url || "";
					document.getElementById("char-phone-widget-img-2").src = widgets.widget2_url || "";

					// 渲染应用网格并显示手机界面
					renderCharacterAppGrid();
					showScreen("character-phone-container");
					showCharacterPhonePage("character-phone-screen");
					applyCharPhoneAppWallpaper();
				}

				/**
				 * 渲染角色手机应用网格
				 */
				function renderCharacterAppGrid() {
					const gridEl = document.getElementById("character-app-grid");
					gridEl.innerHTML = "";
					if (!activeCharacterPhoneId) return;

					const chat = state.chats[activeCharacterPhoneId];
					const customIcons = chat.characterPhoneData.appIcons || {};

					// 为每个应用创建图标元素
					CHAR_PHONE_APPS.forEach((app) => {
						const iconEl = document.createElement("div");
						iconEl.className = "app-icon";

						const customIconUrl = customIcons[app.id];

						// 根据是否有自定义图标设置不同的显示样式
						let iconBgStyle = "display: flex; justify-content: center; align-items: center; padding: 12px;";
						let iconHtml;

						if (customIconUrl) {
							// 使用自定义图标
							iconBgStyle = "padding: 0; background-color: transparent;";
							iconHtml = `<img src="${customIconUrl}" style="width:100%; height:100%; object-fit:cover; border-radius: 18px;">`;
						} else {
							// 使用默认SVG图标
							iconHtml = app.svg;
						}

						iconEl.innerHTML = `
                            <div class="icon-bg" style="${iconBgStyle}">
                                ${iconHtml}
                            </div>
                            <span class="label">${app.name}</span>
                        `;

						// 添加点击事件处理
						iconEl.addEventListener("click", () => {
							if (app.id === "appearance") {
								openCharPhoneAppearanceSettings();
							} else {
								switch (app.id) {
									case "chat":
										renderCharacterChatList();
										break;
									case "cart":
										renderCharacterShoppingCart();
										break;
									case "memos":
										renderCharacterMemos();
										break;
									case "browser":
										renderCharacterBrowser();
										break;
									case "album":
										renderCharacterPhotoAlbum();
										break;
									case "bank":
										renderCharacterBank();
										break;
									case "trajectory":
										renderCharacterTrajectory();
										break;
									case "app_usage":
										renderCharacterAppUsage();
										break;
									case "diary":
										renderCharacterDiary();
										break;
								}
								showCharacterPhonePage(app.screen);
							}
						});
						gridEl.appendChild(iconEl);
					});
				}

				/**
				 * 为"查手机"功能生成某一项数据
				 * @param {string} dataType - 要生成的数据类型 (例如: 'diary', 'chats', 'shoppingCart')
				 */
				async function generateCharacterPhoneDataSegment(dataType) {
					if (!activeCharacterPhoneId) return;
					const chat = state.chats[activeCharacterPhoneId];
					if (!chat) return;

					// 定义各种数据类型的生成描述和JSON结构
					const dataTypeMap = {
						chats: {
							description: `2到5段你与【不同的】NPC朋友们的【全新的、接续上文的】聊天记录。`,
							jsonStructure: `"chats": [\n    {\n      "contactName": "【NPC朋友A的名字】",\n      "messages": [\n        {"sender": "【联系人名A】", "content": "消息内容1..."},\n        {"sender": "${chat.name}", "content": "你的回复1..."}\n      ]\n    },\n    {\n      "contactName": "【NPC朋友B的名字】",\n      "messages": [\n        {"sender": "【联系人名B】", "content": "消息内容1..."},\n        {"sender": "${chat.name}", "content": "你的回复1..."}\n      ]\n    }\n  ]`,
						},
						shoppingCart: {
							description: "3到5件你最近加入购物车的新商品。",
							jsonStructure: `"shoppingCart": [\n    {"name": "商品名1", "price": 123.45, "store": "店铺名"},\n    {"name": "商品名2", "price": 67.89, "store": "店铺名"}\n  ]`,
						},
						memos: {
							description: "2到3篇你新写的简短备忘录。",
							jsonStructure: `"memos": [\n    {"title": "备忘录标题1", "content": "备忘录详细内容1..."},\n    {"title": "备忘录标题2", "content": "备忘录详细内容2..."}\n  ]`,
						},
						browserHistory: {
							description: "2到3条你最近的浏览器搜索记录或浏览的文章。",
							jsonStructure: `"browserHistory": [\n    {"query": "搜索标题1", "result": "模拟文章内容1..."},\n    {"query": "搜索标题2", "result": "模拟文章内容2..."}\n  ]`,
						},
						photoAlbum: {
							description: "2到3张你“拍摄”的新照片的文字描述（用于文字生图）。",
							jsonStructure: `"photoAlbum": [\n    {"hiddenContent": "对新照片画面1的详细文字描述..."},\n    {"hiddenContent": "对新照片画面2的详细文字描述..."}\n  ]`,
						},
						bank: {
							description: "3到5条你最近的银行交易记录（收入或支出）。",
							jsonStructure: `"bank": {\n    "transactions": [\n      {"type": "收入或支出", "amount": 123.45, "description": "交易描述1"},\n      {"type": "收入或支出", "amount": 67.89, "description": "交易描述2"}\n    ]\n  }`,
						},
						trajectory: {
							description: "2到3条你最近的行动轨迹记录。",
							jsonStructure: `"trajectory": [\n    {"time": "时间段1", "location": "地点1", "activity": "干了什么事1"},\n    {"time": "时间段2", "location": "地点2", "activity": "干了什么事2"}\n  ]`,
						},
						appUsage: {
							description: "3到5条你最近的应用使用记录。",
							jsonStructure: `"appUsage": [\n    {"appName": "应用名1", "duration": "使用时长1"},\n    {"appName": "应用名2", "duration": "使用时长2"}\n  ]`,
						},
						diary: {
							description: `一篇全新的日记。`,
							jsonStructure: `"diary": [\n    {"timestamp": ${Date.now()}, "content": "【用Markdown语法写一篇符合人设和情景的新日记】"}\n  ]`,
						},
					};

					const dataTypeInfo = dataTypeMap[dataType];
					if (!dataTypeInfo) {
						console.error("请求了无效的数据生成类型:", dataType);
						return;
					}

					// 根据是否已有交易记录调整银行数据的生成描述
					let finalDataTypeInfo = { ...dataTypeInfo };

					if (dataType === "bank") {
						const hasExistingTransactions = chat.characterPhoneData?.bank?.transactions?.length > 0;

						if (!hasExistingTransactions) {
							// 第一次生成银行数据，要求提供初始余额
							finalDataTypeInfo.description = "一个符合你人设的【初始银行余额】，以及3到5条初始交易记录。";
							finalDataTypeInfo.jsonStructure = `"bank": {\n    "balance": 12345.67,\n    "transactions": [\n      {"type": "收入或支出", "amount": 123.45, "description": "交易描述1"}\n    ]\n  }`;
						} else {
							// 后续生成，提供当前余额作为参考
							const currentBalance = (chat.characterPhoneData.bank.balance || 0).toFixed(2);
							finalDataTypeInfo.description = `3到5条【全新的】银行交易记录（收入或支出）。【提示：你当前的余额是 ${currentBalance} 元，请在此基础上生成合理的交易】`;
							finalDataTypeInfo.jsonStructure = `"bank": {\n    "transactions": [\n      {"type": "收入或支出", "amount": 123.45, "description": "交易描述1"}\n    ]\n  }`;
						}
					}

					document.getElementById("generation-overlay").classList.add("visible");

					try {
						const userNickname = state.qzoneSettings.nickname || "我";
						const persona = (chat.settings.aiPersona || "").substring(0, 4000);
						const maxMemory = chat.settings.maxMemory || 20;
						const recentHistory = chat.history
							.slice(-maxMemory)
							.map((msg) => {
								const sender = msg.role === "user" ? userNickname : chat.name;
								return `${sender}: ${msg.content}`;
							})
							.join("\n");

						// 添加记忆互通的聊天记录作为参考
						let linkedMemoryContext = "";
						if (chat.settings.linkedMemories && chat.settings.linkedMemories.length > 0) {
							const contextPromises = chat.settings.linkedMemories.map(async (link) => {
								const linkedChat = state.chats[link.chatId];
								if (!linkedChat) return "";

								const freshLinkedChat = await db.chats.get(link.chatId);
								if (!freshLinkedChat) return "";

								const recentHistory = freshLinkedChat.history.filter((msg) => !msg.isHidden).slice(-link.depth);

								if (recentHistory.length === 0) return "";

								const formattedMessages = recentHistory.map((msg) => `  - ${formatMessageForContext(msg, freshLinkedChat)}`).join("\n");

								return `\n## 附加上下文：来自与“${linkedChat.name}”的最近对话内容 (仅你可见)\n${formattedMessages}`;
							});

							const allContexts = await Promise.all(contextPromises);
							linkedMemoryContext = allContexts.filter(Boolean).join("\n");
						}

						// 构建世界观上下文
						let worldBookContext = "";
						if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
							worldBookContext =
								"--- 世界观设定 (必须严格遵守) ---\n" +
								chat.settings.linkedWorldBookIds
									.map((id) => {
										const book = state.worldBooks.find((b) => b.id === id);
										return book ? `[${book.name}]: ${book.content}` : "";
									})
									.join("\n\n");
						}

						// 构建NPC好友列表上下文
						const npcLibrary = chat.npcLibrary || [];
						let npcContext = "";
						if (npcLibrary.length > 0) {
							npcContext = "# 你的专属NPC好友列表 (你必须从中随机选择2-3位朋友进行对话)\n" + "这些人是你的好朋友，你和他们非常熟悉。请根据他们的人设，生成符合你们关系的、自然的聊天记录。\n" + npcLibrary.map((npc) => `- **${npc.name}**: ${npc.persona}`).join("\n");
						} else {
							npcContext = "# 你的专属NPC好友列表\n(你当前没有专属NPC，请虚构2-3个普通朋友并生成对话)";
						}

						// 构建已有聊天记录摘要
						let npcChatHistoryContext = "";
						const existingNpcChats = Object.entries(chat.characterPhoneData.chats || {}).filter(([name, chatData]) => chatData.history && chatData.history.length > 0);
						if (existingNpcChats.length > 0) {
							npcChatHistoryContext += "\n\n# 已有的聊天记录摘要 (请在此基础上继续对话)\n";
							existingNpcChats.forEach(([contactName, chatData]) => {
								const recentMessages = chatData.history
									.slice(-5)
									.map((msg) => `  - ${msg.sender}: ${msg.content}`)
									.join("\n");
								npcChatHistoryContext += `\n## 你和“${contactName}”的最近对话:\n${recentMessages}\n`;
							});
						}

						// 构建提示词
						const prompt = `
                # 任务
                你现在是角色 "${chat.name}"。请根据你的信息和最近的聊天记录，【只生成一项】你手机中的新数据。
                具体任务是：生成${finalDataTypeInfo.description}

                # 【【【情景一致性铁律】】】
                你生成的所有数据（尤其是"trajectory"行动轨迹）**必须**与"最近聊天记录摘要"中提到的最新情景保持绝对一致。
                当生成 "bank" 数据时，你的交易记录【绝对不能】包含与用户("${userNickname}")的转账或收款。所有交易都应是你与其他NPC或商家的。
                # 【【【绝对禁止事项】】】
                在生成 "chats" 数据时，**绝对不允许**让用户（${userNickname}）出现在你与其他NPC的对话中。

                # 【【【重要指令：关于聊天记录生成】】】
                - 你正在续写这段对话。你提供的聊天记录是上下文，你【绝对不能】重复或改写其中的任何内容。你的生成必须从【全新的、下一条】消息开始。
                - 如果"你的专属NPC好友列表"不为空，你【必须】为列表中的【每一个NPC】都生成一段与你（${chat.name}）的对话。
                - 如果列表为空，你可以虚构2-3个普通朋友并生成对话。
                - 你必须为每个联系人生成一段【至少包含5条消息】的对话。
                - 对话内容应该自然流畅，可以包含连续发言、表情包和表情符号等，以体现真实感。
                - 不要只生成一问一答的机械式对话。
                -   **【【【绝对禁止重复铁律】】】**: 你生成的 "messages" 数组中，【绝对不能】包含我提供给你的上下文里的任何一条消息。你的第一条消息必须是对话历史中最后一条消息的【下一条】。
                # 你的信息
                - 你的名字: ${chat.name}
                - 你的人设: ${persona}
                ${worldBookContext}
                # 和${userNickname}的最近聊天记录摘要
                ${recentHistory}
                ${npcContext}
                ${npcChatHistoryContext}

                # JSON输出格式 (必须严格遵守，只包含你被要求的那个键)
                {
                ${finalDataTypeInfo.jsonStructure}
                }
                `;

						// 发送API请求
						const { proxyUrl, apiKey, model } = state.apiConfig;
						let isGemini = proxyUrl === GEMINI_API_URL;
						let geminiConfig = toGeminiRequestData(model, apiKey, prompt, [{ role: "user", content: prompt }], isGemini);

						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({
										model: model,
										messages: [{ role: "user", content: prompt }],
										temperature: parseFloat(state.apiConfig.temperature) || 0.8,
										response_format: { type: "json_object" },
									}),
							  });

						if (!response.ok) {
							let errorMsg = `API请求失败: ${response.status} - ${await response.text()}`;
							throw new Error(errorMsg);
						}

						// 处理API响应
						const data = await response.json();
						const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, "");

						const newData = JSON.parse(aiResponseContent);

						let phoneData = chat.characterPhoneData;
						phoneData.lastGenerated = Date.now();
						let updateSuccess = false;

						// 根据数据类型更新手机数据
						if (newData && newData[dataType]) {
							if (dataType === "bank" && newData.bank.transactions) {
								if (!phoneData.bank) phoneData.bank = { balance: 0, transactions: [] };
								if (typeof phoneData.bank.balance !== "number") phoneData.bank.balance = 0;
								(newData.bank.transactions || []).forEach((transaction) => {
									const amount = parseFloat(transaction.amount);
									if (!isNaN(amount)) {
										if (transaction.type === "收入") phoneData.bank.balance += amount;
										else if (transaction.type === "支出") phoneData.bank.balance -= amount;
									}
								});
								phoneData.bank.transactions.push(...(newData.bank.transactions || []));
								if (typeof newData.bank.balance === "number") {
									phoneData.bank.balance = newData.bank.balance;
								}
								updateSuccess = true;
							} else if (dataType === "chats" && newData.chats) {
								newData.chats.forEach((newChat) => {
									if (!newChat.messages) return;
									const contactName = newChat.contactName;
									if (phoneData.chats[contactName] && phoneData.chats[contactName].history) {
										phoneData.chats[contactName].history.push(...newChat.messages);
									} else {
										phoneData.chats[contactName] = {
											avatar: newChat.avatar,
											history: newChat.messages,
										};
									}
								});
								updateSuccess = true;
							} else if (dataType === "appUsage" && Array.isArray(newData.appUsage)) {
								const usageMap = new Map();
								(phoneData.appUsage || []).forEach((item) => {
									usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
								});
								newData.appUsage.forEach((item) => {
									usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
								});
								const mergedUsage = [];
								for (const [appName, totalMinutes] of usageMap.entries()) {
									mergedUsage.push({ appName: appName, duration: formatMinutesToDuration(totalMinutes) });
								}
								phoneData.appUsage = mergedUsage;
								updateSuccess = true;
							} else if (Array.isArray(phoneData[dataType])) {
								phoneData[dataType].push(...(newData[dataType] || []));
								updateSuccess = true;
							}
						}

						if (!updateSuccess) {
							throw new Error(`AI返回的JSON中缺少'${dataType}'字段或格式不正确。`);
						}

						await db.chats.put(chat);
						alert(`"${chat.name}"的${dataTypeMap[dataType].description.split("。")[0]}已更新！`);

						// 根据数据类型刷新对应界面
						switch (dataType) {
							case "chats":
								renderCharacterChatList();
								break;
							case "shoppingCart":
								renderCharacterShoppingCart();
								break;
							case "memos":
								renderCharacterMemos();
								break;
							case "browserHistory":
								renderCharacterBrowser();
								break;
							case "photoAlbum":
								renderCharacterPhotoAlbum();
								break;
							case "bank":
								renderCharacterBank();
								break;
							case "trajectory":
								renderCharacterTrajectory();
								break;
							case "appUsage":
								renderCharacterAppUsage();
								break;
							case "diary":
								renderCharacterDiary();
								break;
						}
					} catch (error) {
						console.error(`生成角色手机数据(${dataType})失败:`, error);
						await showCustomAlert("生成失败", `发生了一个错误：\n\n${error.message}`);
					} finally {
						document.getElementById("generation-overlay").classList.remove("visible");
					}
				}

				/**
				 * 处理角色手机各个APP页面数据清空功能
				 * @param {string} dataType - 要清空的数据类型
				 */
				async function handleClearCharacterDataSegment(dataType) {
					if (!activeCharacterPhoneId) return;
					const chat = state.chats[activeCharacterPhoneId];
					if (!chat) return;

					// 定义各种数据类型的名称和数据键
					const dataTypeMap = {
						chats: { name: "NPC聊天记录", dataKey: "chats" },
						shoppingCart: { name: "购物车", dataKey: "shoppingCart" },
						memos: { name: "备忘录", dataKey: "memos" },
						browserHistory: { name: "浏览器历史", dataKey: "browserHistory" },
						photoAlbum: { name: "相册", dataKey: "photoAlbum" },
						"bank.transactions": { name: "交易记录", dataKey: "bank" },
						trajectory: { name: "足迹", dataKey: "trajectory" },
						appUsage: { name: "使用记录", dataKey: "appUsage" },
						diary: { name: "日记", dataKey: "diary" },
					};

					const info = dataTypeMap[dataType];
					if (!info) {
						console.error("未知的清空数据类型:", dataType);
						return;
					}

					// 确认是否清空数据
					const confirmed = await showCustomConfirm(`确认清空`, `确定要清空"${chat.name}"手机里的所有【${info.name}】吗？此操作不可恢复。`, { confirmButtonClass: "btn-danger" });

					if (!confirmed) return;

					try {
						// 根据数据类型执行不同的清空逻辑
						if (dataType === "chats") {
							// 清空所有NPC聊天（不包括和user的）
							chat.characterPhoneData.chats = {};
						} else if (dataType === "bank.transactions") {
							// 清空银行交易记录，并将余额归零
							if (chat.characterPhoneData.bank) {
								chat.characterPhoneData.bank.transactions = [];
								chat.characterPhoneData.bank.balance = 0;
							}
						} else if (chat.characterPhoneData[info.dataKey]) {
							// 通用处理：清空数组
							chat.characterPhoneData[info.dataKey] = [];
						}

						// 保存到数据库
						await db.chats.put(chat);

						// 根据数据类型刷新对应界面
						switch (dataType) {
							case "chats":
								renderCharacterChatList();
								break;
							case "shoppingCart":
								renderCharacterShoppingCart();
								break;
							case "memos":
								renderCharacterMemos();
								break;
							case "browserHistory":
								renderCharacterBrowser();
								break;
							case "photoAlbum":
								renderCharacterPhotoAlbum();
								break;
							case "bank.transactions":
								renderCharacterBank();
								break;
							case "trajectory":
								renderCharacterTrajectory();
								break;
							case "appUsage":
								renderCharacterAppUsage();
								break;
							case "diary":
								renderCharacterDiary();
								break;
						}

						alert(`已成功清空所有${info.name}。`);
					} catch (error) {
						console.error(`清空 ${info.name} 时出错:`, error);
						await showCustomAlert("操作失败", `清空时发生错误: ${error.message}`);
					}
				}

				/**
				 * 生成角色手机完整数据
				 */
				async function generateCharacterPhoneData() {
					if (!activeCharacterPhoneId) return;
					const chat = state.chats[activeCharacterPhoneId];
					if (!chat) return;

					document.getElementById("generation-overlay").classList.add("visible");

					try {
						const userNickname = state.qzoneSettings.nickname || "我";

						// 限制人设长度防止请求过长
						const persona = (chat.settings.aiPersona || "").substring(0, 4000);

						// 获取最近20条聊天记录作为上下文
						const recentHistory = chat.history
							.slice(-20)
							.map((msg) => {
								const sender = msg.role === "user" ? userNickname : chat.name;
								return `${sender}: ${msg.content}`;
							})
							.join("\n");

						// 添加记忆互通的聊天记录作为参考
						let linkedMemoryContext = "";
						if (chat.settings.linkedMemories && chat.settings.linkedMemories.length > 0) {
							const contextPromises = chat.settings.linkedMemories.map(async (link) => {
								const linkedChat = state.chats[link.chatId];
								if (!linkedChat) return "";

								const freshLinkedChat = await db.chats.get(link.chatId);
								if (!freshLinkedChat) return "";

								const recentHistory = freshLinkedChat.history.filter((msg) => !msg.isHidden).slice(-link.depth);

								if (recentHistory.length === 0) return "";

								const formattedMessages = recentHistory.map((msg) => `  - ${formatMessageForContext(msg, freshLinkedChat)}`).join("\n");

								return `\n## 附加上下文：来自与"${linkedChat.name}"的最近对话内容 (仅你可见)\n${formattedMessages}`;
							});

							const allContexts = await Promise.all(contextPromises);
							linkedMemoryContext = allContexts.filter(Boolean).join("\n");
						}

						// 构建世界观上下文
						let worldBookContext = "";
						if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
							worldBookContext =
								"--- 世界观设定 (必须严格遵守) ---\n" +
								chat.settings.linkedWorldBookIds
									.map((id) => {
										const book = state.worldBooks.find((b) => b.id === id);
										return book ? `[${book.name}]: ${book.content}` : "";
									})
									.join("\n\n");
						}

						// 构建NPC好友列表上下文
						const npcLibrary = chat.npcLibrary || [];
						let npcContext = "";
						if (npcLibrary.length > 0) {
							npcContext = '# 你的专属NPC好友列表 (你必须在下方"chats"中为他们生成对话)\n' + "这些人是你的好朋友，你和他们非常熟悉。请根据他们的人设，生成符合你们关系的、自然的聊天记录。\n" + npcLibrary.map((npc) => `- **${npc.name}**: ${npc.persona}`).join("\n");
						} else {
							npcContext = "# 你的专属NPC好友列表\n(你没有专属NPC，请虚构一些普通朋友)";
						}

						// 构建已有聊天记录摘要
						let npcChatHistoryContext = "";
						const existingNpcChats = Object.entries(chat.characterPhoneData.chats || {}).filter(([name, chatData]) => chatData.history && chatData.history.length > 0);

						if (existingNpcChats.length > 0) {
							npcChatHistoryContext += "\n\n# 已有的聊天记录摘要 (请在此基础上继续对话)\n";
							existingNpcChats.forEach(([contactName, chatData]) => {
								const recentMessages = chatData.history
									.slice(-5)
									.map((msg) => `  - ${msg.sender}: ${msg.content}`)
									.join("\n");
								npcChatHistoryContext += `\n## 你和"${contactName}"的最近对话:\n${recentMessages}\n`;
							});
						}

						// 构建提示词
						const prompt = `
                # 任务
                【【【情景一致性铁律】】】：你生成的所有数据（尤其是"trajectory"行动轨迹）**必须**与"最近聊天记录摘要"中提到的最新情景保持绝对一致。如果聊天记录显示你正在上课，你的行动轨迹就必须是在教室；如果聊天记录显示你在咖啡馆，你的行动轨迹就必须是咖啡馆。**绝对不能**仅凭你的人设就生成与聊天记录相矛盾的内容。
                你现在是角色 "${chat.name}"。请根据你的人设、世界观、NPC好友列表以及和${userNickname}的最近聊天记录，模拟生成你手机中的各项数据。你需要一次性生成所有数据，并严格按照下面的JSON格式返回。

                # 【【【绝对禁止事项：这是必须遵守的安全红线】】】
                1.  在生成JSON数据，特别是chats字段时，**绝对不允许**创建另一个用户（${userNickname}）的虚拟形象或让他/她出现在你与其他NPC的对话中。
                2.  "bank" 字段中的交易记录【绝对不能】涉及用户("${userNickname}")。所有交易都必须是你与其他NPC、商家或因某些事件（如购物、收到工资）产生的。
                3.  chats字段中，与NPC或朋友的聊天记录，其sender或content**绝对不能**包含${userNickname}的名字或代称。
                4.  所有你生成的聊天对话，都必须严格限制在【你(${chat.name})】和【另一位NPC/朋友】这**两个人之间**。**严禁**出现任何形式的第三者，尤其是${userNickname}。

                # 你的信息
                - 你的名字: ${chat.name}
                - 你的人设: ${persona}
                ${worldBookContext}
                # 和${userNickname}的最近聊天记录摘要
                ${recentHistory}

                ${npcContext}
                ${npcChatHistoryContext}
                # JSON输出格式 (必须严格遵守，不要添加任何额外说明)
                {
                "chats": [
                    {
                    "contactName": "【这里填写你给${userNickname}的备注名】"
                    },
                    {
                    "contactName": "【这里必须填写上面NPC列表中的一个名字，或一个虚构朋友名】",
                    "messages": [
                        {"sender": "【联系人名，严禁填写'${userNickname}'】", "content": "消息内容1..."},
                        {"sender": "${chat.name}", "content": "你的回复1..."},
                        {"sender": "【联系人名，严禁填写'${userNickname}'】", "content": "消息内容2..."},
                        {"sender": "【联系人名，严禁填写'${userNickname}'】", "content": "消息内容3..."},
                        {"sender": "${chat.name}", "content": "你的回复2..."}
                    ]
                    }
                ],
                "shoppingCart": [
                    {"name": "商品名", "price": 价格, "store": "店铺名"}
                ],
                "memos": [
                    {"title": "备忘录标题", "content": "备忘录详细内容..."}
                ],
                "browserHistory": [
                    {"query": "搜索或浏览的标题", "result": "【这里是AI生成的、关于这个搜索标题的模拟文章或网页内容】"}
                ],
                "photoAlbum": [
                    {"hiddenContent": "对照片画面的详细文字描述"}
                ],
                "bank": {
                    "balance": 银行卡余额(数字),
                    "transactions": [
                    {"type": "收入或支出", "amount": 金额, "description": "交易描述"}
                    ]
                },
                "trajectory": [
                    {"time": "时间段", "location": "地点", "activity": "干了什么事"}
                ],
                "appUsage": [
                    {"appName": "应用名", "duration": "使用时长"}
                ],
                "diary": [
                    {"timestamp": ${Date.now()}, "content": "【今天是${new Date().toLocaleString("zh-CN", { dateStyle: "full" })}，用Markdown语法写一篇符合人设和今天情景的日记】"}
                ]
                }

                # 【【【重要指令：关于聊天记录生成】】】
                - 你正在续写这段对话。你提供的聊天记录是上下文，你【绝对不能】重复或改写其中的任何内容。你的生成必须从【全新的、下一条】消息开始。
                - 你必须严格遵守本提示词最上方的【绝对禁止事项】。
                - 如果"你的专属NPC好友列表"不为空，你【必须】为列表中的【每一个NPC】都生成一段与你（${chat.name}）的对话。
                - 如果列表为空，你可以虚构2-3个普通朋友并生成对话。
                - 你必须为每个联系人生成一段【至少包含5条消息】的对话。
                - 对话内容应该自然流畅，可以包含连续发言、表情包和表情符号等，以体现真实感。
                - 不要只生成一问一答的机械式对话。
                -   **【【【绝对禁止重复铁律】】】**: 你生成的 "messages" 数组中，【绝对不能】包含我提供给你的上下文里的任何一条消息。你的第一条消息必须是对话历史中最后一条消息的【下一条】。
                `;

						// 发送API请求
						const { proxyUrl, apiKey, model } = state.apiConfig;
						let isGemini = proxyUrl === GEMINI_API_URL;
						let geminiConfig = toGeminiRequestData(model, apiKey, prompt, [{ role: "user", content: prompt }], isGemini);

						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({
										model: model,
										messages: [{ role: "user", content: prompt }],
										temperature: parseFloat(state.apiConfig.temperature) || 0.8,
										response_format: { type: "json_object" },
									}),
							  });

						if (!response.ok) {
							let errorMsg = `API请求失败，状态码: ${response.status}`;
							try {
								const errorData = await response.json();
								errorMsg += `\n错误信息: ${errorData.error.message}`;
							} catch (e) {
								errorMsg += `\n无法解析错误响应体。`;
							}
							throw new Error(errorMsg);
						}

						// 处理API响应
						const data = await response.json();
						const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, "");

						let newData;
						try {
							newData = JSON.parse(aiResponseContent);
						} catch (e) {
							throw new Error(`AI返回的不是有效的JSON格式，无法解析。\n原始返回内容:\n${aiResponseContent}`);
						}

						let phoneData = chat.characterPhoneData;
						phoneData.lastGenerated = Date.now();

						// 处理聊天记录数据
						if (newData.chats) {
							newData.chats.forEach((newChat) => {
								if (!newChat.messages) {
									const myNickname = userNickname || "我";
									if (!phoneData.chats[myNickname]) {
										phoneData.chats[myNickname] = { avatar: "", history: [] };
									}
									phoneData.chats[myNickname].remarkName = newChat.contactName;
								} else {
									const contactName = newChat.contactName;
									if (phoneData.chats[contactName] && phoneData.chats[contactName].history) {
										console.log(`合并聊天记录: 为 "${contactName}" 追加 ${newChat.messages.length} 条新消息。`);
										phoneData.chats[contactName].history.push(...newChat.messages);
									} else {
										console.log(`创建新聊天: "${contactName}"`);
										phoneData.chats[contactName] = {
											avatar: newChat.avatar,
											history: newChat.messages,
										};
									}
								}
							});
						}

						// 处理其他数组类型数据
						if (!phoneData.shoppingCart) phoneData.shoppingCart = [];
						phoneData.shoppingCart.push(...(newData.shoppingCart || []));
						if (!phoneData.memos) phoneData.memos = [];
						phoneData.memos.push(...(newData.memos || []));
						if (!phoneData.browserHistory) phoneData.browserHistory = [];
						phoneData.browserHistory.push(...(newData.browserHistory || []));
						if (!phoneData.photoAlbum) phoneData.photoAlbum = [];
						phoneData.photoAlbum.push(...(newData.photoAlbum || []));
						if (!phoneData.trajectory) phoneData.trajectory = [];
						phoneData.trajectory.push(...(newData.trajectory || []));
						if (!phoneData.diary) phoneData.diary = [];
						phoneData.diary.push(...(newData.diary || []));

						// 处理应用使用时间数据
						if (newData.appUsage && Array.isArray(newData.appUsage)) {
							const usageMap = new Map();
							// 先加载已有的使用记录
							(phoneData.appUsage || []).forEach((item) => {
								usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
							});
							// 再累加新生成的使用记录
							newData.appUsage.forEach((item) => {
								usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
							});
							// 重新生成合并后的列表
							const mergedUsage = [];
							for (const [appName, totalMinutes] of usageMap.entries()) {
								mergedUsage.push({ appName: appName, duration: formatMinutesToDuration(totalMinutes) });
							}
							phoneData.appUsage = mergedUsage;
						}

						// 处理钱包数据
						if (newData.bank) {
							if (!phoneData.bank) phoneData.bank = { balance: 0, transactions: [] };
							if (typeof phoneData.bank.balance !== "number") phoneData.bank.balance = 0;

							// 如果AI返回了新的总余额 (通常是第一次生成时)，则以此为准
							if (typeof newData.bank.balance === "number") {
								phoneData.bank.balance = newData.bank.balance;
							}

							// 遍历新生成的交易记录，并累加/累减到余额上
							if (newData.bank.transactions && Array.isArray(newData.bank.transactions)) {
								newData.bank.transactions.forEach((transaction) => {
									const amount = parseFloat(transaction.amount);
									if (!isNaN(amount)) {
										// 只有在AI没有直接提供新余额时，我们才根据交易记录自己计算
										if (typeof newData.bank.balance !== "number") {
											if (transaction.type === "收入") {
												phoneData.bank.balance += amount;
											} else if (transaction.type === "支出") {
												phoneData.bank.balance -= amount;
											}
										}
									}
								});
								// 将新交易记录追加到历史记录中
								if (!phoneData.bank.transactions) phoneData.bank.transactions = [];
								phoneData.bank.transactions.push(...newData.bank.transactions);
							}
						}

						await db.chats.put(chat);
						alert("数据已刷新！");
					} catch (error) {
						console.error("生成角色手机数据失败:", error);
						await showCustomAlert("生成失败", `发生了一个错误，请检查你的网络、API密钥或模型设置。\n\n详细信息:\n${error.message}`);
					} finally {
						document.getElementById("generation-overlay").classList.remove("visible");
					}
				}

				/**
				 * 清空角色手机数据
				 */
				async function clearCharacterPhoneData() {
					if (!activeCharacterPhoneId) return;
					const chat = state.chats[activeCharacterPhoneId];
					if (!chat) return;

					// 确认是否清空所有数据
					const confirmed = await showCustomConfirm("确认清空", `确定要清空"${chat.name}"的所有手机数据吗？此操作不可恢复。`, { confirmButtonClass: "btn-danger" });
					if (confirmed) {
						// 重置为初始状态
						chat.characterPhoneData = {
							lastGenerated: null,
							chats: {},
							shoppingCart: [],
							memos: [],
							browserHistory: [],
							photoAlbum: [],
							bank: { balance: 0, transactions: [] },
							trajectory: [],
							appUsage: [],
							diary: [],
						};
						await db.chats.put(chat);
						// 重新渲染APP网格
						renderCharacterAppGrid();
						alert("数据已清空。");
					}
				}

				/**
				 * 渲染角色手机的聊天列表 (支持透明磨砂分组)
				 */
				function renderCharacterChatList() {
					const listEl = document.getElementById("character-chat-list");
					const characterChat = state.chats[activeCharacterPhoneId];
					if (!characterChat) return;

					const characterChatData = characterChat.characterPhoneData;
					const realChatHistory = characterChat.history;
					listEl.innerHTML = "";

					// 创建NPC消息的容器
					const npcContainer = document.createElement("div");
					npcContainer.className = "npc-chat-group";

					// 获取"我"的备注名
					const userContactInData = characterChatData.chats ? Object.values(characterChatData.chats).find((c) => !c.history || c.history.length === 0) : null;
					const remarkNameForMe = userContactInData ? userContactInData.remarkName : "我";

					// 渲染与"我"的聊天
					const lastMsg = realChatHistory.filter((m) => !m.isHidden).slice(-1)[0] || { content: "..." };
					const myChatItem = document.createElement("div");
					myChatItem.className = "chat-list-item";
					myChatItem.dataset.contactName = remarkNameForMe;
					myChatItem.dataset.isUserChat = "true";
					const myAvatar = characterChat.settings.myAvatar || defaultMyGroupAvatar;
					myChatItem.innerHTML = `
                        <img src="${myAvatar}" class="avatar" style="border-radius: 6px;">
                        <div class="info">
                            <span class="name">${remarkNameForMe}</span>
                            <div class="last-msg">${stripHtmlAndCode(String(lastMsg.content)).substring(0, 30)}</div>
                        </div>
                    `;
					listEl.appendChild(myChatItem);

					// 渲染与其他NPC的聊天
					if (characterChatData.chats) {
						for (const contactName in characterChatData.chats) {
							if (contactName === remarkNameForMe) continue;
							const contact = characterChatData.chats[contactName];
							if (!contact.history || contact.history.length === 0) continue;

							const lastNpcMsg = contact.history.slice(-1)[0] || { content: "..." };
							const npcChatItem = document.createElement("div");
							npcChatItem.className = "chat-list-item";
							npcChatItem.dataset.contactName = contactName;

							let npcAvatarHtml;
							const npcFromLibrary = (characterChat.npcLibrary || []).find((npc) => npc.name === contactName);
							if (npcFromLibrary && npcFromLibrary.avatar) {
								npcAvatarHtml = `<img src="${npcFromLibrary.avatar}" class="avatar" style="border-radius: 6px;">`;
							} else {
								const avatarColors = ["#FFC107", "#4CAF50", "#2196F3", "#F44336", "#9C27B0", "#00BCD4"];
								const npcNameInitial = contactName.slice(-1);
								const colorIndex = contactName.length % avatarColors.length;
								const bgColor = avatarColors[colorIndex];
								npcAvatarHtml = `<div class="avatar" style="border-radius: 6px; background-color: ${bgColor}; color: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 500;">${npcNameInitial}</div>`;
							}
							npcChatItem.innerHTML = `${npcAvatarHtml}<div class="info"><span class="name">${contactName}</span><div class="last-msg">${stripHtmlAndCode(String(lastNpcMsg.content)).substring(0, 30)}</div></div>`;

							// 将NPC消息添加到新的容器中
							npcContainer.appendChild(npcChatItem);
						}
					}

					// 将包含所有NPC消息的容器一次性添加到列表中
					if (npcContainer.hasChildNodes()) {
						listEl.appendChild(npcContainer);
					}
				}

				/**
				 * 渲染角色手机的具体聊天记录 (分页加载)
				 * @param {string} contactName - 联系人名称
				 * @param {boolean} isUserChat - 是否为与用户的聊天
				 * @param {number} loadOffset - 加载偏移量
				 */
				function renderCharacterChatHistory(contactName, isUserChat = false, loadOffset = 0) {
					const MESSAGES_PER_PAGE = 50; // 每次加载50条

					const messagesEl = document.getElementById("character-chat-history-messages");
					const characterChat = state.chats[activeCharacterPhoneId];
					if (!characterChat) {
						console.error("找不到 characterChat 对象！");
						return;
					}

					// 准备工作：设置标题和头像 (仅在首次加载时执行)
					if (loadOffset === 0) {
						messagesEl.innerHTML = ""; // 首次加载才清空
						let finalContactName = contactName;
						if (isUserChat) {
							const myChatData = characterChat.characterPhoneData.chats["我"];
							// 尝试从手机数据里找AI给用户的备注名
							const userContactInData = characterChat.characterPhoneData.chats ? Object.values(characterChat.characterPhoneData.chats).find((c) => !c.history || c.history.length === 0) : null;
							finalContactName = userContactInData ? userContactInData.remarkName : "我";
						}
						document.getElementById("character-chat-with-name").textContent = finalContactName;
					}

					// 数据源选择
					let fullHistory = [];
					if (isUserChat) {
						fullHistory = characterChat.history.filter((m) => !m.isHidden);
					} else {
						const npcChat = characterChat.characterPhoneData.chats[contactName];
						if (npcChat && npcChat.history) {
							fullHistory = npcChat.history;
						}
					}

					// 核心分页逻辑
					const totalMessages = fullHistory.length;
					const startIndex = Math.max(0, totalMessages - MESSAGES_PER_PAGE - loadOffset);
					const endIndex = totalMessages - loadOffset;
					const historyToShow = fullHistory.slice(startIndex, endIndex);

					// 移除旧的"加载更多"按钮
					const existingLoader = document.getElementById("load-more-messages-btn");
					if (existingLoader) {
						existingLoader.remove();
					}

					// 渲染消息
					const fragment = document.createDocumentFragment(); // 使用文档片段提升性能
					const characterName = characterChat.name;

					// 渲染消息到文档片段
					historyToShow.forEach((msg, index) => {
						if (msg.isHidden) return;
						const container = document.createElement("div");
						let sender;
						if (isUserChat) {
							sender = msg.role === "user" ? "我" : characterName;
						} else {
							sender = msg.sender;
						}

						const isSentByCharacter = sender === characterName;
						container.className = `character-chat-bubble-container ${isSentByCharacter ? "sent" : "received"}`;

						let avatarHtml = "";
						if (isSentByCharacter) {
							avatarHtml = `<img src="${characterChat.settings.aiAvatar || defaultAvatar}" class="character-chat-avatar">`;
						} else {
							if (isUserChat) {
								avatarHtml = `<img src="${characterChat.settings.myAvatar || defaultMyGroupAvatar}" class="character-chat-avatar">`;
							} else {
								const npcData = (characterChat.npcLibrary || []).find((npc) => npc.name === contactName);
								if (npcData && npcData.avatar) {
									avatarHtml = `<img src="${npcData.avatar}" class="character-chat-avatar">`;
								} else {
									const avatarColors = ["#FFC107", "#4CAF50", "#2196F3", "#F44336", "#9C27B0", "#00BCD4"];
									const npcNameInitial = contactName.slice(-1);
									const colorIndex = contactName.length % avatarColors.length;
									const bgColor = avatarColors[colorIndex];
									avatarHtml = `<div class="character-chat-avatar" style="background-color: ${bgColor}; color: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 500;">${npcNameInitial}</div>`;
								}
							}
						}

						let contentHtml = "";
						if (typeof msg.content === "string" && STICKER_REGEX.test(msg.content)) {
							contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-height: 100px;">`;
						} else {
							contentHtml = msg.content;
						}
						const bubbleHtml = `<div class="character-chat-bubble">${contentHtml}</div>`;
						const originalIndex = startIndex + index; // 计算在完整历史记录中的真实索引
						container.innerHTML = `${avatarHtml}${bubbleHtml}<button class="item-delete-btn message-delete-btn" data-contact-name="${contactName}" data-index="${originalIndex}" data-is-user-chat="${isUserChat}">×</button>`;
						fragment.appendChild(container);
					});

					// 决定是否显示"加载更多"按钮
					if (startIndex > 0) {
						const loadMoreBtn = document.createElement("div");
						loadMoreBtn.id = "load-more-messages-btn";
						loadMoreBtn.textContent = "加载更早的消息";
						loadMoreBtn.style.textAlign = "center";
						loadMoreBtn.style.padding = "10px";
						loadMoreBtn.style.color = "#888";
						loadMoreBtn.style.cursor = "pointer";
						loadMoreBtn.style.fontSize = "12px";
						loadMoreBtn.onclick = () => {
							// 记录当前滚动条位置，以便加载后恢复
							const currentScrollHeight = messagesEl.scrollHeight;
							renderCharacterChatHistory(contactName, isUserChat, loadOffset + MESSAGES_PER_PAGE);
							// 加载后，将滚动条定位到之前的位置，避免跳动
							messagesEl.scrollTop = messagesEl.scrollHeight - currentScrollHeight;
						};
						messagesEl.prepend(loadMoreBtn); // 将按钮添加到顶部
					}

					messagesEl.prepend(fragment); // 将新消息一次性插入到DOM中

					// 滚动条定位
					if (loadOffset === 0) {
						// 首次加载，滚动到底部
						messagesEl.scrollTop = messagesEl.scrollHeight;
					}
				}

				/**
				 * 渲染角色手机购物车界面
				 */
				function renderCharacterShoppingCart() {
					const listEl = document.getElementById("character-shopping-cart-list");
					const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.shoppingCart;
					listEl.innerHTML = "";
					if (!items || items.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">购物车是空的</p>';
						return;
					}
					items.forEach((item, index) => {
						const itemEl = document.createElement("div");
						itemEl.className = "character-cart-item";
						itemEl.innerHTML = `
                            <div class="cart-item-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path></svg>
                            </div>
                            <div class="cart-item-info">
                                <div class="title">${item.name}</div>
                                <div class="store">${item.store}</div>
                            </div>
                            <div class="cart-item-price">¥ ${item.price.toFixed(2)}</div>
                            <button class="item-delete-btn" data-type="shoppingCart" data-index="${index}">×</button>
                        `;
						listEl.appendChild(itemEl);
					});
				}

				/**
				 * 渲染角色手机备忘录界面
				 */
				function renderCharacterMemos() {
					const listEl = document.getElementById("character-memos-list");
					const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.memos;
					listEl.innerHTML = "";
					if (!items || items.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">备忘录是空的</p>';
						return;
					}
					items.forEach((item, index) => {
						const itemEl = document.createElement("div");
						itemEl.className = "character-data-item";
						itemEl.innerHTML = `
                            <div class="title">${item.title}</div>
                            <div class="content">${item.content}</div>
                            <button class="item-delete-btn" data-type="memos" data-index="${index}">×</button>
                        `;
						listEl.appendChild(itemEl);
					});
				}

				/**
				 * 在角色手机内部切换页面
				 * @param {string} pageId - 要显示的角色手机页面的ID
				 */
				function showCharacterPhonePage(pageId) {
					// 找到角色手机内部屏幕的所有页面
					const pages = document.querySelectorAll(".character-phone-page");
					// 隐藏所有页面
					pages.forEach((p) => p.classList.remove("active"));
					// 显示目标页面
					const pageToShow = document.getElementById(pageId);
					if (pageToShow) {
						pageToShow.classList.add("active");
					}
				}

				/**
				 * 渲染角色手机浏览器界面
				 */
				function renderCharacterBrowser() {
					const listEl = document.getElementById("character-browser-list");
					const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.browserHistory;
					listEl.innerHTML = "";
					if (!items || items.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">浏览器历史为空</p>';
						return;
					}
					items.forEach((item, index) => {
						const itemEl = document.createElement("div");
						itemEl.className = "character-browser-item";
						itemEl.innerHTML = `
                            <span class="browser-item-icon">🌐</span>
                            <div class="title">${item.query}</div>
                            <button class="item-delete-btn" data-type="browserHistory" data-index="${index}">×</button>
                        `;
						itemEl.addEventListener("click", (e) => {
							if (e.target.classList.contains("item-delete-btn")) return;
							document.getElementById("character-browser-detail-title").textContent = item.query;
							document.getElementById("character-browser-detail-content").innerHTML = (item.result || "AI未生成详细内容。").replace(/\n/g, "<br>");
							showCharacterPhonePage("character-browser-detail-screen");
						});
						listEl.appendChild(itemEl);
					});
				}

				/**
				 * 渲染角色手机相册界面
				 */
				function renderCharacterPhotoAlbum() {
					const gridEl = document.getElementById("character-album-grid");
					const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.photoAlbum;
					gridEl.innerHTML = "";
					if (!items || items.length === 0) {
						gridEl.innerHTML = '<p style="grid-column: 1 / -1; text-align:center; color: #8a8a8a; margin-top: 50px;">相册里没有照片</p>';
						return;
					}
					items.forEach((item, index) => {
						const itemEl = document.createElement("div");
						itemEl.className = "character-album-item";
						itemEl.style.position = "relative";
						itemEl.innerHTML = `
                            <img src="https://i.postimg.cc/KYr2qRCK/1.jpg" alt="文字图">
                            <button class="item-delete-btn" data-type="photoAlbum" data-index="${index}" style="top: 10px; right: 10px; z-index: 1;">×</button>
                        `;
						itemEl.addEventListener("click", (e) => {
							if (e.target.classList.contains("item-delete-btn")) return;
							showCustomAlert("图片内容", item.hiddenContent);
						});
						gridEl.appendChild(itemEl);
					});
				}

				/**
				 * 渲染角色手机银行界面
				 */
				function renderCharacterBank() {
					const detailsEl = document.getElementById("character-bank-details");
					// 获取当前角色对象，为后面找备注名做准备
					const characterChat = state.chats[activeCharacterPhoneId];
					if (!characterChat) return;

					const bankData = characterChat.characterPhoneData?.bank;
					detailsEl.innerHTML = "";

					// 获取角色给用户的备注名
					const userContactInData = characterChat.characterPhoneData.chats ? Object.values(characterChat.characterPhoneData.chats).find((c) => !c.history || c.history.length === 0) : null;
					const remarkNameForMe = userContactInData ? userContactInData.remarkName : "我";

					const balanceCard = document.createElement("div");
					balanceCard.className = "character-bank-balance-card";
					balanceCard.innerHTML = `
                        <div class="label">账户余额</div>
                        <div class="amount">¥ ${(bankData?.balance || 0).toFixed(2)}</div>
                    `;
					detailsEl.appendChild(balanceCard);

					if (!bankData?.transactions || bankData.transactions.length === 0) {
						detailsEl.innerHTML += '<p style="text-align:center; color: #8a8a8a; margin-top: 30px;">暂无交易明细</p>';
						return;
					}

					[...bankData.transactions].reverse().forEach((item, index) => {
						const originalIndex = bankData.transactions.length - 1 - index;
						const isIncome = item.type === "收入";
						const itemEl = document.createElement("div");
						itemEl.className = "character-bank-transaction";
						const iconBg = isIncome ? "#4CAF50" : "#E91E63";
						const iconSvg = isIncome ? `<svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M7 10h10v4H7z" opacity=".3"/><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"/></svg>` : `<svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-1 14H5c-.55 0-1-.45-1-1v-5h16v5c0 .55-.45 1-1 1zm1-10H4V7c0-.55.45-1 1-1h14c.55 0 1 .45 1 1v2z"/></svg>`;

						// 用正则表达式全局替换所有"我"字
						const displayDescription = item.description.replace(/我/g, remarkNameForMe);

						itemEl.innerHTML = `
                            <div class="transaction-details">
                                <div class="transaction-icon" style="background-color: ${iconBg};">${iconSvg}</div>
                                <div>
                                    <div class="title">${displayDescription}</div>
                                    <div class="meta" style="border:none; padding:0; margin-top:4px;"><span>${item.type}</span></div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span class="transaction-amount ${isIncome ? "income" : "expense"}">
                                    ${isIncome ? "+" : "-"} ${item.amount.toFixed(2)}
                                </span>
                                <button class="item-delete-btn" data-type="bank.transactions" data-index="${originalIndex}">×</button>
                            </div>
                        `;
						detailsEl.appendChild(itemEl);
					});
				}

				/**
				 * 渲染角色手机行动轨迹界面
				 */
				function renderCharacterTrajectory() {
					const listEl = document.getElementById("character-trajectory-list");
					const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.trajectory;
					listEl.innerHTML = "";
					listEl.classList.add("character-trajectory-list");

					if (!items || items.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">暂无足迹</p>';
						return;
					}

					// 使用parseTime函数对轨迹数组进行排序
					items.sort((a, b) => parseTime(a.time) - parseTime(b.time));

					items.forEach((item, index) => {
						const itemEl = document.createElement("div");
						itemEl.className = "character-trajectory-item";
						itemEl.innerHTML = `
                            <div class="trajectory-item-content">
                                <div class="title">${item.activity}</div>
                                <div class="meta">
                                    <span>📍 ${item.location}</span>
                                    <span style="margin-left: 10px;">🕒 ${item.time}</span>
                                </div>
                            </div>
                            <button class="item-delete-btn" data-type="trajectory" data-index="${index}">×</button>
                        `;
						listEl.appendChild(itemEl);
					});
				}

				/**
				 * 渲染角色手机APP使用记录界面
				 */
				function renderCharacterAppUsage() {
					const listEl = document.getElementById("character-app-usage-list");
					const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.appUsage;
					listEl.innerHTML = "";
					if (!items || items.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">暂无使用记录</p>';
						return;
					}
					const durationsInMinutes = items.map((item) => parseDurationToMinutes(item.duration));
					const maxDuration = Math.max(...durationsInMinutes);
					items.forEach((item, index) => {
						const itemEl = document.createElement("div");
						itemEl.className = "character-app-usage-item";
						const durationInMinutes = durationsInMinutes[index];
						const barWidth = maxDuration > 0 ? (durationInMinutes / maxDuration) * 100 : 0;
						itemEl.innerHTML = `
                            <div class="app-usage-header">
                                <span class="name">${item.appName}</span>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span class="duration">${item.duration}</span>
                                    <button class="item-delete-btn" data-type="appUsage" data-index="${index}">×</button>
                                </div>
                            </div>
                            <div class="app-usage-bar-container">
                                <div class="app-usage-bar" style="width: ${barWidth}%;"></div>
                            </div>
                        `;
						listEl.appendChild(itemEl);
					});
				}

				/**
				 * 渲染角色手机日记界面
				 */
				function renderCharacterDiary() {
					const listEl = document.getElementById("character-diary-list");
					const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.diary;
					listEl.innerHTML = "";
					if (!items || items.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">日记本还是空的，点击右上角写下第一篇日记吧。</p>';
						return;
					}

					[...items].reverse().forEach((item, index) => {
						const originalIndex = items.length - 1 - index;
						const itemEl = document.createElement("div");
						itemEl.className = "character-data-item";
						const contentHtml = renderMarkdown(item.content);
						itemEl.innerHTML = `
                            <div class="content">${contentHtml}</div>
                            <div class="meta">
                                <span>${new Date(item.timestamp).toLocaleString()}</span>
                            </div>
                            <button class="item-delete-btn" data-type="diary" data-index="${originalIndex}">×</button>
                        `;
						listEl.appendChild(itemEl);
					});
				}

				/**
				 * 独立刷新，生成新的日记条目
				 */
				async function generateNewDiaryEntry() {
					if (!activeCharacterPhoneId) return;
					const chat = state.chats[activeCharacterPhoneId];
					if (!chat) return;

					document.getElementById("generation-overlay").classList.add("visible");

					try {
						const persona = chat.settings.aiPersona;
						const recentHistory = chat.history
							.slice(-20)
							.map((msg) => {
								const sender = msg.role === "user" ? "我" : chat.name;
								return `${sender}: ${msg.content}`;
							})
							.join("\n");

						let worldBookContext = "";
						if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
							worldBookContext =
								"--- 世界观设定 (这是你必须严格遵守的背景) ---\n" +
								chat.settings.linkedWorldBookIds
									.map((id) => {
										const book = state.worldBooks.find((b) => b.id === id);
										return book ? `[${book.name}]: ${book.content}` : "";
									})
									.join("\n\n");
						}

						const diaryPrompt = `
                            # 任务
                            你现在是角色 "${chat.name}"。今天是 ${new Date().toLocaleString("zh-CN", { dateStyle: "full" })}。请你回顾一下最近和我的聊天，以及你的人设，然后用你的口吻写一篇关于【今天或近期发生事情】的日记。
                            这篇日记是你内心的独白，可以记录你的感受、思考、计划或者秘密。
                            内容要丰富、有深度，长度在100到300字之间。

                            # 【【【重要：格式指令】】】
                            你【必须】使用以下Markdown语法来丰富日记的格式，使其更具表现力：
                            -   **标题**: 使用 \`#\` 或 \`##\` 来创建大标题和副标题。 (例如: \`# 今天的心情\`)
                            -   **粗体**: 使用 \`**文字**\` 来强调重点。 (例如: \`今天真的**非常**开心。\`)
                            -   **斜体**: 使用 \`*文字*\` 来表达情绪或内心想法。 (例如: \`*他到底是怎么想的呢...*\`)
                            -   **删除线**: 使用 \`~~文字~~\` 来表示划掉或否定的想法。 (例如: \`我决定明天去<s>逛街</s>学习。\`)
                            -   **遮挡/剧透**: 使用 \`||文字||\` 来隐藏秘密或悄悄话。 (例如: \`我偷偷准备了一个惊喜，||是一个手织的围巾||。\`)

                            你的输出【必须且只能】是日记的正文内容，不要包含任何其他说明或JSON格式。

                            # 你的信息
                            - 你的名字: ${chat.name}
                            - 你的人设: ${persona}
                            ${worldBookContext}

                            # 最近聊天记录参考
                            ${recentHistory}
                        `;

						const { proxyUrl, apiKey, model } = state.apiConfig;
						let isGemini = proxyUrl === GEMINI_API_URL;
						let geminiConfig = toGeminiRequestData(model, apiKey, diaryPrompt, [{ role: "user", content: diaryPrompt }], isGemini);

						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({
										model: model,
										messages: [{ role: "user", content: diaryPrompt }],
										temperature: parseFloat(state.apiConfig.temperature) || 0.8,
									}),
							  });

						// 错误处理核心代码
						if (!response.ok) {
							let errorMsg = `API请求失败，状态码: ${response.status}`;
							try {
								const errorData = await response.json();
								errorMsg += `\n错误信息: ${errorData.error.message}`;
							} catch (e) {
								errorMsg += `\n无法解析错误响应体。`;
							}
							throw new Error(errorMsg);
						}

						const data = await response.json();
						const diaryContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;

						const newEntry = {
							timestamp: Date.now(),
							content: diaryContent,
						};

						chat.characterPhoneData.diary.push(newEntry);
						await db.chats.put(chat);

						renderCharacterDiary();
						alert("新日记已生成！");
					} catch (error) {
						console.error("生成日记失败:", error);
						await showCustomAlert("生成失败", `发生了一个错误，请检查你的网络、API密钥或模型设置。\n\n详细信息:\n${error.message}`);
					} finally {
						document.getElementById("generation-overlay").classList.remove("visible");
					}
				}

				/**
				 * 将Markdown文本安全地渲染为HTML
				 * @param {string} markdownText - 原始的Markdown文本
				 * @returns {string} - 处理和净化后的安全HTML字符串
				 */
				function renderMarkdown(markdownText) {
					if (!markdownText) return "";

					// 支持自定义的"遮挡/剧透"语法 ||spoiler||
					let processedText = markdownText.replace(/\|\|(.*?)\|\|/g, '<span class="spoiler">$1</span>');

					// 使用 marked.js 将Markdown转换为HTML
					let rawHtml = marked.parse(processedText, { gfm: true, breaks: true });

					// 使用 DOMPurify 清洗HTML，防止XSS攻击
					let sanitizedHtml = DOMPurify.sanitize(rawHtml);

					return sanitizedHtml;
				}

				/**
				 * 将时长字符串（如"2.5小时"）转换为分钟数
				 * @param {string} durationString - 时长字符串
				 * @returns {number} - 转换后的分钟数
				 */
				function parseDurationToMinutes(durationString) {
					if (!durationString) return 0;
					const num = parseFloat(durationString) || 0;
					if (durationString.includes("小时") || durationString.includes("h")) {
						return num * 60;
					}
					// 默认单位是分钟
					return num;
				}

				/**
				 * 切换视频通话的大小窗口画面
				 */
				function switchVideoViews() {
					const mainView = document.getElementById("video-main-view");
					const pipView = document.getElementById("video-pip-view");

					// 交换两张图片的 src
					const mainImg = mainView.querySelector("img");
					const pipImg = pipView.querySelector("img");
					const tempSrc = mainImg.src;
					mainImg.src = pipImg.src;
					pipImg.src = tempSrc;
				}

				/**
				 * 处理视频通话中的"重roll"请求
				 */
				async function handleVideoCallReroll() {
					if (!videoCallState.isActive) return;

					// 找到用户最后一次说的话的索引
					const lastUserSpeechIndex = videoCallState.callHistory.findLastIndex((h) => h.role === "user");

					// 从通话历史中，删除掉那之后的所有AI回复
					if (lastUserSpeechIndex > -1) {
						videoCallState.callHistory.splice(lastUserSpeechIndex + 1);
					} else {
						// 如果用户还没说过话，就清空所有历史，让AI重说第一句话
						videoCallState.callHistory = [];
					}

					// 根据当前模式，清空对应的聊天容器
					const chat = state.chats[videoCallState.activeChatId];
					const isVisualMode = chat.settings.visualVideoCallEnabled;
					const callFeed = isVisualMode ? document.getElementById("video-call-messages-visual") : document.getElementById("video-call-main");

					callFeed.innerHTML = ""; // 清空容器

					// 重新渲染删除后的历史记录
					videoCallState.callHistory.forEach((msg) => {
						let bubble;
						if (isVisualMode) {
							bubble = document.createElement("div");
							bubble.className = `visual-call-bubble ${msg.role === "user" ? "user" : "ai"}`;
						} else {
							bubble = document.createElement("div");
							bubble.className = `call-message-bubble ${msg.role === "user" ? "user-speech" : "ai-speech"}`;
						}
						bubble.textContent = msg.content;
						callFeed.appendChild(bubble);
					});

					// 重新触发AI响应
					await triggerAiInCallAction();
				}

				/**
				 * 应用指定的主题（'light' 或 'dark'）
				 * @param {string} theme - 要应用的主题名称
				 */
				function applyTheme(theme) {
					const phoneScreen = document.getElementById("phone-screen");
					const toggleSwitch = document.getElementById("theme-toggle-switch");

					const isDark = theme === "dark";

					// 核心操作：添加或移除 .dark-mode 类
					phoneScreen.classList.toggle("dark-mode", isDark);

					// 如果开关存在，就同步它的状态
					if (toggleSwitch) {
						toggleSwitch.checked = isDark;
					}

					// 将用户的选择保存到本地存储
					localStorage.setItem("ephone-theme", theme);

					// 切换主题后需要重新渲染聊天界面
					if (state.activeChatId) {
						renderChatInterface(state.activeChatId);
					}
				}

				/**
				 * 当用户点击开关时，切换当前的主题
				 */
				function toggleTheme() {
					const toggleSwitch = document.getElementById("theme-toggle-switch");
					// 直接根据开关的选中状态来决定新主题
					const newTheme = toggleSwitch.checked ? "dark" : "light";
					applyTheme(newTheme);
				}

				/**
				 * 删除角色手机中的一个联系人及其所有聊天记录
				 * @param {string} contactName - 要删除的联系人的名字
				 */
				async function deleteCharacterPhoneContact(contactName) {
					if (!activeCharacterPhoneId) return;

					// 弹出确认框，防止误删
					const confirmed = await showCustomConfirm("删除联系人", `确定要从TA的手机中删除联系人"${contactName}"以及所有相关聊天记录吗？此操作不可恢复。`, { confirmButtonClass: "btn-danger" });

					if (confirmed) {
						const chat = state.chats[activeCharacterPhoneId];
						if (chat && chat.characterPhoneData && chat.characterPhoneData.chats) {
							// 从数据中删除这个联系人
							delete chat.characterPhoneData.chats[contactName];

							// 将更新后的数据保存回数据库
							await db.chats.put(chat);

							// 重新渲染聊天列表
							renderCharacterChatList();

							alert(`联系人"${contactName}"已删除。`);
						}
					}
				}

				/**
				 * 打开心声面板，应用背景和所有自定义设置
				 */
				function openInnerVoiceModal() {
					if (!state.activeChatId) return;
					const chat = state.chats[state.activeChatId];
					if (!chat) return;

					// 应用自定义样式
					applySavedInnerVoiceStyles();

					applyInnerVoiceBackground(chat.innerVoiceBackground || "");

					if (!chat.latestInnerVoice) {
						alert("还没有捕捉到Ta的心声哦，试着再聊一句吧！");
						return;
					}

					const modal = document.getElementById("inner-voice-modal");
					const data = chat.latestInnerVoice;

					// 填充角色信息
					document.getElementById("inner-voice-avatar").src = chat.settings.aiAvatar || defaultAvatar;
					document.getElementById("inner-voice-char-name").textContent = chat.name;
					const frameImg = document.getElementById("inner-voice-avatar-frame");
					const avatarWrapper = document.getElementById("inner-voice-avatar-wrapper");
					const frameUrl = chat.settings.aiAvatarFrame || "";

					if (frameUrl) {
						frameImg.src = frameUrl;
						frameImg.style.display = "block";
						avatarWrapper.classList.remove("has-border");
					} else {
						frameImg.src = "";
						frameImg.style.display = "none";
						avatarWrapper.classList.add("has-border");
					}

					const labelFormat = chat.settings.innerVoiceAdopterLabelFormat || "领养人: {{user}}";
					const userNickname = chat.settings.myNickname || "你";
					const finalAdopterText = labelFormat.replace("{{user}}", userNickname);

					document.getElementById("inner-voice-adopter-avatar").src = chat.settings.myAvatar || defaultAvatar;
					document.getElementById("inner-voice-adopter-name").textContent = finalAdopterText;

					const header = document.querySelector("#inner-voice-main-panel .modal-header");
					if (header) {
						const shouldHideBorder = chat.settings.innerVoiceHideHeaderBorder || false;
						header.classList.toggle("no-border", shouldHideBorder);
					}

					// 填充心声内容
					document.getElementById("inner-voice-clothing").textContent = data.clothing || "...";
					document.getElementById("inner-voice-behavior").textContent = data.behavior || "...";
					document.getElementById("inner-voice-thoughts").textContent = data.thoughts || "...";
					document.getElementById("inner-voice-naughty-thoughts").textContent = data.naughtyThoughts || "...";

					// 显示面板
					modal.classList.add("visible");
					document.getElementById("inner-voice-history-panel").style.display = "none";
					document.getElementById("inner-voice-main-panel").style.display = "flex";
					isInnerVoiceHistoryOpen = false;
				}

				/**
				 * 打开或关闭历史记录面板
				 */
				function toggleInnerVoiceHistory() {
					const mainPanel = document.getElementById("inner-voice-main-panel");
					const historyPanel = document.getElementById("inner-voice-history-panel");

					if (isInnerVoiceHistoryOpen) {
						// 如果是打开的，就关闭它，显示主面板
						mainPanel.style.display = "flex";
						historyPanel.style.display = "none";
					} else {
						// 如果是关闭的，就打开它，隐藏主面板
						renderInnerVoiceHistory(); // 渲染历史记录
						mainPanel.style.display = "none";
						historyPanel.style.display = "flex";
					}
					isInnerVoiceHistoryOpen = !isInnerVoiceHistoryOpen; // 切换状态
				}

				/**
				 * 渲染心声的历史记录列表
				 */
				function renderInnerVoiceHistory() {
					const listEl = document.getElementById("inner-voice-history-list");
					listEl.innerHTML = "";
					const chat = state.chats[state.activeChatId];
					const history = chat.innerVoiceHistory || [];

					if (history.length === 0) {
						listEl.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">还没有历史记录</p>';
						return;
					}

					// 从新到旧显示
					[...history].reverse().forEach((item) => {
						const itemEl = document.createElement("div");
						itemEl.className = "inner-voice-history-item";

						const date = new Date(item.timestamp);
						const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(date.getDate()).padStart(2, "0")} ${String(date.getHours()).padStart(2, "0")}:${String(date.getMinutes()).padStart(2, "0")}`;

						// 在HTML中加入了删除按钮
						itemEl.innerHTML = `
                        <button class="history-item-delete-btn" data-timestamp="${item.timestamp}">×</button>
                        <div class="history-item-timestamp">${dateString}</div>
                        <div class="history-item-content">
                            <p><strong>服装:</strong> ${item.clothing || "..."}</p>
                            <p><strong>行为:</strong> ${item.behavior || "..."}</p>
                            <p><strong>心声:</strong> ${item.thoughts || "..."}</p>
                            <p><strong>坏心思:</strong> ${item.naughtyThoughts || "..."}</p>
                        </div>
                    `;
						listEl.appendChild(itemEl);
					});
				}

				/**
				 * 删除单条心声记录
				 * @param {number} timestamp - 要删除的心声的时间戳
				 */
				async function deleteSingleInnerVoice(timestamp) {
					const chat = state.chats[state.activeChatId];
					if (!chat || !chat.innerVoiceHistory) return;

					// 弹出确认框
					const confirmed = await showCustomConfirm("确认删除", "确定要删除这条心声记录吗？", { confirmButtonClass: "btn-danger" });
					if (confirmed) {
						// 从数组中过滤掉匹配的项
						chat.innerVoiceHistory = chat.innerVoiceHistory.filter((item) => item.timestamp !== timestamp);
						// 保存回数据库
						await db.chats.put(chat);
						// 重新渲染列表
						renderInnerVoiceHistory();
					}
				}

				/**
				 * 清空所有心声记录（包括当前心声）
				 */
				async function clearAllInnerVoiceHistory() {
					const chat = state.chats[state.activeChatId];
					// 优化了判断条件，确保只要有历史或当前心声，就可以执行清空
					if (!chat || ((!chat.innerVoiceHistory || chat.innerVoiceHistory.length === 0) && !chat.latestInnerVoice)) {
						alert("没有可以清空的心声记录。");
						return;
					}

					const confirmed = await showCustomConfirm("确认清空", "确定要清空所有心声历史记录吗？此操作不可恢复。", { confirmButtonClass: "btn-danger" });
					if (confirmed) {
						// 不仅清空历史数组，也要清空当前的心声对象
						chat.innerVoiceHistory = [];
						chat.latestInnerVoice = null; // 将当前心声设为null

						await db.chats.put(chat);

						// 手动清空主面板的显示，防止返回时看到旧数据
						document.getElementById("inner-voice-clothing").textContent = "...";
						document.getElementById("inner-voice-behavior").textContent = "...";
						document.getElementById("inner-voice-thoughts").textContent = "...";
						document.getElementById("inner-voice-naughty-thoughts").textContent = "...";

						// 刷新历史记录列表
						renderInnerVoiceHistory();

						// 给用户一个成功的提示
						alert("所有心声记录已清空！");
					}
				}

				/**
				 * 当用户点击"召唤NPC评论"按钮时触发
				 * @param {number} postId - 动态的ID
				 * @param {string} authorId - 动态作者的ID ('user' 或 'chat_...')
				 */
				async function handleNpcSummonClick(postId, authorId) {
					const post = await db.qzonePosts.get(postId);
					if (!post) {
						alert("找不到该动态！");
						return;
					}

					if (authorId === "user") {
						// 如果是用户发的动态，弹出选择菜单
						await handleUserPostCommentTrigger(post);
					} else {
						// 如果是角色发的动态，直接触发他自己的NPC
						await handleCharPostCommentTrigger(post, authorId);
					}
				}

				/**
				 * 处理角色动态的NPC召唤
				 * @param {object} post - 动态对象
				 * @param {string} authorId - 动态作者的角色ID
				 */
				async function handleCharPostCommentTrigger(post, authorId) {
					const authorChar = state.chats[authorId];
					if (!authorChar || !authorChar.npcLibrary || authorChar.npcLibrary.length === 0) {
						alert(`角色"${authorChar.name}"还没有自己的NPC朋友哦！`);
						return;
					}

					// 只使用这个角色自己的NPC库
					// 把作者本人(authorChar)作为"主人"传进去
					await generateNpcCommentsForPost(post, authorChar.npcLibrary, authorChar);
				}

				/**
				 * 处理用户动态的NPC召唤（弹出选择框）
				 * @param {object} post - 动态对象
				 */
				async function handleUserPostCommentTrigger(post) {
					const modal = document.getElementById("custom-modal-overlay");
					const modalTitle = document.getElementById("custom-modal-title");
					const modalBody = document.getElementById("custom-modal-body");
					const modalConfirmBtn = document.getElementById("custom-modal-confirm");
					const modalCancelBtn = document.getElementById("custom-modal-cancel");

					modalTitle.textContent = "选择要召唤的NPC";

					// 筛选出所有拥有NPC库的角色
					const charsWithNpcs = Object.values(state.chats).filter((chat) => !chat.isGroup && chat.npcLibrary && chat.npcLibrary.length > 0);

					if (charsWithNpcs.length === 0) {
						alert("当前没有任何角色拥有NPC库。");
						return;
					}

					// 构建选择列表的HTML
					let optionsHtml = '<div style="text-align: left;">';
					optionsHtml += `<label style="display: block; padding: 5px;"><input type="radio" name="npc_summon_choice" value="all" checked> 召唤所有人</label>`;
					charsWithNpcs.forEach((char) => {
						optionsHtml += `<label style="display: block; padding: 5px;"><input type="radio" name="npc_summon_choice" value="${char.id}"> 只召唤 ${char.name} 的朋友</label>`;
					});
					optionsHtml += "</div>";

					modalBody.innerHTML = optionsHtml;
					modalConfirmBtn.textContent = "确认召唤";
					modalCancelBtn.style.display = "block";

					modal.classList.add("visible");

					modalConfirmBtn.onclick = async () => {
						const selectedValue = document.querySelector('input[name="npc_summon_choice"]:checked').value;
						let npcsToSummon = [];
						let ownerChar = null; // 声明一个变量来存储主人

						if (selectedValue === "all") {
							// 集合所有角色的所有NPC
							charsWithNpcs.forEach((char) => {
								npcsToSummon.push(...char.npcLibrary);
							});
							// 召唤所有人时，我们不指定特定的主人
						} else {
							// 只获取被选中的那个角色的NPC
							const selectedChar = state.chats[selectedValue];
							if (selectedChar) {
								npcsToSummon = selectedChar.npcLibrary;
								ownerChar = selectedChar; // 把选中的角色存为主人
							}
						}

						modal.classList.remove("visible");
						if (npcsToSummon.length > 0) {
							// 把主人(ownerChar)作为第三个参数传进去
							await generateNpcCommentsForPost(post, npcsToSummon, ownerChar);
						}
					};

					modalCancelBtn.onclick = () => modal.classList.remove("visible");
				}

				/**
				 * 生成NPC评论或回复，并更新到动态
				 * @param {object} post - 动态对象
				 * @param {Array<object>} npcsToComment - 将要发表评论的NPC对象数组
				 * @param {object|null} ownerChar - 这些NPC的"主人"角色对象
				 */
				async function generateNpcCommentsForPost(post, npcsToComment, ownerChar = null) {
					console.log("【NPC评论-诊断】: 1. 函数 generateNpcCommentsForPost 已触发", { post, npcsToComment, ownerChar });

					await showCustomAlert("请稍候...", "正在召唤NPC们前来围观评论...");

					const { proxyUrl, apiKey, model } = state.apiConfig;
					if (!proxyUrl || !apiKey || !model) {
						alert("请先配置API！");
						return;
					}

					const postContent = (post.content || post.publicText || post.hiddenContent || "(图片动态)").substring(0, 150);
					const existingComments = (post.comments || [])
						.slice(-3)
						.map((c) => `${c.commenterName}: ${c.text}`)
						.join("\n");

					const shuffledNpcs = [...npcsToComment].sort(() => 0.5 - Math.random());
					const selectedNpcs = shuffledNpcs.slice(0, 5);
					const npcList = selectedNpcs.map((npc) => `- ${npc.name} (人设: ${npc.persona})`).join("\n");

					const authorName = post.authorId === "user" ? state.qzoneSettings.nickname : state.chats[post.authorId]?.name || "未知作者";

					// 这就是我们新增的核心逻辑！
					let ownerContext = "";
					// 如果明确告诉了AI这些NPC的主人是谁
					if (ownerChar) {
						ownerContext = `
                            # NPC归属与关系 (重要背景)
                            - 你将要扮演的这些NPC都是角色"${ownerChar.name}"的朋友或关联人物。
                            - "${ownerChar.name}"的人设是: ${ownerChar.settings.aiPersona}
                            - 你在发表评论时，需要体现出你(作为NPC)与"${ownerChar.name}"的关系，并以此视角来看待动态作者"${authorName}"。
                            `;
					}

					const systemPrompt = `
                            # 任务
                            你是一个多角色扮演AI。现在有一条动态需要你扮演指定的NPC角色进行评论或回复。

                            ${ownerContext}

                            # 动态信息
                            - 作者: ${authorName}
                            - 内容摘要: ${postContent}...
                            - 最近的评论 (你可以回复他们):
                            ${existingComments || "(暂无评论)"}

                            # 你需要扮演的NPC列表 (及他们的人设)
                            ${npcList}

                            # 核心规则
                            1.  你【必须】从上面的NPC列表中，选择1到3个最合适的角色进行评论或回复。
                            2.  评论/回复内容【必须】严格符合该NPC的人设和口吻，并与动态内容或已有评论相关。
                            3.  你的回复【必须且只能】是一个严格的JSON数组，每个对象代表一条评论或回复。
                            4.  格式: \`[{"commenterName": "NPC名字", "commentText": "评论内容", "replyTo": "(可选)被回复者名字"}]\`

                            现在，请开始生成评论或回复。
                        `;
					console.log("【NPC评论-诊断】: 2. 已构建完成，准备发送给AI的 System Prompt:", systemPrompt);

					try {
						let isGemini = proxyUrl === GEMINI_API_URL;
						let messagesForApi;
						if (isGemini) {
							messagesForApi = [{ role: "user", content: systemPrompt }];
						} else {
							messagesForApi = [
								{ role: "system", content: systemPrompt },
								{ role: "user", content: "请根据你在system prompt中读到的信息生成评论。" },
							];
						}

						let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);

						console.log("【NPC评论-诊断】: 3. 即将发送API请求... 请求地址:", isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`);
						console.log("【NPC评论-诊断】: 3.1 请求体 (Body) 内容:", isGemini ? geminiConfig.data.body : JSON.stringify({ model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } }));

						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({
										model: model,
										messages: messagesForApi,
										temperature: parseFloat(state.apiConfig.temperature) || 0.8,
										response_format: { type: "json_object" },
									}),
							  });

						console.log("【NPC评论-诊断】: 4. 收到API响应", { ok: response.ok, status: response.status });

						if (!response.ok) {
							const errorText = await response.text();
							throw new Error(`API请求失败: ${response.status} - ${errorText}`);
						}

						const data = await response.json();
						const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, "").trim();

						console.log("【NPC评论-诊断】: 5. 从API获取到的原始回复内容:", aiResponseContent);

						let newComments;
						if (aiResponseContent.includes('"chatResponse"')) {
							newComments = JSON.parse(aiResponseContent).chatResponse;
						} else {
							newComments = JSON.parse(aiResponseContent);
						}

						console.log("【NPC评论-诊断】: 6. 成功解析后的评论对象数组:", newComments);

						if (Array.isArray(newComments) && newComments.length > 0) {
							const postToUpdate = await db.qzonePosts.get(post.id);
							if (!postToUpdate) throw new Error("在数据库中找不到要更新的帖子！");
							if (!postToUpdate.comments) postToUpdate.comments = [];

							newComments.forEach((comment) => {
								if (comment.commenterName && comment.commentText) {
									const newCommentObject = {
										commenterName: comment.commenterName,
										text: comment.commentText,
										timestamp: Date.now(),
									};
									if (comment.replyTo) newCommentObject.replyTo = comment.replyTo;
									postToUpdate.comments.push(newCommentObject);
								}
							});

							await db.qzonePosts.put(postToUpdate);
							hideCustomModal();
							await renderQzonePosts();
							alert("NPC们评论成功！");
						} else {
							hideCustomModal();
							alert("NPC们似乎没什么想说的。");
						}
					} catch (error) {
						console.error("【NPC评论-错误】: 召唤NPC评论失败:", error);
						await showCustomAlert("召唤失败", `发生了一个错误：\n${error.message}`);
					}
				}

				/**
				 * 如果数据库中没有，则自动创建一个内置的夜间模式主题
				 */
				async function addDefaultDarkModeThemeIfNeeded() {
					const themeName = "内置夜间模式"; // 内置主题名字
					try {
						// 检查数据库里是否已经有了这个名字的主题
						const existingTheme = await db.themes.where("name").equals(themeName).first();

						// 如果没有找到，则创建它
						if (!existingTheme) {
							console.log("内置夜间模式不存在，正在创建...");

							// 完整的夜间模式CSS代码
							const darkModeCss = `
                                /* 1. 全局重新定义颜色变量 */
                                :root {
                                --secondary-bg: #1c1c1e;
                                --border-color: #38383a;
                                --text-primary: #ffffff;
                                --text-secondary: #8e8e93;
                                --status-bar-text-color: #ffffff;
                                --accent-color: #0A84FF; /* iOS风格的蓝色 */
                                }

                                /* 2. 为所有屏幕和主要容器设置基础深色背景 */
                                #phone-screen, .screen, #chat-list, #world-book-list, .list-container, .form-container, #chat-messages,
                                #wallpaper-screen, #font-settings-screen, #api-settings-screen, #character-selection-screen,
                                #world-book-screen, #world-book-editor-screen, #character-phone-inner-screen, #character-phone-page {
                                    background-color: #000000 !important;
                                }

                                /* 3. 主屏幕专属样式 */
                                #home-screen { background: #111827 !important; }
                                #desktop-dock { background-color: rgba(55, 65, 81, 0.5); }
                                .desktop-app-icon .label, .widget-subtext { color: #e5e7eb; text-shadow: 0 1px 2px rgba(0,0,0,0.7); }
                                #profile-widget .profile-info { background: linear-gradient(to bottom, rgba(28, 28, 30, 0.85) 20%, rgba(28, 28, 30, 0)); color: #f9fafb; }
                                #profile-username, #profile-bio, #profile-location span { color: #f9fafb; }
                                #profile-sub-username, #profile-location { color: #9ca3af; }
                                #profile-location { background-color: rgba(255,255,255,0.1); }
                                .widget-bubble { background-color: rgba(55, 65, 81, 0.9); color: #e5e7eb; }
                                .widget-bubble::after { border-top-color: rgba(55, 65, 81, 0.9); }

                                /* 4. 适配所有页面的头部Header */
                                .header, .qzone-header, .character-phone-header {
                                    background-color: rgba(28, 28, 30, 0.85) !important;
                                    border-bottom-color: var(--border-color) !important;
                                    color: var(--text-primary) !important; 
                                }

                                /* 5. 适配所有通用组件 */
                                #chat-input-area, #chat-list-bottom-nav { background-color: rgba(28, 28, 30, 0.85); border-top-color: var(--border-color); }
                                #chat-input { background-color: var(--secondary-bg); color: var(--text-primary); }
                                .modal-content, #custom-modal { background-color: #2c2c2e; }
                                .modal-header, .modal-footer, .custom-modal-footer, .custom-modal-footer button:first-child { border-color: var(--border-color); }
                                .form-group input, .form-group select, .form-group textarea { background-color: var(--secondary-bg); color: var(--text-primary); border-color: var(--border-color); }
                                .list-item, .chat-list-item-swipe-container:not(:last-child), .chat-group-container, .world-book-group-container { border-bottom-color: var(--border-color) !important; }
                                .chat-group-container:first-of-type { border-top-color: var(--border-color) !important; }
                                .list-item:hover, .chat-list-item:hover { background-color: #2c2c2e; }

                                /* 6. 特殊页面深度适配 */
                                .chat-group-header, .world-book-group-header { background-color: #1c1c1e; }
                                .chat-list-item-content.pinned { background-color: #3a3a3c; }
                                #font-preview, #wallpaper-preview, .font-preset-slot { background-color: #1c1c1e !important; border-color: #38383a !important; }

                                /* 7. 角色手机内部适配 & 全局文字颜色修复 */
                                #character-phone-container { background-color: #000000; }
                                .character-phone-frame { background-color: #111; }
                                #character-chat-history-messages { background-color: #0e0e0e !important; }
                                .character-chat-bubble.received { background-color: #2c2c2e !important; }
                                .character-data-item, .character-bank-transaction, .character-cart-item, .character-browser-item {
                                    background-color: #1c1c1e;
                                    border-color: #38383a;
                                }

                                /* 修复角色手机内文字颜色 */
                                .character-data-item .title,
                                .character-data-item .content,
                                .character-data-item .meta,
                                .cart-item-price,
                                .cart-item-info .title,
                                .character-browser-item .title,
                                .transaction-details .title,
                                .transaction-amount,
                                .character-select-item .name,
                                #character-diary-list .character-data-item .content,
                                #character-diary-list .character-data-item .content h1,
                                #character-diary-list .character-data-item .content h2 {
                                    color: #E0E0E0 !important;
                                }

                                .character-data-item .meta span,
                                #character-diary-list .character-data-item .meta {
                                    color: #9E9E9E !important;
                                }

                                #character-diary-list .character-data-item {
                                    background-color: #26211a;
                                    border-color: #524a3d;
                                    border-left-color: #9e8a70;
                                }

                            `;

							// 把这个新主题添加到数据库
							await db.themes.add({ name: themeName, css: darkModeCss });
							console.log("内置夜间模式已成功创建！");
						} else {
							console.log("内置夜间模式已存在，跳过创建。");
						}
					} catch (error) {
						console.error("检查或创建内置夜间模式时出错:", error);
					}
				}

				/**
				 * 打开并准备聊天记录搜索界面
				 */
				function openChatSearchScreen() {
					const chat = state.chats[state.activeChatId];
					if (!chat) return;

					// 清空旧的搜索条件和结果
					document.getElementById("keyword-search-input").value = "";
					document.getElementById("sender-search-select").innerHTML = "";
					document.getElementById("date-search-input").value = "";
					document.getElementById("chat-search-results-list").innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">输入条件开始搜索</p>';

					// 动态填充"人物"下拉菜单
					const senderSelect = document.getElementById("sender-search-select");
					senderSelect.innerHTML = '<option value="">所有人</option>'; // 默认选项

					const myNickname = chat.isGroup ? chat.settings.myNickname || "我" : "我";
					const myOption = document.createElement("option");
					myOption.value = myNickname;
					myOption.textContent = myNickname;
					senderSelect.appendChild(myOption);

					if (chat.isGroup) {
						chat.members.forEach((member) => {
							const memberOption = document.createElement("option");
							memberOption.value = member.originalName; // 使用本名进行精确匹配
							memberOption.textContent = member.groupNickname; // 显示群昵称给用户看
							senderSelect.appendChild(memberOption);
						});
					} else {
						const aiOption = document.createElement("option");
						aiOption.value = chat.name;
						aiOption.textContent = chat.name;
						senderSelect.appendChild(aiOption);
					}

					// 关闭聊天设置弹窗，并显示搜索界面
					document.getElementById("chat-settings-modal").classList.remove("visible");
					showScreen("chat-search-screen");
				}

				/**
				 * 执行搜索操作
				 */
				function performChatSearch() {
					const chat = state.chats[state.activeChatId];
					if (!chat) {
						// 如果找不到聊天对象，给用户一个明确的提示
						alert("无法执行搜索，因为没有找到当前聊天。");
						return;
					}

					// 获取所有搜索条件
					const keyword = document.getElementById("keyword-search-input").value.trim();
					const senderValue = document.getElementById("sender-search-select").value;
					const dateValue = document.getElementById("date-search-input").value;

					// 将关键词保存到全局变量，以便在渲染结果时用于高亮
					currentSearchKeyword = keyword;

					if (!keyword && !senderValue && !dateValue) {
						alert("请至少输入一个搜索条件！");
						return;
					}

					// 筛选聊天记录
					console.log(`开始搜索: 关键词='${keyword}', 发言人='${senderValue}', 日期='${dateValue}'`);

					const results = chat.history.filter((msg) => {
						// 过滤掉系统消息和对用户隐藏的消息
						if (msg.isHidden || msg.role === "system" || msg.type === "recalled_message") {
							return false;
						}

						// 按日期筛选
						if (dateValue) {
							const msgDate = new Date(msg.timestamp).toISOString().split("T")[0];
							if (msgDate !== dateValue) {
								return false;
							}
						}

						// 按发言人筛选
						if (senderValue) {
							const myNickname = chat.isGroup ? chat.settings.myNickname || "我" : "我";
							let msgSenderName = "";

							if (msg.role === "user") {
								msgSenderName = myNickname;
							} else {
								// AI或群成员的消息
								// 这里我们使用 originalName 来精确匹配，因为群昵称可能会变
								msgSenderName = chat.isGroup ? msg.senderName : chat.name;
							}
							if (msgSenderName !== senderValue) {
								return false;
							}
						}

						// 按关键词筛选
						if (keyword) {
							let contentText = "";
							// 将所有可能包含文本的内容都转换成字符串进行搜索
							if (typeof msg.content === "string") {
								contentText = msg.content;
							} else if (typeof msg.content === "object" && msg.content !== null) {
								// 对于复杂对象，我们可以简单地将它们转为JSON字符串来搜索
								contentText = JSON.stringify(msg.content);
							}

							if (!contentText.toLowerCase().includes(keyword.toLowerCase())) {
								return false;
							}
						}

						return true; // 所有条件都满足
					});

					console.log(`搜索到 ${results.length} 条结果`);

					// 渲染结果
					renderSearchResults(results);
				}

				/**
				 * 渲染搜索结果列表
				 * @param {Array} results - 筛选出的消息数组
				 */
				function renderSearchResults(results) {
					const listEl = document.getElementById("chat-search-results-list");
					listEl.innerHTML = "";
					listEl.scrollTop = 0; // 每次渲染前，都将滚动条重置到顶部

					if (results.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">未找到相关记录</p>';
						return;
					}

					const chat = state.chats[state.activeChatId];
					const myNickname = chat.isGroup ? chat.settings.myNickname || "我" : "我";

					// 为了性能，只渲染最新的100条结果
					results
						.slice(-100)
						.reverse()
						.forEach((msg) => {
							const item = document.createElement("div");
							item.className = "search-result-item";
							item.dataset.timestamp = msg.timestamp; // 关键！用于跳转

							let senderName, senderAvatar;
							if (msg.role === "user") {
								senderName = myNickname;
								senderAvatar = chat.settings.myAvatar;
							} else {
								if (chat.isGroup) {
									senderName = msg.senderName;
									const member = chat.members.find((m) => m.originalName === senderName);
									senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
								} else {
									senderName = chat.name;
									senderAvatar = chat.settings.aiAvatar;
								}
							}

							let contentText = "";
							if (msg.type === "sticker" || (typeof msg.content === "string" && STICKER_REGEX.test(msg.content))) {
								contentText = "[表情]";
							} else if (msg.type === "ai_image" || msg.type === "user_photo" || Array.isArray(msg.content)) {
								contentText = "[图片]";
							} else {
								contentText = String(msg.content);
							}

							item.innerHTML = `
                            <img src="${senderAvatar || defaultAvatar}" class="avatar">
                            <div class="search-result-info">
                                <div class="search-result-meta">
                                    <span class="name">${senderName}</span>
                                    <span class="timestamp">${formatDateStamp(msg.timestamp)}</span>
                                </div>
                                <div class="search-result-content">
                                    ${highlightText(contentText, currentSearchKeyword)}
                                </div>
                            </div>
                        `;
							listEl.appendChild(item);
						});
				}

				/**
				 * 辅助函数：高亮文本中的关键词
				 * @param {string} text - 原始文本
				 * @param {string} keyword - 要高亮的关键词
				 * @returns {string} - 处理后的HTML字符串
				 */
				function highlightText(text, keyword) {
					if (!keyword || !text) {
						return text;
					}
					const regex = new RegExp(keyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"), "gi");
					return text.replace(regex, `<span class="highlight">$&</span>`);
				}

				/**
				 * 点击搜索结果，跳转到对应的消息位置
				 * @param {number} timestamp - 目标消息的时间戳
				 */
				async function jumpToMessage(timestamp) {
					const chat = state.chats[state.activeChatId];
					if (!chat) return;

					const targetIndex = chat.history.findIndex((msg) => msg.timestamp === timestamp);
					if (targetIndex === -1) {
						await showCustomAlert("错误", "找不到该条消息，可能已被删除。");
						return;
					}

					// 1. 切换回聊天界面
					showScreen("chat-interface-screen");
					await new Promise((resolve) => setTimeout(resolve, 50));

					const messagesContainer = document.getElementById("chat-messages");
					messagesContainer.innerHTML = ""; // 清空当前内容

					// 2. 计算要渲染的消息窗口（以目标消息为中心）
					const windowSize = 50; // 和 MESSAGE_RENDER_WINDOW 保持一致
					const startIndex = Math.max(0, targetIndex - Math.floor(windowSize / 2));
					const messagesToRender = chat.history.slice(startIndex);

					// 3. 更新 currentRenderedCount 以同步加载状态
					//    这一步至关重要，它告诉"加载更多"功能下次应该从哪里开始加载
					currentRenderedCount = messagesToRender.length;

					// 4. 如果计算出的起始位置大于0，说明前面还有更早的记录，需要显示"加载更多"按钮
					if (startIndex > 0) {
						prependLoadMoreButton(messagesContainer);
					}

					// 5. 渲染消息窗口和日期戳
					let lastMessageTimestamp = startIndex > 0 ? chat.history[startIndex - 1].timestamp : null;
					messagesToRender.forEach((msg) => {
						if (msg.isHidden) return;
						if (isNewDay(msg.timestamp, lastMessageTimestamp)) {
							const dateStampEl = createDateStampElement(msg.timestamp);
							messagesContainer.appendChild(dateStampEl);
						}
						// 使用 true 作为第三个参数，表示这是初始加载，不应播放动画
						appendMessage(msg, chat, true);
						lastMessageTimestamp = msg.timestamp;
					});

					// 6. 滚动到目标消息并高亮它
					//    使用 setTimeout 确保 DOM 元素已经完全渲染到页面上
					setTimeout(() => {
						const targetMessage = messagesContainer.querySelector(`.message-bubble[data-timestamp="${timestamp}"]`);
						if (targetMessage) {
							// 使用 'auto' 滚动，比 'smooth' 更快速直接
							targetMessage.scrollIntoView({ behavior: "auto", block: "center" });

							// 添加闪烁高亮效果，让用户能注意到
							targetMessage.classList.add("flash");
							setTimeout(() => {
								targetMessage.classList.remove("flash");
							}, 1500);
						}
					}, 100);

					// 7. 我们已经移除了导致页面跳回的 setTimeout(renderChatInterface, ...)
				}

				/**
				 * 通用的图片编辑函数 (本地上传或URL)
				 * @param {string} title - 弹窗标题
				 * @param {string} currentUrl - 当前的图片URL
				 * @returns {Promise<string|null>} - 新的图片URL或null
				 */
				async function getNewImageUrl(title, currentUrl) {
					const choice = await showChoiceModal(title, [
						{ text: "📁 从本地上传", value: "local" },
						{ text: "🌐 使用网络URL", value: "url" },
					]);

					if (choice === "local") {
						return await uploadImageLocally();
					} else if (choice === "url") {
						const url = await showCustomPrompt(title, "请输入新的图片URL", currentUrl, "url");
						if (url && url.trim().startsWith("http")) {
							return url.trim();
						} else if (url !== null) {
							alert("请输入一个有效的URL！");
						}
					}
					return null;
				}

				/**
				 * 打开QQ空间发布器
				 * @param {string} mode - 发布模式 ('shuoshuo' 或其他)
				 */
				async function openQZonePublisher(mode) {
					resetCreatePostModal();
					const modal = document.getElementById("create-post-modal");
					modal.dataset.mode = mode;
					document.getElementById("create-post-modal-title").textContent = "发布动态";

					if (mode === "shuoshuo") {
						modal.querySelector(".post-mode-switcher").style.display = "none";
						modal.querySelector("#image-mode-content").style.display = "none";
						modal.querySelector("#text-image-mode-content").style.display = "none";
						modal.querySelector("#post-public-text").placeholder = "分享新鲜事...";
					} else {
						modal.querySelector(".post-mode-switcher").style.display = "flex";
						modal.querySelector("#image-mode-content").classList.add("active");
						modal.querySelector("#text-image-mode-content").classList.remove("active");
						modal.querySelector("#post-public-text").placeholder = "分享新鲜事...（非必填的公开文字）";
					}

					document.getElementById("post-comments-toggle-group").style.display = "block";

					// 设置可见性选项
					const visibilityGroup = document.getElementById("post-visibility-group");
					const groupsContainer = document.getElementById("post-visibility-groups");
					const visibilityRadios = document.querySelectorAll('input[name="visibility"]');

					visibilityGroup.style.display = "block";
					groupsContainer.innerHTML = ""; // 清空旧的分组列表

					// 从数据库读取你的好友分组
					const groups = await db.qzoneGroups.toArray();
					if (groups.length > 0) {
						groups.forEach((group) => {
							const label = document.createElement("label");
							label.innerHTML = `<input type="checkbox" value="${group.id}"> ${group.name}`;
							groupsContainer.appendChild(label);
						});
					} else {
						groupsContainer.innerHTML = '<p style="color: #8a8a8a; font-size: 13px;">还没有创建任何好友分组哦。</p>';
					}

					// 默认选中"所有人可见"并隐藏分组选择
					visibilityRadios[0].checked = true;
					groupsContainer.style.display = "none";

					// 监听单选按钮的变化
					visibilityRadios.forEach((radio) => {
						radio.onchange = function () {
							groupsContainer.style.display = this.value === "groups" ? "block" : "none";
						};
					});

					modal.classList.add("visible");
				}

				// 主屏幕美化预设核心功能函数

				let activeHomePresetId = null; // 用于追踪当前选中的预设ID

				/**
				 * 启用或禁用预设管理按钮
				 */
				function toggleHomePresetButtons(isEnabled) {
					document.getElementById("apply-home-preset-btn").disabled = !isEnabled;
					document.getElementById("update-home-preset-btn").disabled = !isEnabled;
					document.getElementById("rename-home-preset-btn").disabled = !isEnabled;
					document.getElementById("delete-home-preset-btn").disabled = !isEnabled;
					document.getElementById("export-home-preset-btn").disabled = !isEnabled;
				}

				/**
				 * 加载预设到下拉框
				 */
				async function loadHomeScreenPresetsToDropdown() {
					const selector = document.getElementById("home-preset-selector");
					selector.innerHTML = '<option value="">-- 请选择一个预设 --</option>';
					const presets = await db.homeScreenPresets.toArray();
					presets.forEach((preset) => {
						const option = document.createElement("option");
						option.value = preset.id;
						option.textContent = preset.name;
						selector.appendChild(option);
					});
					activeHomePresetId = null; // 重置选择
					toggleHomePresetButtons(false); // 默认禁用按钮
				}

				/**
				 * 当用户从下拉框选择一个预设时
				 */
				function handleHomePresetSelection() {
					const selector = document.getElementById("home-preset-selector");
					activeHomePresetId = selector.value ? parseInt(selector.value) : null;
					// 只有当用户确实选择了一个预设时，才启用相关按钮
					toggleHomePresetButtons(!!activeHomePresetId);
				}

				/**
				 * 应用选中的主屏幕预设
				 */
				async function applySelectedHomeScreenPreset() {
					if (!activeHomePresetId) {
						alert("请先从下拉框中选择一个要应用的预设。");
						return;
					}
					const preset = await db.homeScreenPresets.get(activeHomePresetId);
					if (preset && preset.data) {
						// 将预设数据加载到全局状态
						state.globalSettings.widgetData = preset.data;

						if (preset.data.wallpaper) {
							state.globalSettings.wallpaper = preset.data.wallpaper;
						}
						if (preset.data.appIcons) {
							state.globalSettings.appIcons = { ...preset.data.appIcons };
						}

						// 检查预设中是否有appLabels数据，如果有，就加载它
						if (preset.data.appLabels) {
							state.globalSettings.appLabels = { ...preset.data.appLabels };
						} else {
							// 如果这个旧的预设里没有保存App名字，就清空当前的自定义名字，以恢复默认
							state.globalSettings.appLabels = {};
						}

						// 保存所有更新到数据库
						await db.globalSettings.put(state.globalSettings);

						// 依次应用所有设置
						applyGlobalWallpaper();
						applyAppIcons();
						applyAppLabels();
						applyWidgetData();

						alert(`已成功应用预设: "${preset.name}"！`);
						showScreen("home-screen");
					}
				}

				/**
				 * 渲染主屏幕个人资料卡的头像框
				 */
				function renderHomeScreenProfileFrame() {
					// 获取保存的头像框URL
					const frameUrl = state.globalSettings.homeAvatarFrame || "";
					// 找到头像框的img元素
					const frameImg = document.getElementById("profile-avatar-frame");
					if (frameImg) {
						// 如果URL存在，就显示它
						if (frameUrl) {
							frameImg.src = frameUrl;
							frameImg.style.display = "block";
						} else {
							// 如果URL为空（即选择了"无"），就隐藏它
							frameImg.src = "";
							frameImg.style.display = "none";
						}
					}
				}

				/**
				 * 保存当前的主屏幕设置为一个新的预设
				 */
				async function saveCurrentHomeScreenAsPreset() {
					saveAppLabels();
					const presetName = await showCustomPrompt("保存预设", "请为这个主屏幕美化方案起个名字：");
					if (!presetName || !presetName.trim()) {
						if (presetName !== null) alert("名字不能为空！");
						return;
					}

					// 核心：构建一个包含所有主屏幕元素的完整数据对象
					const presetData = {
						// 个人资料卡片
						"profile-banner-img": document.getElementById("profile-banner-img").src,
						"profile-avatar-img": document.getElementById("profile-avatar-img").src,
						homeAvatarFrame: document.getElementById("profile-avatar-frame").src,
						"profile-username": document.getElementById("profile-username").textContent,
						"profile-sub-username": document.getElementById("profile-sub-username").textContent,
						"profile-bio": document.getElementById("profile-bio").textContent,
						"profile-location": document.getElementById("profile-location").innerHTML,

						// 第一页小组件
						"widget-bubble-1": document.getElementById("widget-bubble-1").textContent,
						"widget-image-1": document.getElementById("widget-image-1").src,
						"widget-subtext-1": document.getElementById("widget-subtext-1").textContent,
						"widget-bubble-2": document.getElementById("widget-bubble-2").textContent,
						"widget-image-2": document.getElementById("widget-image-2").src,
						"widget-subtext-2": document.getElementById("widget-subtext-2").textContent,

						// 第二页小组件
						"widget-image-3": document.getElementById("widget-image-3").src,
						"second-page-bubble": document.getElementById("second-page-bubble").textContent,
						"flat-capsule-bubble": document.getElementById("flat-capsule-bubble").textContent,
						"circular-bubble": document.getElementById("circular-bubble").textContent,
						"widget-image-4": document.getElementById("widget-image-4").src,
						"avatar-subtitle": document.getElementById("avatar-subtitle").textContent,
						"bubble-top-left": document.getElementById("bubble-top-left").textContent,
						"bubble-top-right": document.getElementById("bubble-top-right").textContent,
						"bubble-bottom-left": document.getElementById("bubble-bottom-left").textContent,
						"bubble-bottom-right": document.getElementById("bubble-bottom-right").textContent,
						"new-widget-avatar": document.getElementById("new-widget-avatar").src,
						"new-widget-text-1": document.getElementById("new-widget-text-1").textContent,
						"new-widget-text-2": document.getElementById("new-widget-text-2").textContent,
						"new-widget-text-3": document.getElementById("new-widget-text-3").textContent,
						"widget-month-display": document.getElementById("widget-month-display").textContent,

						// App图标和壁纸
						appIcons: { ...state.globalSettings.appIcons },
						appLabels: { ...state.globalSettings.appLabels },
						wallpaper: state.globalSettings.wallpaper,
					};

					// 保存到数据库
					await db.homeScreenPresets.add({ name: presetName.trim(), data: presetData });
					await loadHomeScreenPresetsToDropdown(); // 刷新下拉列表
					alert(`预设 "${presetName.trim()}" 已保存！`);
				}

				/**
				 * 更新选中的主屏幕预设
				 */
				async function updateSelectedHomeScreenPreset() {
					saveAppLabels();
					if (!activeHomePresetId) {
						alert("请先选择一个要更新的预设。");
						return;
					}

					const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
					if (!currentPreset) return;

					const confirmed = await showCustomConfirm("确认更新", `确定要用当前的主屏幕布局覆盖预设 "${currentPreset.name}" 吗？`, { confirmButtonClass: "btn-danger" });

					if (confirmed) {
						// 构建与保存时完全相同的完整数据对象
						const presetData = {
							"profile-banner-img": document.getElementById("profile-banner-img").src,
							"profile-avatar-img": document.getElementById("profile-avatar-img").src,
							homeAvatarFrame: document.getElementById("profile-avatar-frame").src,
							"profile-username": document.getElementById("profile-username").textContent,
							"profile-sub-username": document.getElementById("profile-sub-username").textContent,
							"profile-bio": document.getElementById("profile-bio").textContent,
							"profile-location": document.getElementById("profile-location").innerHTML,
							"widget-bubble-1": document.getElementById("widget-bubble-1").textContent,
							"widget-image-1": document.getElementById("widget-image-1").src,
							"widget-subtext-1": document.getElementById("widget-subtext-1").textContent,
							"widget-bubble-2": document.getElementById("widget-bubble-2").textContent,
							"widget-image-2": document.getElementById("widget-image-2").src,
							"widget-subtext-2": document.getElementById("widget-subtext-2").textContent,
							"widget-image-3": document.getElementById("widget-image-3").src,
							"second-page-bubble": document.getElementById("second-page-bubble").textContent,
							"flat-capsule-bubble": document.getElementById("flat-capsule-bubble").textContent,
							"circular-bubble": document.getElementById("circular-bubble").textContent,
							"widget-image-4": document.getElementById("widget-image-4").src,
							"avatar-subtitle": document.getElementById("avatar-subtitle").textContent,
							"bubble-top-left": document.getElementById("bubble-top-left").textContent,
							"bubble-top-right": document.getElementById("bubble-top-right").textContent,
							"bubble-bottom-left": document.getElementById("bubble-bottom-left").textContent,
							"bubble-bottom-right": document.getElementById("bubble-bottom-right").textContent,
							"new-widget-avatar": document.getElementById("new-widget-avatar").src,
							"new-widget-text-1": document.getElementById("new-widget-text-1").textContent,
							"new-widget-text-2": document.getElementById("new-widget-text-2").textContent,
							"new-widget-text-3": document.getElementById("new-widget-text-3").textContent,
							"widget-month-display": document.getElementById("widget-month-display").textContent,
							appIcons: { ...state.globalSettings.appIcons },
							appLabels: { ...state.globalSettings.appLabels },
							wallpaper: state.globalSettings.wallpaper,
						};

						await db.homeScreenPresets.update(activeHomePresetId, { data: presetData });
						await showCustomAlert("成功", `预设 "${currentPreset.name}" 已更新！`);
					}
				}

				/**
				 * 重命名选中的预设
				 */
				async function renameSelectedHomeScreenPreset() {
					if (!activeHomePresetId) return;
					const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
					const newName = await showCustomPrompt("重命名", "请输入新的名称：", currentPreset.name);
					if (newName && newName.trim()) {
						await db.homeScreenPresets.update(activeHomePresetId, { name: newName.trim() });
						await loadHomeScreenPresetsToDropdown();
						document.getElementById("home-preset-selector").value = activeHomePresetId;
						alert("重命名成功！");
					}
				}

				/**
				 * 删除选中的预设
				 */
				async function deleteSelectedHomeScreenPreset() {
					if (!activeHomePresetId) return;
					const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
					const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${currentPreset.name}" 吗？`, { confirmButtonClass: "btn-danger" });
					if (confirmed) {
						await db.homeScreenPresets.delete(activeHomePresetId);
						await loadHomeScreenPresetsToDropdown(); // 这会自动重置选择并禁用按钮
						alert("预设已删除。");
					}
				}

				/**
				 * 导出选中的预设
				 */
				async function exportHomeScreenPreset() {
					if (!activeHomePresetId) return;
					const preset = await db.homeScreenPresets.get(activeHomePresetId);
					const blob = new Blob([JSON.stringify(preset, null, 2)], { type: "application/json" });
					const url = URL.createObjectURL(blob);
					const a = document.createElement("a");
					a.href = url;
					a.download = `${preset.name}-HomeScreen.json`;
					a.click();
					URL.revokeObjectURL(url);
				}

				/**
				 * 导入预设文件
				 */
				function importHomeScreenPreset(file) {
					if (!file) return;
					const reader = new FileReader();
					reader.onload = async (e) => {
						try {
							const data = JSON.parse(e.target.result);
							// 简单验证一下文件内容是不是我们需要的格式
							if (data.name && data.data) {
								await db.homeScreenPresets.add({ name: `${data.name} (导入)`, data: data.data });
								await loadHomeScreenPresetsToDropdown();
								alert(`预设 "${data.name}" 导入成功！`);
							} else {
								alert("导入失败：文件格式不正确。");
							}
						} catch (error) {
							alert(`导入失败：文件解析错误。${error.message}`);
						}
					};
					reader.readAsText(file);
				}

				/**
				 * 角色表情包管理核心功能
				 */
				async function openCharStickerManager() {
					if (!state.activeChatId) return;
					const chat = state.chats[state.activeChatId];
					// 根据聊天类型显示不同的标题
					if (chat.isGroup) {
						document.getElementById("sticker-manager-title").textContent = `"${chat.name}"的群表情`;
					} else {
						document.getElementById("sticker-manager-title").textContent = `"${chat.name}"的表情包`;
					}

					// 默认显示专属表情
					document.getElementById("sticker-tab-exclusive").click();

					await renderCharStickers("exclusive");
					await renderCharStickers("common");

					showScreen("char-sticker-manager-screen");
				}

				/**
				 * 渲染角色表情包
				 * @param {string} type - 表情包类型 ('exclusive' 专属或 'common' 通用)
				 */
				async function renderCharStickers(type) {
					const isExclusive = type === "exclusive";
					const gridId = isExclusive ? "exclusive-sticker-grid" : "common-sticker-grid";
					const grid = document.getElementById(gridId);
					grid.innerHTML = "";

					let stickers = [];
					if (isExclusive) {
						const chat = state.chats[state.activeChatId];
						stickers = chat.settings.stickerLibrary || [];
					} else {
						state.charStickers = await db.charStickers.toArray();
						stickers = state.charStickers || [];
					}

					if (stickers.length === 0) {
						grid.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">这里还是空的哦~</p>`;
						return;
					}

					// 为了正确删除，我们需要原始索引
					const stickersWithIndex = stickers.map((sticker, index) => ({ ...sticker, originalIndex: index }));

					stickersWithIndex.forEach((sticker) => {
						const item = document.createElement("div");
						item.className = "sticker-item";
						item.style.backgroundImage = `url(${sticker.url})`;
						item.title = sticker.name;

						// 使用 URL 作为唯一标识符，因为它在两种库中都是唯一的
						const uniqueId = sticker.url;

						if (isCharStickerSelectionMode) {
							// 选择模式下的逻辑
							item.classList.add("in-selection-mode");
							if (selectedCharStickers.has(uniqueId)) {
								item.classList.add("selected");
							}

							item.addEventListener("click", () => {
								item.classList.toggle("selected");
								if (selectedCharStickers.has(uniqueId)) {
									selectedCharStickers.delete(uniqueId);
								} else {
									selectedCharStickers.add(uniqueId);
								}
								const deleteBtn = document.getElementById("delete-selected-char-stickers-btn");
								deleteBtn.textContent = `删除已选 (${selectedCharStickers.size})`;
								deleteBtn.disabled = selectedCharStickers.size === 0;
							});
						} else {
							// 正常模式下的逻辑（只有删除按钮）
							const deleteBtn = document.createElement("div");
							deleteBtn.className = "delete-btn";
							deleteBtn.innerHTML = "×";
							deleteBtn.style.display = "block"; // 默认就显示
							deleteBtn.onclick = async (e) => {
								e.stopPropagation();
								const confirmed = await showCustomConfirm("删除表情", `确定要删除表情 "${sticker.name}" 吗？`, { confirmButtonClass: "btn-danger" });
								if (confirmed) {
									if (isExclusive) {
										const chat = state.chats[state.activeChatId];
										chat.settings.stickerLibrary.splice(sticker.originalIndex, 1);
										await db.chats.put(chat);
									} else {
										await db.charStickers.delete(sticker.id);
									}
									await renderCharStickers(type); // 刷新
								}
							};
							item.appendChild(deleteBtn);
						}
						grid.appendChild(item);
					});
				}

				/**
				 * 处理批量删除选中的角色表情
				 */
				async function handleBulkDeleteCharStickers() {
					if (selectedCharStickers.size === 0) return;

					const confirmed = await showCustomConfirm("确认删除", `确定要删除选中的 ${selectedCharStickers.size} 个表情吗？`, { confirmButtonClass: "btn-danger" });

					if (confirmed) {
						const activeTab = document.querySelector("#char-sticker-manager-screen .frame-tab.active");
						const type = activeTab.id === "sticker-tab-exclusive" ? "exclusive" : "common";

						if (type === "exclusive") {
							const chat = state.chats[state.activeChatId];
							chat.settings.stickerLibrary = chat.settings.stickerLibrary.filter((s) => !selectedCharStickers.has(s.url));
							await db.chats.put(chat);
						} else {
							// common
							const stickersToDelete = await db.charStickers.where("url").anyOf(Array.from(selectedCharStickers)).toArray();
							const idsToDelete = stickersToDelete.map((s) => s.id);
							if (idsToDelete.length > 0) {
								await db.charStickers.bulkDelete(idsToDelete);
							}
						}

						// 退出编辑模式
						toggleCharStickerSelectionMode();

						alert("选中的表情已删除。");
					}
				}

				/**
				 * 批量添加表情包到指定库
				 * @param {string} type - 表情包类型 ('exclusive' 专属或 'common' 通用)
				 */
				async function bulkAddCharStickers(type) {
					const textInput = await showCustomPrompt(`批量添加${type === "exclusive" ? "专属" : "通用"}表情`, "一行一个，格式：\n猫猫喝水 https://..../cat.gif", "", "textarea");
					if (!textInput || !textInput.trim()) return;

					const lines = textInput.trim().split("\n");
					const newStickers = [];
					let successCount = 0;

					lines.forEach((line, index) => {
						line = line.trim();
						if (!line) return;

						// 使用更智能、更健壮的分割逻辑
						let name = "";
						let url = "";
						let splitIndex = -1;
						const httpIndex = line.indexOf("http");
						const dataIndex = line.indexOf("data:image");
						if (httpIndex > -1) {
							splitIndex = httpIndex;
						} else if (dataIndex > -1) {
							splitIndex = dataIndex;
						}

						if (splitIndex > 0) {
							name = line.substring(0, splitIndex).trim();
							url = line.substring(splitIndex).trim();
							if (name.endsWith(":") || name.endsWith("：")) {
								name = name.slice(0, -1).trim();
							}
						}

						if (name && (url.startsWith("http") || url.startsWith("data:image"))) {
							const stickerData = { url, name };
							if (type !== "exclusive") {
								stickerData.id = "char_sticker_" + (Date.now() + index);
							}
							newStickers.push(stickerData);
							successCount++;
						}
					});

					if (newStickers.length > 0) {
						if (type === "exclusive") {
							const chat = state.chats[state.activeChatId];
							chat.settings.stickerLibrary.push(...newStickers);
							await db.chats.put(chat);
						} else {
							await db.charStickers.bulkAdd(newStickers);
						}
						await renderCharStickers(type); // 在数据库操作后，统一重新渲染
					}
					await showCustomAlert("导入报告", `成功导入：${successCount} 个表情。`);
				}

				/**
				 * 从本地上传表情到指定库
				 * @param {string} type - 表情包类型 ('exclusive' 专属或 'common' 通用)
				 */
				async function uploadCharStickersLocal(type) {
					const input = document.getElementById("char-sticker-upload-input"); // 应该长这样
					input.onchange = async (event) => {
						const files = event.target.files;
						if (!files.length) return;

						const stickersToAdd = []; // 先收集所有要添加的表情

						for (const file of files) {
							const name = await showCustomPrompt("为表情命名", "请输入表情名称", file.name.replace(/\.[^/.]+$/, ""));
							if (name && name.trim()) {
								const base64Url = await new Promise((resolve) => {
									const reader = new FileReader();
									reader.onload = (e) => resolve(e.target.result);
									reader.readAsDataURL(file);
								});

								const stickerData = { name: name.trim(), url: base64Url };
								if (type !== "exclusive") {
									stickerData.id = "char_sticker_" + Date.now() + Math.random();
								}
								stickersToAdd.push(stickerData);
							}
						}

						if (stickersToAdd.length > 0) {
							if (type === "exclusive") {
								const chat = state.chats[state.activeChatId];
								chat.settings.stickerLibrary.push(...stickersToAdd);
								await db.chats.put(chat);
							} else {
								await db.charStickers.bulkAdd(stickersToAdd);
							}
							await renderCharStickers(type); // 在数据库操作后，统一重新渲染
							alert(`已成功上传 ${stickersToAdd.length} 个表情！`);
						}

						event.target.value = null;
					};
					input.click();
				}

				/**
				 * 显示指定的角色表情包标签页
				 * @param {'exclusive' | 'common'} type - 要显示的标签页类型
				 */
				function showCharStickerTab(type) {
					// 切换标签按钮的 'active' 状态
					document.querySelectorAll(".char-sticker-tab-btn").forEach((btn) => {
						btn.classList.toggle("active", btn.dataset.type === type);
					});

					// 切换内容区域的显示
					document.querySelectorAll(".sticker-tab-content").forEach((content) => {
						content.classList.toggle("active", content.id === `${type}-sticker-content`);
					});

					// 渲染对应标签页的表情
					// (这一步确保每次切换标签时，表情都会刷新)
					renderCharStickers(type);
				}

				/**
				 * 塔罗牌占卜功能核心
				 */
				let activeTarotReading = null; // 用于暂存当前占卜的结果

				// 牌阵信息定义
				const TAROT_SPREADS = {
					single: { name: "单张牌 - 快速指引", count: 1, positions: ["核心指引"] },
					three_past_present_future: { name: "三张牌 - 过去/现在/未来", count: 3, positions: ["过去", "现在", "未来"] },
					three_situation_challenge_advice: { name: "三张牌 - 情境/挑战/建议", count: 3, positions: ["情境", "挑战", "建议"] },
					celtic_cross: { name: "凯尔特十字 - 深度分析", count: 10, positions: ["现状", "挑战", "根基", "过去", "目标", "未来", "自我认知", "外部影响", "希望与恐惧", "最终结果"] },
				};

				// 打开塔罗牌占卜主模态框
				function openTarotModal() {
					document.getElementById("tarot-divination-modal").classList.add("visible");
					document.getElementById("tarot-setup-view").style.display = "block";
					document.getElementById("tarot-result-view").style.display = "none";
					document.getElementById("tarot-history-view").style.display = "none";
					document.getElementById("tarot-question-input").value = "";
				}

				// 执行抽牌逻辑
				function handleDrawCards() {
					const question = document.getElementById("tarot-question-input").value.trim();
					const spreadType = document.getElementById("tarot-spread-select").value;
					const orientation = document.querySelector('input[name="tarot-orientation"]:checked').value;

					if (!question) {
						alert("请输入您的问题或关注点。");
						return;
					}

					const spreadInfo = TAROT_SPREADS[spreadType];
					const deck = [...TAROT_DECK];

					// 洗牌
					for (let i = deck.length - 1; i > 0; i--) {
						const j = Math.floor(Math.random() * (i + 1));
						[deck[i], deck[j]] = [deck[j], deck[i]];
					}

					// 抽牌
					const drawnCardsRaw = deck.slice(0, spreadInfo.count);
					const drawnCards = drawnCardsRaw.map((card, index) => {
						const isReversed = orientation === "reversed" && Math.random() < 0.5;
						return {
							...card,
							isReversed: isReversed,
							position: spreadInfo.positions[index],
						};
					});

					activeTarotReading = {
						question: question,
						spread: spreadInfo,
						cards: drawnCards,
						timestamp: Date.now(),
					};

					displayTarotResults(activeTarotReading);
				}

				// 显示占卜结果 (纯文字版)
				function displayTarotResults(reading) {
					const displayEl = document.getElementById("tarot-result-display");
					displayEl.innerHTML = ""; // 清空

					// 显示问题
					const questionEl = document.createElement("div");
					questionEl.className = "tarot-result-question";
					questionEl.textContent = `您的问题是：“${reading.question}”`;
					displayEl.appendChild(questionEl);

					const container = document.createElement("div");
					container.className = "tarot-spread-container";

					reading.cards.forEach((card) => {
						const cardWrapper = document.createElement("div");
						cardWrapper.className = "tarot-card-wrapper";

						cardWrapper.innerHTML = `
                            <div class="tarot-card-position">[${card.position}]</div>
                            <div class="tarot-card-name">${card.name} ${card.isReversed ? "(逆位)" : "(正位)"}</div>
                        `;
						container.appendChild(cardWrapper);
					});

					displayEl.appendChild(container);

					// 切换视图
					document.getElementById("tarot-setup-view").style.display = "none";
					document.getElementById("tarot-result-view").style.display = "flex";
				}

				// AI智能解读最终版
				async function sendTarotReadingToChat() {
					if (!activeTarotReading || !state.activeChatId) return;

					const chat = state.chats[state.activeChatId];
					const { proxyUrl, apiKey, model } = state.apiConfig;

					if (!proxyUrl || !apiKey || !model) {
						alert("请先在API设置中配置好才能触发AI解读哦！");
						return;
					}

					// 关闭弹窗，并显示“正在解读”的提示
					document.getElementById("tarot-divination-modal").classList.remove("visible");
					await showCustomAlert("请稍候...", "塔罗师正在为你连接星辰，解读牌面...");

					try {
						const reading = activeTarotReading;

						// 给“塔罗师AI”一个更专业、更结构化的指令 (Prompt)
						const cardDetails = reading.cards
							.map((card) => {
								const orientation = card.isReversed ? "逆位" : "正位";
								const meaning = card.isReversed ? card.reversed : card.upright;
								return `- ${card.position}: ${card.name} (${orientation})，象征: ${meaning}`;
							})
							.join("\n");

						const tarotMasterPrompt = `
                            # 角色
                            你是一位世界级的塔罗牌解读大师，以深刻的洞察力、清晰的表达和富有同情心的指引而闻名。

                            # 核心任务
                            为用户提供一次全面、结构化且易于理解的塔罗牌解读。你的解读必须严格遵循下面的输出结构。

                            # 输出结构 (必须严格遵守)
                            你的回答必须包含以下三个部分，并使用Markdown加粗标题来分隔：

                            1.  **✨ 综合解读 (Overall Interpretation):**
                                首先，根据所有牌面的整体感觉，给出一个高度概括的、1-2句话的核心结论或氛围描述。

                            2.  **🃏 牌面详解 (Card Details):**
                                然后，逐一分析每一张牌。对于每一张牌，你必须：
                                -   使用格式 \`**[牌位名称] - [牌名] ([正位/逆位])**\` 作为小标题。
                                -   详细解释这张牌在这个特定牌位上，是如何回应用户的问题的。
                                -   将牌的象征意义与用户的具体情境（问题）紧密结合起来进行分析。

                            3.  **💡 核心建议 (Key Advice):**
                                最后，综合所有牌的信息，为用户提供一个明确、具体、可操作的行动建议或心态指引。

                            # 指导原则
                            - **故事性**: 将所有牌的含义编织成一个连贯的叙事，而不是简单地罗列关键词。
                            - **相关性**: 始终将解读直接与用户提出的具体问题联系起来。
                            - **清晰易懂**: 避免使用过于神秘或专业的术语。用平实的语言解释复杂的概念。
                            - **深度而非罗列**: 绝对不要只是重复我提供给你的“象征”关键词。你必须在这些关键词的基础上进行综合、提炼和深化，给出你作为大师的独特见解。

                            # 占卜信息
                            - **用户的问题**: "${reading.question}"
                            - **使用的牌阵**: ${reading.spread.name}
                            - **抽到的牌及基础含义**:
                            ${cardDetails}

                            # 最终指令
                            你的最终输出【只能是】完整的、格式化后的解读文本。不要添加任何“好的，这是你的解读：”之类的对话性开场白。
                        `;

						// 发起API调用，让AI扮演塔罗师
						let isGemini = proxyUrl === GEMINI_API_URL;
						let messagesForApi = [{ role: "user", content: tarotMasterPrompt }];
						let geminiConfig = toGeminiRequestData(model, apiKey, tarotMasterPrompt, messagesForApi, isGemini);

						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8 }),
							  });

						if (!response.ok) {
							throw new Error(`API请求失败: ${await response.text()}`);
						}

						const data = await response.json();
						const interpretation = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).trim();

						// 创建对用户可见的“系统解读”消息
						const systemMessageVisible = {
							role: "system",
							type: "pat_message", // 复用居中灰色气泡样式
							content: `🔮 **塔罗牌解读** 🔮\n\n**您的问题**：“${reading.question}”\n\n${interpretation}`,
							timestamp: Date.now(),
						};
						chat.history.push(systemMessageVisible);
						appendMessage(systemMessageVisible, chat);

						// 创建给角色Char看的隐藏指令
						const hiddenInstruction = {
							role: "system",
							content: `[系统指令：刚刚系统为用户进行了一次塔罗牌占卜，解读结果是：“${interpretation}”。现在，请你以角色的身份，和用户一起讨论这个结果。]`,
							timestamp: Date.now() + 1, // 确保时间戳在后
							isHidden: true,
						};
						chat.history.push(hiddenInstruction);

						// 保存所有数据
						await saveTarotReading(activeTarotReading);
						await db.chats.put(chat);
						renderChatList();

						// 我们在这里删除了 triggerAiResponse()，不再自动触发Char！

						activeTarotReading = null;
					} catch (error) {
						console.error("塔罗牌AI解读失败:", error);
						await showCustomAlert("解读失败", `抱歉，连接塔罗师时出现了一点问题：\n\n${error.message}`);
						activeTarotReading = null;
					}
				}

				// 保存占卜记录到数据库
				async function saveTarotReading(reading) {
					// 为了节省空间，我们只保存解读文本，而不是整个牌组对象
					const interpretationText =
						`牌阵: ${reading.spread.name}\n` +
						reading.cards
							.map((card, index) => {
								const orientationText = card.isReversed ? "逆位" : "正位";
								const meaning = card.isReversed ? card.reversed : card.upright;
								return `[${card.position}]: ${card.name} (${orientationText}) - ${meaning}`;
							})
							.join("\n");

					await db.tarotReadings.add({
						question: reading.question,
						interpretation: interpretationText,
						timestamp: reading.timestamp,
					});
				}

				// 打开历史记录界面
				async function openTarotHistory() {
					const readings = await db.tarotReadings.orderBy("timestamp").reverse().toArray();
					renderTarotHistory(readings);
					document.getElementById("tarot-setup-view").style.display = "none";
					document.getElementById("tarot-history-view").style.display = "flex";
				}

				// 渲染历史记录列表
				function renderTarotHistory(readings) {
					const listEl = document.getElementById("tarot-history-list");
					listEl.innerHTML = "";
					if (readings.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">还没有占卜历史哦</p>';
						return;
					}
					readings.forEach((reading) => {
						const item = document.createElement("div");
						item.className = "tarot-history-item";
						item.innerHTML = `
                            <div class="question">${reading.question}</div>
                            <div class="details">${new Date(reading.timestamp).toLocaleString()}</div>
                            <button class="tarot-history-delete-btn" data-id="${reading.id}">×</button>
                        `;
						listEl.appendChild(item);
					});
				}

				// 删除一条历史记录
				async function deleteTarotReading(readingId) {
					const confirmed = await showCustomConfirm("确认删除", "确定要删除这条占卜历史吗？", { confirmButtonClass: "btn-danger" });
					if (confirmed) {
						await db.tarotReadings.delete(readingId);
						openTarotHistory(); // 重新加载历史记录
					}
				}

				/**
				 * 应用主屏幕图标和小组件的文字颜色
				 * @param {string} color - 颜色代码, e.g., '#FFFFFF'
				 */
				function applyHomeIconWidgetTextColor(color) {
					const phoneScreen = document.getElementById("phone-screen");
					if (phoneScreen && color) {
						phoneScreen.style.setProperty("--home-icon-widget-text-color", color);
					}
				}

				/**
				 * 将时长字符串（如“2.5小时”, "30m"）解析为分钟数
				 * @param {string} durationString - 时长描述文本
				 * @returns {number} - 对应的分钟数
				 */
				function parseDurationToMinutes(durationString) {
					if (!durationString || typeof durationString !== "string") return 0;

					const text = durationString.toLowerCase();
					const num = parseFloat(text.match(/(\d+(\.\d+)?)/)?.[0]) || 0;

					if (text.includes("小时") || text.includes("h")) {
						return num * 60;
					}
					if (text.includes("分钟") || text.includes("m")) {
						return num;
					}
					// 如果没有单位，但数值大于等于10，我们猜测是分钟
					if (num >= 10) {
						return num;
					}
					// 其他情况（如数值很小且无单位），猜测是小时
					return num * 60;
				}

				/**
				 * 将总分钟数格式化为 "X小时Y分钟" 的字符串
				 * @param {number} totalMinutes - 总分钟数
				 * @returns {string} - 格式化后的时长字符串
				 */
				function formatMinutesToDuration(totalMinutes) {
					if (totalMinutes < 1) return "不到1分钟";

					const hours = Math.floor(totalMinutes / 60);
					const minutes = Math.round(totalMinutes % 60);

					if (hours > 0 && minutes > 0) {
						return `${hours}小时${minutes}分钟`;
					} else if (hours > 0) {
						return `${hours}小时`;
					} else {
						return `${minutes}分钟`;
					}
				}

				// 宠物功能核心函数

				let currentPetData = null; // 用于暂存正在编辑的宠物数据
				let isPetDragging = false; // 标记是否正在拖动宠物
				let petDragOffset = { x: 0, y: 0 };

				/**
				 * 打开宠物主面板（设置与互动）
				 */
				async function openPetModal() {
					if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
						alert("只有在单人聊天中才能养宠物哦！");
						return;
					}
					const chat = state.chats[state.activeChatId];

					// 核心判断：检查是否已领养
					if (!chat.settings.petAdopted) {
						// 如果未领养，弹出确认框
						const confirmed = await showCustomConfirm("领养新宠物", `你还没有为“${chat.name}”领养宠物，要现在开启宠物系统吗？`, { confirmText: "现在领养" });

						if (confirmed) {
							// 用户同意领养
							chat.settings.petAdopted = true;
							// 创建一个全新的默认宠物对象
							chat.settings.pet = {
								type: "无",
								name: "",
								image: "🥚",
								persona: "一只可爱的小宠物，对世界充满好奇。",
								petChatHistory: [],
								isCustomImage: false,
								display: { show: false, size: 100, top: "80%", left: "50%" },
								status: {
									hunger: 100,
									happiness: 100,
									intimacyToUser: 50,
									intimacyToChar: 50,
									lastUpdated: Date.now(),
								},
							};
							await db.chats.put(chat);
							alert(`恭喜！你已成功为“${chat.name}”开启宠物系统！现在来为它设置一下吧。`);
							// 领养成功后，再次调用本函数，这次会直接进入设置界面
							openPetModal();
						}
						// 如果用户取消，则什么也不做
						return;
					}

					// --- 如果已经领养，则执行原来的显示逻辑 ---
					currentPetData = JSON.parse(JSON.stringify(chat.settings.pet));

					document.getElementById("pet-type-input").value = currentPetData.type === "无" ? "" : currentPetData.type;
					document.getElementById("pet-name-input").value = currentPetData.name;
					document.getElementById("pet-image-input").value = currentPetData.image;
					document.getElementById("pet-display-toggle").checked = currentPetData.display.show;
					document.getElementById("pet-size-slider").value = currentPetData.display.size;
					document.getElementById("pet-size-value").textContent = `${currentPetData.display.size}px`;
					document.getElementById("pet-persona-input").value = currentPetData.persona || "";

					updatePetPreview();

					if (currentPetData.type !== "无") {
						document.getElementById("pet-stats-area").style.display = "flex";
						updatePetStatusUI(currentPetData);
					} else {
						document.getElementById("pet-stats-area").style.display = "none";
					}

					const positionControls = document.getElementById("pet-position-controls");
					positionControls.style.display = currentPetData.display.show ? "block" : "none";

					document.getElementById("pet-modal").classList.add("visible");
				}

				/**
				 * 计算并应用宠物的数值衰减
				 * @param {object} pet - 宠物对象
				 * @returns {boolean} - 如果数值发生了变化，返回 true
				 */
				function applyPetDecay(pet) {
					if (!pet || !pet.status) return false;

					const now = Date.now();
					const lastUpdated = pet.status.lastUpdated || now;
					const timeElapsed = now - lastUpdated;

					// 计算过去了多少个衰减周期
					const intervalsPassed = Math.floor(timeElapsed / PET_DECAY_INTERVAL);

					if (intervalsPassed > 0) {
						// 计算总共要衰减多少
						const totalHungerDecay = intervalsPassed * PET_DECAY_AMOUNT.hunger;
						const totalHappinessDecay = intervalsPassed * PET_DECAY_AMOUNT.happiness;

						// 应用衰减，确保不低于0
						pet.status.hunger = Math.max(0, pet.status.hunger - totalHungerDecay);
						pet.status.happiness = Math.max(0, pet.status.happiness - totalHappinessDecay);

						// 更新最后更新时间，只加上已经计算过的周期的时间，避免丢失零头时间
						pet.status.lastUpdated = lastUpdated + intervalsPassed * PET_DECAY_INTERVAL;

						console.log(`宠物"${pet.name}"数值衰减: ${intervalsPassed}个周期, 饱食度-${totalHungerDecay}, 心情-${totalHappinessDecay}`);
						return true; // 数值已改变
					}

					return false; // 数值未改变
				}

				/**
				 * 停止当前的宠物衰减计时器
				 */
				function stopPetDecayTimer() {
					if (petDecayTimer) {
						clearInterval(petDecayTimer);
						petDecayTimer = null;
						// console.log("宠物衰减计时器已停止。");
					}
				}

				/**
				 * 为当前聊天中的宠物启动衰减计时器
				 */
				function startPetDecayTimer() {
					stopPetDecayTimer(); // 先确保停止任何旧的计时器

					const chat = state.chats[state.activeChatId];
					if (!chat || !chat.settings.pet || chat.settings.pet.type === "无") {
						return; // 如果当前聊天没有宠物，则不启动
					}

					// console.log(`为宠物"${chat.settings.pet.name}"启动衰减计时器。`);

					// 使用 setInterval 定期检查并应用衰减
					petDecayTimer = setInterval(async () => {
						const currentChat = state.chats[state.activeChatId];
						if (!currentChat) {
							// 安全检查，如果聊天已关闭则停止计时器
							stopPetDecayTimer();
							return;
						}
						const pet = currentChat.settings.pet;

						if (applyPetDecay(pet)) {
							// 如果数值变化了，更新UI并保存到数据库
							// 只有当宠物面板打开时才需要更新UI
							if (document.getElementById("pet-modal").classList.contains("visible")) {
								updatePetStatusUI(pet);
							}
							await db.chats.put(currentChat);
						}
					}, 60 * 1000); // 每分钟检查一次，是否到达了衰减周期
				}

				/**
				 * 更新宠物数值面板的UI显示
				 * @param {object} petData - 宠物的数据对象
				 */
				function updatePetStatusUI(petData) {
					const hunger = petData.status.hunger || 0;
					const happiness = petData.status.happiness || 0;
					// 获取亲密度数值
					const intimacyToUser = petData.status.intimacyToUser || 0;
					const intimacyToChar = petData.status.intimacyToChar || 0;

					const hungerFill = document.querySelector("#pet-hunger-bar .stat-bar-fill");
					const happinessFill = document.querySelector("#pet-happiness-bar .stat-bar-fill");
					// 获取亲密度进度条元素
					const intimacyUserFill = document.querySelector("#pet-intimacy-user-bar .stat-bar-fill");
					const intimacyCharFill = document.querySelector("#pet-intimacy-char-bar .stat-bar-fill");

					if (hungerFill) {
						hungerFill.style.width = `${hunger}%`;
						hungerFill.textContent = `${hunger}%`;
					}
					if (happinessFill) {
						happinessFill.style.width = `${happiness}%`;
						happinessFill.textContent = `${happiness}%`;
					}
					// 渲染亲密度进度条
					if (intimacyUserFill) {
						intimacyUserFill.style.width = `${intimacyToUser}%`;
						intimacyUserFill.textContent = `${intimacyToUser}%`;
					}
					if (intimacyCharFill) {
						intimacyCharFill.style.width = `${intimacyToChar}%`;
						intimacyCharFill.textContent = `${intimacyToChar}%`;
					}
				}

				/**
				 * 在弹窗中更新宠物的预览
				 */
				function updatePetPreview() {
					const previewDisplay = document.getElementById("pet-preview-display");
					const nameEl = document.getElementById("pet-preview-name");
					const typeEl = document.getElementById("pet-preview-type");

					const imageInput = document.getElementById("pet-image-input").value.trim();

					if (imageInput.startsWith("http") || imageInput.startsWith("data:image")) {
						previewDisplay.innerHTML = `<img src="${imageInput}" style="width: 60px; height: 60px; object-fit: contain;">`;
					} else {
						previewDisplay.textContent = imageInput || "🥚";
					}

					nameEl.textContent = document.getElementById("pet-name-input").value.trim() || "(未命名)";
					typeEl.textContent = document.getElementById("pet-type-input").value.trim() || "物种";
				}

				/**
				 * 保存宠物设置
				 */
				async function savePetSettings() {
					const chat = state.chats[state.activeChatId];

					// 从UI读取数据
					const type = document.getElementById("pet-type-input").value.trim() || "无";
					const name = document.getElementById("pet-name-input").value.trim();
					const image = document.getElementById("pet-image-input").value.trim() || "🥚";

					const newPetSettings = {
						...currentPetData, // 保留如位置等未在主面板修改的属性
						type: type,
						name: name,
						image: image,
						persona: document.getElementById("pet-persona-input").value.trim(),
						isCustomImage: image.startsWith("http") || image.startsWith("data:image"),
						display: {
							...currentPetData.display,
							show: document.getElementById("pet-display-toggle").checked,
							size: parseInt(document.getElementById("pet-size-slider").value),
						},
					};

					// 更新到 state 和数据库
					chat.settings.pet = newPetSettings;
					await db.chats.put(chat);

					// 刷新聊天界面上的宠物
					renderChatPet();

					document.getElementById("pet-modal").classList.remove("visible");
					currentPetData = null; // 清理临时数据
					alert("宠物信息已保存！");
				}

				/**
				 * 在聊天界面上渲染宠物
				 */
				function renderChatPet() {
					const chat = state.chats[state.activeChatId];
					const petContainer = document.getElementById("chat-pet-container");
					const petEl = document.getElementById("chat-pet");

					if (!chat || chat.isGroup || !chat.settings.petAdopted || !chat.settings.pet || !chat.settings.pet.display.show) {
						petEl.style.display = "none";
						return;
					}

					const pet = chat.settings.pet;
					petEl.style.display = "block";

					if (pet.isCustomImage) {
						petEl.innerHTML = `<img src="${pet.image}" alt="${pet.name}">`;
					} else {
						petEl.innerHTML = pet.image;
					}

					// 应用样式
					petEl.style.fontSize = `${pet.display.size}px`;
					petEl.style.width = `${pet.display.size}px`;
					petEl.style.height = `${pet.display.size}px`;
					petEl.style.top = pet.display.top;
					petEl.style.left = pet.display.left;
				}

				/**
				 * 处理用户与宠物的互动 (V2 - 增强互动记录)
				 * @param {string} action - 互动类型, e.g., 'feed', 'play'
				 */
				async function handlePetInteraction(action) {
					const chat = state.chats[state.activeChatId];
					if (!chat || !chat.settings.petAdopted || !chat.settings.pet || chat.settings.pet.type === "无") {
						alert("你还没有宠物，或者还没有给它设定种类哦！");
						return;
					}

					const pet = chat.settings.pet;
					let actionText = "";
					const myNickname = chat.settings.myNickname || "我";

					switch (action) {
						case "feed":
							pet.status.hunger = Math.min(100, pet.status.hunger + 20);
							pet.status.happiness = Math.min(100, pet.status.happiness + 5);
							pet.status.intimacyToUser = Math.min(100, pet.status.intimacyToUser + 10);
							actionText = `${myNickname} 喂了 ${pet.name} 一些食物。`;
							break;
						case "play":
							pet.status.hunger = Math.max(0, pet.status.hunger - 10);
							pet.status.happiness = Math.min(100, pet.status.happiness + 15);
							pet.status.intimacyToUser = Math.min(100, pet.status.intimacyToUser + 15);
							actionText = `${myNickname} 陪 ${pet.name} 玩了一会儿。`;
							break;
						case "touch":
							pet.status.happiness = Math.min(100, pet.status.happiness + 10);
							pet.status.intimacyToUser = Math.min(100, pet.status.intimacyToUser + 5);
							actionText = `${myNickname} 轻轻地抚摸了 ${pet.name}。`;
							break;
						case "chat":
							openPetChat();
							return;
					}

					updatePetStatusUI(pet);
					chat.settings.pet = pet;

					// 创建对用户【可见】的系统消息
					const visibleMessage = {
						role: "system",
						type: "pat_message",
						content: `[系统：${actionText}]`,
						timestamp: Date.now(),
					};
					chat.history.push(visibleMessage);

					// 创建给AI看的【隐藏】指令
					const hiddenMessageForAI = {
						role: "system",
						content: `[系统提示：用户刚刚和宠物“${pet.name}”进行了互动：${actionText}。]`,
						timestamp: Date.now() + 1, // 确保时间戳在后
						isHidden: true,
					};
					chat.history.push(hiddenMessageForAI);

					await db.chats.put(chat);

					if (document.getElementById("chat-interface-screen").classList.contains("active")) {
						appendMessage(visibleMessage, chat);
					}

					document.getElementById("pet-modal").classList.remove("visible");
				}

				/**
				 * 打开宠物聊天模态框
				 */
				function openPetChat() {
					const chat = state.chats[state.activeChatId];
					if (!chat || !chat.settings.pet || chat.settings.pet.type === "无") {
						alert("先给你的宠物起个名字和种类吧！");
						return;
					}

					// 关闭主设置面板，打开聊天面板
					document.getElementById("pet-modal").classList.remove("visible");
					const chatModal = document.getElementById("pet-chat-modal");
					document.getElementById("pet-chat-title").textContent = `和“${chat.settings.pet.name}”的对话`;
					document.getElementById("pet-chat-input").value = "";

					renderPetChatHistory(); // 渲染历史记录
					chatModal.classList.add("visible");
				}

				/**
				 * 渲染宠物的聊天记录
				 */
				function renderPetChatHistory() {
					const chat = state.chats[state.activeChatId];
					const pet = chat.settings.pet;
					const messagesEl = document.getElementById("pet-chat-messages");
					messagesEl.innerHTML = "";

					if (!pet.petChatHistory || pet.petChatHistory.length === 0) {
						messagesEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary);">试着和它打个招呼吧！</p>`;
						return;
					}

					// 获取用户头像
					const myAvatar = chat.settings.myAvatar || defaultAvatar;

					pet.petChatHistory.forEach((msg) => {
						const wrapper = document.createElement("div");
						// msg.sender 会是 'user', 'pet', 或 'char'
						wrapper.className = `message-wrapper ${msg.sender}`;

						const bubble = document.createElement("div");
						bubble.className = "message-bubble";

						let avatarSrc = "";
						let avatarHtml = "";

						if (msg.sender === "user") {
							// 如果是用户发的，使用用户头像
							avatarSrc = myAvatar;
							avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
						} else if (msg.sender === "char") {
							// 如果是角色(char)发的，就使用角色的头像
							avatarSrc = chat.settings.aiAvatar || defaultAvatar;
							avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
						} else {
							// 剩下的情况就是宠物(pet)自己发的
							avatarSrc = pet.isCustomImage ? pet.image : null;
							if (avatarSrc) {
								// 如果是图片，显示图片
								avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
							} else {
								// 如果是Emoji，直接显示Emoji
								avatarHtml = `<div class="avatar" style="font-size: 28px; text-align: center;">${pet.image}</div>`;
							}
						}

						bubble.innerHTML = `
                            ${avatarHtml}
                            <div class="content">${msg.content.replace(/\n/g, "<br>")}</div>
                        `;
						wrapper.appendChild(bubble);
						messagesEl.appendChild(wrapper);
					});

					messagesEl.scrollTop = messagesEl.scrollHeight;
				}

				/**
				 * 处理用户在宠物聊天框中发送消息
				 */
				async function handleSendToPet() {
					const chat = state.chats[state.activeChatId];
					const pet = chat.settings.pet;
					const input = document.getElementById("pet-chat-input");
					const userInput = input.value.trim();
					if (!userInput) return;

					input.value = "";
					input.style.height = "auto";

					pet.petChatHistory.push({ sender: "user", content: userInput });
					renderPetChatHistory();

					const petResponse = await getPetApiResponse(pet);
					if (petResponse) {
						pet.petChatHistory.push({ sender: "pet", content: petResponse });
						renderPetChatHistory();
					}

					// 创建对用户【可见】的系统消息，记录这次对话
					const visibleLog = `[系统：你和宠物“${pet.name}”进行了对话。你说：“${userInput}”，它回应：“${petResponse}”。]`;
					const visibleMessage = {
						role: "system",
						type: "pat_message", // 使用这个类型来显示居中灰色气泡
						content: visibleLog,
						timestamp: Date.now(),
					};
					chat.history.push(visibleMessage);

					// 只有当用户正在查看当前聊天时，才实时追加到界面上
					if (document.getElementById("chat-interface-screen").classList.contains("active") && state.activeChatId === chat.id) {
						appendMessage(visibleMessage, chat);
					}

					// 创建给AI看的【隐藏】指令，这部分保持不变
					const hiddenMessageForAI = `[系统提示：用户刚刚和宠物“${pet.name}”进行了一次对话。用户说：“${userInput}”，宠物回应：“${petResponse}”。]`;
					const hiddenMessage = {
						role: "system",
						content: hiddenMessageForAI,
						timestamp: Date.now() + 1,
						isHidden: true,
					};
					chat.history.push(hiddenMessage);

					await db.chats.put(chat);
				}

				/**
				 * 为宠物获取API回复
				 * @param {object} pet - 宠物对象
				 * @returns {Promise<string|null>} - AI生成的宠物回复文本
				 */
				async function getPetApiResponse(pet) {
					const { proxyUrl, apiKey, model } = state.apiConfig;
					if (!proxyUrl || !apiKey || !model) {
						alert("请先配置API！");
						return "（我好像断线了...）";
					}

					// 重构对话历史的生成逻辑
					const historyForPet = pet.petChatHistory
						.slice(-6)
						.map((msg) => {
							let senderName;
							if (msg.sender === "user") {
								senderName = "主人";
							} else if (msg.sender === "char") {
								senderName = msg.senderName; // 正确获取Char的名字
							} else {
								// 'pet'
								senderName = pet.name;
							}
							return `${senderName}: ${msg.content}`;
						})
						.join("\n");

					const systemPrompt = `你现在正在扮演一只宠物。
                        # 你的核心设定
                        - 你的种类: ${pet.type}
                        - 你的名字: ${pet.name}
                        - 你的性格和背景故事: ${pet.persona}

                        # 核心规则
                        1. 你【必须】完全代入你的角色设定进行回复。
                        2. 你的回复应该是简短、可爱的，符合一只宠物的说话方式（例如，使用拟声词、简单的词汇）。
                        3. 你的回复【只能是纯文本】，不要包含任何JSON或特殊格式。

                        # 最近的对话
                        ${historyForPet}

                        现在，请根据上面的对话，继续你的回应。`;

					try {
						const messagesForApi = [{ role: "user", content: "请根据你在系统指令中读到的规则，立即开始你的行动。" }];
						let isGemini = proxyUrl === GEMINI_API_URL;
						let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);

						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({
										model: model,
										messages: [{ role: "system", content: systemPrompt }, ...messagesForApi],
										temperature: parseFloat(state.apiConfig.temperature) || 0.8,
									}),
							  });

						if (!response.ok) throw new Error(await response.text());
						const data = await response.json();
						return (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).trim();
					} catch (error) {
						console.error("获取宠物回复失败:", error);
						return "（呜...我好像说不出话了...）";
					}
				}

				/**
				 * 初始化宠物的拖拽功能
				 */
				function initPetDragging() {
					const petEl = document.getElementById("chat-pet");
					const container = document.getElementById("chat-pet-container");

					const onDragStart = (e) => {
						if (!petEl.style.display || petEl.style.display === "none") return;
						e.preventDefault();
						isPetDragging = true;

						const rect = petEl.getBoundingClientRect();
						const coords = getEventCoords(e);

						petDragOffset.x = coords.x - rect.left;
						petDragOffset.y = coords.y - rect.top;

						document.addEventListener("mousemove", onDragMove);
						document.addEventListener("mouseup", onDragEnd);
						document.addEventListener("touchmove", onDragMove, { passive: false });
						document.addEventListener("touchend", onDragEnd);
					};

					const onDragMove = (e) => {
						if (!isPetDragging) return;
						e.preventDefault();

						const containerRect = container.getBoundingClientRect();
						const coords = getEventCoords(e);

						let newLeft = coords.x - petDragOffset.x - containerRect.left;
						let newTop = coords.y - petDragOffset.y - containerRect.top;

						// 边界检测
						newLeft = Math.max(0, Math.min(newLeft, container.clientWidth - petEl.offsetWidth));
						newTop = Math.max(0, Math.min(newTop, container.clientHeight - petEl.offsetHeight));

						// 用百分比存储，以适应不同屏幕尺寸
						petEl.style.left = `${(newLeft / container.clientWidth) * 100}%`;
						petEl.style.top = `${(newTop / container.clientHeight) * 100}%`;
					};

					const onDragEnd = async () => {
						if (!isPetDragging) return;
						isPetDragging = false;

						// 拖动结束后，保存新的位置
						const chat = state.chats[state.activeChatId];
						if (chat && chat.settings.pet) {
							chat.settings.pet.display.top = petEl.style.top;
							chat.settings.pet.display.left = petEl.style.left;
							await db.chats.put(chat);
						}

						document.removeEventListener("mousemove", onDragMove);
						document.removeEventListener("mouseup", onDragEnd);
						document.removeEventListener("touchmove", onDragMove);
						document.removeEventListener("touchend", onDragEnd);
					};

					petEl.addEventListener("mousedown", onDragStart);
					petEl.addEventListener("touchstart", onDragStart, { passive: true });
				}

				/**
				 * 渲染线下模式预设的下拉框
				 */
				function renderOfflinePresetsSelector() {
					const select = document.getElementById("offline-preset-select");
					const presets = state.offlinePresets || [];
					select.innerHTML = '<option value="">-- 使用自定义输入 --</option>';

					// 为每个预设创建选项
					presets.forEach((preset) => {
						const option = document.createElement("option");
						option.value = preset.id;
						option.textContent = preset.name;
						select.appendChild(option);
					});
				}

				/**
				 * 处理线下模式预设选择事件
				 */
				function handleOfflinePresetSelection() {
					const select = document.getElementById("offline-preset-select");
					const selectedId = parseInt(select.value);

					// 如果选择了有效预设，则填充对应内容到输入框
					if (selectedId) {
						const preset = state.offlinePresets.find((p) => p.id === selectedId);
						if (preset) {
							document.getElementById("offline-prompt-input").value = preset.prompt;
							document.getElementById("offline-style-input").value = preset.style;
						}
					}
				}

				/**
				 * 打开线下模式预设管理操作菜单
				 */
				async function openOfflinePresetManager() {
					const select = document.getElementById("offline-preset-select");
					const selectedId = select.value ? parseInt(select.value) : null;

					// 显示管理选项菜单
					const choice = await showChoiceModal("管理线下模式预设", [
						{ text: "💾 保存当前为新预设", value: "save_new" },
						{ text: "✏️ 更新选中预设", value: "update_selected", disabled: !selectedId },
						{ text: "🗑️ 删除选中预设", value: "delete_selected", disabled: !selectedId },
					]);

					// 根据用户选择执行相应操作
					switch (choice) {
						case "save_new":
							await saveCurrentAsOfflinePreset();
							break;
						case "update_selected":
							if (selectedId) await updateSelectedOfflinePreset(selectedId);
							break;
						case "delete_selected":
							if (selectedId) await deleteSelectedOfflinePreset(selectedId);
							break;
					}
				}

				/**
				 * 将当前输入内容保存为新的线下模式预设
				 */
				async function saveCurrentAsOfflinePreset() {
					const name = await showCustomPrompt("保存新预设", "请输入预设名称：");

					if (name && name.trim()) {
						const newPreset = {
							name: name.trim(),
							prompt: document.getElementById("offline-prompt-input").value.trim(),
							style: document.getElementById("offline-style-input").value.trim(),
						};

						// 保存到数据库并更新内存状态
						const newId = await db.offlinePresets.add(newPreset);
						if (!state.offlinePresets) state.offlinePresets = [];
						state.offlinePresets.push({ id: newId, ...newPreset });

						renderOfflinePresetsSelector();
						document.getElementById("offline-preset-select").value = newId;
						alert(`预设 "${name.trim()}" 已保存！`);
					}
				}

				/**
				 * 用当前输入内容更新选中的线下模式预设
				 */
				async function updateSelectedOfflinePreset(presetId) {
					const preset = state.offlinePresets.find((p) => p.id === presetId);
					if (!preset) return;

					const confirmed = await showCustomConfirm("确认更新", `确定要用当前内容覆盖预设 "${preset.name}" 吗？`);
					if (confirmed) {
						const updatedData = {
							prompt: document.getElementById("offline-prompt-input").value.trim(),
							style: document.getElementById("offline-style-input").value.trim(),
						};

						// 更新数据库和内存状态
						await db.offlinePresets.update(presetId, updatedData);
						preset.prompt = updatedData.prompt;
						preset.style = updatedData.style;
						alert("预设已更新！");
					}
				}

				/**
				 * 删除选中的线下模式预设
				 */
				async function deleteSelectedOfflinePreset(presetId) {
					const preset = state.offlinePresets.find((p) => p.id === presetId);
					if (!preset) return;

					const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${preset.name}" 吗？`, { confirmButtonClass: "btn-danger" });
					if (confirmed) {
						// 从数据库和内存中删除预设
						await db.offlinePresets.delete(presetId);
						state.offlinePresets = state.offlinePresets.filter((p) => p.id !== presetId);

						renderOfflinePresetsSelector();
						document.getElementById("offline-prompt-input").value = "";
						document.getElementById("offline-style-input").value = "";
						alert("预设已删除。");
					}
				}

				/**
				 * 自动在后台执行总结，只总结触发条件的N条消息
				 */
				async function performAutomaticSummary(chatId) {
					console.log(`自动总结触发 for chat: ${chatId}`);
					const chat = state.chats[chatId];
					const summarySettings = chat.settings.summary;

					// 精确截取最后N条消息作为总结范围
					const messagesToSummarize = chat.history.slice(-summarySettings.count);

					try {
						const summaryText = await generateSummary(chatId, messagesToSummarize);
						if (summaryText) {
							await saveSummaryAsMemory(chatId, summaryText);
						}
					} catch (e) {
						// generateSummary 内部已经处理了错误弹窗，这里我们只需要记录日志即可
						console.error("自动总结过程中发生未捕获的错误:", e);
					}
				}

				/**
				 * 弹出提示框，提醒用户可以进行手动总结了
				 */
				async function notifyForManualSummary(chatId) {
					console.log(`手动总结提醒触发 for chat: ${chatId}`);

					// 只弹出一个简单的通知
					await showCustomAlert("总结提醒", "对话已达到设定长度，你可以随时在“聊天设置”中点击“立即手动总结”来生成对话记忆。");

					// 提醒过后，更新“上次总结位置”，以防止每条新消息都弹窗。
					// 这意味着计时器会从现在重新开始计算。
					const chat = state.chats[chatId];
					chat.settings.summary.lastSummaryIndex = chat.history.length - 1;
					await db.chats.put(chat);
				}

				/**
				 * 调用API生成总结内容
				 * @param {string} chatId - 聊天的ID
				 * @param {Array | null} specificMessages - 如果提供，则只总结这个数组里的消息；如果为null，则总结自上次以来的所有消息。
				 * @returns {Promise<string|null>} - AI生成的总结文本
				 */
				async function generateSummary(chatId, specificMessages = null) {
					const chat = state.chats[chatId];
					const { proxyUrl, apiKey, model } = state.apiConfig;

					if (!proxyUrl || !apiKey || !model) {
						throw new Error("API未配置，无法生成总结。");
					}

					const summarySettings = chat.settings.summary;
					let messagesToSummarize;

					if (specificMessages && specificMessages.length > 0) {
						messagesToSummarize = specificMessages;
					} else {
						const lastSummaryIndex = summarySettings.lastSummaryIndex > -1 ? summarySettings.lastSummaryIndex : 0;
						messagesToSummarize = chat.history.slice(lastSummaryIndex + 1);
					}

					const filteredMessagesForSummary = messagesToSummarize.filter((msg) => msg.type !== "summary");

					if (filteredMessagesForSummary.length === 0) {
						if (!specificMessages) {
							await showCustomAlert("无需总结", "自上次总结以来没有新的对话内容。");
						}
						return null;
					}

					// 在构建对话文本时，加入时间戳
					const conversationText = filteredMessagesForSummary
						.map((msg) => {
							const sender = msg.role === "user" ? (chat.isGroup ? chat.settings.myNickname || "我" : "我") : msg.senderName || chat.name;
							let content = "";
							if (typeof msg.content === "string") {
								content = msg.content;
							} else if (Array.isArray(msg.content)) {
								content = "[图片]";
							} else if (msg.type) {
								content = `[${msg.type}]`;
							}
							// 将毫秒时间戳转换为人类可读的日期时间字符串
							const readableTime = new Date(msg.timestamp).toLocaleString("zh-CN", { hour12: false });
							return `[${readableTime}] ${sender}: ${content}`;
						})
						.join("\n");

					// 更新系统指令，要求AI使用时间戳
					const systemPrompt = summarySettings.prompt + `\n\n重要提示：每条消息开头都有一个 [时间] 标记。你在总结时，【必须】参考这些时间，在总结关键事件时附上对应的时间范围或具体时间点，让总结包含时间线索。\n\n--- 对话开始 ---\n${conversationText}\n--- 对话结束 ---`;

					try {
						if (!specificMessages) {
							await showCustomAlert("正在生成...", "AI正在努力总结你们的对话，请稍候...");
						}

						const isGemini = proxyUrl === GEMINI_API_URL;
						const messagesForApi = [{ role: "user", content: systemPrompt }];
						const geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({
										model: model,
										messages: messagesForApi,
										temperature: parseFloat(state.apiConfig.temperature) || 0.3,
									}),
							  });

						if (!response.ok) throw new Error(await response.text());
						const data = await response.json();
						const aiContent = isGemini ? data?.candidates?.[0]?.content?.parts?.[0]?.text : data?.choices?.[0]?.message?.content;

						if (!aiContent) {
							throw new Error("AI返回了空内容。");
						}

						return aiContent;
					} catch (error) {
						console.error("生成总结失败:", error);
						await showCustomAlert("总结失败", `发生错误: ${error.message}`);
						return null;
					}
				}

				/**
				 * 将生成的总结作为一条特殊的记忆消息保存起来
				 */
				async function saveSummaryAsMemory(chatId, summaryText) {
					const chat = state.chats[chatId];

					// 记录下总结操作发生时的最后一条消息的索引
					const newLastSummaryIndex = chat.history.length - 1;

					const summaryMessage = {
						role: "system",
						type: "summary", // 特殊类型
						content: summaryText,
						timestamp: Date.now(),
						isHidden: true, // 这条消息对AI可见，但对用户隐藏
					};

					chat.history.push(summaryMessage);
					chat.settings.summary.lastSummaryIndex = newLastSummaryIndex; // 更新索引

					await db.chats.put(chat);
					console.log(`新的总结已作为记忆保存 for chat: ${chatId}`);
				}

				// --- 以下是总结管理界面的函数 ---

				let editingSummaryTimestamp = null;

				/**
				 * 打开总结查看器界面
				 */
				async function openSummaryViewer() {
					const chat = state.chats[state.activeChatId];
					document.getElementById("summary-viewer-title").textContent = `“${chat.name}”的对话记忆`;

					const listEl = document.getElementById("summary-list");
					listEl.innerHTML = "";

					const summaries = chat.history.filter((msg) => msg.type === "summary");

					if (summaries.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">还没有生成过任何总结。</p>';
					} else {
						[...summaries].reverse().forEach((summary) => {
							const card = document.createElement("div");
							card.className = "summary-item-card";

							// 让生成时间显示得更简短好看
							card.innerHTML = `
                                <div class="summary-actions">
                                    <button class="concise-summary-btn" data-timestamp="${summary.timestamp}" title="精简总结">✨</button>
                                    <button class="edit-summary-btn" data-timestamp="${summary.timestamp}" title="编辑">✏️</button>
                                    <button class="delete-summary-btn" data-timestamp="${summary.timestamp}" title="删除">🗑️</button>
                                </div>
                                <div class="summary-content">${summary.content.replace(/\n/g, "<br>")}</div>
                                <div class="summary-meta">
                                    <span>生成于: ${new Date(summary.timestamp).toLocaleString("zh-CN", { dateStyle: "short", timeStyle: "short" })}</span>
                                </div>
                            `;
							listEl.appendChild(card);
						});
					}

					document.getElementById("chat-settings-modal").classList.remove("visible");
					document.getElementById("summary-viewer-modal").classList.add("visible");
				}

				/**
				 * 编辑一条总结
				 */
				async function editSummary(timestamp) {
					const chat = state.chats[state.activeChatId];
					const summary = chat.history.find((msg) => msg.timestamp === timestamp);
					if (!summary) return;

					const newContent = await showCustomPrompt("编辑总结", "修改总结内容:", summary.content, "textarea");

					if (newContent !== null) {
						summary.content = newContent.trim();
						await db.chats.put(chat);
						openSummaryViewer(); // 重新渲染列表
					}
				}

				/**
				 * 删除一条总结，并智能更新总结索引
				 */
				async function deleteSummary(timestamp) {
					const confirmed = await showCustomConfirm("确认删除", "确定要删除这条总结记忆吗？这可能会影响AI的长期记忆。", { confirmButtonClass: "btn-danger" });
					if (confirmed) {
						const chat = state.chats[state.activeChatId];

						// 从历史记录中过滤掉被删除的总结
						chat.history = chat.history.filter((msg) => msg.timestamp !== timestamp);

						// 重新计算 lastSummaryIndex
						// 找到剩下的总结中，最新的那一条
						const lastRemainingSummary = chat.history.filter((m) => m.type === "summary").pop();

						let newLastSummaryIndex;

						if (lastRemainingSummary) {
							// 如果还有其他总结，就找到它在历史记录中的位置
							const lastSummaryMessageIndexInHistory = chat.history.findIndex((m) => m.timestamp === lastRemainingSummary.timestamp);
							// 新的索引就是它前面那条普通消息的索引
							newLastSummaryIndex = lastSummaryMessageIndexInHistory > 0 ? lastSummaryMessageIndexInHistory - 1 : -1;
						} else {
							// 如果一条总结都不剩了，就彻底重置索引
							newLastSummaryIndex = -1;
						}

						// 更新设置
						if (chat.settings.summary) {
							chat.settings.summary.lastSummaryIndex = newLastSummaryIndex;
						}

						// 保存更改并刷新UI
						await db.chats.put(chat);
						openSummaryViewer();
						await showCustomAlert("操作成功", "总结已删除！");
					}
				}

				/**
				 * 调用API将指定文本精简为摘要
				 * @param {string} originalText - 原始的、较长的总结文本
				 * @returns {Promise<string|null>} - AI生成的精简摘要，如果失败则返回null
				 */
				async function generateConciseSummary(originalText) {
					const { proxyUrl, apiKey, model } = state.apiConfig;
					if (!proxyUrl || !apiKey || !model) {
						throw new Error("API未配置，无法生成精简摘要。");
					}

					// 核心Prompt：指示AI将内容精简为一句话
					const systemPrompt = `请你将以下内容精简为一句话的核心摘要，保留最关键的人物、事件和结论，字数控制在20字以内：\n\n--- 内容开始 ---\n${originalText}\n--- 内容结束 ---`;

					try {
						const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
							method: "POST",
							headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
							body: JSON.stringify({
								model: model,
								messages: [{ role: "user", content: systemPrompt }],
								temperature: parseFloat(state.apiConfig.temperature) || 0.5,
							}),
						});

						if (!response.ok) throw new Error(await response.text());
						const data = await response.json();
						return data.choices[0].message.content;
					} catch (error) {
						console.error("生成精简摘要失败:", error);
						await showCustomAlert("精简失败", `发生错误: ${error.message}`);
						return null;
					}
				}

				/**
				 * 处理单条总结的精简
				 * @param {number} timestamp - 要精简的总结消息的时间戳
				 */
				async function handleConciseSummary(timestamp) {
					const chat = state.chats[state.activeChatId];
					const summary = chat.history.find((msg) => msg.timestamp === timestamp);
					if (!summary) return;

					await showCustomAlert("请稍候...", "AI正在努力为您精简内容...");

					const conciseText = await generateConciseSummary(summary.content);

					if (conciseText) {
						summary.content = conciseText.trim(); // 用精简后的文本替换原文
						await db.chats.put(chat); // 保存到数据库
						await openSummaryViewer(); // 重新渲染列表
						await showCustomAlert("成功", "本条总结已精简！");
					}
				}

				/**
				 * 处理全部总结的精简
				 */
				async function handleConciseAllSummaries() {
					const chat = state.chats[state.activeChatId];
					const summaries = chat.history.filter((msg) => msg.type === "summary");

					if (summaries.length === 0) {
						alert("没有可以精简的总结。");
						return;
					}

					const confirmed = await showCustomConfirm("确认全部精简", `确定要精简全部 ${summaries.length} 条总结吗？此操作会覆盖原始内容且不可恢复。`, { confirmButtonClass: "btn-danger" });
					if (!confirmed) return;

					await showCustomAlert("请稍候...", `正在批量精简 ${summaries.length} 条总结，这可能需要一些时间...`);

					try {
						// 使用 for...of 循环来逐条处理，避免同时发送太多API请求导致被限制
						for (const summary of summaries) {
							const conciseText = await generateConciseSummary(summary.content);
							if (conciseText) {
								summary.content = conciseText.trim();
							}
							// 每处理完一条，稍微等待一下，给API一点喘息时间
							await new Promise((resolve) => setTimeout(resolve, 500));
						}

						await db.chats.put(chat);
						await openSummaryViewer();
						await showCustomAlert("成功", "所有总结都已精简完毕！");
					} catch (error) {
						// generateConciseSummary 内部已经处理了错误弹窗，这里我们只需要确保流程正常结束
						console.error("批量精简时出错:", error);
					}
				}

				/**
				 * 用户点击"立即手动总结"按钮时触发的函数 (支持不同模式)
				 * @param {'latest' | 'range'} mode - 总结模式
				 * @param {{start: number, end: number} | null} range - 如果是范围模式，则为起始和结束序号
				 */
				async function triggerManualSummaryNow(mode = "latest", range = null) {
					if (isSummarizing) {
						alert("正在处理上一个总结任务，请稍候...");
						return;
					}

					const chat = state.chats[state.activeChatId];
					if (!chat) {
						alert("错误：找不到当前聊天，无法总结。");
						return;
					}

					isSummarizing = true; // 上锁

					try {
						let messagesToSummarize = [];

						// 根据传入的模式，决定要截取哪些消息
						if (mode === "latest") {
							const summarySettings = chat.settings.summary;
							const count = summarySettings && summarySettings.count > 0 ? summarySettings.count : 20;
							messagesToSummarize = chat.history.slice(-count);
							console.log(`手动总结最新 ${count} 条消息...`);
						} else if (mode === "range" && range) {
							// 注意：数组索引从0开始，而用户输入从1开始，所以需要-1
							messagesToSummarize = chat.history.slice(range.start - 1, range.end);
							console.log(`手动总结从 ${range.start} 到 ${range.end} 的消息...`);
						} else {
							throw new Error("无效的总结模式或范围。");
						}

						// 后续的逻辑保持不变
						if (messagesToSummarize.length === 0) {
							alert("选定的范围内没有可总结的聊天记录。");
							isSummarizing = false; // 解锁
							return;
						}

						const summaryText = await generateSummary(state.activeChatId, messagesToSummarize);

						if (summaryText) {
							await saveSummaryAsMemory(state.activeChatId, summaryText);
							await showCustomAlert("总结完成", "新的对话记忆已生成！");
							if (document.getElementById("summary-viewer-modal").classList.contains("visible")) {
								openSummaryViewer();
							}
						}
					} catch (e) {
						console.error("手动总结过程中发生未捕获的错误:", e);
						await showCustomAlert("错误", "手动总结时发生错误，详情请查看控制台。");
					} finally {
						isSummarizing = false; // 别忘了无论成功失败都要解锁
					}
				}

				/**
				 * 更新角色手机钱包的余额和交易记录
				 * @param {string} charId - 要更新钱包的角色ID
				 * @param {number} amount - 交易金额 (正数为收入, 负数为支出)
				 * @param {string} description - 交易描述 (例如: "转账给 XX", "收到 XX 的红包")
				 */
				async function updateCharacterBankBalance(charId, amount, description) {
					// 安全检查：如果缺少关键信息，则直接返回
					if (!charId || !amount || isNaN(amount)) {
						console.warn("updateCharacterBankBalance 调用失败：缺少charId或有效的amount。");
						return;
					}

					// 从全局状态中获取角色对象
					const chat = state.chats[charId];
					// 安全检查：确保角色存在且不是群聊
					if (!chat || chat.isGroup) {
						console.warn(`updateCharacterBankBalance 跳过：找不到ID为 ${charId} 的角色或该ID为群聊。`);
						return;
					}

					// 确保数据结构完整，兼容旧数据
					if (!chat.characterPhoneData) {
						chat.characterPhoneData = {};
					}
					if (!chat.characterPhoneData.bank) {
						chat.characterPhoneData.bank = { balance: 0, transactions: [] };
					}
					// 如果旧数据的余额不是数字，则强制设为0
					if (typeof chat.characterPhoneData.bank.balance !== "number") {
						chat.characterPhoneData.bank.balance = 0;
					}
					// 如果旧数据的交易记录不是数组，则创建一个空数组
					if (!Array.isArray(chat.characterPhoneData.bank.transactions)) {
						chat.characterPhoneData.bank.transactions = [];
					}

					// 核心逻辑
					// 1. 创建一条新的交易记录
					const newTransaction = {
						type: amount > 0 ? "收入" : "支出",
						amount: Math.abs(amount), // 交易记录里的金额总是正数
						description: description,
						timestamp: Date.now(), // 记录交易发生的时间
					};

					// 2. 更新余额
					chat.characterPhoneData.bank.balance += amount;

					// 3. 将新交易记录添加到列表的开头（让最新的显示在最前面）
					chat.characterPhoneData.bank.transactions.unshift(newTransaction);

					// 4. 将更新后的角色数据保存回数据库
					await db.chats.put(chat);

					console.log(`✅ 钱包同步成功: 角色[${chat.name}], 交易[${description}], 金额[${amount.toFixed(2)}], 新余额[${chat.characterPhoneData.bank.balance.toFixed(2)}]`);
				}

				/**
				 * 打开角色手机的外观设置页面
				 */
				function openCharPhoneAppearanceSettings() {
					renderCharPhoneAppearanceScreen(); // 渲染页面内容
					showCharacterPhonePage("character-phone-appearance-screen"); // 显示页面
					loadCharPhonePresetsToDropdown();
				}

				/**
				 * 渲染角色手机的外观设置页面
				 */
				function renderCharPhoneAppearanceScreen() {
					if (!activeCharacterPhoneId) return;
					const chat = state.chats[activeCharacterPhoneId];
					if (!chat) return;

					// 渲染壁纸预览
					const wallpaperPreview = document.getElementById("char-phone-wallpaper-preview");
					const wallpaperUrl = chat.characterPhoneData.wallpaper || "";
					if (wallpaperUrl) {
						wallpaperPreview.style.backgroundImage = `url(${wallpaperUrl})`;
						wallpaperPreview.textContent = "";
					} else {
						wallpaperPreview.style.backgroundImage = "none";
						wallpaperPreview.textContent = "暂无壁纸";
					}

					// 渲染App内壁纸预览
					const appWallpaperPreview = document.getElementById("char-phone-app-wallpaper-preview");
					const appWallpaperUrl = newAppWallpaperBase64 || chat.characterPhoneData.appWallpaper || "";
					if (appWallpaperUrl) {
						appWallpaperPreview.style.backgroundImage = `url(${appWallpaperUrl})`;
						appWallpaperPreview.textContent = "";
					} else {
						appWallpaperPreview.style.backgroundImage = "none";
						appWallpaperPreview.textContent = "点击下方上传";
					}

					// 渲染App图标设置列表
					const iconGrid = document.getElementById("char-phone-icon-settings-grid");
					iconGrid.innerHTML = "";
					const customIcons = chat.characterPhoneData.appIcons || {};

					// 遍历所有App并渲染图标设置项
					CHAR_PHONE_APPS.forEach((app) => {
						const customIconUrl = customIcons[app.id];
						// 使用默认图标作为备用
						const currentIconUrl = customIconUrl || DEFAULT_APP_ICONS[app.id] || "";
						const currentIconHtml = currentIconUrl ? `<img src="${currentIconUrl}" style="width:100%; height:100%; object-fit:cover;">` : app.svg;

						const itemEl = document.createElement("div");
						itemEl.className = "icon-setting-item";
						itemEl.dataset.iconId = app.id;
						itemEl.innerHTML = `
                            <div class="icon-preview" style="width: 50px; height: 50px; border-radius: 12px; display: flex; justify-content: center; align-items: center; padding: 8px; background: #f0f2f5;">
                                ${currentIconHtml}
                            </div>
                            <span style="font-size: 13px;">${app.name}</span>
                            <button class="change-icon-btn" data-icon-id="${app.id}" style="padding: 4px 10px; font-size: 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer;">更换</button>
                        `;
						iconGrid.appendChild(itemEl);
					});

					// 渲染小组件预览
					const widgets = chat.characterPhoneData.widgets || {};
					const widgetPreview1 = document.getElementById("char-phone-widget-preview-1");
					const widgetPreview2 = document.getElementById("char-phone-widget-preview-2");

					if (widgets.widget1_url) {
						widgetPreview1.style.backgroundImage = `url(${widgets.widget1_url})`;
						widgetPreview1.textContent = "";
					} else {
						widgetPreview1.style.backgroundImage = "none";
						widgetPreview1.textContent = "点击上传";
					}

					if (widgets.widget2_url) {
						widgetPreview2.style.backgroundImage = `url(${widgets.widget2_url})`;
						widgetPreview2.textContent = "";
					} else {
						widgetPreview2.style.backgroundImage = "none";
						widgetPreview2.textContent = "点击上传";
					}
				}

				/**
				 * 处理角色手机壁纸的更换和移除
				 * @param {string} newUrl - 新的壁纸URL，如果为空字符串则表示移除
				 */
				async function handleCharPhoneWallpaperChange(newUrl) {
					if (!activeCharacterPhoneId) return;
					const chat = state.chats[activeCharacterPhoneId];

					chat.characterPhoneData.wallpaper = newUrl;
					await db.chats.put(chat);

					// 立即应用壁纸到角色手机主屏幕
					const phoneScreen = document.getElementById("character-phone-screen");
					if (newUrl) {
						phoneScreen.style.backgroundImage = `url(${newUrl})`;
						phoneScreen.style.backgroundColor = "transparent";
					} else {
						phoneScreen.style.backgroundImage = "none";
						const isDarkMode = document.getElementById("phone-screen").classList.contains("dark-mode");
						phoneScreen.style.backgroundColor = isDarkMode ? "#000" : "#f0f2f5";
					}

					// 刷新设置页面的预览
					renderCharPhoneAppearanceScreen();
					alert(newUrl ? "壁纸已更新！" : "壁纸已移除！");
				}

				/**
				 * 处理角色手机App图标的更换
				 * @param {string} iconId - 要更换的App的ID
				 */
				async function handleChangeCharPhoneIcon(iconId) {
					if (!activeCharacterPhoneId) return;

					const choice = await showChoiceModal("更换图标", [
						{ text: "📁 从本地上传", value: "local" },
						{ text: "🌐 使用网络URL", value: "url" },
						{ text: "🔄 恢复默认", value: "reset" },
					]);

					let newIconUrl = null;

					if (choice === "local") {
						newIconUrl = await uploadImageLocally();
					} else if (choice === "url") {
						newIconUrl = await showCustomPrompt("图标URL", "请输入图片链接");
					} else if (choice === "reset") {
						const chat = state.chats[activeCharacterPhoneId];
						if (chat.characterPhoneData.appIcons && chat.characterPhoneData.appIcons[iconId]) {
							delete chat.characterPhoneData.appIcons[iconId];
							await db.chats.put(chat);
							renderCharPhoneAppearanceScreen();
							renderCharacterAppGrid();
							alert("图标已恢复默认。");
						}
						return;
					}

					if (newIconUrl && newIconUrl.trim()) {
						const chat = state.chats[activeCharacterPhoneId];
						if (!chat.characterPhoneData.appIcons) {
							chat.characterPhoneData.appIcons = {};
						}
						chat.characterPhoneData.appIcons[iconId] = newIconUrl.trim();
						await db.chats.put(chat);

						renderCharPhoneAppearanceScreen(); // 刷新设置页面
						renderCharacterAppGrid(); // 刷新主屏幕
						alert("图标已更新！");
					}
				}

				let isIntentionalStop = false;
				// 全局锁，true表示有语音正在播放或加载
				let isTtsPlaying = false;
				// 记录当前正在播放动画或音频的气泡元素
				let currentTtsAudioBubble = null;

				/**
				 * 查找从指定位置开始的所有连续AI语音消息
				 * @param {Array} history - 完整的聊天历史记录数组
				 * @param {number} startIndex - 开始查找的索引位置
				 * @returns {Array} - 一个包含所有连续AI语音消息对象的数组
				 */
				function findConsecutiveAiVoiceMessages(history, startIndex) {
					const messagesToPlay = [];
					if (startIndex < 0 || startIndex >= history.length) {
						return messagesToPlay;
					}

					// 从点击的那条消息开始，向后遍历
					for (let i = startIndex; i < history.length; i++) {
						const msg = history[i];
						// 检查这条消息是否是AI发送的，并且类型是语音
						if (msg.role === "assistant" && msg.type === "voice_message") {
							messagesToPlay.push(msg); // 如果是，就把它加入待播放列表
						} else {
							// 一旦遇到不是AI语音的消息（比如用户的回复，或AI的图片/文字消息），就立刻停止查找
							break;
						}
					}
					return messagesToPlay;
				}

				/**
				 * 停止当前正在播放的Minimax TTS语音
				 */
				function stopMinimaxAudio() {
					if (!isTtsPlaying) return;

					// 在执行停止操作前，先设置"故意停止"的标志为 true
					isIntentionalStop = true;

					const ttsPlayer = document.getElementById("tts-audio-player");
					ttsPlayer.pause();
					ttsPlayer.src = ""; // 这行代码会触发 onerror 事件

					if (window.currentAnimatingBubbles) {
						window.currentAnimatingBubbles.forEach((b) => b.classList.remove("playing"));
					}

					isTtsPlaying = false;
					currentTtsAudioBubble = null;
					window.currentAnimatingBubbles = null;
					console.log("Minimax TTS: Playback stopped by user.");

					// 用一个微小的延迟来重置标志位
					// 这能确保 onerror 事件有足够的时间检查到标志位，然后再将其重置
					setTimeout(() => {
						isIntentionalStop = false;
					}, 100);
				}

				/**
				 * 调用 Minimax TTS API 生成语音并播放
				 * @param {string} text - 要转换为语音的合并后的文本
				 * @param {string} voiceId - Minimax 的语音 ID
				 * @param {Array<HTMLElement>} bubblesToAnimate - 需要播放动画的所有语音气泡元素的数组
				 */
				async function playMinimaxAudio(text, voiceId, bubblesToAnimate) {
					stopMinimaxAudio();
					await new Promise((resolve) => setTimeout(resolve, 50));

					const ttsPlayer = document.getElementById("tts-audio-player");
					const firstBubble = bubblesToAnimate[0];

					isTtsPlaying = true;
					currentTtsAudioBubble = firstBubble;
					window.currentAnimatingBubbles = bubblesToAnimate;
					bubblesToAnimate.forEach((b) => b.classList.add("playing"));

					const mainAudioPlayer = document.getElementById("audio-player");
					if (mainAudioPlayer && !mainAudioPlayer.paused) {
						mainAudioPlayer.pause();
						musicState.isPlaying = false;
						updatePlayerUI();
					}

					const groupId = state.apiConfig.minimaxGroupId;
					const apiKey = state.apiConfig.minimaxApiKey;
					if (!groupId || !apiKey) {
						await showCustomAlert("语音播放失败", "尚未配置Minimax的Group ID和API Key。");
						stopMinimaxAudio();
						return;
					}

					// 从全局 apiConfig 获取语音模型
					const speechModel = state.apiConfig.minimaxSpeechModel || "speech-01";
					console.log(`正在使用 Minimax 语音模型: ${speechModel}`);

					try {
						const response = await fetch(`https://api.minimax.chat/v1/text_to_speech?GroupId=${groupId}`, {
							method: "POST",
							headers: { Authorization: `Bearer ${apiKey}`, "Content-Type": "application/json" },
							body: JSON.stringify({
								text: text,
								voice_id: voiceId,
								model: speechModel, // 使用我们获取到的模型变量
								speed: 1.0,
								pitch: 0,
								timber_list: [],
							}),
						});

						if (!response.ok) {
							const errorData = await response.json();
							throw new Error(`Minimax API 错误: ${errorData.base_resp?.status_msg || response.statusText}`);
						}
						const contentType = response.headers.get("Content-Type");
						if (!contentType || !contentType.startsWith("audio/")) {
							const errorData = await response.json().catch(() => response.text());
							throw new Error(`Minimax API 未返回有效的音频文件，而是返回了: ${JSON.stringify(errorData)}`);
						}
						const audioBlob = await response.blob();
						const audioUrl = URL.createObjectURL(audioBlob);

						ttsPlayer.src = audioUrl;

						const cleanupAndReset = () => {
							if (isTtsPlaying) {
								isTtsPlaying = false;
								URL.revokeObjectURL(audioUrl);
								if (window.currentAnimatingBubbles) {
									window.currentAnimatingBubbles.forEach((b) => b.classList.remove("playing"));
								}
								currentTtsAudioBubble = null;
								window.currentAnimatingBubbles = null;
							}
						};

						ttsPlayer.onended = cleanupAndReset;

						ttsPlayer.onerror = (e) => {
							if (!isIntentionalStop) {
								console.error("TTS音频播放时发生错误，已自动切换为文本显示:", e);
							} else {
								console.log("Intentional stop triggered error event, alert skipped.");
							}
							cleanupAndReset();
						};

						await ttsPlayer.play();
					} catch (error) {
						console.error("Minimax TTS 调用失败:", error);
						await showCustomAlert("语音合成失败", `错误信息: ${error.message}`);
						stopMinimaxAudio();
					}
				}

				/**
				 * 启用或禁用角色手机预设管理按钮
				 * @param {boolean} isEnabled - 是否启用
				 */
				function toggleCharPhonePresetButtons(isEnabled) {
					document.getElementById("apply-char-phone-preset-btn").disabled = !isEnabled;
					document.getElementById("update-char-phone-preset-btn").disabled = !isEnabled;
					document.getElementById("rename-char-phone-preset-btn").disabled = !isEnabled;
					document.getElementById("delete-char-phone-preset-btn").disabled = !isEnabled;
					document.getElementById("export-char-phone-preset-btn").disabled = !isEnabled;
				}

				/**
				 * 加载角色手机外观预设到下拉框
				 */
				async function loadCharPhonePresetsToDropdown() {
					const selector = document.getElementById("char-phone-preset-selector");
					if (!selector) return;
					selector.innerHTML = '<option value="">-- 请选择一个预设 --</option>';
					const presets = await db.charPhonePresets.toArray();
					presets.forEach((preset) => {
						const option = document.createElement("option");
						option.value = preset.id;
						option.textContent = preset.name;
						selector.appendChild(option);
					});
					activeCharPhonePresetId = null;
					toggleCharPhonePresetButtons(false);
				}

				/**
				 * 当用户从下拉框选择一个预设时触发
				 */
				function handleCharPhonePresetSelection() {
					const selector = document.getElementById("char-phone-preset-selector");
					activeCharPhonePresetId = selector.value ? parseInt(selector.value) : null;
					toggleCharPhonePresetButtons(!!activeCharPhonePresetId);
				}

				/**
				 * 应用选中的角色手机外观预设
				 */
				async function applySelectedCharPhonePreset() {
					if (!activeCharPhonePresetId) {
						alert("请先从下拉框中选择一个要应用的预设。");
						return;
					}
					if (!activeCharacterPhoneId) {
						alert("错误：没有找到当前正在操作的角色手机。");
						return;
					}
					const preset = await db.charPhonePresets.get(activeCharPhonePresetId);
					const chat = state.chats[activeCharacterPhoneId];

					if (preset && preset.data && chat) {
						// 将预设数据深拷贝一份，应用到角色的手机数据上
						chat.characterPhoneData.wallpaper = preset.data.wallpaper || "";
						chat.characterPhoneData.appIcons = { ...DEFAULT_APP_ICONS, ...(preset.data.appIcons || {}) };
						chat.characterPhoneData.widgets = { ...(preset.data.widgets || {}) };

						// 应用App内壁纸
						chat.characterPhoneData.appWallpaper = preset.data.appWallpaper || "";

						await db.chats.put(chat);

						// 刷新手机界面以显示新外观
						openCharacterPhone(activeCharacterPhoneId);

						// 刷新外观设置页面，以便预览和数据同步
						renderCharPhoneAppearanceScreen();

						alert(`已成功为“${chat.name}”应用预设: "${preset.name}"！`);
					} else {
						alert("应用预设失败，找不到预设或角色数据。");
					}
				}

				/**
				 * 保存当前角色手机的外观设置为一个新的预设
				 */
				async function saveCurrentCharPhonePreset() {
					if (!activeCharacterPhoneId) return;

					const presetName = await showCustomPrompt("保存预设", "请为这个外观方案起个名字：");
					if (!presetName || !presetName.trim()) {
						if (presetName !== null) alert("名字不能为空！");
						return;
					}

					const chat = state.chats[activeCharacterPhoneId];
					// 从当前角色的数据中提取外观设置
					const presetData = {
						wallpaper: chat.characterPhoneData.wallpaper || "",
						appIcons: { ...(chat.characterPhoneData.appIcons || {}) },
						widgets: { ...(chat.characterPhoneData.widgets || {}) },
						appWallpaper: chat.characterPhoneData.appWallpaper || "",
					};

					await db.charPhonePresets.add({ name: presetName.trim(), data: presetData });
					await loadCharPhonePresetsToDropdown();
					alert(`外观预设 "${presetName.trim()}" 已保存！`);
				}

				/**
				 * 更新当前选中的预设
				 */
				async function updateSelectedCharPhonePreset() {
					if (!activeCharPhonePresetId || !activeCharacterPhoneId) return;

					const currentPreset = await db.charPhonePresets.get(activeCharPhonePresetId);
					if (!currentPreset) return;

					const confirmed = await showCustomConfirm("确认更新", `确定要用当前手机的外观覆盖预设 "${currentPreset.name}" 吗？`, { confirmButtonClass: "btn-danger" });

					if (confirmed) {
						const chat = state.chats[activeCharacterPhoneId];
						const presetData = {
							wallpaper: chat.characterPhoneData.wallpaper || "",
							appIcons: { ...(chat.characterPhoneData.appIcons || {}) },
							widgets: { ...(chat.characterPhoneData.widgets || {}) },
							appWallpaper: chat.characterPhoneData.appWallpaper || "",
						};
						await db.charPhonePresets.update(activeCharPhonePresetId, { data: presetData });
						await showCustomAlert("成功", `预设 "${currentPreset.name}" 已更新！`);
					}
				}

				/**
				 * 重命名选中的预设
				 */
				async function renameSelectedCharPhonePreset() {
					if (!activeCharPhonePresetId) return;
					const currentPreset = await db.charPhonePresets.get(activeCharPhonePresetId);
					const newName = await showCustomPrompt("重命名", "请输入新的名称：", currentPreset.name);
					if (newName && newName.trim()) {
						await db.charPhonePresets.update(activeCharPhonePresetId, { name: newName.trim() });
						await loadCharPhonePresetsToDropdown();
						document.getElementById("char-phone-preset-selector").value = activeCharPhonePresetId;
						alert("重命名成功！");
					}
				}

				/**
				 * 删除选中的预设
				 */
				async function deleteSelectedCharPhonePreset() {
					if (!activeCharPhonePresetId) return;
					const currentPreset = await db.charPhonePresets.get(activeCharPhonePresetId);
					const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${currentPreset.name}" 吗？`, { confirmButtonClass: "btn-danger" });
					if (confirmed) {
						await db.charPhonePresets.delete(activeCharPhonePresetId);
						await loadCharPhonePresetsToDropdown();
						alert("预设已删除。");
					}
				}

				/**
				 * 导出选中的预设
				 */
				async function exportCharPhonePreset() {
					if (!activeCharPhonePresetId) return;
					const preset = await db.charPhonePresets.get(activeCharPhonePresetId);
					const blob = new Blob([JSON.stringify(preset, null, 2)], { type: "application/json" });
					const url = URL.createObjectURL(blob);
					const a = document.createElement("a");
					a.href = url;
					a.download = `[CharPhone]${preset.name}.json`;
					a.click();
					URL.revokeObjectURL(url);
				}

				/**
				 * 导入预设文件
				 */
				function importCharPhonePreset(file) {
					if (!file) return;
					const reader = new FileReader();
					reader.onload = async (e) => {
						try {
							const data = JSON.parse(e.target.result);
							if (data.name && data.data) {
								await db.charPhonePresets.add({ name: `${data.name} (导入)`, data: data.data });
								await loadCharPhonePresetsToDropdown();
								alert(`预设 "${data.name}" 导入成功！`);
							} else {
								alert("导入失败：文件格式不正确。");
							}
						} catch (error) {
							alert(`导入失败：文件解析错误。${error.message}`);
						}
					};
					reader.readAsText(file);
				}

				/**
				 * 在外观设置页面渲染出所有App的名称设置项
				 */
				function renderAppNameSettings() {
					const grid = document.getElementById("icon-rename-grid");
					if (!grid) return;
					grid.innerHTML = "";

					const appLabels = state.globalSettings.appLabels || {};

					// 遍历默认标签对象，以确保所有app都有设置项
					for (const appId in DEFAULT_APP_LABELS) {
						if (DEFAULT_APP_LABELS.hasOwnProperty(appId)) {
							const defaultName = DEFAULT_APP_LABELS[appId];
							const currentName = appLabels[appId] || defaultName;

							const item = document.createElement("div");
							item.className = "form-group";
							item.style.marginBottom = "0"; // 让布局更紧凑
							item.innerHTML = `
                                <label for="rename-input-${appId}">${defaultName}</label>
                                <input type="text" id="rename-input-${appId}" class="app-rename-input" data-appid="${appId}" value="${currentName}">
                            `;
							grid.appendChild(item);
						}
					}
				}

				/**
				 * 将保存的App名称应用到主屏幕的图标上
				 */
				function applyAppLabels() {
					const appLabels = state.globalSettings.appLabels || {};

					for (const appId in DEFAULT_APP_LABELS) {
						if (DEFAULT_APP_LABELS.hasOwnProperty(appId)) {
							const defaultName = DEFAULT_APP_LABELS[appId];
							const customName = appLabels[appId] || defaultName;

							// 这个选择器会同时找到主屏幕和Dock栏上的所有图标
							const icons = document.querySelectorAll(`.desktop-app-icon [id="icon-img-${appId}"]`);

							icons.forEach((iconImg) => {
								const appIconContainer = iconImg.closest(".desktop-app-icon");
								if (appIconContainer) {
									const labelElement = appIconContainer.querySelector(".label");
									if (labelElement) {
										labelElement.textContent = customName;
									}
								}
							});
						}
					}
				}

				/**
				 * 从输入框读取并保存用户修改的App名称
				 */
				function saveAppLabels() {
					const appNameInputs = document.querySelectorAll(".app-rename-input");
					if (!state.globalSettings.appLabels) {
						state.globalSettings.appLabels = {};
					}

					appNameInputs.forEach((input) => {
						const appId = input.dataset.appid;
						const newName = input.value.trim();
						const defaultName = DEFAULT_APP_LABELS[appId];

						// 如果用户输入了新名字，且和默认名字不一样，就保存
						if (newName && newName !== defaultName) {
							state.globalSettings.appLabels[appId] = newName;
						} else {
							// 如果用户清空了输入框，或者改回了默认名字，就删除保存记录，以恢复默认
							delete state.globalSettings.appLabels[appId];
						}
					});
				}

				/**
				 * 处理导入的SillyTavern世界书文件
				 * @param {File} file - 用户选择的JSON文件
				 */
				async function handleImportSillyTavernWorldBook(file) {
					// 使用FileReader来读取文件内容
					const reader = new FileReader();
					reader.onload = async (e) => {
						try {
							const text = e.target.result;
							const data = JSON.parse(text);

							// 验证文件格式是否正确，确保包含'entries'对象
							if (!data.entries || typeof data.entries !== "object") {
								throw new Error("文件格式无效。SillyTavern世界书应包含'entries'对象。");
							}

							// 从文件名提取名称，作为新的分类名
							let categoryName = file.name.replace(/\.(json|jsonl)$/i, "").trim();
							if (!categoryName) categoryName = "导入的世界书";

							// 检查该分类是否已存在，如果不存在则创建
							let category = await db.worldBookCategories.where("name").equals(categoryName).first();
							if (!category) {
								const newCategoryId = await db.worldBookCategories.add({ name: categoryName });
								category = { id: newCategoryId, name: categoryName };
								console.log(`创建了新的世界书分类: ${categoryName} (ID: ${newCategoryId})`);
							} else {
								console.log(`将条目添加到已存在的分类: ${categoryName} (ID: ${category.id})`);
							}

							const newBooks = [];
							// 遍历SillyTavern worldbook中的所有条目
							for (const key in data.entries) {
								const entry = data.entries[key];

								// 导入所有条目，包括被禁用的
								if (entry) {
									// 使用entry.comment作为书名，如果为空则使用"条目 key"作为备用
									const entryName = (entry.comment || `条目 ${key}`).trim();
									const entryContent = (entry.content || "").trim();
									// 确保书名和内容都不为空
									if (entryName && entryContent) {
										newBooks.push({
											id: "wb_" + Date.now() + Math.random(), // 创建唯一ID
											name: entryName,
											content: entryContent,
											categoryId: category.id, // 归属到新的分类
										});
									}
								}
							}

							if (newBooks.length === 0) {
								alert("没有找到任何可导入的有效条目。");
								return;
							}

							// 批量将新书添加到数据库，效率更高
							await db.worldBooks.bulkAdd(newBooks);
							// 更新内存中的state，以便UI能立即刷新
							state.worldBooks.push(...newBooks);

							// 重新渲染世界书列表，显示新内容
							await renderWorldBookScreen();
							await showCustomAlert("导入成功", `成功将《${categoryName}》中的 ${newBooks.length} 个条目导入到世界书！`);
						} catch (error) {
							console.error("导入世界书失败:", error);
							await showCustomAlert("导入失败", `无法解析文件，请确保它是有效的SillyTavern世界书JSON文件。\n\n错误: ${error.message}`);
						}
					};
					// 以UTF-8编码读取文件内容
					reader.readAsText(file, "UTF-8");
				}

				/**
				 * 当用户点击"更换背景"按钮时，弹出操作菜单
				 */
				async function handleInnerVoiceBgChange() {
					const choice = await showChoiceModal("更换心声背景", [
						{ text: "上传新背景", value: "upload" },
						{ text: "恢复默认", value: "reset" },
					]);

					if (choice === "upload") {
						// 触发隐藏的文件选择器
						document.getElementById("inner-voice-bg-input").click();
					} else if (choice === "reset") {
						// 调用保存函数并传入空字符串，表示恢复默认
						await saveInnerVoiceBackground("");
					}
				}

				/**
				 * 保存新的背景图片URL到当前角色
				 * @param {string} url - 图片的URL (可以是网络链接或Base64)
				 */
				async function saveInnerVoiceBackground(url) {
					if (!state.activeChatId) return;
					const chat = state.chats[state.activeChatId];
					if (!chat) return;

					// 将背景URL保存在当前角色的数据中
					chat.innerVoiceBackground = url;

					// 将更新后的整个 chat 对象保存回数据库
					await db.chats.put(chat);

					// 立即应用新的背景
					applyInnerVoiceBackground(url);

					// 给用户一个反馈
					alert(url ? "当前角色背景已更新！" : "当前角色背景已恢复默认。");
				}

				/**
				 * 将指定的背景图应用到心声面板上
				 * @param {string} url - 图片的URL
				 */
				function applyInnerVoiceBackground(url) {
					const panel = document.getElementById("inner-voice-main-panel");
					if (!panel) return;

					if (url) {
						panel.style.backgroundImage = `url(${url})`;
					} else {
						// 如果URL为空，就移除背景图，恢复CSS中定义的默认样式
						panel.style.backgroundImage = "none";
					}
				}

				/**
				 * 估算文本的Token数 (按字符数计算)
				 * @param {string} text - 要计算的文本
				 * @returns {number} - 估算的token数
				 */
				function calculateTokenCount(text) {
					if (!text) return 0;
					// 这是一个非常简化的估算，直接返回字符数。
					// 对于中文，一个字约等于1-2个token。对于英文，一个词约等于1.3个token。
					// 直接用字符数作为一个简单直观的参考值。
					return text.length;
				}

				/**
				 * 为Token计算准备完整的上下文和提示词
				 * @param {string} chatId - 目标聊天的ID
				 * @returns {Promise<string>} - 拼接好的、将要发送给AI的完整文本
				 */
				async function getContextForTokenCalculation(chatId) {
					const chat = state.chats[chatId];
					if (!chat) return "";

					let combinedText = "";
					const settings = chat.settings;

					// 1. 添加核心提示词 (人设)
					if (chat.isGroup) {
						const membersList = chat.members.map((m) => `- **${m.originalName}**: ${m.persona}`).join("\n");
						const myNickname = chat.settings.myNickname || "我";
						combinedText += `你是一个群聊AI... # 群成员列表及人设\n${membersList}\n# 用户的角色\n- **${myNickname}**: ${chat.settings.myPersona}`;
					} else {
						combinedText += chat.settings.aiPersona || "";
						combinedText += chat.settings.myPersona || "";
					}

					// 2. 添加世界书内容
					if (settings.linkedWorldBookIds && settings.linkedWorldBookIds.length > 0) {
						const linkedContents = settings.linkedWorldBookIds
							.map((bookId) => {
								const worldBook = state.worldBooks.find((wb) => wb.id === bookId);
								return worldBook ? worldBook.content : "";
							})
							.join("\n");
						combinedText += linkedContents;
					}

					// 3. 添加所有总结作为长期记忆
					const summaryContext = chat.history
						.filter((msg) => msg.type === "summary")
						.map((s) => s.content)
						.join("\n");
					combinedText += summaryContext;

					// 4. 添加最近的对话记录 (上下文记忆)
					const history = chat.history.filter((msg) => !msg.isHidden);
					const memoryDepth = settings.maxMemory || 10;
					const contextMessages = history.slice(-memoryDepth);

					const messageText = contextMessages
						.map((msg) => {
							let content = "";
							if (typeof msg.content === "string") {
								content = msg.content;
							} else if (Array.isArray(msg.content)) {
								content = "[图片]"; // 将图片简化为占位符
							} else if (msg.type) {
								content = `[${msg.type}]`;
							}
							const sender = msg.role === "user" ? "用户" : msg.senderName || chat.name;
							return `${sender}: ${content}`;
						})
						.join("\n");

					combinedText += "\n" + messageText;

					return combinedText;
				}

				/**
				 * 清理所有与已删除角色关联的失效数据
				 */
				async function clearOrphanedData() {
					// 在执行敏感操作前，先弹窗向用户确认
					const confirmed = await showCustomConfirm(
						"确认清理",
						"此操作将扫描并删除所有与【已不存在的角色】关联的数据（如动态、微博、回忆、通话记录等），释放存储空间。\n\n此操作不可撤销，确定要继续吗？",
						{ confirmButtonClass: "btn-danger" } // 使用醒目的红色按钮
					);

					// 如果用户点了"取消"，则直接退出
					if (!confirmed) return;

					// 显示一个"处理中"的提示，避免用户以为程序卡死
					await showCustomAlert("请稍候...", "正在扫描并清理失效数据...");

					try {
						let totalDeletedCount = 0;

						// 获取所有仍然存在的、有效的角色ID列表
						const validChatIds = new Set((await db.chats.toArray()).map((c) => c.id));
						validChatIds.add("user"); // 'user' (即"我") 永远是有效的作者

						// 定义我们需要检查的数据库表和它们用来关联角色ID的字段名
						const tablesToCheck = [
							{ name: "qzonePosts", idField: "authorId", typeName: "动态" },
							{ name: "weiboPosts", idField: "authorId", typeName: "微博" },
							{ name: "memories", idField: "chatId", typeName: "回忆/约定" },
							{ name: "callRecords", idField: "chatId", typeName: "通话记录" },
						];

						// 遍历每一个需要检查的表
						for (const tableInfo of tablesToCheck) {
							const table = db[tableInfo.name];
							const allItems = await table.toArray();

							// 找出所有作者ID已经不存在的"孤儿"数据
							const idsToDelete = allItems.filter((item) => !validChatIds.has(item[tableInfo.idField])).map((item) => item.id);

							// 如果找到了需要删除的数据
							if (idsToDelete.length > 0) {
								await table.bulkDelete(idsToDelete); // 批量删除，效率更高
								console.log(`从 ${tableInfo.name} 表中清除了 ${idsToDelete.length} 条失效数据。`);
								totalDeletedCount += idsToDelete.length;
							}
						}

						// 根据清理结果，给用户最终的反馈
						if (totalDeletedCount > 0) {
							await showCustomAlert("清理完成", `已成功清理 ${totalDeletedCount} 条失效数据！`);
						} else {
							await showCustomAlert("扫描完成", "未发现任何可清理的失效数据。");
						}
					} catch (error) {
						console.error("清理失效数据时出错:", error);
						await showCustomAlert("操作失败", `清理过程中发生错误: ${error.message}`);
					}
				}

				/**
				 * 处理取消情侣空间
				 */
				async function handleCancelLoversSpace() {
					if (!activeLoversSpaceCharId) return;
					const confirmed = await showCustomConfirm("取消情侣空间", "确定要取消情侣空间吗？这会使空间变为未启用状态，但所有数据（说说、照片等）都会被保留。此操作不会通知对方。", { confirmButtonClass: "btn-danger" });

					if (confirmed) {
						const chat = state.chats[activeLoversSpaceCharId];
						if (chat && chat.loversSpaceData) {
							// 将情侣空间数据设置为null，即可禁用它
							chat.loversSpaceData = null;
							await db.chats.put(chat);
							document.getElementById("ls-settings-modal").classList.remove("visible");
							alert("情侣空间已取消。");
							// 返回到聊天列表主屏幕
							showScreen("chat-list-screen");
						}
					}
				}

				/**
				 * 处理解除情侣关系
				 */
				async function handleDisconnectLoversSpace() {
					if (!activeLoversSpaceCharId) return;
					const chat = state.chats[activeLoversSpaceCharId];
					if (!chat) return;

					const confirmed = await showCustomConfirm("解除关系", `确定要与"${chat.name}"解除关系吗？情侣空间将被取消，并且对方会收到通知并对此发表意见。`, { confirmButtonClass: "btn-danger" });

					if (confirmed) {
						// 1. 禁用空间
						chat.loversSpaceData = null;

						// 创建您发出的、在右侧的"解除卡片"
						const userDisconnectCardMessage = {
							role: "user",
							type: "lovers_space_disconnect", // 一个新类型，用于渲染卡片
							content: `情侣空间已解除`, // 卡片底层可编辑的文字
							timestamp: Date.now(),
						};
						chat.history.push(userDisconnectCardMessage);

						// 创建居中的、灰色的"系统通知"
						const systemNotification = {
							role: "system",
							type: "pat_message", // 复用"拍一拍"的居中灰色气泡样式
							content: `你和 ${chat.name} 的情侣空间已解除`,
							timestamp: Date.now() + 1, // 时间戳+1确保在卡片之后
						};
						chat.history.push(systemNotification);

						// 给AI看的隐藏指令
						const hiddenMessageForAI = {
							role: "system",
							content: `[系统指令：用户刚刚解除了与你的情侣关系。]`,
							timestamp: Date.now() + 2, // 时间戳再+1
							isHidden: true,
						};
						chat.history.push(hiddenMessageForAI);

						// 保存、关闭弹窗、跳转、触发回应
						await db.chats.put(chat);
						document.getElementById("ls-settings-modal").classList.remove("visible");
						document.getElementById("lovers-space-screen").classList.remove("visible");

						openChat(activeLoversSpaceCharId);

						alert("关系已解除，对方已知晓。");
						triggerAiResponse();
					}
				}

				/**
				 * 打开手动总结的模式选择弹窗
				 */
				async function openManualSummaryOptions() {
					const choice = await showChoiceModal("手动总结", [
						{ text: "总结最新内容", value: "latest" },
						{ text: "总结指定范围", value: "range" },
					]);

					if (choice === "latest") {
						// 用户选择总结最新，调用主函数并传入'latest'模式
						await triggerManualSummaryNow("latest");
					} else if (choice === "range") {
						// 用户选择总结范围，调用范围输入函数
						await promptForSummaryRange();
					}
				}

				/**
				 * 提示用户输入要总结的消息范围
				 */
				async function promptForSummaryRange() {
					const chat = state.chats[state.activeChatId];
					if (!chat) return;

					const totalMessages = chat.history.length;
					if (totalMessages === 0) {
						alert("聊天记录为空，无法进行总结。");
						return;
					}

					// 弹出输入框，让用户输入开始序号
					const startStr = await showCustomPrompt("指定范围", `请输入开始的消息序号 (1 - ${totalMessages})`, "1", "number");
					if (startStr === null) return; // 用户点击了取消

					const startNum = parseInt(startStr);
					if (isNaN(startNum) || startNum < 1 || startNum > totalMessages) {
						alert("请输入有效的开始序号。");
						return;
					}

					// 弹出输入框，让用户输入结束序号
					const endStr = await showCustomPrompt("指定范围", `请输入结束的消息序号 (${startNum} - ${totalMessages})`, totalMessages, "number");
					if (endStr === null) return; // 用户点击了取消

					const endNum = parseInt(endStr);
					if (isNaN(endNum) || endNum < startNum || endNum > totalMessages) {
						alert("请输入有效的结束序号。");
						return;
					}

					// 调用主函数并传入'range'模式和具体的范围
					await triggerManualSummaryNow("range", { start: startNum, end: endNum });
				}

				/**
				 * 将时间字符串（如 "20:00", "早上9点"）解析为分钟数
				 * @param {string} timeStr - 时间字符串
				 * @returns {number} - 从午夜0点开始的分钟数
				 */
				function parseTime(timeStr) {
					if (!timeStr || typeof timeStr !== "string") return -1; // 错误或无效输入返回-1

					let hours = 0;
					let minutes = 0;

					// 匹配 "HH:mm" 或 "H:mm" 格式
					const match = timeStr.match(/(\d{1,2}):(\d{2})/);
					if (match) {
						hours = parseInt(match[1], 10);
						minutes = parseInt(match[2], 10);
					} else {
						// 如果不是标准格式，尝试匹配中文描述
						const numMatch = timeStr.match(/(\d+)/);
						const num = numMatch ? parseInt(numMatch[0], 10) : -1;

						if (num !== -1) {
							if (timeStr.includes("下午") || timeStr.includes("晚上")) {
								// 下午1点(13点)到晚上11点(23点)
								if (num < 12) {
									hours = num + 12;
								} else {
									hours = num; // 如果已经是24小时制如"晚上20点"，直接使用
								}
							} else {
								// 早上或上午
								hours = num;
							}
						} else {
							return -1; // 无法解析
						}
					}

					// 处理特殊情况，如晚上12点应为0点
					if ((timeStr.includes("晚上") || timeStr.includes("凌晨")) && hours === 12) {
						hours = 0;
					}
					// 处理下午12点应为12点
					if ((timeStr.includes("下午") || timeStr.includes("中午")) && hours === 24) {
						hours = 12;
					}

					return hours * 60 + minutes;
				}

				/**
				 * 检查并更新火花天数 (已修复熄灭后从1开始的问题)
				 * @param {string} chatId - 要更新火花的聊天ID
				 * @returns {Promise<boolean>} - 如果火花天数有变化，则返回true
				 */
				async function updateStreak(chatId) {
					const chat = state.chats[chatId];
					// 如果不是单聊，或者功能未开启，直接返回
					if (!chat || chat.isGroup || !chat.settings.streak?.enabled) {
						return false;
					}

					const streak = chat.settings.streak;
					const today = new Date().toISOString().split("T")[0]; // YYYY-MM-DD格式

					// 如果今天已经互动过了，就什么都不做
					if (streak.lastInteractionDate === today) {
						return false;
					}

					let changed = false;

					// 检查火花是否已熄灭
					if (streak.lastInteractionDate && streak.extinguishThreshold !== -1) {
						const lastDate = new Date(streak.lastInteractionDate);
						const todayDate = new Date(today);
						// 为了精确计算天数差异，我们将两个日期都设置为UTC时间的午夜
						const lastDateUTC = Date.UTC(lastDate.getFullYear(), lastDate.getMonth(), lastDate.getDate());
						const todayDateUTC = Date.UTC(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate());

						const daysDiff = (todayDateUTC - lastDateUTC) / (1000 * 60 * 60 * 24);

						if (daysDiff >= streak.extinguishThreshold) {
							// 如果断联天数达到了你设置的阈值，就将当前火花天数归零。
							streak.currentDays = 0;
							console.log(`🔥 与 ${chat.name} 的火花因超过 ${streak.extinguishThreshold} 天未联系而熄灭，将重新从 1 开始计算。`);
							changed = true;
						}
					}

					// 今天是新的互动日，天数+1
					// 如果是永不熄灭模式，currentDays 为 -1, 不应该增加
					if (streak.currentDays >= 0) {
						streak.currentDays++;
						changed = true;
					}

					// 无论火花是否熄灭，只要今天互动了，就把"最后互动日期"更新为今天。
					streak.lastInteractionDate = today;

					await db.chats.put(chat);

					if (changed) {
						console.log(`🔥 与 ${chat.name} 的火花天数更新为: ${streak.currentDays}`);
					}

					return changed; // 返回是否发生了变化
				}

				/**
				 * 处理设置/取消管理员
				 */
				async function handleToggleAdmin(memberId) {
					const chat = state.chats[state.activeChatId];
					// 权限检查：确保操作者是群主
					if (!chat || chat.ownerId !== "user") {
						alert("你不是群主，没有权限执行此操作！");
						return;
					}

					let targetNickname;
					let isAdminNow;

					// 判断操作目标是不是用户自己
					if (memberId === "user") {
						// 如果是用户，就修改 chat.settings 里的专属标志
						// 我们使用 isUserAdmin 属性来记录用户是否是管理员
						chat.settings.isUserAdmin = !chat.settings.isUserAdmin;
						targetNickname = chat.settings.myNickname || "我";
						isAdminNow = chat.settings.isUserAdmin;
					} else {
						// 如果是其他成员，保持原有逻辑不变
						const member = chat.members.find((m) => m.id === memberId);
						if (!member) return;

						// 不能将群主设为管理员或取消其管理员身份
						if (member.id === chat.ownerId) {
							alert("不能对群主进行此操作。");
							return;
						}

						member.isAdmin = !member.isAdmin;
						targetNickname = member.groupNickname;
						isAdminNow = member.isAdmin;
					}

					await db.chats.put(chat);

					// 准备并发送系统通知消息
					const actionText = isAdminNow ? "设为管理员" : "取消了管理员身份";
					const myNickname = chat.settings.myNickname || "我";
					// 这里我们用 logSystemMessage 函数来发送通知，它会自动刷新UI
					await logSystemMessage(chat.id, `"${myNickname}"将"${targetNickname}"${actionText}。`);

					// 刷新成员管理列表的显示
					renderMemberManagementList();
				}

				/**
				 * 处理设置群成员头衔
				 */
				async function handleSetMemberTitle(memberId) {
					const chat = state.chats[state.activeChatId];
					// 权限检查：群主或管理员才能设置
					const isOwner = chat.ownerId === "user";
					const isAdmin = chat.settings.isUserAdmin;

					if (!chat || (!isOwner && !isAdmin)) {
						alert("你不是群主或管理员，没有权限执行此操作！");
						return;
					}

					let targetNickname;
					let oldTitle;

					if (memberId === "user") {
						targetNickname = chat.settings.myNickname || "我";
						oldTitle = chat.settings.myGroupTitle || "";
					} else {
						const member = chat.members.find((m) => m.id === memberId);
						if (!member) return;
						targetNickname = member.groupNickname;
						oldTitle = member.groupTitle || "";
					}

					const newTitle = await showCustomPrompt(`为"${targetNickname}"设置头衔`, "留空则为取消头衔", oldTitle);

					if (newTitle !== null) {
						const trimmedTitle = newTitle.trim();
						if (memberId === "user") {
							chat.settings.myGroupTitle = trimmedTitle;
						} else {
							const member = chat.members.find((m) => m.id === memberId);
							if (member) member.groupTitle = trimmedTitle;
						}

						await db.chats.put(chat);

						const myNickname = chat.settings.myNickname || "我";
						await logTitleChange(chat.id, myNickname, targetNickname, trimmedTitle);

						renderMemberManagementList();
					}
				}

				/**
				 * 处理转让群主 (已添加系统消息通知)
				 */
				async function handleTransferOwnership(memberId) {
					const chat = state.chats[state.activeChatId];
					const newOwner = chat.members.find((m) => m.id === memberId);
					if (!newOwner) return;

					// 获取旧群主的昵称，也就是你自己的昵称
					const oldOwnerNickname = chat.settings.myNickname || "我";

					const confirmed = await showCustomConfirm("转让群主", `你确定要将群主身份转让给"${newOwner.groupNickname}"吗？\n此操作不可撤销，你将失去群主权限。`, { confirmButtonClass: "btn-danger" });

					if (confirmed) {
						// 更新群主ID
						chat.ownerId = newOwner.id;

						// 将新群主设为管理员（如果他之前不是）
						newOwner.isAdmin = true;

						// 构建系统消息的内容
						const message = `"${oldOwnerNickname}"已将群主转让给"${newOwner.groupNickname}"`;

						// 调用已有的函数来发送这条系统消息
						await logSystemMessage(chat.id, message);

						// 刷新成员管理列表的显示
						renderMemberManagementList();

						// 给出成功提示
						await showCustomAlert("操作成功", `群主已成功转让给"${newOwner.groupNickname}"。`);
					}
				}

				/**
				 * 发送一条居中显示的系统消息到当前聊天
				 * @param {string} chatId - 目标聊天的ID
				 * @param {string} messageContent - 要显示的消息内容
				 */
				async function logSystemMessage(chatId, messageContent) {
					const chat = state.chats[chatId];
					if (!chat) return;

					// 1. 创建系统消息对象
					const systemMessage = {
						role: "system", // 这是一个系统角色的消息
						type: "pat_message", // 复用"拍一拍"的居中灰色气泡样式
						content: messageContent,
						timestamp: Date.now(),
					};

					// 2. 将消息添加到聊天记录并保存
					chat.history.push(systemMessage);
					await db.chats.put(chat);

					// 3. 如果用户正在查看此聊天，则立即显示新消息
					if (state.activeChatId === chatId && document.getElementById("chat-interface-screen").classList.contains("active")) {
						appendMessage(systemMessage, chat);
					}

					// 4. 刷新聊天列表以更新预览
					await renderChatList();

					console.log(`系统消息已记录: ${messageContent}`);
				}

				/**
				 * 记录并发送群头衔变更的系统消息
				 * @param {string} chatId - 发生变更的群聊ID
				 * @param {string} actorName - 执行操作的人的昵称
				 * @param {string} targetName - 被修改头衔的人的昵称
				 * @param {string} newTitle - 新的头衔
				 */
				async function logTitleChange(chatId, actorName, targetName, newTitle) {
					// 1. 构造消息内容
					const messageContent = newTitle ? `${actorName} 将"${targetName}"的群头衔修改为"${newTitle}"` : `${actorName} 取消了"${targetName}"的群头衔`;

					// 2. 调用通用的系统消息函数
					await logSystemMessage(chatId, messageContent);
				}

				/* 群公告功能核心函数 */

				/**
				 * 打开群公告弹窗并渲染内容
				 */
				function openGroupAnnouncementModal() {
					const chat = state.chats[state.activeChatId];
					if (!chat || !chat.isGroup) return;

					const modal = document.getElementById("group-announcement-modal");
					const contentArea = document.getElementById("announcement-content-area");
					const footer = document.getElementById("announcement-footer");

					const announcement = chat.settings.groupAnnouncement || "暂无公告";
					contentArea.innerHTML = announcement.replace(/\n/g, "<br>");

					const canEdit = chat.ownerId === "user" || chat.settings.isUserAdmin;

					footer.innerHTML = "";
					if (canEdit) {
						const editBtn = document.createElement("button");
						editBtn.className = "cancel";
						editBtn.textContent = "编辑";
						// 改用 addEventListener 来绑定事件，更安全可靠
						editBtn.addEventListener("click", editGroupAnnouncement);
						footer.appendChild(editBtn);
					}

					const closeBtn = document.createElement("button");
					closeBtn.className = "save";
					closeBtn.textContent = "关闭";
					// 同样改用 addEventListener
					closeBtn.addEventListener("click", closeGroupAnnouncementModal);
					footer.appendChild(closeBtn);

					modal.classList.add("visible");
				}

				/**
				 * 进入公告编辑模式
				 */
				function editGroupAnnouncement() {
					const chat = state.chats[state.activeChatId];
					const contentArea = document.getElementById("announcement-content-area");
					const footer = document.getElementById("announcement-footer");

					const currentContent = chat.settings.groupAnnouncement || "";
					contentArea.innerHTML = `<textarea id="announcement-editor">${currentContent}</textarea>`;

					// 这里也全部改用 addEventListener 的方式绑定
					footer.innerHTML = ""; // 先清空

					const cancelBtn = document.createElement("button");
					cancelBtn.className = "cancel";
					cancelBtn.textContent = "取消";
					cancelBtn.addEventListener("click", closeGroupAnnouncementModal); // 直接调用函数

					const saveBtn = document.createElement("button");
					saveBtn.className = "save";
					saveBtn.textContent = "保存";
					saveBtn.addEventListener("click", saveGroupAnnouncement); // 直接调用函数

					footer.appendChild(cancelBtn);
					footer.appendChild(saveBtn);

					document.getElementById("announcement-editor").focus();
				}

				/**
				 * 保存新的群公告
				 */
				async function saveGroupAnnouncement() {
					const chat = state.chats[state.activeChatId];
					const newContent = document.getElementById("announcement-editor").value.trim();

					chat.settings.groupAnnouncement = newContent;
					await db.chats.put(chat);

					const myNickname = chat.settings.myNickname || "我";
					await logSystemMessage(chat.id, `"${myNickname}"修改了群公告。`);

					closeGroupAnnouncementModal();
					alert("群公告已更新！");
				}

				/**
				 * 关闭群公告弹窗
				 */
				function closeGroupAnnouncementModal() {
					// 关闭后，重新渲染一次查看状态，以防用户取消了编辑
					const modal = document.getElementById("group-announcement-modal");
					modal.classList.remove("visible");
					// 延迟一点点再打开，可以避免视觉上的冲突
					setTimeout(() => {
						if (modal.classList.contains("visible")) {
							// 做个检查，万一用户快速操作
							openGroupAnnouncementModal();
						}
					}, 10);
					// 直接关闭，不再重新打开
					document.getElementById("group-announcement-modal").classList.remove("visible");
				}

				/**
				 * 获取并格式化当前聊天的续火花状态，生成给AI看的上下文
				 * @param {object} chat - 当前的聊天对象
				 * @returns {string} - 格式化后的火花状态文本，或空字符串
				 */
				async function getStreakContext(chat) {
					// 1. 安全检查：如果不是单聊，或者功能未开启，则直接返回空内容
					if (!chat || chat.isGroup || !chat.settings.streak?.enabled) {
						return "";
					}

					const streak = chat.settings.streak;
					const currentDays = streak.currentDays || 0;
					const extinguishThreshold = streak.extinguishThreshold || 1;
					const lastInteractionDate = streak.lastInteractionDate;
					let isExtinguished = false;

					// 2. 判断火花是否已熄灭
					if (lastInteractionDate && extinguishThreshold !== -1) {
						const lastDate = new Date(lastInteractionDate);
						const todayDate = new Date();
						todayDate.setHours(0, 0, 0, 0); // 将时间设为当日零点，以精确计算天数

						// 计算最后一次互动到今天过了多少天
						const daysDiff = (todayDate.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24);

						if (daysDiff >= extinguishThreshold) {
							isExtinguished = true;
						}
					}

					let statusText = "";

					// 3. 根据不同状态，生成给AI看的不同文本
					if (isExtinguished && currentDays > 0) {
						// 这种状态表示"曾经有过火花，但现在断了"
						statusText = `你们的聊天火花【已熄灭】。之前曾连续聊了 ${currentDays} 天，但现在中断了。`;
					} else if (currentDays > 10) {
						statusText = `你们的聊天火花正在热烈燃烧，已经持续了【${currentDays}】天了！这是一个值得纪念的数字。`;
					} else if (currentDays > 0) {
						statusText = `你们的聊天火花正在延续，已经持续了【${currentDays}】天。`;
					} else {
						// 天数为0，说明是刚开启或刚重置
						statusText = "你们刚刚点燃了聊天火花，要继续保持哦！";
					}

					// 4. 拼接成最终的上下文格式
					return `\n- **聊天火花状态**: ${statusText}`;
				}

				/* 用户表情包批量删除的JS核心函数 */

				/**
				 * 切换用户表情包的选择模式
				 */
				function toggleUserStickerSelectionMode() {
					isUserStickerSelectionMode = !isUserStickerSelectionMode;
					const stickerPanel = document.getElementById("sticker-panel");

					selectedUserStickers.clear();
					// 核心修改：在这里给父容器添加/移除一个class
					stickerPanel.classList.toggle("selection-mode", isUserStickerSelectionMode);

					document.getElementById("edit-user-stickers-btn").style.display = isUserStickerSelectionMode ? "none" : "block";
					document.getElementById("done-user-stickers-btn").style.display = isUserStickerSelectionMode ? "block" : "none";
					document.getElementById("sticker-panel-footer").style.display = isUserStickerSelectionMode ? "flex" : "none";

					const deleteBtn = document.getElementById("delete-selected-user-stickers-btn");
					deleteBtn.textContent = `删除已选 (0)`;
					deleteBtn.disabled = true;

					const moveBtn = document.getElementById("move-selected-stickers-btn");
					moveBtn.disabled = true;

					renderStickerPanel(); // 这一步会调用 renderStickerCategories，并根据新的模式重新渲染
				}

				/**
				 * 退出用户表情包的选择模式
				 */
				function exitUserStickerSelectionMode() {
					if (isUserStickerSelectionMode) {
						toggleUserStickerSelectionMode();
					}
				}

				/* 角色表情包批量删除的JS核心函数 */

				/**
				 * 切换角色表情包的选择模式
				 */
				function toggleCharStickerSelectionMode() {
					isCharStickerSelectionMode = !isCharStickerSelectionMode;
					const screen = document.getElementById("char-sticker-manager-screen");

					// 清空选择集并更新UI
					selectedCharStickers.clear();
					screen.classList.toggle("selection-mode", isCharStickerSelectionMode);

					document.getElementById("edit-char-stickers-btn").style.display = isCharStickerSelectionMode ? "none" : "block";
					document.getElementById("done-char-stickers-btn").style.display = isCharStickerSelectionMode ? "block" : "none";
					document.getElementById("char-sticker-footer").style.display = isCharStickerSelectionMode ? "block" : "none";
					document.getElementById("delete-selected-char-stickers-btn").textContent = `删除已选 (0)`;
					document.getElementById("delete-selected-char-stickers-btn").disabled = true;

					// 重新渲染当前激活的页签
					const activeTab = document.querySelector("#char-sticker-manager-screen .frame-tab.active");
					if (activeTab) {
						renderCharStickers(activeTab.id === "sticker-tab-exclusive" ? "exclusive" : "common");
					}
				}

				/**
				 * 退出角色表情包的选择模式
				 */
				function exitCharStickerSelectionMode() {
					if (isCharStickerSelectionMode) {
						toggleCharStickerSelectionMode();
					}
				}

				/**
				 * 当用户点击心声面板的编辑按钮时，打开操作菜单
				 */
				async function showInnerVoiceEditOptions() {
					const chat = state.chats[state.activeChatId];
					if (!chat) return;

					const borderHidden = chat.settings.innerVoiceHideHeaderBorder || false;
					const borderOptionText = borderHidden ? "显示分割线" : "隐藏分割线";

					// 在选项数组里新增了 'editStyles'
					const choice = await showChoiceModal("编辑心声面板", [
						{ text: "🎨 编辑面板样式", value: "editStyles" },
						{ text: borderOptionText, value: "toggleBorder" },
						{ text: "修改领养人", value: "editAdopter" },
					]);

					if (choice === "editStyles") {
						openInnerVoiceStyleEditor(); // 调用我们新写的函数来打开样式编辑器
					} else if (choice === "toggleBorder") {
						await toggleInnerVoiceHeaderBorder();
					} else if (choice === "editAdopter") {
						await editInnerVoiceAdopterName();
					}
				}

				/**
				 * 切换心声面板头部分割线的显示/隐藏
				 */
				async function toggleInnerVoiceHeaderBorder() {
					const chat = state.chats[state.activeChatId];
					if (!chat) return;

					// 确保 chat.settings 存在
					if (!chat.settings) chat.settings = {};

					// 切换布尔值
					chat.settings.innerVoiceHideHeaderBorder = !(chat.settings.innerVoiceHideHeaderBorder || false);

					// 保存到数据库
					await db.chats.put(chat);

					// 更新UI
					const header = document.querySelector("#inner-voice-main-panel .modal-header");
					if (header) {
						header.classList.toggle("no-border", chat.settings.innerVoiceHideHeaderBorder);
					}

					await showCustomAlert("操作成功", `分割线已${chat.settings.innerVoiceHideHeaderBorder ? "隐藏" : "显示"}。`);
				}

				/**
				 * 修改"领养人"的标签模板
				 */
				async function editInnerVoiceAdopterName() {
					const chat = state.chats[state.activeChatId];
					if (!chat) return;

					// 获取当前的标签模板，如果没有设置过，就使用默认值
					const currentFormat = chat.settings.innerVoiceAdopterLabelFormat || "领养人: {{user}}";

					// 弹出输入框，让用户编辑整个模板字符串
					const newFormat = await showCustomPrompt("修改领养人标签", "你可以修改整个标签，其中 {{user}} 会被自动替换为你的昵称。", currentFormat);

					// 如果用户输入了新内容（不是取消）
					if (newFormat !== null) {
						// 保存新模板，如果输入为空则恢复默认
						chat.settings.innerVoiceAdopterLabelFormat = newFormat.trim() || "领养人: {{user}}";
						await db.chats.put(chat);

						// 重新渲染心声面板以显示新标签
						openInnerVoiceModal();
						await showCustomAlert("修改成功", "领养人标签已更新！");
					}
				}

				/* 心声面板样式编辑功能的核心函数 */

				/**
				 * 将十六进制颜色(#FFFFFF)转换为 "R, G, B" 字符串 (255, 255, 255)
				 * @param {string} hex - 十六进制颜色代码
				 * @returns {string} - RGB字符串
				 */
				function hexToRgb(hex) {
					if (!hex || hex.length < 4) return "255, 255, 255";
					let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
					return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : "255, 255, 255";
				}

				/**
				 * 将保存的样式应用到心声面板
				 */
				function applySavedInnerVoiceStyles() {
					if (!state.activeChatId) return;
					const chat = state.chats[state.activeChatId];
					if (!chat || !chat.settings.innerVoiceStyles) return;

					const styles = chat.settings.innerVoiceStyles;
					const panel = document.getElementById("inner-voice-main-panel");

					panel.style.setProperty("--iv-color-clothing", styles.clothingColor);
					panel.style.setProperty("--iv-color-behavior", styles.behaviorColor);
					panel.style.setProperty("--iv-color-thoughts", styles.thoughtsColor);
					panel.style.setProperty("--iv-color-naughty", styles.naughtyColor);
					panel.style.setProperty("--iv-card-bg-rgb", hexToRgb(styles.cardBgColor));
					panel.style.setProperty("--iv-card-opacity", styles.cardOpacity);

					// 在这里应用我们保存的图标颜色
					panel.style.setProperty("--iv-icon-color", styles.iconColor || "#ff8a80");
				}

				/**
				 * 打开心声面板样式编辑器
				 */
				function openInnerVoiceStyleEditor() {
					if (!state.activeChatId) return;
					const chat = state.chats[state.activeChatId];
					if (!chat || !chat.settings.innerVoiceStyles) return;

					document.getElementById("inner-voice-edit-options-modal")?.classList.remove("visible");

					const styles = chat.settings.innerVoiceStyles;
					const modal = document.getElementById("inner-voice-editor-modal");

					// 加载当前样式到编辑器
					document.getElementById("iv-color-clothing").value = styles.clothingColor;
					document.getElementById("iv-color-behavior").value = styles.behaviorColor;
					document.getElementById("iv-color-thoughts").value = styles.thoughtsColor;
					document.getElementById("iv-color-naughty").value = styles.naughtyColor;
					document.getElementById("iv-card-bg-color").value = styles.cardBgColor;
					document.getElementById("iv-opacity-slider").value = styles.cardOpacity;
					document.getElementById("iv-opacity-value").textContent = `${Math.round(styles.cardOpacity * 100)}%`;

					// 加载我们保存的图标颜色
					document.getElementById("iv-icon-color").value = styles.iconColor || "#ff8a80";

					modal.classList.add("visible");
				}

				/**
				 * 保存用户修改的样式
				 */
				async function saveInnerVoiceStyles() {
					if (!state.activeChatId) return;
					const chat = state.chats[state.activeChatId];

					// 从编辑器读取新值
					const newStyles = {
						clothingColor: document.getElementById("iv-color-clothing").value,
						behaviorColor: document.getElementById("iv-color-behavior").value,
						thoughtsColor: document.getElementById("iv-color-thoughts").value,
						naughtyColor: document.getElementById("iv-color-naughty").value,
						cardBgColor: document.getElementById("iv-card-bg-color").value,
						cardOpacity: parseFloat(document.getElementById("iv-opacity-slider").value),
						iconColor: document.getElementById("iv-icon-color").value,
					};

					// 更新到state和数据库
					chat.settings.innerVoiceStyles = newStyles;
					await db.chats.put(chat);

					// 关闭弹窗
					document.getElementById("inner-voice-editor-modal").classList.remove("visible");

					// 重新应用一下最终保存的样式，以防万一
					applySavedInnerVoiceStyles();

					await showCustomAlert("保存成功", "心声面板的样式已更新！");
				}

				/**
				 * 打开AI生成群成员的模态框
				 */
				function openAiGenerateMembersModal() {
					// 清空上次的输入
					document.getElementById("ai-member-count-input").value = "3";
					document.getElementById("ai-member-prompt-input").value = "";
					// 显示弹窗
					document.getElementById("ai-generate-members-modal").classList.add("visible");
				}

				/**
				 * 处理用户点击"开始生成"按钮的逻辑
				 * 通过AI为指定群聊生成新成员
				 */
				async function handleGenerateMembers() {
					// 检查当前聊天是否存在且为群聊
					if (!state.activeChatId) return;
					const chat = state.chats[state.activeChatId];
					if (!chat || !chat.isGroup) return;

					// 获取用户输入的成员数量和要求
					const count = parseInt(document.getElementById("ai-member-count-input").value);
					const requirements = document.getElementById("ai-member-prompt-input").value.trim();

					// 验证成员数量有效性
					if (isNaN(count) || count < 1 || count > 20) {
						alert("请输入1到20之间的有效人数！");
						return;
					}

					// 关闭模态框并显示加载提示
					document.getElementById("ai-generate-members-modal").classList.remove("visible");
					await showCustomAlert("请稍候...", `AI正在为"${chat.name}"创造 ${count} 位新朋友...`);

					// 构建AI提示词
					const systemPrompt = `
                        # 任务
                        你是一个群聊成员生成器。请根据用户的要求，为群聊"${chat.name}"创建${count}个新成员。

                        # 用户要求:
                        ${requirements || "无特殊要求，请自由发挥。"}

                        # 核心规则
                        1.  你生成的每个成员都必须有独特的名字(name)和鲜明的性格人设(persona)。
                        2.  人设描述要生动、具体，能体现出角色的特点。
                        3.  【格式铁律】: 你的回复【必须且只能】是一个严格的JSON数组，直接以'['开头, 以']'结尾。数组中的每个元素都是一个代表成员的JSON对象。

                        # JSON输出格式示例:
                        [
                        {
                            "name": "林风",
                            "persona": "一个阳光开朗的运动系少年，热爱篮球，性格直爽，是团队里的气氛担当。"
                        },
                        {
                            "name": "陈雪",
                            "persona": "文静内向的学霸少女，喜欢读书和画画，心思细腻，不善言辞但观察力敏锐。"
                        }
                        ]
                        `;

					try {
						// 获取API配置信息
						const { proxyUrl, apiKey, model } = state.apiConfig;
						let isGemini = proxyUrl === GEMINI_API_URL;
						let messagesForApi = [{ role: "user", content: systemPrompt }];
						let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

						// 发送API请求
						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } }),
							  });

						// 检查响应状态
						if (!response.ok) throw new Error(`API请求失败: ${response.status} - ${await response.text()}`);

						// 解析响应数据
						const data = await response.json();
						const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, "").trim();
						const newMembersData = JSON.parse(rawContent);

						// 验证并处理返回的成员数据
						if (Array.isArray(newMembersData) && newMembersData.length > 0) {
							const addedNames = [];
							newMembersData.forEach((memberData, index) => {
								// 确保成员数据包含必要字段
								if (memberData.name && memberData.persona) {
									// 创建新成员对象
									const newMember = {
										id: "npc_" + (Date.now() + index),
										originalName: memberData.name.trim(),
										groupNickname: memberData.name.trim(),
										avatar: defaultGroupMemberAvatar,
										persona: memberData.persona.trim(),
										avatarFrame: "",
										isAdmin: false,
										groupTitle: "",
									};
									// 添加到群聊成员列表
									chat.members.push(newMember);
									addedNames.push(`"${newMember.groupNickname}"`);
								}
							});

							// 保存新成员并更新界面
							if (addedNames.length > 0) {
								await db.chats.put(chat);
								await logSystemMessage(chat.id, `邀请了 ${addedNames.length} 位新成员: ${addedNames.join("、")}加入了群聊。`);
								await showCustomAlert("生成成功！", `${addedNames.length} 位新成员已加入群聊！`);
								renderMemberManagementList(); // 刷新成员管理列表
							} else {
								throw new Error("AI返回的数据格式不正确，缺少name或persona字段。");
							}
						} else {
							throw new Error("AI返回的数据不是有效的数组。");
						}
					} catch (error) {
						// 处理错误情况
						console.error("AI生成群成员失败:", error);
						await showCustomAlert("生成失败", `发生了一个错误：\n${error.message}`);
					}
				}

				/**
				 * 当用户点击约会卡片时，打开角色选择器
				 * @param {object} scene - 被选中的约会场景对象
				 */
				async function openDatingCharacterSelector(scene) {
					const modal = document.getElementById("dating-char-selector-modal");
					const listEl = document.getElementById("dating-char-selector-list");
					listEl.innerHTML = "";

					// 找出所有可约会的单聊角色
					const singleChats = Object.values(state.chats).filter((chat) => !chat.isGroup);

					// 检查是否存在可约会角色
					if (singleChats.length === 0) {
						alert("你还没有任何可以约会的角色哦，先去创建一个吧！");
						return;
					}

					// 为每个角色创建列表项
					singleChats.forEach((chat) => {
						const item = document.createElement("div");
						item.className = "character-select-item"; // 复用现有的样式
						item.dataset.charId = chat.id; // 将角色ID存起来
						item.innerHTML = `
                            <img src="${chat.settings.aiAvatar || defaultAvatar}" alt="${chat.name}">
                            <span class="name">${chat.name}</span>
                        `;
						// 为每个角色项绑定点击事件
						item.addEventListener("click", () => {
							modal.classList.remove("visible"); // 点击后先关闭选择器
							openDatingInvitationModal(scene, chat.id); // 然后带着场景和角色ID，打开支付弹窗
						});
						listEl.appendChild(item);
					});

					// 绑定取消按钮
					document.getElementById("dating-cancel-char-select-btn").onclick = () => modal.classList.remove("visible");

					// 显示角色选择弹窗
					modal.classList.add("visible");
				}

				/**
				 * 打开支付方式选择的模态框
				 * @param {object} scene - 约会场景对象
				 * @param {string} targetCharId - 被邀请角色的ID
				 */
				async function openDatingInvitationModal(scene, targetCharId) {
					const modal = document.getElementById("dating-payment-modal");
					document.getElementById("dating-modal-scene-name").textContent = scene.name;
					document.getElementById("dating-modal-scene-cost").textContent = `预计花费: ${scene.cost}金币`;

					const optionsContainer = document.getElementById("dating-payment-options");
					optionsContainer.innerHTML = ""; // 清空旧按钮

					const chat = state.chats[targetCharId];
					if (!chat) return;

					// 创建"我来付全款"按钮
					const userPayBtn = document.createElement("button");
					userPayBtn.className = "form-button";
					userPayBtn.textContent = "我来付全款";
					userPayBtn.onclick = async () => {
						const userBalance = state.globalSettings.userBalance || 0;
						// 检查用户余额是否足够
						if (userBalance < scene.cost) {
							await showCustomAlert("余额不足", "你的钱包空空如也，无法支付这次约会的花费！");
							return;
						}
						// 扣除用户余额并记录交易
						await updateUserBalanceAndLogTransaction(-scene.cost, `约会支出: ${scene.name}`);
						await showCustomAlert("支付成功", `已成功支付 ${scene.cost}金币！`);
						modal.classList.remove("visible");
						startDatingScene(scene, targetCharId, "user"); // 记录由user支付
					};
					optionsContainer.appendChild(userPayBtn);

					// 创建"让对方付全款"按钮
					const charPayBtn = document.createElement("button");
					charPayBtn.className = "form-button";
					charPayBtn.textContent = `让 ${chat.name} 付全款`;
					charPayBtn.onclick = async () => {
						const charBalance = chat.characterPhoneData?.bank?.balance || 0;
						// 检查角色余额是否足够
						if (charBalance < scene.cost) {
							await showCustomAlert("对方余额不足", `"${chat.name}"的钱包好像不够支付这次约会的费用哦。`);
							return;
						}
						// 扣除角色余额并记录交易
						await updateCharacterPhoneBankBalance(targetCharId, -scene.cost, `约会支出: ${scene.name}`);
						await showCustomAlert("支付成功", `"${chat.name}"爽快地买单了！`);
						modal.classList.remove("visible");
						startDatingScene(scene, targetCharId, "char"); // 记录由char支付
					};
					optionsContainer.appendChild(charPayBtn);

					// 创建"AA制"按钮
					const aaPayBtn = document.createElement("button");
					aaPayBtn.className = "form-button";
					aaPayBtn.textContent = "我们AA制吧";
					aaPayBtn.onclick = async () => {
						const splitCost = scene.cost / 2;
						const userBalance = state.globalSettings.userBalance || 0;
						const charBalance = chat.characterPhoneData?.bank?.balance || 0;

						// 检查双方余额是否足够
						if (userBalance < splitCost) {
							await showCustomAlert("余额不足", "你的钱包不够支付AA的费用哦！");
							return;
						}
						if (charBalance < splitCost) {
							await showCustomAlert("对方余额不足", `"${chat.name}"的钱包不够支付AA的费用哦。`);
							return;
						}

						// 扣除双方余额并记录交易
						await updateUserBalanceAndLogTransaction(-splitCost, `约会AA支出: ${scene.name}`);
						await updateCharacterPhoneBankBalance(targetCharId, -splitCost, `约会AA支出: ${scene.name}`);

						await showCustomAlert("支付成功", `你们愉快地决定AA制！`);
						modal.classList.remove("visible");
						startDatingScene(scene, targetCharId, "aa"); // 记录为AA制
					};
					optionsContainer.appendChild(aaPayBtn);

					// 创建"找人借钱"按钮（如果存在其他角色）
					const otherChars = Object.values(state.chats).filter((c) => !c.isGroup && c.id !== targetCharId);
					if (otherChars.length > 0) {
						const borrowBtn = document.createElement("button");
						borrowBtn.className = "form-button";
						borrowBtn.textContent = "我钱不够，找别人借点...";
						borrowBtn.onclick = () => {
							modal.classList.remove("visible");
							openBorrowMoneyModal(scene, targetCharId);
						};
						optionsContainer.appendChild(borrowBtn);
					}

					// 绑定取消按钮
					document.getElementById("dating-cancel-btn").onclick = () => modal.classList.remove("visible");
					// 显示弹窗
					modal.classList.add("visible");
				}

				/**
				 * 处理用户付全款的逻辑
				 * @param {object} scene - 约会场景对象
				 * @param {string} targetCharId - 被邀请角色的ID
				 */
				async function handleUserPaysForDate(scene, targetCharId) {
					const cost = scene.cost;
					const userBalance = state.globalSettings.userBalance || 0;

					// 检查用户余额是否足够
					if (userBalance < cost) {
						await showCustomAlert("余额不足", "你的钱包空空如也，无法支付这次约会的花费！");
						return;
					}

					// 扣除用户余额并记录交易
					await updateUserBalanceAndLogTransaction(-cost, `约会支出: ${scene.name}`);
					await showCustomAlert("支付成功", `已成功支付 ${cost}金币！现在可以开始你们的约会了。`);

					// 创建系统消息通知AI约会开始
					const hiddenMessage = {
						role: "system",
						content: `[系统提示：用户已为约会"${scene.name}"付款，花费${cost}金币。现在约会正式开始，请根据场景和人设，开启一段浪漫的约会对话。]`,
						timestamp: Date.now(),
						isHidden: true,
					};

					// 将消息添加到目标角色的聊天记录中
					const chat = state.chats[targetCharId];
					chat.history.push(hiddenMessage);
					await db.chats.put(chat);

					// 打开与该角色的聊天并触发回应
					openChat(targetCharId);
					triggerAiResponse();
				}

				/**
				 * 向AI请求让它付全款
				 * @param {object} scene - 约会场景对象
				 * @param {string} targetCharId - 被邀请角色的ID
				 */
				async function requestCharToPay(scene, targetCharId) {
					const chat = state.chats[targetCharId];
					const cost = scene.cost;

					// 创建系统指令消息请求AI决定是否支付
					const hiddenMessage = {
						role: "system",
						content: `[系统指令：用户邀请你进行约会"${scene.name}"，并希望由你来支付全部费用（${cost}金币）。你的钱包余额是 ${chat.characterPhoneData.bank.balance.toFixed(2)} 金币。请根据你的人设、你与用户的关系以及你的钱包余额，决定是否同意。你【必须】使用 'dating_payment_response' 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应。]`,
						timestamp: Date.now(),
						isHidden: true,
					};

					// 将消息添加到聊天记录
					chat.history.push(hiddenMessage);
					await db.chats.put(chat);

					// 通知用户请求已发送
					await showCustomAlert("请求已发送", `已向 ${chat.name} 发出请求，请到聊天中查看Ta的回应吧。`);
					openChat(targetCharId);
					triggerAiResponse();
				}

				/**
				 * 向AI请求AA制
				 * @param {object} scene - 约会场景对象
				 * @param {string} targetCharId - 被邀请角色的ID
				 */
				async function requestAAsplit(scene, targetCharId) {
					const chat = state.chats[targetCharId];
					const splitCost = scene.cost / 2;

					const userBalance = state.globalSettings.userBalance || 0;
					// 检查用户余额是否足够支付AA费用
					if (userBalance < splitCost) {
						await showCustomAlert("余额不足", `你的余额不足以支付AA制的费用（${splitCost.toFixed(2)}金币）！`);
						return;
					}

					// 创建系统指令消息请求AI决定是否接受AA制
					const hiddenMessage = {
						role: "system",
						content: `[系统指令：用户邀请你进行约会"${scene.name}"，并提议AA制，即各自支付 ${splitCost.toFixed(2)} 金币。你的钱包余额是 ${chat.characterPhoneData.bank.balance.toFixed(2)} 金币。请根据你的人设和你与用户的关系，决定是否同意。你【必须】使用 'dating_aa_response' 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应。]`,
						timestamp: Date.now(),
						isHidden: true,
					};

					// 将消息添加到聊天记录
					chat.history.push(hiddenMessage);
					await db.chats.put(chat);

					// 通知用户请求已发送
					await showCustomAlert("请求已发送", `已向 ${chat.name} 发出AA制的提议，请到聊天中查看Ta的回应吧。`);
					openChat(targetCharId);
					triggerAiResponse();
				}

				/**
				 * 打开"找人借钱"的选择列表
				 * @param {object} scene - 约会场景对象
				 * @param {string} dateTargetCharId - 你的约会对象ID
				 */
				async function openBorrowMoneyModal(scene, dateTargetCharId) {
					const modal = document.getElementById("borrow-money-modal");
					const listEl = document.getElementById("borrow-money-char-list");
					listEl.innerHTML = "";

					// 获取除约会对象外的其他角色
					const otherChars = Object.values(state.chats).filter((c) => !c.isGroup && c.id !== dateTargetCharId);

					// 检查是否存在可借款角色
					if (otherChars.length === 0) {
						alert("没有其他可以借钱的朋友了。");
						return;
					}

					// 为每个可借款角色创建列表项
					otherChars.forEach((char) => {
						const item = document.createElement("div");
						item.className = "character-select-item"; // 复用样式
						item.dataset.charId = char.id;
						item.innerHTML = `
                            <img src="${char.settings.aiAvatar || defaultAvatar}" alt="${char.name}">
                            <span class="name">${char.name}</span>
                        `;
						item.addEventListener("click", async () => {
							modal.classList.remove("visible");
							// 获取用户输入的借款金额
							const borrowAmountStr = await showCustomPrompt("借多少？", "请输入你想借的金额", "", "number");
							const borrowAmount = parseFloat(borrowAmountStr);
							// 验证借款金额有效性
							if (borrowAmount > 0) {
								await requestToBorrowMoney(scene, dateTargetCharId, char.id, borrowAmount);
							} else if (borrowAmountStr !== null) {
								alert("请输入有效的借款金额！");
							}
						});
						listEl.appendChild(item);
					});

					// 绑定取消按钮
					document.getElementById("borrow-money-cancel-btn").onclick = () => modal.classList.remove("visible");
					modal.classList.add("visible");
				}

				/**
				 * 向指定角色发送借款请求
				 * @param {object} scene - 约会场景对象
				 * @param {string} dateTargetCharId - 约会对象ID
				 * @param {string} lenderChatId - 借款人角色ID
				 * @param {number} amount - 借款金额
				 */
				async function requestToBorrowMoney(scene, dateTargetCharId, lenderChatId, amount) {
					const dateTargetChat = state.chats[dateTargetCharId];
					const lenderChat = state.chats[lenderChatId];
					if (!lenderChat || !dateTargetChat) return;

					const myNickname = dateTargetChat.settings.myNickname || "我";

					// 构建借款请求信息
					const reasonText = `用于和"${dateTargetChat.name}"在"${scene.name}"的约会。`;
					const payloadData = {
						lenderName: lenderChat.name,
						amount: amount,
						reason: reasonText,
					};
					// 创建文本消息内容
					const textContent = `向 ${lenderChat.name} 借钱 ${amount.toFixed(2)}元，${reasonText}`;

					// 创建借款请求消息对象
					const borrowRequestMessage = {
						role: "user",
						type: "borrow_money_request",
						timestamp: Date.now(),
						payload: payloadData, // payload 用于渲染借条卡片
						content: textContent, // content 用于显示为文本消息
					};

					// 将借条发到"债主"的聊天里
					lenderChat.history.push(borrowRequestMessage);

					// 创建给AI看的、带有详细信息的隐藏指令
					const hiddenMessage = {
						role: "system",
						content: `[系统指令：用户 "${myNickname}" 想向你借 ${amount.toFixed(2)} 金币，用于和 "${dateTargetChat.name}" 在 "${scene.name}" 约会。你的钱包余额是 ${lenderChat.characterPhoneData.bank.balance.toFixed(2)} 金币。请根据你的人设、你和用户的关系以及你的钱包余额，决定是否借钱。你【必须】使用 'lend_money_response' 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应，并可以在文本消息中说明理由。]`,
						timestamp: Date.now() + 1, // 确保时间戳在后
						isHidden: true,
					};
					lenderChat.history.push(hiddenMessage);
					await db.chats.put(lenderChat);

					// 通知用户请求已发送
					await showCustomAlert("借钱请求已发送", `已向"${lenderChat.name}"发起了借款请求，请到和Ta的聊天中查看结果。`);

					// 打开与"债主"的聊天并触发回应
					openChat(lenderChatId);
					triggerAiResponse();
				}

				// 约会游戏状态管理对象
				let datingGameState = {
					isActive: false, // 标记当前是否正在进行约会
					scene: null, // 当前约会场景信息
					characterId: null, // 当前约会角色ID
					storyHistory: [], // 存储对话历史，用于AI生成后续内容
				};

				/**
				 * 渲染约会数值条（心形UI）
				 * 使用SVG线性渐变实现动态填充效果
				 */
				function renderDatingValues() {
					const romanceContainer = document.getElementById("romance-value");
					const lustContainer = document.getElementById("lust-value");
					if (!romanceContainer || !lustContainer) return;

					// 清空旧的心形
					romanceContainer.innerHTML = "";
					lustContainer.innerHTML = "";

					// 渲染单个数值条的辅助函数
					const renderValueBar = (container, value, type) => {
						// 定义颜色：粉色代表浪漫，黄色代表性欲
						const fillColor = type === "romance" ? "#ff8fab" : "#ffde59";
						const emptyColor = "#ccc";
						const emptyOpacity = "0.3";

						for (let i = 0; i < 5; i++) {
							// 计算当前心形的填充百分比
							const fillPercentage = Math.max(0, Math.min(100, (value - i * 20) * 5));

							// 为每个SVG生成唯一的渐变ID
							const gradientId = `heart-gradient-${type}-${i}`;

							const heartSvg = `
                                <svg viewBox="0 0 24 24">
                                    <defs>
                                        <linearGradient id="${gradientId}" x1="0" x2="0" y1="1" y2="0">
                                            <stop offset="${fillPercentage}%" stop-color="${fillColor}" />
                                            <stop offset="${fillPercentage}%" stop-color="${emptyColor}" stop-opacity="${emptyOpacity}" />
                                        </linearGradient>
                                    </defs>
                                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"
                                        fill="url(#${gradientId})"
                                        stroke="#aaa" 
                                        stroke-width="1.5"/>
                                </svg>
                            `;
							container.innerHTML += heartSvg;
						}
					};

					// 渲染浪漫值和性欲值两个数值条
					renderValueBar(romanceContainer, datingGameState.romance, "romance");
					renderValueBar(lustContainer, datingGameState.lust, "lust");
				}

				/**
				 * 开始一场约会
				 * @param {Object} scene - 约会场景对象
				 * @param {string} targetCharId - 目标角色ID
				 */
				async function startDatingScene(scene, targetCharId) {
					console.log(`开始约会: 场景="${scene.name}", 角色ID=${targetCharId}`);

					// 初始化约会状态
					datingGameState = {
						isActive: true,
						scene: scene,
						characterId: targetCharId,
						storyHistory: [],
						romance: 0,
						lust: 0,
						currentStoryText: "",
						currentSentenceIndex: -1,
						sentences: [],
						isSwitchingSentence: false,
						isNsfwMode: false, // NSFW模式开关
						completion: 0, // 约会完成度
					};

					const chat = state.chats[targetCharId];
					if (!chat) return;

					// 准备UI元素
					const backgroundEl = document.getElementById("dating-game-background");
					const charNameEl = document.getElementById("dating-game-char-name");
					const textContentEl = document.getElementById("dating-game-text-content");
					const choicesEl = document.getElementById("dating-game-choices");

					// 重置UI到初始状态
					charNameEl.textContent = chat.name;
					backgroundEl.style.backgroundImage = "none";
					textContentEl.innerHTML = "<p>AI正在精心构筑你们的约会世界...</p>";
					textContentEl.parentElement.style.opacity = 1;
					choicesEl.innerHTML = "";

					// 显示游戏界面
					showScreen("dating-game-screen");

					// 加载背景图
					const uiSettings = chat.settings.datingUISettings || {};

					// 优先使用用户设置的背景
					if (uiSettings.backgroundUrl) {
						console.log("检测到自定义约会背景，正在加载...");
						backgroundEl.style.backgroundImage = `url(${uiSettings.backgroundUrl})`;
					} else {
						// 如果没有设置，调用AI生成
						console.log("未检测到自定义背景，将由AI生成...");
						const imagePrompt = scene.imagePrompt + ", vertical, phone wallpaper, cinematic lighting, masterpiece, best quality, beautiful anime style art";
						generateAndLoadImage(imagePrompt)
							.then((imageUrl) => {
								backgroundEl.style.backgroundImage = `url(${imageUrl})`;
							})
							.catch((error) => {
								console.error("约会背景图加载失败:", error);
								backgroundEl.style.backgroundColor = "#1c1e26"; // 失败时的备用背景
							});
					}

					// 重置并显示数值条和完成度进度条
					datingGameState.romance = 0;
					datingGameState.lust = 0;
					datingGameState.completion = 0;
					renderDatingCompletion();
					document.getElementById("dating-completion-bar-container").style.display = "block";
					renderDatingValues();
					document.getElementById("dating-values-container").style.display = "flex";

					// 触发初始剧情
					await triggerDatingStory("start");
				}

				/**
				 * 渲染并更新约会完成度进度条的UI
				 */
				function renderDatingCompletion() {
					const container = document.getElementById("dating-completion-bar-container");
					const fill = document.getElementById("dating-completion-bar-fill");
					const text = document.getElementById("dating-completion-text");

					if (!container || !fill || !text) return;

					// 从游戏状态中获取完成度
					const completion = datingGameState.completion || 0;

					// 更新填充条的宽度和百分比文字
					fill.style.width = `${completion}%`;
					text.textContent = `${Math.round(completion)}%`;
				}

				/**
				 * 触发约会剧情发展
				 * @param {string} userAction - 用户的选择或行动
				 */
				async function triggerDatingStory(userAction) {
					datingGameState.isNsfwMode = false;
					if (!datingGameState.isActive) return;

					const { scene, characterId, storyHistory } = datingGameState;
					const chat = state.chats[characterId];
					const { proxyUrl, apiKey, model } = state.apiConfig;
					if (!proxyUrl || !apiKey || !model) {
						alert("API未配置，无法继续约会。");
						return;
					}

					// 记录用户选择到历史中
					if (userAction !== "start") {
						storyHistory.push(`【你的选择】: ${userAction}`);
					}

					const textContentEl = document.getElementById("dating-game-text-content");
					const choicesEl = document.getElementById("dating-game-choices");

					// 显示等待状态
					textContentEl.innerHTML = "<p><i>对方正在思考...</i></p>";
					choicesEl.innerHTML = "";

					// 获取角色立绘信息
					const uiSettings = chat.settings.datingUISettings || {};
					const customPrompt = uiSettings.prompt || "";
					const customStyle = uiSettings.style || "你的回复必须是【第三人称】的旁白，详细描绘场景、角色的动作、神态、心理活动以及对话。让用户感觉像在看小说。";

					let spriteContext = "";
					let spriteChoiceInstruction = "";
					const spriteGroupId = uiSettings.spriteGroupId;

					if (spriteGroupId) {
						const sprites = await db.datingSprites.where("groupId").equals(spriteGroupId).toArray();
						if (sprites.length > 0) {
							spriteContext = `
                # 可用角色立绘
                你有一个立绘库，请根据当前情景选择一个最能表达角色“${chat.name}”心情和动作的立绘描述。
                - ${sprites.map((s) => `[描述: ${s.description}]`).join("\n- ")}
                `;
							spriteChoiceInstruction = `"sprite": "【从上方列表中选择一个最合适的描述，并填在这里】",`;
						}
					}

					// 构建系统提示词
					const systemPrompt = `
                        # 角色扮演：恋爱互动小说游戏引擎
                        你现在是一个顶级的恋爱互动小说游戏引擎。你的任务是根据用户选择，推动一个浪漫约会故事的发展。
                        ## 故事背景
                        - **你的角色**: 你将扮演角色“${chat.name}”。
                        - **你的角色人设**: ${chat.settings.aiPersona}\n${customPrompt}
                        - **用户的人设**: ${chat.settings.myPersona}
                        - **约会场景**: ${scene.name}
                        ${spriteContext}
                        ## 当前约会状态 (重要参考)
                        - **浪漫值**: ${datingGameState.romance}/100
                        - **性欲值**: ${datingGameState.lust}/100
                        - **约会完成度**: ${datingGameState.completion}%

                        ## 核心规则
                        1.  **沉浸式叙事**: ${customStyle}
                        2.  **提供选择**: 在每段叙事后，你【必须】提供 2-4 个供用户选择的行动或对话选项。
                        3.  **【【【智能评分铁律】】】**: 你【必须】根据当前的故事进展、用户的选择以及你的回应，对本次互动的“质量”进行评估，并给出三个数值的【增加值】。
                            - **"romance" (浪漫值)**: 如果互动是甜蜜、温馨或感人的，可以增加5-15分。
                            - **"lust" (性欲值)**: 如果互动包含挑逗、暗示或身体接触，可以增加5-15分。
                            - **"completion_increase" (完成度增加值)**:
                                -   这是一个【可正可负】的数值。
                                -   **正面互动**: 如果用户的选择让关系升温（例如，选择了更浪漫或大胆的选项），你应该给一个正数，范围在 **3到10** 之间。
                                -   **负面互动**: 如果用户的选择很煞风景、粗鲁或导致尴尬，你应该给一个【负数】，范围在 **-10到-1** 之间，表示约会进度倒退。
                                -   **平淡互动**: 如果互动很平淡或只是过渡，可以给 **0** 或 **1-2** 分。
                        4.  **【【【结束时机铁律】】】**: 当你认为故事已经发展到一个完美的、可以自然结束的节点时（例如：互相道别、回到家中），并且总完成度已接近100%，你【必须】将 \`"isDateOver"\` 字段设置为 \`true\`。
                        5.  **【【【格式铁律】】】**: 你的回复【必须且只能】是一个严格的JSON对象，格式如下:
                            {
                            ${spriteChoiceInstruction}
                            "story": "【这里是你的叙事内容...】",
                            "choices": [
                                "【选项1的文字描述】",
                                "【选项2的文字描述】"
                            ],
                            "valuesUpdate": {
                                "romance": 5,
                                "lust": 0,
                                "completion_increase": 8
                            },
                            "isDateOver": false
                            }
                        ## 故事历史 (供你参考)
                        ${storyHistory.join("\n")}
                        现在，请根据用户的最新选择“${userAction}”，生成下一段故事、新的选项和智能评分。
                    `;

					try {
						const messagesForApi = [{ role: "user", content: systemPrompt }];
						let isGemini = proxyUrl === GEMINI_API_URL;
						let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

						const response = isGemini
							? await fetch(geminiConfig.url, geminiConfig.data)
							: await fetch(`${proxyUrl}/v1/chat/completions`, {
									method: "POST",
									headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
									body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.9, response_format: { type: "json_object" } }),
							  });

						if (!response.ok) throw new Error(`API 请求失败: ${await response.text()}`);

						const data = await response.json();
						const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, "").trim();
						const gameData = JSON.parse(rawContent);

						// 处理AI返回的游戏数据
						if (gameData.story && Array.isArray(gameData.choices)) {
							// 更新数值
							if (gameData.valuesUpdate) {
								const romanceChange = gameData.valuesUpdate.romance || 0;
								const lustChange = gameData.valuesUpdate.lust || 0;
								const completionIncrease = gameData.valuesUpdate.completion_increase || 0;

								datingGameState.romance = Math.max(0, Math.min(100, datingGameState.romance + romanceChange));
								datingGameState.lust = Math.max(0, Math.min(100, datingGameState.lust + lustChange));
								datingGameState.completion = Math.max(0, Math.min(100, datingGameState.completion + completionIncrease));

								console.log(`数值更新 -> 浪漫: ${datingGameState.romance}/100, 性欲: ${datingGameState.lust}/100, 完成度: ${datingGameState.completion}% (本次变化: ${completionIncrease})`);

								renderDatingValues();
								renderDatingCompletion();
							}

							const isDateOver = gameData.isDateOver || false;
							// 检查约会是否结束且完成度达到100%
							if (isDateOver && datingGameState.completion >= 100) {
								// 显示结算卡片
								showDatingSummaryCard(gameData.story);
								return;
							}

							// 更新立绘
							const spriteContainer = document.getElementById("dating-game-sprite-container");
							const spriteImg = document.getElementById("dating-game-sprite");
							if (gameData.sprite && spriteGroupId) {
								const chosenSprite = await db.datingSprites.where({ groupId: spriteGroupId, description: gameData.sprite }).first();
								if (chosenSprite) {
									spriteContainer.style.display = "block";
									spriteContainer.style.left = `${chosenSprite.x}%`;
									spriteContainer.style.bottom = `${100 - chosenSprite.y}%`;
									spriteContainer.style.width = `${chosenSprite.size}%`;
									spriteContainer.style.transform = `translateX(-50%) translateY(${100 - chosenSprite.y}%)`;
									spriteImg.style.opacity = 0;
									setTimeout(() => {
										spriteImg.src = chosenSprite.url;
										spriteImg.style.opacity = 1;
									}, 300);
								} else {
									if (spriteContainer) spriteContainer.style.display = "none";
								}
							} else {
								if (spriteContainer) spriteContainer.style.display = "none";
							}

							// 记录故事并显示
							datingGameState.storyHistory.push(`【旁白】: ${gameData.story}`);
							displayStoryText(gameData.story, gameData.choices);

							// 检查是否触发NSFW剧情
							if (datingGameState.lust >= 100 && !datingGameState.isNsfwMode) {
								await triggerNsfwScene();
							}
						} else {
							throw new Error("AI返回的数据格式不正确。");
						}
					} catch (error) {
						console.error("约会剧情生成失败:", error);
						textContentEl.innerHTML = `<p style="color: #ff8a80;">错误: 剧情加载失败，AI可能开小差了... \n(${error.message})</p>`;
					}
				}

				/**
				 * 当欲望值满时，触发并推进NSFW剧情
				 * @param {string} userAction - 用户的选择或自定义行动
				 */
				async function triggerNsfwScene(userAction = "故事自然发展") {
					// 设置并确认NSFW模式标志
					datingGameState.isNsfwMode = true;
					console.log("NSFW模式已激活，正在生成NSFW剧情...");

					if (!datingGameState.isActive) return;

					// 获取所需的所有数据
					const { scene, characterId, storyHistory } = datingGameState;
					const chat = state.chats[characterId];
					const { proxyUrl, apiKey, model } = state.apiConfig;
					if (!proxyUrl || !apiKey || !model) {
						alert("API未配置，无法继续约会。");
						return;
					}

					storyHistory.push(`【你的选择】: ${userAction}`);

					// 更新UI为等待状态
					const textContentEl = document.getElementById("dating-game-text-content");
					const choicesEl = document.getElementById("dating-game-choices");
					textContentEl.innerHTML = "<p><i>气氛变得有些不一样了...</i></p>";
					choicesEl.innerHTML = "";

					// 读取约会场景的通用设置
					const uiSettings = chat.settings.datingUISettings || {};
					const customPrompt = uiSettings.prompt || "";
					const baseStyle = uiSettings.style || "你的回复必须是【第三人称】的旁白，详细描绘场景、角色的动作、神态、心理活动以及对话。让用户感觉像在看小说。";
					const nsfwStyleInstruction = `
                # NSFW剧情指令 (最高优先级)
                接下来的故事【必须】包含详细、露骨、毫不避讳的性爱场面描写。你需要大胆地描绘角色的身体接触、动作、喘息、对话和内心感受，让故事进入高潮。叙事必须连贯、自然，符合角色性格。`;
					const customStyleWithNsfw = `${baseStyle}\n${nsfwStyleInstruction}`;

					// 立绘逻辑
					let spriteContext = "";
					let spriteChoiceInstruction = "";
					const spriteGroupId = uiSettings.spriteGroupId;
					if (spriteGroupId) {
						const sprites = await db.datingSprites.where("groupId").equals(spriteGroupId).toArray();
						if (sprites.length > 0) {
							spriteContext = `\n# 可用角色立绘\n${sprites.map((s) => `- [描述: ${s.description}]`).join("\n")}`;
							spriteChoiceInstruction = `"sprite": "【从上方列表中选择一个最合适的描述，并填在这里】",`;
						}
					}

					// 构建NSFW系统提示词
					const systemPrompt = `
                        # 角色扮演：NSFW恋爱互动小说游戏引擎
                        你现在是一个顶级的成人小说游戏引擎。你的任务是根据用户选择，续写一段已经发展到高潮的浪漫约会故事。

                        ## 故事背景
                        - **你的角色**: 你将扮演角色“${chat.name}”。
                        - **你的角色人设**: ${chat.settings.aiPersona}\n${customPrompt}
                        - **用户的人设**: ${chat.settings.myPersona}
                        - **约会场景**: ${scene.name}
                        ${spriteContext}
                        ## 当前约会状态 (重要参考)
                        - **浪漫值**: ${datingGameState.romance}/100
                        - **性欲值**: ${datingGameState.lust}/100
                        - **约会完成度**: ${datingGameState.completion}%

                        ## 核心规则
                        1.  **沉浸式叙事**: ${customStyleWithNsfw}
                        2.  **提供选择**: 在每段NSFW叙事后，你【必须】提供 2-4 个供用户选择的、符合当前情景的行动或对话选项。
                        3.  **智能评分**: 你【必须】根据当前的故事进展、用户的选择以及你的回应，对本次互动的“质量”进行评估，并给出三个数值的【增加值】。
                            - "romance" (浪漫值): 如果互动是甜蜜、温馨或感人的，可以增加5-15分。
                            - "lust" (性欲值): 因为是NSFW剧情，此项应该持续增加，范围在10-25分之间。
                            - "completion_increase" (完成度增加值): 如果用户的选择让关系升温（例如，选择了更浪漫或大胆的选项），你应该给一个正数，范围在 3到10 之间。如果用户的选择很煞风景，你应该给一个负数，范围在 -10到-1 之间。
                        4.  **【【【结束时机铁律】】】**: 你的主要任务是推进剧情，但当故事发展到一个**自然且满足的结局**时（例如：激情后的温存、相拥而眠、约定下次再见等），你【必须】将 \`"isDateOver"\` 字段设置为 \`true\` 来结束本次约会。这是结束的唯一方式。**不要无限地进行下去。**
                        5.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON对象，格式如下:
                            {
                            ${spriteChoiceInstruction}
                            "story": "【这里是你的NSFW叙事内容...】",
                            "choices": [
                                "【选项1的文字描述】",
                                "【选项2的文字描述】"
                            ],
                            "valuesUpdate": {
                                "romance": 5,
                                "lust": 15,
                                "completion_increase": 7
                            },
                            "isDateOver": false
                            }
                        ## 故事历史 (供你参考)
                        ${storyHistory.join("\n")}

                        现在，请根据用户的最新选择“${userAction}”，生成下一段NSFW故事、新的选项和智能评分。
                    `;

					try {
						const messagesForApi = [{ role: "user", content: systemPrompt }];
						let isGemini = proxyUrl === GEMINI_API_URL;
						let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

						const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, {
							method: "POST",
							headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
							body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } }),
						});

						if (!response.ok) throw new Error(`API 请求失败: ${await response.text()}`);

						const data = await response.json();
						const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, "").trim();
						const gameData = JSON.parse(rawContent);

						if (gameData.story && Array.isArray(gameData.choices)) {
							// 数值更新逻辑
							if (gameData.valuesUpdate) {
								const romanceChange = gameData.valuesUpdate.romance || 0;
								const lustChange = gameData.valuesUpdate.lust || 0;
								const completionIncrease = gameData.valuesUpdate.completion_increase || 1;
								datingGameState.romance = Math.max(0, Math.min(100, datingGameState.romance + romanceChange));
								datingGameState.lust = Math.max(0, Math.min(100, datingGameState.lust + lustChange));
								datingGameState.completion = Math.max(0, Math.min(100, datingGameState.completion + completionIncrease));
								renderDatingValues();
								renderDatingCompletion();
							}

							// 根据 AI 的 `isDateOver` 标志决定是否结束
							const isDateOver = gameData.isDateOver || false;
							if (isDateOver) {
								showDatingSummaryCard(gameData.story);
								return;
							}

							// 更新立绘
							const spriteContainer = document.getElementById("dating-game-sprite-container");
							const spriteImg = document.getElementById("dating-game-sprite");
							if (gameData.sprite && spriteGroupId) {
								const chosenSprite = await db.datingSprites.where({ groupId: spriteGroupId, description: gameData.sprite }).first();
								if (chosenSprite) {
									spriteContainer.style.display = "block";
									spriteContainer.style.left = `${chosenSprite.x}%`;
									spriteContainer.style.bottom = `${100 - chosenSprite.y}%`;
									spriteContainer.style.width = `${chosenSprite.size}%`;
									spriteContainer.style.transform = `translateX(-50%) translateY(${100 - chosenSprite.y}%)`;
									spriteImg.style.opacity = 0;
									setTimeout(() => {
										spriteImg.src = chosenSprite.url;
										spriteImg.style.opacity = 1;
									}, 300);
								} else {
									if (spriteContainer) spriteContainer.style.display = "none";
								}
							} else {
								if (spriteContainer) spriteContainer.style.display = "none";
							}

							// 记录故事并显示
							datingGameState.storyHistory.push(`【旁白】: ${gameData.story}`);
							displayStoryText(gameData.story, gameData.choices);
						} else {
							throw new Error("AI返回的数据格式不正确。");
						}
					} catch (error) {
						console.error("NSFW剧情生成失败:", error);
						textContentEl.innerHTML = `<p style="color: #ff8a80;">错误: NSFW剧情加载失败... \n(${error.message})</p>`;
					}
				}

				/**
				 * 处理剧情文本的逐句显示
				 * @param {string} storyText - AI返回的完整剧情文本
				 * @param {Array<string>} choices - AI返回的选项数组
				 */
				function displayStoryText(storyText, choices) {
					// 按标点符号分割句子
					const sentences = storyText.match(/[^。！？\s][^。！？]*[。！？]?/g) || [storyText];

					// 更新游戏状态
					datingGameState.sentences = sentences;
					datingGameState.currentSentenceIndex = -1; // 重置索引
					datingGameState.choices = choices; // 暂存选项

					// 准备UI，但不显示选项
					document.getElementById("dating-game-text-content").innerHTML = "";
					document.getElementById("dating-game-choices").innerHTML = "";

					// 显示第一句
					showNextSentence();
				}

				/**
				 * 显示下一句剧情文本，或在结束后显示选项
				 * - 修正了文本意外消失的bug (使用appendChild代替innerHTML)
				 * - 增加了点击保护，防止跳过句子
				 */
				function showNextSentence() {
					// 如果正在切换句子，则阻止任何新的操作，防止用户快速点击跳过剧情
					if (datingGameState.isSwitchingSentence) return;
					datingGameState.isSwitchingSentence = true; // 加锁

					const { sentences, choices } = datingGameState;
					const textContentEl = document.getElementById("dating-game-text-content");
					const choicesEl = document.getElementById("dating-game-choices");
					const textboxEl = textContentEl.parentElement;

					// 获取进度条元素
					const progressBarContainer = document.getElementById("dating-completion-bar-container");

					// 句子索引+1
					datingGameState.currentSentenceIndex++;
					const nextIndex = datingGameState.currentSentenceIndex;

					// 用安全的方式移除旧的“点击继续”提示
					const oldIndicator = textboxEl.querySelector(".continue-indicator");
					if (oldIndicator) {
						oldIndicator.remove();
					}

					// 先让旧文本淡出
					textContentEl.classList.add("fade-out");

					// 设定一个延迟来执行文本替换和动画
					setTimeout(() => {
						if (nextIndex < sentences.length) {
							const nextSentence = sentences[nextIndex];

							// 使用textContent进行安全的文本替换，绝对不会累积
							textContentEl.textContent = nextSentence;

							// 如果这不是最后一句...
							if (nextIndex < sentences.length - 1) {
								// 显示进度条
								if (progressBarContainer) progressBarContainer.style.display = "block";

								// 创建并添加“点击继续”的提示
								const indicator = document.createElement("div");
								indicator.className = "continue-indicator";
								indicator.textContent = "▼";
								textboxEl.appendChild(indicator);
							} else {
								// 如果是最后一句了，准备显示选项，隐藏进度条
								if (progressBarContainer) progressBarContainer.style.display = "none";

								choices.forEach((choiceText) => {
									const choiceBtn = document.createElement("button");
									choiceBtn.className = "dating-game-choice-btn";
									choiceBtn.textContent = choiceText;
									choiceBtn.onclick = () => {
										if (datingGameState.isNsfwMode) {
											triggerNsfwScene(choiceText);
										} else {
											triggerDatingStory(choiceText);
										}
									};
									choicesEl.appendChild(choiceBtn);
								});

								// 添加“自由输入”按钮
								const inputBtn = document.createElement("button");
								inputBtn.className = "dating-game-choice-btn input-action";
								inputBtn.textContent = "自定义行动...";
								inputBtn.onclick = async () => {
									const userInput = await showCustomPrompt("你的行动", "请输入你想说的话或想做的事：");
									if (userInput && userInput.trim()) {
										if (datingGameState.isNsfwMode) {
											triggerNsfwScene(userInput.trim());
										} else {
											triggerDatingStory(userInput.trim());
										}
									}
								};
								choicesEl.appendChild(inputBtn);
							}
						}

						// 让新文本淡入
						textContentEl.classList.remove("fade-out");

						// 所有操作完成后，解锁，允许下一次点击
						datingGameState.isSwitchingSentence = false;
					}, 250);
				}

				/**
				 * 当用户点击“结束约会”时，弹出选择框
				 */
				async function endDate() {
					if (!datingGameState.isActive) return;

					// 弹出选择框，让用户决定如何结束
					const choice = await showChoiceModal("结束约会", [
						{ text: "生成并记录约会", value: "record" },
						{ text: "直接结束不记录", value: "discard" },
					]);

					// 根据用户的选择执行不同操作
					if (choice === "record") {
						// 如果选择“记录”，就显示结算卡片
						showDatingSummaryCard();
					} else if (choice === "discard") {
						// 如果选择“不记录”，就直接结束并返回聊天列表
						finalizeAndExitDate();
					}
					// 如果用户点了取消，则什么也不做，约会继续
				}

				/**
				 * 最终结束约会并重置状态的函数
				 */
				async function finalizeAndExitDate() {
					if (!datingGameState.isActive) return;

					const chat = state.chats[datingGameState.characterId];
					if (chat) {
						const endMessage = { role: "system", type: "pat_message", content: `你和“${chat.name}”在“${datingGameState.scene.name}”的约会结束了。`, timestamp: Date.now() };
						chat.history.push(endMessage);
						await db.chats.put(chat);
					}

					// 隐藏进度条
					document.getElementById("dating-completion-bar-container").style.display = "none";

					// 重置游戏状态
					datingGameState = {
						isActive: false,
						scene: null,
						characterId: null,
						storyHistory: [],
						romance: 0,
						lust: 0,
						completion: 0,
						currentStoryText: "",
						currentSentenceIndex: -1,
						sentences: [],
						isSwitchingSentence: false,
						isNsfwMode: false,
					};

					// 隐藏结算卡片（如果它还开着）
					document.getElementById("dating-summary-overlay").classList.remove("visible");

					// 返回聊天列表并刷新
					showScreen("chat-list-screen");
					await renderChatList();
				}

				/**
				 * 打开约会场景设置弹窗
				 */
				async function openDatingSettingsModal() {
					const modal = document.getElementById("dating-game-settings-modal");
					const chat = state.chats[datingGameState.characterId];
					if (!chat) return;

					// 加载当前角色的约会UI设置
					currentDatingUISettings = JSON.parse(
						JSON.stringify(
							chat.settings.datingUISettings || {
								prompt: "",
								style: "",
								backgroundUrl: "",
								spriteGroupId: null,
								sprite: { url: "", x: 50, y: 100, size: 80 },
							}
						)
					);

					// 填充弹窗内容
					document.getElementById("dating-prompt-input").value = currentDatingUISettings.prompt;
					document.getElementById("dating-style-input").value = currentDatingUISettings.style;
					document.getElementById("dating-bg-url-input").value = currentDatingUISettings.backgroundUrl;

					// 调用渲染函数
					await renderDatingSpriteGroupSelector();
					await renderDatingPresetSelector();

					// 显示弹窗
					modal.classList.add("visible");
				}

				/**
				 * 应用当前的UI设置到游戏界面
				 */
				function applyDatingUISettings() {
					if (!currentDatingUISettings) return;

					// 应用背景图
					const backgroundEl = document.getElementById("dating-game-background");
					if (currentDatingUISettings.backgroundUrl) {
						backgroundEl.style.backgroundImage = `url(${currentDatingUISettings.backgroundUrl})`;
					} else {
						// 如果没有设置，可以恢复到场景默认图或一个通用背景
						const imagePrompt = datingGameState.scene.imagePrompt + ", vertical, phone wallpaper, cinematic lighting, masterpiece, best quality, beautiful anime style art";
						generateAndLoadImage(imagePrompt)
							.then((imageUrl) => {
								backgroundEl.style.backgroundImage = `url(${imageUrl})`;
							})
							.catch(() => {
								backgroundEl.style.backgroundColor = "#1c1e26";
							});
					}

					// 应用立绘
					const spriteContainer = document.getElementById("dating-game-sprite-container");
					const spriteImg = document.getElementById("dating-game-sprite");
					const sprite = currentDatingUISettings.sprite;
					if (sprite.url) {
						spriteImg.src = sprite.url;
						spriteContainer.style.display = "block";
						spriteContainer.style.left = `${sprite.x}%`;
						spriteContainer.style.bottom = `${100 - sprite.y}%`;
						spriteContainer.style.width = `${sprite.size}%`;
						// 根据Y坐标调整transform，使立绘的“脚”能贴住设定的位置
						spriteContainer.style.transform = `translateX(-50%) translateY(${100 - sprite.y}%)`;
					} else {
						spriteImg.src = "";
						spriteContainer.style.display = "none";
					}
				}

				/**
				 * 保存当前设置到角色数据中
				 */
				async function saveDatingSettings() {
					if (!datingGameState.characterId) return;
					const chat = state.chats[datingGameState.characterId];

					// 从UI读取所有设置值
					currentDatingUISettings.prompt = document.getElementById("dating-prompt-input").value.trim();
					currentDatingUISettings.style = document.getElementById("dating-style-input").value.trim();
					currentDatingUISettings.backgroundUrl = document.getElementById("dating-bg-url-input").value.trim();

					// 保存选中的立绘组ID
					const selectedSpriteGroupId = document.getElementById("dating-sprite-group-select").value;
					currentDatingUISettings.spriteGroupId = selectedSpriteGroupId ? parseInt(selectedSpriteGroupId) : null;

					// 立绘位置和大小的保存逻辑保持不变 (但我们现在不再在这里保存立绘URL了)
					currentDatingUISettings.sprite.x = 50;
					currentDatingUISettings.sprite.y = 100;
					currentDatingUISettings.sprite.size = 80;
					currentDatingUISettings.sprite.url = ""; // URL由AI动态决定，这里不保存

					// 确保角色的settings对象存在
					if (!chat.settings) chat.settings = {};
					// 保存
					chat.settings.datingUISettings = currentDatingUISettings;
					await db.chats.put(chat);

					// 应用并关闭弹窗
					applyDatingUISettings();
					document.getElementById("dating-game-settings-modal").classList.remove("visible");
					alert("场景设置已保存！");
				}

				/**
				 * 处理图片上传
				 * @param {'bg' | 'sprite'} type - 上传类型
				 */
				function handleDatingImageUpload(type) {
					const inputId = type === "bg" ? "dating-bg-upload-input" : "dating-sprite-upload-input";
					const urlInputId = type === "bg" ? "dating-bg-url-input" : "dating-sprite-url-input";
					document.getElementById(inputId).click();

					document.getElementById(inputId).onchange = async (e) => {
						const file = e.target.files[0];
						if (file) {
							const dataUrl = await new Promise((resolve) => {
								const reader = new FileReader();
								reader.onload = (e) => resolve(e.target.result);
								reader.readAsDataURL(file);
							});
							document.getElementById(urlInputId).value = dataUrl;
							if (type === "bg") currentDatingUISettings.backgroundUrl = dataUrl;
							else currentDatingUISettings.sprite.url = dataUrl;
							applyDatingUISettings();
						}
						e.target.value = null; // 清空以便下次选择
					};
				}

				/**
				 * 重Roll功能
				 */
				async function handleDatingReroll() {
					if (!datingGameState.isActive || datingGameState.storyHistory.length === 0) {
						alert("还没有可以重Roll的内容哦！");
						return;
					}

					// 找到最后一次用户的行动
					let lastUserActionIndex = -1;
					for (let i = datingGameState.storyHistory.length - 1; i >= 0; i--) {
						if (datingGameState.storyHistory[i].startsWith("【你的选择】")) {
							lastUserActionIndex = i;
							break;
						}
					}

					// 如果找不到用户的行动（比如刚开始），就重Roll第一段剧情
					if (lastUserActionIndex === -1) {
						datingGameState.storyHistory = [];
						await triggerDatingStory("start");
						return;
					}

					// 截取历史记录，回到用户做出选择之前的状态
					const lastUserAction = datingGameState.storyHistory[lastUserActionIndex].replace("【你的选择】: ", "");
					datingGameState.storyHistory = datingGameState.storyHistory.slice(0, lastUserActionIndex);

					// 重新触发AI，使用户的最后一次行动再次生效
					await triggerDatingStory(lastUserAction);
				}

				// --- 以下是预设管理功能 ---

				async function renderDatingPresetSelector() {
					const select = document.getElementById("dating-preset-select");
					const presets = await db.datingPresets.toArray();
					select.innerHTML = '<option value="">-- 自定义 --</option>';
					presets.forEach((p) => {
						select.innerHTML += `<option value="${p.id}">${p.name}</option>`;
					});
				}

				/**
				 * 处理约会预设选择
				 */
				async function handleDatingPresetSelect() {
					const select = document.getElementById("dating-preset-select");
					const presetId = parseInt(select.value);

					// 如果用户选择的是“-- 自定义 --”（即没有 presetId），则清空输入框
					if (!presetId) {
						document.getElementById("dating-prompt-input").value = "";
						document.getElementById("dating-style-input").value = "";
						document.getElementById("dating-bg-url-input").value = "";
						document.getElementById("dating-sprite-group-select").value = "";

						// 重置临时的设置对象
						if (currentDatingUISettings) {
							currentDatingUISettings.prompt = "";
							currentDatingUISettings.style = "";
							currentDatingUISettings.backgroundUrl = "";
							currentDatingUISettings.spriteGroupId = null;
						}
						// 应用空的背景进行预览
						applyDatingUISettings();
						return;
					}

					// 根据ID从数据库获取预设
					const preset = await db.datingPresets.get(presetId);
					if (preset && preset.settings) {
						const loadedSettings = preset.settings;

						// 确保临时的UI设置对象存在
						if (!currentDatingUISettings) {
							currentDatingUISettings = {
								prompt: "",
								style: "",
								backgroundUrl: "",
								spriteGroupId: null,
								sprite: { url: "", x: 50, y: 100, size: 80 },
							};
						}

						// 用加载的预设值更新当前设置对象
						currentDatingUISettings.prompt = loadedSettings.prompt || "";
						currentDatingUISettings.style = loadedSettings.style || "";
						currentDatingUISettings.backgroundUrl = loadedSettings.backgroundUrl || "";
						currentDatingUISettings.spriteGroupId = loadedSettings.spriteGroupId || null;

						// 将新值同步更新到弹窗的UI控件上
						document.getElementById("dating-prompt-input").value = currentDatingUISettings.prompt;
						document.getElementById("dating-style-input").value = currentDatingUISettings.style;
						document.getElementById("dating-bg-url-input").value = currentDatingUISettings.backgroundUrl;
						document.getElementById("dating-sprite-group-select").value = currentDatingUISettings.spriteGroupId || "";

						// 实时应用背景预览
						applyDatingUISettings();
					}
				}

				/**
				 * 打开并管理约会场景预设
				 */
				async function openDatingPresetManager() {
					// 获取当前下拉框选中的预设ID
					const select = document.getElementById("dating-preset-select");
					if (!select) {
						alert("错误：在HTML中找不到ID为 'dating-preset-select' 的元素。");
						return;
					}
					const selectedId = select.value ? parseInt(select.value) : null;

					// 弹出操作选择菜单
					const choice = await showChoiceModal("管理场景预设", [
						{ text: "💾 保存当前为新预设", value: "save" },
						{ text: "🔄 更新选中预设", value: "update", disabled: !selectedId },
						{ text: "🗑️ 删除选中预设", value: "delete", disabled: !selectedId },
					]);

					hidePresetActions(); // 关闭选择菜单

					// 根据用户的选择，执行正确的操作
					if (choice === "save") {
						const name = await showCustomPrompt("保存预设", "请输入预设名称：");
						if (name && name.trim()) {
							// 从UI收集当前的设置
							const currentSettings = {
								prompt: document.getElementById("dating-prompt-input").value.trim(),
								style: document.getElementById("dating-style-input").value.trim(),
								backgroundUrl: document.getElementById("dating-bg-url-input").value.trim(),
								spriteGroupId: document.getElementById("dating-sprite-group-select").value ? parseInt(document.getElementById("dating-sprite-group-select").value) : null,
							};
							// 保存到数据库
							await db.datingPresets.add({ name: name.trim(), settings: currentSettings });
							await renderDatingPresetSelector(); // 刷新下拉框
							alert("预设已保存！");
						}
					} else if (choice === "update") {
						if (selectedId) {
							// 收集当前设置
							const currentSettings = {
								prompt: document.getElementById("dating-prompt-input").value.trim(),
								style: document.getElementById("dating-style-input").value.trim(),
								backgroundUrl: document.getElementById("dating-bg-url-input").value.trim(),
								spriteGroupId: document.getElementById("dating-sprite-group-select").value ? parseInt(document.getElementById("dating-sprite-group-select").value) : null,
							};
							// 更新数据库中的预设
							await db.datingPresets.update(selectedId, { settings: currentSettings });
							alert("预设已更新！");
						}
					} else if (choice === "delete") {
						if (selectedId) {
							const presetToDelete = await db.datingPresets.get(selectedId);
							const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${presetToDelete.name}" 吗？`, { confirmButtonClass: "btn-danger" });
							if (confirmed) {
								await db.datingPresets.delete(selectedId);
								await renderDatingPresetSelector(); // 刷新下拉框
								// 删除后清空输入框
								document.getElementById("dating-prompt-input").value = "";
								document.getElementById("dating-style-input").value = "";
								document.getElementById("dating-bg-url-input").value = "";
								document.getElementById("dating-sprite-group-select").value = "";
								alert("预设已删除。");
							}
						}
					}
				}

				/* 约会立绘功能核心函数 */

				/**
				 * 渲染约会设置中"立绘组"的下拉选择器
				 */
				async function renderDatingSpriteGroupSelector() {
					const select = document.getElementById("dating-sprite-group-select");
					select.innerHTML = '<option value="">-- 不使用立绘 --</option>'; // 默认选项

					const groups = await db.datingSpriteGroups.toArray();
					groups.forEach((group) => {
						select.innerHTML += `<option value="${group.id}">${group.name}</option>`;
					});

					// 根据当前加载的预设，自动选中对应的立绘组
					if (currentDatingUISettings && currentDatingUISettings.spriteGroupId) {
						select.value = currentDatingUISettings.spriteGroupId;
					}
				}

				/**
				 * 打开立绘组管理器
				 */
				async function openSpriteGroupManager() {
					await renderSpriteGroupManagerList();
					document.getElementById("sprite-group-manager-modal").classList.add("visible");
				}

				/**
				 * 在管理器中渲染立绘组列表
				 */
				async function renderSpriteGroupManagerList() {
					const container = document.getElementById("sprite-group-list-container");
					container.innerHTML = "";
					const groups = await db.datingSpriteGroups.orderBy("name").toArray();

					if (groups.length === 0) {
						container.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有任何立绘组，点击"新建"创建一个吧！</p>';
						return;
					}

					groups.forEach((group) => {
						const item = document.createElement("div");
						item.className = "sprite-group-list-item";
						item.innerHTML = `
                            <span class="group-name">${group.name}</span>
                            <div class="group-actions">
                                <button class="form-button-secondary" data-action="edit" data-id="${group.id}">编辑</button>
                                <button class="form-button-secondary" data-action="delete" data-id="${group.id}" style="color: #ff3b30;">删除</button>
                            </div>
                        `;
						container.appendChild(item);
					});
				}

				/**
				 * 打开立绘组编辑器（用于新建或编辑）
				 * @param {number|null} groupId - 如果是编辑，则传入ID；如果是新建，则为null
				 */
				async function openSpriteEditor(groupId = null) {
					editingSpriteGroupId = groupId;
					const modal = document.getElementById("sprite-editor-modal");
					const titleEl = document.getElementById("sprite-editor-title");
					const nameInput = document.getElementById("sprite-group-name-input");
					const listEditor = document.getElementById("sprite-list-editor");

					listEditor.innerHTML = ""; // 清空旧的立绘

					if (groupId) {
						// 编辑模式
						const group = await db.datingSpriteGroups.get(groupId);
						const sprites = await db.datingSprites.where("groupId").equals(groupId).toArray();
						titleEl.textContent = `编辑立绘组: ${group.name}`;
						nameInput.value = group.name;
						sprites.forEach((sprite) => {
							listEditor.appendChild(createSpriteEditCard(sprite));
						});
					} else {
						// 新建模式
						titleEl.textContent = "新建立绘组";
						nameInput.value = "";
						// 默认创建一个空的立绘卡片
						listEditor.appendChild(createSpriteEditCard());
					}

					modal.classList.add("visible");
				}

				/**
				 * 创建一个立绘编辑卡片的DOM元素
				 * @param {object} sprite - 可选的立绘数据对象
				 * @returns {HTMLElement}
				 */
				function createSpriteEditCard(sprite = {}) {
					const card = document.createElement("div");
					card.className = "sprite-edit-card";
					card.dataset.spriteId = sprite.id || `new_${Date.now()}_${Math.random()}`;

					// 为 x, y, size 提供默认值
					const xPos = sprite.x ?? 50; // 默认水平居中
					const yPos = sprite.y ?? 100; // 默认垂直贴底
					const size = sprite.size ?? 80; // 默认大小为80%

					// 在HTML中加入了三个滑块和数值显示
					card.innerHTML = `
                        <div class="preview-container" style="background-image: url(${sprite.url || ""})"></div>
                        <div class="fields-container">
                            <div class="form-group" style="margin:0;">
                                <label>描述 (用于AI识别)</label>
                                <textarea class="sprite-desc-input" rows="2">${sprite.description || ""}</textarea>
                            </div>
                            <div class="form-group" style="margin:0;">
                                <label>图片 (URL或本地上传)</label>
                                <div class="bg-upload-container">
                                    <button class="form-button-secondary upload-sprite-btn" style="margin-top:0;">上传</button>
                                    <input class="sprite-url-input" type="text" value="${sprite.url || ""}" placeholder="或粘贴URL">
                                </div>
                            </div>
                            
                            <!-- 立绘位置和大小控制滑块 -->
                            <div class="position-controls">
                                <label>X 位置: <span class="pos-value">${xPos}%</span></label>
                                <input type="range" class="sprite-x-slider" min="0" max="100" value="${xPos}">
                            </div>
                            <div class="position-controls">
                                <label>Y 位置: <span class="pos-value">${yPos}%</span></label>
                                <input type="range" class="sprite-y-slider" min="0" max="100" value="${yPos}">
                            </div>
                            <div class="position-controls">
                                <label>大小: <span class="pos-value">${size}%</span></label>
                                <input type="range" class="sprite-size-slider" min="10" max="150" value="${size}">
                            </div>

                        </div>
                        <button class="delete-sprite-btn">×</button>
                    `;

					// 为卡片内的按钮绑定事件
					card.querySelector(".delete-sprite-btn").onclick = () => card.remove();
					card.querySelector(".upload-sprite-btn").onclick = () => handleSpriteImageUpload(card);
					card.querySelector(".sprite-url-input").oninput = (e) => {
						card.querySelector(".preview-container").style.backgroundImage = `url(${e.target.value})`;
					};

					// 为新滑块绑定事件，实时更新旁边的数值显示
					card.querySelectorAll('.position-controls input[type="range"]').forEach((slider) => {
						slider.addEventListener("input", () => {
							const valueSpan = slider.previousElementSibling.querySelector(".pos-value");
							if (valueSpan) {
								valueSpan.textContent = `${slider.value}%`;
							}
						});
					});

					return card;
				}

				/**
				 * 处理单个立绘的图片上传
				 * @param {HTMLElement} cardElement - 对应的立绘编辑卡片
				 */
				function handleSpriteImageUpload(cardElement) {
					const fileInput = document.createElement("input");
					fileInput.type = "file";
					fileInput.accept = "image/*";
					fileInput.onchange = async () => {
						const file = fileInput.files[0];
						if (file) {
							const dataUrl = await new Promise((resolve) => {
								const reader = new FileReader();
								reader.onload = (e) => resolve(e.target.result);
								reader.readAsDataURL(file);
							});
							cardElement.querySelector(".sprite-url-input").value = dataUrl;
							cardElement.querySelector(".preview-container").style.backgroundImage = `url(${dataUrl})`;
						}
					};
					fileInput.click();
				}

				/**
				 * 保存整个立绘组（包括所有立绘）
				 */
				async function saveSpriteGroup() {
					const name = document.getElementById("sprite-group-name-input").value.trim();
					if (!name) {
						alert("立绘组名称不能为空！");
						return;
					}

					// 保存或更新立绘组的名称
					let groupId;
					if (editingSpriteGroupId) {
						await db.datingSpriteGroups.update(editingSpriteGroupId, { name });
						groupId = editingSpriteGroupId;
					} else {
						groupId = await db.datingSpriteGroups.add({ name });
					}

					// 准备更新的立绘数据
					const spriteCards = document.querySelectorAll("#sprite-list-editor .sprite-edit-card");
					const spritesToSave = [];
					let hasError = false;

					spriteCards.forEach((card) => {
						const description = card.querySelector(".sprite-desc-input").value.trim();
						const url = card.querySelector(".sprite-url-input").value.trim();

						// 从新增的滑块中读取 x, y, size 的值
						const x = parseInt(card.querySelector(".sprite-x-slider").value);
						const y = parseInt(card.querySelector(".sprite-y-slider").value);
						const size = parseInt(card.querySelector(".sprite-size-slider").value);

						if (!description || !url) {
							hasError = true;
						}

						spritesToSave.push({
							id: card.dataset.spriteId.startsWith("new_") ? undefined : parseInt(card.dataset.spriteId),
							groupId: groupId,
							description,
							url,
							// 将读取到的值添加到要保存的对象中
							x: x,
							y: y,
							size: size,
						});
					});

					if (hasError) {
						alert("存在描述或图片URL为空的立绘，请填写完整！");
						return;
					}

					// 使用事务，一次性更新所有数据
					await db.transaction("rw", db.datingSprites, async () => {
						await db.datingSprites.where("groupId").equals(groupId).delete();
						await db.datingSprites.bulkAdd(spritesToSave);
					});

					// 关闭弹窗并刷新UI
					document.getElementById("sprite-editor-modal").classList.remove("visible");
					await renderSpriteGroupManagerList();
					await renderDatingSpriteGroupSelector();

					if (document.getElementById("dating-game-settings-modal").classList.contains("visible")) {
						document.getElementById("dating-sprite-group-select").value = groupId;
					}

					alert("立绘组已保存！");
				}

				/**
				 * 删除一个立绘组及其所有立绘
				 * @param {number} groupId - 要删除的立绘组的ID
				 */
				async function deleteSpriteGroup(groupId) {
					const group = await db.datingSpriteGroups.get(groupId);
					const confirmed = await showCustomConfirm("删除立绘组", `确定要删除立绘组 "${group.name}" 吗？此操作不可恢复。`, { confirmButtonClass: "btn-danger" });
					if (confirmed) {
						await db.transaction("rw", db.datingSpriteGroups, db.datingSprites, db.datingPresets, async () => {
							// 删除该组下的所有立绘
							await db.datingSprites.where("groupId").equals(groupId).delete();
							// 删除立绘组本身
							await db.datingSpriteGroups.delete(groupId);
							// 找到所有引用了这个立绘组的约会预设，并将它们的引用清空
							const presetsToUpdate = await db.datingPresets.where("settings.spriteGroupId").equals(groupId).toArray();
							for (const preset of presetsToUpdate) {
								preset.settings.spriteGroupId = null;
								await db.datingPresets.put(preset);
							}
						});
						await renderSpriteGroupManagerList();
						await renderDatingSpriteGroupSelector();
						alert("立绘组已删除。");
					}
				}
				/* 约会立绘功能核心函数结束 */

				/**
				 * 当约会结束时，显示结算卡片，并自动保存到历史记录
				 * @param {string} [finalStory=""] - 约会的最后一段剧情文本
				 */
				async function showDatingSummaryCard(finalStory = "") {
					const overlay = document.getElementById("dating-summary-overlay");
					const card = document.querySelector(".dating-summary-card");
					const cardInner = document.querySelector(".dating-summary-card-inner");
					const cardFront = document.querySelector(".card-front");
					const avatarEl = document.getElementById("summary-card-avatar");
					const ratingEl = document.getElementById("summary-card-rating");
					const historyEl = document.getElementById("summary-card-history");

					document.getElementById("summary-share-btn").style.display = "block";

					card.classList.remove("is-flipped");
					cardFront.classList.remove("romantic", "passionate", "perfect");

					const romance = datingGameState.romance;
					const lust = datingGameState.lust;
					const completion = datingGameState.completion;
					let ratingText = "";
					let cardClass = "";
					let finalRatingType = "anticipation";

					if (romance >= 100 && lust >= 100 && completion >= 100) {
						ratingText = "完美之夜 🎊";
						cardClass = "perfect";
						finalRatingType = "perfect";
					} else if (romance >= 100) {
						ratingText = "浪漫之夜 ❤️";
						cardClass = "romantic";
						finalRatingType = "romantic";
					} else if (lust >= 100) {
						ratingText = "激情之夜 ⭐";
						cardClass = "passionate";
						finalRatingType = "passionate";
					} else {
						ratingText = "期待之夜";
					}

					const character = state.chats[datingGameState.characterId];
					avatarEl.src = character.settings.aiAvatar || defaultAvatar;
					ratingEl.textContent = ratingText;
					if (cardClass) {
						cardFront.classList.add(cardClass);
					}

					const fullHistory = [...datingGameState.storyHistory, `【旁白】: ${finalStory}`].join("\n\n").replace(/\n/g, "<br>");
					historyEl.innerHTML = `<p>${fullHistory}</p>`;

					// 暂存数据，以便分享
					currentDatingSummary = {
						rating: ratingText,
						ratingType: finalRatingType,
						characterId: datingGameState.characterId,
						avatarUrl: avatarEl.src,
						storyHistory: datingGameState.storyHistory,
						finalStory: finalStory,
						sceneName: datingGameState.scene.name,
					};

					// 将约会结算卡片保存到历史库
					try {
						const historyRecord = {
							...currentDatingSummary, // 将卡片的所有信息都复制过来
							timestamp: Date.now(), // 加上一个保存时的时间戳
						};
						// 使用 await 异步地将这条记录添加到我们的新数据库表中
						await db.datingHistory.add(historyRecord);
						console.log("约会结算卡片已保存到历史库:", historyRecord);
					} catch (error) {
						console.error("保存约会结算卡片失败:", error);
					}

					overlay.classList.add("visible");
				}

				/**
				 * 将结算卡片分享到与角色的聊天中 (包含完整记录用于编辑)
				 */
				async function shareDatingSummary() {
					// 安全检查，确保有结算数据
					if (!currentDatingSummary) return;

					const chat = state.chats[currentDatingSummary.characterId];
					if (!chat) return;

					// 准备一个用于【编辑时】显示的、包含完整约会过程的详细文本
					const storyForEdit = [...currentDatingSummary.storyHistory, `【旁白】: ${currentDatingSummary.finalStory}`].join("\n");
					const contentForEditing = `
                        [约会记录]
                        约会场所: ${currentDatingSummary.sceneName}
                        约会评级: ${currentDatingSummary.rating}
                        --------------------
                        ${storyForEdit}
                    `.trim();

					// 创建一个特殊的消息对象，它将作为聊天记录被保存
					const summaryMessage = {
						role: "user", // 标记为用户发出的消息
						type: "dating_summary_card", // 自定义的新消息类型，用于识别
						timestamp: Date.now(),

						// 这个 content 字段就是你想要的，当编辑这条消息时，就会显示这里的文本
						content: contentForEditing,

						// payload 字段用于存储渲染UI所需的所有数据
						payload: {
							rating: currentDatingSummary.rating,
							ratingType: currentDatingSummary.ratingType,
							avatarUrl: currentDatingSummary.avatarUrl,
							storyHistory: currentDatingSummary.storyHistory,
							finalStory: currentDatingSummary.finalStory,
							sceneName: currentDatingSummary.sceneName,
							characterName: chat.name, // 把角色名字也存进去，方便卡片背面显示
						},
					};

					// 将这条新消息添加到聊天记录并保存到数据库
					chat.history.push(summaryMessage);
					await db.chats.put(chat);

					// 给出成功提示，并关闭结算卡片、结束约会
					await showCustomAlert("分享成功", "你们的约会记录已发送给Ta！");

					document.getElementById("dating-summary-overlay").classList.remove("visible");
					finalizeAndExitDate(); // 这个函数会处理后续的清理工作
					currentDatingSummary = null; // 清理临时数据
				}

				/**
				 * 重新打开约会结算详情卡片
				 * @param {object} payload - 从聊天记录消息中解析出的卡片数据
				 */
				function reopenDatingSummary(payload) {
					const overlay = document.getElementById("dating-summary-overlay");
					const card = document.querySelector(".dating-summary-card");
					const cardInner = document.querySelector(".dating-summary-card-inner");
					const cardFront = document.querySelector(".card-front");
					const avatarEl = document.getElementById("summary-card-avatar");
					const ratingEl = document.getElementById("summary-card-rating");
					const historyEl = document.getElementById("summary-card-history");

					// 重置卡片状态
					card.classList.remove("is-flipped");
					cardFront.classList.remove("romantic", "passionate", "perfect");
					cardFront.style.background = "";

					// 从 payload 中恢复数据并填充到UI元素中
					avatarEl.src = payload.avatarUrl;
					ratingEl.textContent = payload.rating;
					if (payload.ratingType && payload.ratingType !== "anticipation") {
						cardFront.classList.add(payload.ratingType);
					}

					const fullHistory = [...payload.storyHistory, `【旁白】: ${payload.finalStory}`].join("\n\n").replace(/\n/g, "<br>");
					historyEl.innerHTML = `<p>${fullHistory}</p>`;

					// 设置卡片背面的标题
					const cardBackHeader = document.querySelector(".card-back .card-back-header span");
					if (cardBackHeader) {
						cardBackHeader.textContent = `${payload.characterName} - ${payload.sceneName}`;
					}

					// 因为只是查看，所以隐藏"分享"按钮
					document.getElementById("summary-share-btn").style.display = "none";

					overlay.classList.add("visible");
				}

				/**
				 * 打开历史约会界面
				 */
				async function openDatingHistory() {
					showScreen("dating-history-screen");
					await renderDatingHistory();
				}

				/**
				 * 渲染历史约会列表
				 */
				async function renderDatingHistory() {
					const listEl = document.getElementById("dating-history-list");
					listEl.innerHTML = "";

					// 从数据库读取所有记录，并按时间倒序排列
					const records = await db.datingHistory.orderBy("timestamp").reverse().toArray();

					if (records.length === 0) {
						listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有任何约会记录哦</p>';
						return;
					}

					// 遍历每一条记录，创建对应的卡片并添加到列表中
					records.forEach((record) => {
						const card = createDatingHistoryCard(record);
						listEl.appendChild(card);
					});
				}

				/**
				 * 根据单条历史记录，创建一张可翻转的卡片
				 * @param {object} record - 历史记录对象
				 * @returns {HTMLElement} - 创建好的卡片DOM元素
				 */
				function createDatingHistoryCard(record) {
					const cardContainer = document.createElement("div");
					cardContainer.className = "dating-summary-card"; // 复用结算卡片的样式，很方便！

					// 根据评级类型设置卡片正面的颜色
					let cardClass = "";
					if (record.ratingType === "romantic") cardClass = "romantic";
					else if (record.ratingType === "passionate") cardClass = "passionate";
					else if (record.ratingType === "perfect") cardClass = "perfect";

					// 拼接卡片背面的完整约会记录HTML
					const fullHistoryHtml = [...record.storyHistory, `【旁白】: ${record.finalStory}`].join("\n\n").replace(/\n/g, "<br>");

					// 获取角色名字，如果角色被删了，就显示"未知角色"
					const charName = state.chats[record.characterId]?.name || "未知角色";

					// 最终拼接成一个完整的、包含正反两面的卡片HTML
					cardContainer.innerHTML = `
                        <div class="dating-summary-card-inner">
                            <!-- 卡片正面 -->
                            <div class="card-front ${cardClass}">
                                <img src="${record.avatarUrl}" alt="角色头像">
                                <h2>${record.rating}</h2>
                                <p>${new Date(record.timestamp).toLocaleDateString()}</p>
                                <p class="summary-card-tip">点击查看详情</p>
                            </div>
                            <!-- 卡片背面 -->
                            <div class="card-back">
                                <div class="card-back-header">
                                    <span>${charName} - ${record.sceneName}</span>
                                </div>
                                <div class="card-back-content">
                                    <p>${fullHistoryHtml}</p>
                                </div>
                            </div>
                        </div>
                    `;
					return cardContainer;
				}

				/**
				 * 根据场景名称，智能判断并返回重写后的场景描述和风格关键词
				 * @param {string} sceneName - 用户输入的场景名称
				 * @returns {{scenePrompt: string, styleKeywords: string}} - 返回包含场景描述和风格词的对象
				 */
				function getSceneTypeKeywords(sceneName) {
					const name = sceneName.toLowerCase(); // 转换为小写，方便匹配

					const outdoorKeywords = ["公园", "海滩", "山", "森林", "湖", "花园", "夜市", "路边", "街头", "park", "beach", "mountain", "forest", "lake", "garden", "street"];
					const indoorPublicKeywords = ["咖啡", "书店", "博物馆", "美术馆", "水族馆", "影院", "酒吧", "cafe", "bookstore", "museum", "gallery", "aquarium", "cinema", "bar"];
					const loveHotelKeywords = ["情趣", "love hotel", "主题酒店", "lovers hotel", "成人旅馆"];

					// 优先判断是否为特殊的情趣酒店
					if (loveHotelKeywords.some((keyword) => name.includes(keyword))) {
						console.log("场景识别为：情趣酒店（已激活特殊重写模式）");
						// 将"情趣酒店"翻译成纯粹的、描述性的场景
						return {
							scenePrompt: "an empty luxurious romantic hotel room interior, with a heart-shaped bed or a round bed, mirrors on the ceiling, neon mood lighting, Jacuzzi in room, sensual and intimate atmosphere",
							styleKeywords: "romantic, luxurious, intimate, playful",
						};
					}

					// 判断是否为户外场景
					if (outdoorKeywords.some((keyword) => name.includes(keyword))) {
						console.log("场景识别为：户外");
						return {
							scenePrompt: sceneName,
							styleKeywords: "natural lighting, golden hour, beautiful scenery, serene atmosphere, epic sky, wide angle",
						};
					}

					// 判断是否为室内公共场所
					if (indoorPublicKeywords.some((keyword) => name.includes(keyword))) {
						console.log("场景识别为：室内公共场所");
						return {
							scenePrompt: sceneName,
							styleKeywords: "cozy interior, ambient lighting, warm and inviting, charming decor, detailed background",
						};
					}

					// 默认情况，使用用户输入的名称
					console.log("场景识别为：通用/现代酒店");
					return {
						scenePrompt: sceneName,
						styleKeywords: "modern aesthetic, elegant decor, luxurious interior, clean, bright",
					};
				}

				/**
				 * 保存用户自定义的约会场景
				 */
				async function handleSaveCustomDatingScene() {
					const name = document.getElementById("scene-name-input").value.trim();
					const imageUrl = document.getElementById("scene-image-url-input").value.trim();
					const costStr = document.getElementById("scene-cost-input").value.trim();

					if (!name || !costStr) {
						alert("场景名称和花费为必填项！");
						return;
					}

					const cost = parseInt(costStr, 10);
					if (isNaN(cost) || cost < 0) {
						alert("请输入有效的花费金额！");
						return;
					}

					const newScene = {
						name: name,
						cost: cost,
						uid: "scene_user_" + Date.now(),
					};

					if (imageUrl) {
						if (!imageUrl.startsWith("http") && !imageUrl.startsWith("data:image")) {
							alert("请输入一个有效的网络图片URL！");
							return;
						}
						newScene.imageUrl = imageUrl;
						newScene.imagePrompt = "User-provided image";
					} else {
						// 生成AI图像的提示词
						const universalStyle = "photorealistic, 4k, hyperrealistic, cinematic lighting, masterpiece, best quality, ultra detailed, no dark elements, romantic, (no humans:1.5), no people, no characters, empty room, no one";
						const promptParts = getSceneTypeKeywords(name);
						newScene.imageUrl = "";
						newScene.imagePrompt = `${promptParts.scenePrompt}, ${promptParts.styleKeywords}, ${universalStyle}`;

						console.log("【终极版】生成的Image Prompt:", newScene.imagePrompt);
					}

					try {
						await db.datingScenes.add(newScene);
						currentDatingScenes.push(newScene);
						document.getElementById("create-dating-scene-modal").classList.remove("visible");
						renderDatingScenes();
						alert("自定义约会场景已成功创建！");
					} catch (error) {
						console.error("保存自定义约会场景失败:", error);
						alert(`保存失败: ${error.message}`);
					}
				}

				/**
				 * 渲染表情包分类标签
				 */
				async function renderStickerCategories() {
					const tabsContainer = document.getElementById("sticker-category-tabs");
					if (!tabsContainer) return;

					tabsContainer.innerHTML = ""; // 清空旧的标签
					const categories = await db.userStickerCategories.orderBy("name").toArray();
					userStickerCategories = categories; // 更新全局缓存

					// 渲染"未分类"按钮
					const uncategorizedBtn = document.createElement("button");
					uncategorizedBtn.className = "sticker-category-btn";
					uncategorizedBtn.textContent = "未分类";
					uncategorizedBtn.dataset.categoryId = "uncategorized";
					if (activeStickerCategoryId === "uncategorized") {
						uncategorizedBtn.classList.add("active");
					}
					tabsContainer.appendChild(uncategorizedBtn);

					// 渲染所有自定义分类
					for (const category of categories) {
						const btn = document.createElement("button");
						btn.className = "sticker-category-btn";
						// 将ID和名称都存储在父按钮上，方便事件委托获取
						btn.dataset.categoryId = category.id;
						btn.dataset.categoryName = category.name;

						const nameSpan = document.createElement("span");
						nameSpan.textContent = category.name;
						btn.appendChild(nameSpan);

						// 如果是当前激活的分类，添加高亮
						if (activeStickerCategoryId === category.id) {
							btn.classList.add("active");
						}

						// 只在编辑模式下，才创建和添加删除按钮
						if (isUserStickerSelectionMode) {
							const deleteBtn = document.createElement("span");
							deleteBtn.className = "sticker-category-delete-btn";
							deleteBtn.textContent = "×";
							deleteBtn.title = `删除分类 "${category.name}"`; // 增加悬浮提示
							btn.appendChild(deleteBtn);
						}

						tabsContainer.appendChild(btn);
					}
				}

				/**
				 * 打开移动表情到分类的模态框
				 */
				async function openStickerCategoryModal() {
					if (selectedUserStickers.size === 0) {
						alert("请先选择要移动的表情包！");
						return;
					}

					const modal = document.getElementById("sticker-category-modal");
					const listEl = document.getElementById("sticker-category-list");
					const inputEl = document.getElementById("new-sticker-category-input");
					listEl.innerHTML = "";
					inputEl.value = "";

					const categories = await db.userStickerCategories.toArray();
					if (categories.length > 0) {
						categories.forEach((cat) => {
							const label = document.createElement("label");
							label.innerHTML = `<input type="radio" name="sticker_category_select" value="${cat.id}"> ${cat.name}`;
							listEl.appendChild(label);
						});
					} else {
						listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类。</p>';
					}

					modal.classList.add("visible");
				}

				/**
				 * 处理"确认移动"按钮的点击逻辑
				 */
				async function handleMoveStickers() {
					const newCategoryName = document.getElementById("new-sticker-category-input").value.trim();
					const selectedRadio = document.querySelector('input[name="sticker_category_select"]:checked');

					let targetCategoryId = null;

					if (newCategoryName) {
						try {
							// 检查分类是否已存在
							let existingCategory = await db.userStickerCategories.where("name").equalsIgnoreCase(newCategoryName).first();
							if (existingCategory) {
								targetCategoryId = existingCategory.id;
							} else {
								targetCategoryId = await db.userStickerCategories.add({ name: newCategoryName });
							}
						} catch (error) {
							alert("创建新分类失败，可能是名称重复或数据库错误。");
							return;
						}
					} else if (selectedRadio) {
						targetCategoryId = parseInt(selectedRadio.value);
					} else {
						alert("请选择一个分类或创建一个新分类！");
						return;
					}

					try {
						const stickerIdsToMove = Array.from(selectedUserStickers);
						const stickers = await db.userStickers.bulkGet(stickerIdsToMove);

						stickers.forEach((sticker) => {
							if (sticker) {
								sticker.categoryId = targetCategoryId;
							}
						});

						await db.userStickers.bulkPut(stickers);

						// 更新内存中的 state.userStickers
						stickers.forEach((updatedSticker) => {
							const index = state.userStickers.findIndex((s) => s.id === updatedSticker.id);
							if (index > -1) {
								state.userStickers[index].categoryId = targetCategoryId;
							}
						});

						document.getElementById("sticker-category-modal").classList.remove("visible");
						exitUserStickerSelectionMode(); // 退出编辑模式
						alert(`成功移动 ${stickerIdsToMove.length} 个表情！`);
					} catch (error) {
						console.error("移动表情失败:", error);
						alert("移动表情时发生错误。");
					}
				}

				// 视频通话控制按钮的事件委托处理函数
				function handleCallControls(event) {
					// 找到被点击的那个按钮元素
					const button = event.target.closest(".control-btn");
					if (!button) return; // 如果点击的不是按钮，就什么也不做

					// 根据按钮的ID来执行不同的操作
					switch (button.id) {
						case "user-speak-btn":
						case "user-speak-btn-visual":
							// 处理用户发言
							handleUserSpeakInCall();
							break;
						case "hang-up-btn":
						case "hang-up-btn-visual":
							// 挂断通话
							endVideoCall();
							break;
						case "join-call-btn":
							// 加入通话
							handleUserJoinCall();
							break;
						case "reroll-call-btn":
						case "reroll-call-btn-text":
							// 重roll通话
							handleVideoCallReroll();
							break;
						case "switch-camera-btn":
							// 切换镜头
							switchVideoViews();
							break;
						// 如果还有其他按钮，在这里继续添加 case
					}
				}

				// 在init()函数中，为两个控制栏容器绑定事件
				// 注意：因为HTML中有两个 controls div，所以需要分别绑定
				const textModeControls = document.querySelector("#text-call-interface .video-call-controls");
				if (textModeControls) {
					textModeControls.addEventListener("click", handleCallControls);
				}

				const visualModeControls = document.querySelector("#visual-call-interface .video-call-controls");
				if (visualModeControls) {
					visualModeControls.addEventListener("click", handleCallControls);
				}

				/**
				 * 处理用户在通话中点击"发言"按钮的逻辑
				 */
				async function handleUserSpeakInCall() {
					// 安全检查，如果通话未激活则不执行
					if (!videoCallState.isActive) return;

					// 找到用户头像并添加"正在发言"的高亮效果，提升交互感
					const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
					if (userAvatar) {
						userAvatar.classList.add("speaking");
					}

					// 弹出输入框让用户输入发言内容
					const userInput = await showCustomPrompt("你说", "请输入你想说的话...");

					// 无论用户是否输入，只要输入框关闭，就立刻移除头像的高亮效果
					if (userAvatar) {
						userAvatar.classList.remove("speaking");
					}

					// 如果用户确实输入了内容，就调用函数来触发AI响应
					if (userInput && userInput.trim()) {
						triggerAiInCallAction(userInput.trim());
					}
				}

				/**
				 * 初始化默认的小组
				 */
				async function initializeDefaultGroups() {
					const groupCount = await db.forumGroups.count();
					if (groupCount === 0) {
						const defaultGroups = [
							{ name: "娱乐小组", description: "分享八卦和快乐", icon: "🍿" },
							{ name: "灵异小组", description: "分享你的灵异经历", icon: "👻" },
							{ name: "今天我crush了吗", description: "记录心动瞬间", icon: "💖" },
							{ name: "请帮我选择小组", description: "选择困难症患者互助", icon: "🤔" },
							{ name: "同人文小组", description: "为爱发电，创作故事", icon: "✍️" },
							// 新增梦角小组
							{ name: "梦角小组", description: "Char们分享关于user的梦境", icon: "🌙" },
						];
						await db.forumGroups.bulkAdd(defaultGroups);
						console.log("已成功创建默认小组（包含梦角小组）。");
					}
				}

				/**
				 * 打开高级导入导出模态框，并动态生成选项列表
				 */
				async function openAdvancedTransferModal() {
					const appsListEl = document.getElementById("export-apps-list");
					const charactersListEl = document.getElementById("export-characters-list");
					appsListEl.innerHTML = "";
					charactersListEl.innerHTML = "";

					// 定义可独立导出的App数据及其关联的数据库表
					const appsToExport = [
						{ id: "weibo", name: "微博 (全部帖子/角色资料/粉丝数等)", tables: ["weiboPosts", "qzoneSettings"] },
						{ id: "forum", name: "圈子 (所有小组/帖子/评论/分类)", tables: ["forumGroups", "forumPosts", "forumComments", "forumCategories"] },
						{ id: "taobao", name: "桃宝 (所有商品/订单/购物车/余额记录)", tables: ["taobaoProducts", "taobaoOrders", "taobaoCart", "userWalletTransactions"] },
						{ id: "worldBooks", name: "世界书 (全部书籍及分类)", tables: ["worldBooks", "worldBookCategories"] },
						{ id: "userStickers", name: "我的表情包 (包含分类)", tables: ["userStickers", "userStickerCategories"] },
						{ id: "charStickers", name: "角色通用表情包", tables: ["charStickers"] },
						{ id: "gameData", name: "游戏大厅数据 (剧本杀/飞行棋题库等)", tables: ["scriptKillScripts", "ludoQuestionBanks", "ludoQuestions"] },
						{ id: "appearance", name: "通用外观预设 (主题/字体/头像框等)", tables: ["themes", "fontPresets", "homeScreenPresets", "customAvatarFrames", "apiPresets", "bubbleStylePresets"] },
					];

					appsToExport.forEach((app) => {
						appsListEl.innerHTML += `
                            <label style="display: block; margin-bottom: 5px;">
                                <input type="checkbox" class="export-app-checkbox" value="${app.id}"> ${app.name}
                            </label>
                        `;
					});

					// 加载所有单聊角色
					const characters = Object.values(state.chats).filter((chat) => !chat.isGroup);
					if (characters.length === 0) {
						charactersListEl.innerHTML = "<p>没有可导出的角色</p>";
					} else {
						characters.forEach((char) => {
							charactersListEl.innerHTML += `
                                <label style="display: block; margin-bottom: 5px;">
                                    <input type="checkbox" class="export-char-checkbox" value="${char.id}"> ${char.name}
                                </label>
                            `;
						});
					}

					// 重置并绑定全选框
					const selectAllCheckbox = document.getElementById("select-all-characters-checkbox");
					selectAllCheckbox.checked = false;

					// 使用克隆节点技巧，防止事件重复绑定
					const newSelectAllCheckbox = selectAllCheckbox.cloneNode(true);
					selectAllCheckbox.parentNode.replaceChild(newSelectAllCheckbox, selectAllCheckbox);
					newSelectAllCheckbox.addEventListener("change", (e) => {
						document.querySelectorAll(".export-char-checkbox").forEach((cb) => {
							cb.checked = e.target.checked;
						});
					});

					// 显示模态框
					document.getElementById("advanced-transfer-modal").classList.add("visible");
				}

				/**
				 * 执行分块导出 (v3.0)
				 */
				async function exportChunkedData() {
					await showCustomAlert("请稍候...", "正在打包您选择的数据...");

					const backupData = {
						type: "EPhoneChunkedBackup",
						version: 3,
						exportedAt: Date.now(),
						contains: [],
						data: {},
					};

					try {
						const appCheckboxes = document.querySelectorAll(".export-app-checkbox:checked");
						const charCheckboxes = document.querySelectorAll(".export-char-checkbox:checked");

						if (appCheckboxes.length === 0 && charCheckboxes.length === 0) {
							alert("请至少选择一项要导出的内容！");
							hideCustomModal();
							return;
						}

						const appsToExportMap = {
							weibo: { tables: ["weiboPosts", "qzoneSettings"] },
							forum: { tables: ["forumGroups", "forumPosts", "forumComments", "forumCategories"] },
							taobao: { tables: ["taobaoProducts", "taobaoOrders", "taobaoCart", "userWalletTransactions"] },
							worldBooks: { tables: ["worldBooks", "worldBookCategories"] },
							userStickers: { tables: ["userStickers", "userStickerCategories"] },
							charStickers: { tables: ["charStickers"] },
							gameData: { tables: ["scriptKillScripts", "ludoQuestionBanks", "ludoQuestions"] },
							appearance: { tables: ["themes", "fontPresets", "homeScreenPresets", "customAvatarFrames", "apiPresets", "bubbleStylePresets"] },
						};

						// 导出选中的App数据
						for (const checkbox of appCheckboxes) {
							const appId = checkbox.value;
							const appInfo = appsToExportMap[appId];
							if (appInfo) {
								backupData.contains.push(appId);
								for (const tableName of appInfo.tables) {
									backupData.data[tableName] = await db[tableName].toArray();
									console.log(`已打包App数据表: ${tableName}`);
								}
							}
						}

						// 导出选中的角色数据
						const charIds = Array.from(charCheckboxes).map((cb) => cb.value);
						if (charIds.length > 0) {
							backupData.data.chats = await db.chats.bulkGet(charIds);
							backupData.contains.push(...charIds.map((id) => `character_${id}`));

							// 打包所有与这些角色关联的数据
							const relatedDataTables = ["memories", "callRecords", "qzonePosts", "weiboPosts", "datingHistory", "pomodoroSessions"];
							const relatedKey = {
								memories: "chatId",
								callRecords: "chatId",
								qzonePosts: "authorId",
								weiboPosts: "authorId",
								datingHistory: "characterId",
								pomodoroSessions: "chatId",
							};

							for (const tableName of relatedDataTables) {
								const items = await db[tableName].where(relatedKey[tableName]).anyOf(charIds).toArray();
								if (items.length > 0) {
									if (!backupData.data[tableName]) backupData.data[tableName] = [];
									// 使用Set去重，防止因多角色关联同一数据而重复打包
									const existingIds = new Set(backupData.data[tableName].map((i) => i.id));
									items.forEach((item) => {
										if (!existingIds.has(item.id)) {
											backupData.data[tableName].push(item);
											existingIds.add(item.id);
										}
									});
								}
							}
							console.log(`已打包 ${charIds.length} 个角色的核心及关联数据。`);
						}

						// 创建JSON文件并触发下载
						const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: "application/json" });
						const url = URL.createObjectURL(blob);
						const link = document.createElement("a");
						link.href = url;
						link.download = `EPhone-Partial-Backup-${new Date().toISOString().split("T")[0]}.json`;
						document.body.appendChild(link);
						link.click();
						document.body.removeChild(link);
						URL.revokeObjectURL(url);

						await showCustomAlert("导出成功", "已成功导出您选中的数据！");
					} catch (error) {
						console.error("分块导出失败:", error);
						await showCustomAlert("导出失败", `发生错误: ${error.message}`);
					} finally {
						document.getElementById("advanced-transfer-modal").classList.remove("visible");
					}
				}

				/**
				 * 执行补充式导入
				 * @param {File} file - 用户选择的JSON文件
				 */
				async function importChunkedData(file) {
					if (!file) return;

					let data;
					try {
						const text = await file.text();
						data = JSON.parse(text);
					} catch (error) {
						await showCustomAlert("导入失败", "文件读取或解析失败，请确保文件是有效的JSON格式。");
						return;
					}

					if (data.type !== "EPhoneChunkedBackup") {
						const confirmed = await showCustomConfirm("文件类型不匹配", "这是一个【全量备份】文件，继续导入将会【覆盖】所有数据！是否要继续？", { confirmButtonClass: "btn-danger" });
						if (confirmed) importBackup(file);
						return;
					}

					const contentList = data.contains
						.map((item) => {
							const appNameMap = { weibo: "微博", forum: "圈子", taobao: "桃宝", worldBooks: "世界书", userStickers: "我的表情包", charStickers: "角色通用表情包", gameData: "游戏大厅数据", appearance: "通用外观预设" };
							if (item.startsWith("character_")) {
								const charId = item.replace("character_", "");
								const charData = data.data.chats?.find((c) => c.id === charId);
								return `角色数据：${charData ? charData.name : "未知角色"}`;
							}
							return appNameMap[item] || item;
						})
						.join("\n- ");

					const confirmed = await showCustomConfirm("确认导入", `即将导入以下内容：\n\n- ${contentList}\n\n注意：如果现有数据中已存在相同ID的内容（如同名角色），他们的数据将会被导入的数据【完全覆盖】。此操作不可撤销！`);

					if (!confirmed) return;

					await showCustomAlert("请稍候...", "正在导入数据，请勿关闭页面...");

					try {
						// 获取导入文件中有哪些数据表
						const tablesInBackup = Object.keys(data.data);

						// 获取当前数据库中实际存在的所有数据表名称
						const validTableNames = db.tables.map((t) => t.name);

						// 找出二者的交集，这才是我们真正需要操作的数据表
						const tablesToUpdate = tablesInBackup.filter((t) => validTableNames.includes(t));

						console.log("即将操作的有效数据表:", tablesToUpdate);

						// 只对这些有效的数据表开启一个数据库事务
						await db.transaction("rw", tablesToUpdate, async () => {
							for (const tableName of tablesToUpdate) {
								if (Array.isArray(data.data[tableName])) {
									console.log(`正在向表格 "${tableName}" 中补充/覆盖 ${data.data[tableName].length} 条数据...`);
									await db[tableName].bulkPut(data.data[tableName]);
								}
							}
						});

						await loadAllDataFromDB();
						await renderChatList();

						await showCustomAlert("导入成功", "数据已成功补充！应用将刷新以确保所有数据正确加载。");
						setTimeout(() => window.location.reload(), 1500);
					} catch (error) {
						console.error("补充式导入失败:", error);
						await showCustomAlert("导入失败", `写入数据库时发生错误: ${error.message}`);
					} finally {
						document.getElementById("advanced-transfer-modal").classList.remove("visible");
					}
				}

				/**
				 * 将当前App的数据导出为兼容EPhone 330的格式
				 */
				async function exportDataFor330() {
					await showCustomAlert("请稍候...", "正在为你准备兼容性备份文件...");

					const backupData = {
						version: 3, // 将版本号强制写为3，让330版本能识别
						timestamp: Date.now(),
						data: {},
					};

					try {
						const [
							chatsFromDB,
							worldBooksFromDB,
							userStickersFromDB,
							apiConfigFromDB,
							globalSettingsFromDB,
							qzonePostsFromDB,
							qzoneAlbumsFromDB,
							qzonePhotosFromDB,
							qzoneSettingsFromDB,
							personaPresetsFromDB,
							memoriesFromDB,
							apiPresetsFromDB,
							favoritesFromDB,
							worldBookCategoriesFromDB,
							callRecordsFromDB,
							stickerCategoriesFromDB, // 修正了上一版中的拼写错误
						] = await Promise.all([
							db.chats.toArray(),
							db.worldBooks.toArray(),
							db.userStickers.toArray(),
							db.apiConfig.get("main"),
							db.globalSettings.get("main"),
							db.qzonePosts.toArray(),
							db.qzoneAlbums.toArray(),
							db.qzonePhotos.toArray(),
							db.qzoneSettings.get("main"),
							db.personaPresets.toArray(),
							db.memories.toArray(),
							db.apiPresets.toArray(),
							db.favorites.toArray(),
							db.worldBookCategories.toArray(),
							db.callRecords.toArray(),
							db.userStickerCategories.toArray(), // 从 stickerCategories 改为 userStickerCategories
						]);

						const transformedWorldBooks = worldBooksFromDB.map((book) => {
							const newBookFor330 = { ...book };
							if (typeof newBookFor330.content === "string" && newBookFor330.content.trim()) {
								newBookFor330.content = [
									{
										keys: [book.name],
										comment: `从 EPhone 导入的条目`,
										content: book.content,
										enabled: true,
									},
								];
							} else {
								newBookFor330.content = [];
							}
							return newBookFor330;
						});

						const transformedChats = chatsFromDB.map((chat) => {
							if (chat.isGroup) return chat;
							const settingsFor330 = { ...chat.settings, "ai-persona": chat.settings.aiPersona, "my-persona": chat.settings.myPersona, "ai-avatar": chat.settings.aiAvatar, "my-avatar": chat.settings.myAvatar };
							return { ...chat, settings: settingsFor330 };
						});

						const transformedNpcs = [];
						const npcIdSet = new Set();
						for (const chat of chatsFromDB) {
							if (!chat.isGroup && Array.isArray(chat.npcLibrary)) {
								chat.npcLibrary.forEach((npc) => {
									if (!npcIdSet.has(npc.id)) {
										transformedNpcs.push({ id: npc.id, name: npc.name, avatar: npc.avatar, persona: npc.persona, associatedWith: [chat.id] });
										npcIdSet.add(npc.id);
									} else {
										const existingNpc = transformedNpcs.find((n) => n.id === npc.id);
										if (existingNpc) existingNpc.associatedWith.push(chat.id);
									}
								});
							}
						}

						const transformedQzoneSettings = { id: "main", nickname: qzoneSettingsFromDB?.nickname || "你的昵称", avatar: qzoneSettingsFromDB?.avatar || "https://files.catbox.moe/q6z5fc.jpeg", banner: qzoneSettingsFromDB?.banner || "https://files.catbox.moe/r5heyt.gif" };

						const transformedDoubanPosts = qzonePostsFromDB.filter((p) => p.authorId !== "user").map((p) => ({ id: p.id, timestamp: p.timestamp, groupName: "从动态导入的小组", postTitle: (p.publicText || p.content || "无标题").substring(0, 50), authorName: state.chats[p.authorId]?.name || "未知作者", authorOriginalName: state.chats[p.authorId]?.name || "未知作者", content: p.content || p.publicText || "[图片]", likesCount: p.likes?.length || 0, commentsCount: p.comments?.length || 0, comments: (p.comments || []).map((c) => ({ commenter: c.commenterName, text: c.text })) }));

						backupData.data = {
							chats: transformedChats,
							npcs: transformedNpcs,
							worldBooks: transformedWorldBooks,
							worldBookCategories: worldBookCategoriesFromDB,
							userStickers: userStickersFromDB,
							stickerCategories: stickerCategoriesFromDB,
							apiConfig: apiConfigFromDB ? [apiConfigFromDB] : [],
							globalSettings: globalSettingsFromDB ? [globalSettingsFromDB] : [],
							qzoneSettings: [transformedQzoneSettings],
							qzonePosts: qzonePostsFromDB,
							qzoneAlbums: qzoneAlbumsFromDB,
							qzonePhotos: qzonePhotosFromDB,
							personaPresets: personaPresetsFromDB,
							memories: memoriesFromDB,
							apiPresets: apiPresetsFromDB,
							favorites: favoritesFromDB,
							doubanPosts: transformedDoubanPosts,
							callRecords: callRecordsFromDB,
						};

						const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: "application/json" });
						const url = URL.createObjectURL(blob);
						const link = document.createElement("a");
						const dateStr = new Date().toISOString().split("T")[0];
						link.href = url;
						link.download = `EPhone-Compatible-Backup-v330-${dateStr}.json`;
						document.body.appendChild(link);
						link.click();
						document.body.removeChild(link);
						URL.revokeObjectURL(url);

						await showCustomAlert("导出成功", "已成功生成兼容330版本的备份文件！现在你可以去330版本导入它了。");
					} catch (error) {
						console.error("兼容性导出失败:", error);
						await showCustomAlert("导出失败", `发生了一个错误: ${error.message}`);
					} finally {
						const modal = document.getElementById("advanced-transfer-modal");
						if (modal) {
							modal.classList.remove("visible");
						}
					}
				}

				/**
				 * 处理并导入来自330版本格式的备份文件
				 * @param {File} file - 用户选择的330格式的JSON文件
				 */
				async function importFrom330Format(file) {
					if (!file) return;

					const confirmed = await showCustomConfirm("严重警告！", "您正在从330版本导入数据，这将【完全覆盖】您当前的所有数据！此操作不可撤销！确定要继续吗？", { confirmButtonClass: "btn-danger" });
					if (!confirmed) return;

					await showCustomAlert("请稍候...", "正在解析并转换330版本的数据...");

					try {
						const text = await file.text();
						const importedData = JSON.parse(text);

						if (importedData.version !== 3) {
							throw new Error(`文件版本不匹配！需要版本3，但提供的是版本 ${importedData.version}。`);
						}

						const data330 = importedData.data;

						// 这是一个安全列表，确保我们只操作您数据库中存在的表
						const existingTables = ["chats", "worldBooks", "worldBookCategories", "userStickers", "userStickerCategories", "apiConfig", "globalSettings", "qzonePosts", "qzoneAlbums", "qzonePhotos", "qzoneSettings", "personaPresets", "memories", "apiPresets", "favorites", "musicLibrary", "callRecords", "customAvatarFrames", "themes", "bubbleStylePresets", "fontPresets", "homeScreenPresets", "weiboPosts", "forumGroups", "forumPosts", "forumComments", "forumCategories", "tarotReadings", "pomodoroSessions", "scriptKillScripts", "taobaoProducts", "taobaoOrders", "taobaoCart", "userWalletTransactions", "ludoQuestionBanks", "ludoQuestions", "datingScenes", "datingPresets", "datingSpriteGroups", "datingSprites", "datingHistory"];

						await db.transaction("rw", existingTables, async () => {
							for (const tableName of existingTables) {
								if (db[tableName]) {
									await db[tableName].clear();
								}
							}
							console.log("330导入：已清空共有的数据表，准备导入...");

							// 世界书导入逻辑【重大变更】
							// 我们不再合并，而是将330的每个词条拆分成独立的世界书条目
							if (data330.worldBooks && Array.isArray(data330.worldBooks)) {
								const allNewWorldBookEntries = []; // 创建一个新数组来收集所有拆分后的条目
								let entryCounter = 0; // 用于生成唯一ID

								// 遍历330的每一个"世界书合集"
								data330.worldBooks.forEach((book_330) => {
									if (Array.isArray(book_330.content)) {
										// 遍历合集中的每一个词条
										book_330.content.forEach((entry) => {
											entryCounter++;

											// 为每个词条生成新的独立世界书名称
											// 优先使用词条的 `keys` 作为名称，其次是 `comment`，最后是自动生成
											let newName = `导入条目 ${entryCounter}`;
											if (entry.keys && entry.keys.length > 0) {
												newName = entry.keys.join(", "); // 用关键词作为新名称
											} else if (entry.comment) {
												newName = entry.comment; // 其次用备注作为新名称
											}

											// 为每个词条创建一个全新的、独立的世界书对象
											const newBookEntry = {
												id: `imported_wb_${Date.now()}_${entryCounter}`, // 生成唯一ID
												name: newName,
												content: entry.content || "", // 内容就是词条的内容
												categoryId: book_330.categoryId || 0, // 继承原合集的分类ID
												isEnabled: entry.enabled !== false, // 继承启用状态，默认为true
											};

											// 将这个全新的独立条目添加到我们的收集中
											allNewWorldBookEntries.push(newBookEntry);
										});
									}
								});

								// 一次性将所有拆分后的新条目写入数据库
								await db.worldBooks.bulkPut(allNewWorldBookEntries);
								console.log(`330导入：成功"拆分"并导入 ${allNewWorldBookEntries.length} 条独立世界书条目。`);
							}
							// 分类信息保持不变，正常导入
							if (data330.worldBookCategories) await db.worldBookCategories.bulkPut(data330.worldBookCategories);

							// 转换并导入【聊天和NPC】
							if (data330.chats && Array.isArray(data330.chats)) {
								const chatsToImport = [...data330.chats];
								const npcs = data330.npcs || [];
								chatsToImport.forEach((chat) => {
									if (!chat.isGroup) {
										chat.npcLibrary = [];
										npcs.forEach((npc) => {
											if (npc.associatedWith && npc.associatedWith.includes(chat.id)) {
												chat.npcLibrary.push({ id: npc.id, name: npc.name, persona: npc.persona, avatar: npc.avatar });
											}
										});
									}
								});
								await db.chats.bulkPut(chatsToImport);
								console.log(`330导入：成功转换并导入 ${chatsToImport.length} 个聊天。`);
							}

							// 转换并导入【豆瓣/圈子】数据
							if (data330.doubanPosts && Array.isArray(data330.doubanPosts)) {
								const groupMap = new Map();
								for (const post of data330.doubanPosts) {
									let groupId;
									if (groupMap.has(post.groupName)) {
										groupId = groupMap.get(post.groupName);
									} else {
										const newGroup = { name: post.groupName, description: "从330导入的小组", icon: "📖" };
										groupId = await db.forumGroups.add(newGroup);
										groupMap.set(post.groupName, groupId);
									}
									await db.forumPosts.add({ id: post.id, groupId: groupId, title: post.postTitle, content: post.content, authorNickname: post.authorName, timestamp: post.timestamp, likes: post.likesCount || 0 });
									if (post.comments && post.comments.length > 0) {
										const commentsToSave = post.comments.map((c) => ({ postId: post.id, author: c.commenter, content: c.text, timestamp: Date.now() }));
										await db.forumComments.bulkAdd(commentsToSave);
									}
								}
								console.log(`330导入：成功转换并导入 ${data330.doubanPosts.length} 条圈子帖子。`);
							}

							// 转换并导入单对象设置
							if (data330.apiConfig?.[0]) await db.apiConfig.put(data330.apiConfig[0]);
							if (data330.globalSettings?.[0]) await db.globalSettings.put(data330.globalSettings[0]);
							if (data330.qzoneSettings?.[0]) await db.qzoneSettings.put(data330.qzoneSettings[0]);
							if (data330.musicLibrary?.[0]) await db.musicLibrary.put(data330.musicLibrary[0]);

							// 直接导入其他结构相同的【共有】数据表
							const directImportTables = ["userStickers", "personaPresets", "qzonePosts", "qzoneAlbums", "qzonePhotos", "favorites", "memories", "callRecords", "apiPresets", "stickerCategories", "customAvatarFrames"];
							for (const tableName of directImportTables) {
								if (data330[tableName] && Array.isArray(data330[tableName]) && db[tableName]) {
									await db[tableName].bulkPut(data330[tableName]);
									console.log(`330导入：成功导入 ${data330[tableName].length} 条数据到 ${tableName}。`);
								}
							}
						});

						// 导入成功后刷新页面
						await showCustomAlert("导入成功", "来自330版本的数据已成功导入！应用即将刷新以应用所有更改。");
						setTimeout(() => {
							window.location.reload();
						}, 1500);
					} catch (error) {
						console.error("从330格式导入失败:", error);
						await showCustomAlert("导入失败", `文件格式不正确或数据已损坏: ${error.message}`);
					}
				}

				/**
				 * 压缩图片至指定质量并返回Base64，同时跳过GIF
				 * @param {string} base64Str - 原始图片的Base64字符串 (data:...)
				 * @param {number} quality - 压缩质量 (0.1 - 1.0)
				 * @returns {Promise<string>} - 返回压缩后的JPEG格式的Base64字符串，或原始的GIF/PNG字符串
				 */
				function compressImage(base64Str, quality) {
					return new Promise((resolve, reject) => {
						// 添加对 GIF 的判断！
						// 如果是 GIF，或者质量设置为1.0（不压缩），直接返回原图，不进行任何处理。
						if (base64Str.startsWith("data:image/gif") || quality >= 1.0 || !base64Str.startsWith("data:image")) {
							resolve(base64Str);
							return;
						}

						const img = new Image();
						img.src = base64Str;

						img.onload = () => {
							const canvas = document.createElement("canvas");
							const ctx = canvas.getContext("2d");
							canvas.width = img.width;
							canvas.height = img.height;
							ctx.drawImage(img, 0, 0);

							// 依然输出为JPEG，但我们已经提前排除了GIF
							// 这确保了 PNG 和其他静态图能被正确压缩。
							const compressedBase64 = canvas.toDataURL("image/jpeg", quality);
							resolve(compressedBase64);
						};

						img.onerror = (err) => {
							console.error("图片加载失败，无法压缩:", err);
							reject(new Error("图片加载失败，无法压缩"));
						};
					});
				}

				/**
				 * 通用文件上传并压缩处理函数
				 * @param {File} file - 用户选择的文件
				 * @returns {Promise<string>} - 返回压缩后的Base64字符串
				 */
				async function handleImageUploadAndCompress(file) {
					const base64Url = await new Promise((resolve, reject) => {
						const reader = new FileReader();
						reader.onload = () => resolve(reader.result);
						reader.onerror = reject;
						reader.readAsDataURL(file);
					});

					const quality = state.globalSettings.imageCompressionQuality || 0.7;
					console.log(`准备压缩图片，质量: ${quality}`);

					const compressedBase64 = await compressImage(base64Url, quality);
					console.log(`图片压缩完成。原始大小: ${base64Url.length}, 压缩后大小: ${compressedBase64.length}`);

					return compressedBase64;
				}

				/**
				 * 计算Base64字符串的近似文件大小
				 * @param {string} base64Str - Base64字符串 (可以带'data:...'前缀)
				 * @returns {number} - 字节大小
				 */
				function getBase64Size(base64Str) {
					if (!base64Str || typeof base64Str !== "string" || !base64Str.startsWith("data:image")) return 0;
					const base64 = base64Str.split(",")[1] || base64Str;
					const padding = base64.endsWith("==") ? 2 : base64.endsWith("=") ? 1 : 0;
					return (base64.length * 3) / 4 - padding;
				}

				/**
				 * 将字节数格式化为易读的字符串 (KB, MB, GB)
				 * @param {number} bytes - 字节数
				 * @returns {string} - 格式化后的字符串
				 */
				function formatBytes(bytes) {
					if (bytes === 0) return "0 Bytes";
					const k = 1024;
					const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
					const i = Math.floor(Math.log(bytes) / Math.log(k));
					return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
				}

				/**
				 * 计算并显示数据库中所有图片的总大小，并返回数值
				 * @returns {Promise<number>} - 返回总字节数
				 */
				async function calculateTotalImageSize() {
					const displayEl = document.getElementById("image-data-size-display");
					displayEl.textContent = "正在计算中...";

					let totalSize = 0;
					const processedUrls = new Set();

					const calculateSize = (url) => {
						if (!url || typeof url !== "string" || !url.startsWith("data:image") || processedUrls.has(url)) {
							return 0;
						}
						const size = getBase64Size(url);
						processedUrls.add(url);
						return size;
					};

					try {
						const allTables = db.tables.map((table) => table.name);
						for (const tableName of allTables) {
							try {
								const items = await db[tableName].toArray();
								for (const item of items) {
									const findImagesRecursive = (obj) => {
										for (const key in obj) {
											if (typeof obj[key] === "string") {
												totalSize += calculateSize(obj[key]);
											} else if (typeof obj[key] === "object" && obj[key] !== null) {
												findImagesRecursive(obj[key]);
											}
										}
									};
									findImagesRecursive(item);
								}
							} catch (e) {
								console.warn(`扫描表 ${tableName} 出错:`, e);
							}
						}

						displayEl.textContent = `当前图片数据总量约: ${formatBytes(totalSize)}`;
						return totalSize; // 返回计算出的总大小
					} catch (error) {
						console.error("计算图片大小时出错:", error);
						displayEl.textContent = "计算失败，请查看控制台。";
						return 0;
					}
				}

				/**
				 * 一键压缩数据库中所有图片的核心函数
				 */
				async function compressAllImagesInDB() {
					const confirmed = await showCustomConfirm("高风险操作确认", "此操作将扫描并【永久性地】压缩数据库中的【所有静态图片（PNG/JPG等）】。<br><br>【GIF动图会被自动跳过，不会被压缩】。<br><br>压缩是不可逆的，建议在操作前先【导出数据】进行备份！<br><br>确定要继续吗？", { confirmButtonClass: "btn-danger" });

					if (!confirmed) return;

					const loadingOverlay = document.getElementById("generation-overlay");
					const loadingText = loadingOverlay.querySelector("p");
					loadingText.textContent = "正在全力压缩图片，请耐心等待...";
					loadingOverlay.classList.add("visible");

					try {
						const quality = parseFloat(document.getElementById("image-quality-slider").value) || 0.7;
						const originalTotalSize = await calculateTotalImageSize();
						let itemsProcessed = 0;
						let compressedCount = 0;

						const findAndCompressImagesInObject = async (obj) => {
							let hasCompressed = false;
							for (const key in obj) {
								if (typeof obj[key] === "string" && obj[key].startsWith("data:image")) {
									const originalUrl = obj[key];
									const compressedUrl = await compressImage(originalUrl, quality);
									if (originalUrl !== compressedUrl) {
										obj[key] = compressedUrl;
										hasCompressed = true;
										compressedCount++; // 记录压缩了多少张图片
									}
								} else if (typeof obj[key] === "object" && obj[key] !== null) {
									if (await findAndCompressImagesInObject(obj[key])) {
										hasCompressed = true;
									}
								}
							}
							return hasCompressed;
						};

						const allTables = db.tables.map((table) => table.name);
						for (const tableName of allTables) {
							loadingText.textContent = `正在扫描表: ${tableName}...`;
							const itemsToUpdate = [];
							const allItems = await db[tableName].toArray();

							for (const item of allItems) {
								if (await findAndCompressImagesInObject(item)) {
									itemsToUpdate.push(item);
								}
								itemsProcessed++;
								if (itemsProcessed % 20 === 0) {
									loadingText.textContent = `已处理 ${itemsProcessed} 条数据... 压缩了 ${compressedCount} 张图片...`;
								}
							}

							if (itemsToUpdate.length > 0) {
								loadingText.textContent = `正在保存 ${tableName} 的压缩结果...`;
								await db[tableName].bulkPut(itemsToUpdate);
								console.log(`表 ${tableName} 中有 ${itemsToUpdate.length} 条记录的图片被压缩。`);
							}
						}

						// 先隐藏加载动画，再去弹窗
						loadingOverlay.classList.remove("visible");

						const newTotalSize = await calculateTotalImageSize();
						const savedSize = originalTotalSize - newTotalSize;

						await showCustomAlert("压缩完成！", `操作成功！\n原始大小: ${formatBytes(originalTotalSize)}\n压缩后大小: ${formatBytes(newTotalSize)}\n成功为您节省了 ${formatBytes(savedSize)} 的空间！\n\n应用即将刷新以应用所有更改。`);

						setTimeout(() => window.location.reload(), 2000);
					} catch (error) {
						// 出错时也要确保加载动画被隐藏
						loadingOverlay.classList.remove("visible");
						console.error("压缩全部图片时出错:", error);
						await showCustomAlert("压缩失败", `发生了一个错误: ${error.message}`);
					}
				}

				/**
				 * 流式导出函数 (大数据专用)
				 * 原理：不再一次性读取所有数据库表到内存，而是逐个表读取、写入，
				 * 利用 ReadableStream 和 Response 流式传输给用户，从而极大降低内存占用。
				 */
				async function exportDataStream() {
					await showCustomAlert("请稍候...", "正在准备流式导出，这可能需要一些时间，但不会使浏览器崩溃。");

					// 定义所有需要备份的数据库表名
					const tablesToExport = ["chats", "apiConfig", "globalSettings", "userStickers", "charStickers", "worldBooks", "musicLibrary", "personaPresets", "qzoneSettings", "qzonePosts", "qzoneAlbums", "qzonePhotos", "favorites", "qzoneGroups", "memories", "worldBookCategories", "callRecords", "customAvatarFrames", "themes", "apiPresets", "bubbleStylePresets", "fontPresets", "homeScreenPresets", "weiboPosts", "forumGroups", "forumPosts", "forumComments", "forumCategories", "tarotReadings", "pomodoroSessions", "scriptKillScripts", "taobaoProducts", "taobaoOrders", "taobaoCart", "userWalletTransactions", "userStickerCategories", "datingScenes", "datingPresets", "datingSpriteGroups", "datingSprites", "datingHistory"];

					const stream = new ReadableStream({
						async start(controller) {
							const encoder = new TextEncoder();

							// 写入JSON文件的开头
							controller.enqueue(encoder.encode("{\n"));

							// 添加版本和时间戳元数据
							const metaData = `"version": 1,\n"timestamp": ${Date.now()},\n`;
							controller.enqueue(encoder.encode(metaData));

							// 逐个处理数据库表
							for (let i = 0; i < tablesToExport.length; i++) {
								const tableName = tablesToExport[i];
								console.log(`流式导出：正在处理表 ${tableName}...`);

								try {
									const tableData = await db[tableName].toArray();
									const jsonString = JSON.stringify(tableData);

									// 写入 "tableName": [...]
									controller.enqueue(encoder.encode(`"${tableName}": ${jsonString}`));

									// 如果不是最后一个表，就加上逗号和换行符
									if (i < tablesToExport.length - 1) {
										controller.enqueue(encoder.encode(",\n"));
									} else {
										controller.enqueue(encoder.encode("\n"));
									}
								} catch (e) {
									console.error(`流式导出时，处理表 ${tableName} 失败:`, e);
									// 即使某个表失败，也继续尝试下一个
								}
							}

							// 写入JSON文件的结尾
							controller.enqueue(encoder.encode("}"));

							// 通知流已经结束
							controller.close();
							console.log("流式导出：所有数据写入完成。");
						},
					});

					// 使用 Response 将流包装成可下载的文件
					const response = new Response(stream, {
						headers: { "Content-Type": "application/json" },
					});

					// 创建并触发下载链接
					const url = URL.createObjectURL(await response.blob());
					const link = document.createElement("a");
					link.href = url;
					link.download = `EPhone-Stream-Backup-${new Date().toISOString().split("T")[0]}.json`;
					document.body.appendChild(link);
					link.click();
					document.body.removeChild(link);
					URL.revokeObjectURL(url);

					// 关闭"请稍候"的弹窗
					hideCustomModal();
				}

				/**
				 * 恢复所有App名称为默认值
				 */
				async function resetAppNamesToDefault() {
					// 弹出确认框，防止误操作
					const confirmed = await showCustomConfirm("恢复默认名称", "确定要将所有App的名称恢复为默认设置吗？此操作不可撤销。", { confirmButtonClass: "btn-danger" });

					if (confirmed) {
						// 清空存储自定义名称的对象
						state.globalSettings.appLabels = {};

						// 将更改保存到数据库
						await db.globalSettings.put(state.globalSettings);

						// 立即应用更改到UI
						applyAppLabels(); // 更新主屏幕上App的显示名称
						renderAppNameSettings(); // 刷新外观设置页面的输入框，显示回默认名

						// 给出成功提示
						await showCustomAlert("操作成功", "所有App名称已恢复为默认。");
					}
				}

				/**
				 * 将一个新创建的帖子元素添加到列表的顶部
				 * @param {object} post - 包含ID的完整帖子对象
				 */
				function prependNewPostElement(post) {
					const listEl = document.getElementById("group-post-list");

					// 检查列表当前是否显示"空空如也"的消息，如果是，就清空它
					const emptyMessage = listEl.querySelector("p");
					if (emptyMessage && (emptyMessage.textContent.includes("还没有帖子") || emptyMessage.textContent.includes("没有找到符合"))) {
						listEl.innerHTML = "";
					}

					// 创建新帖子的DOM元素（这段代码与renderGroupPosts中的逻辑几乎一样）
					const commentCount = 0; // 新帖子的评论数永远是0
					const item = document.createElement("div");
					item.className = "forum-post-item";
					item.dataset.postId = post.id;

					let categoriesHtml = "";
					if (post.categories && post.categories.length > 0) {
						categoriesHtml = `
                    <div class="category-tag-container">
                        ${post.categories.map((cat) => `<span class="category-tag">#${cat}</span>`).join("")}
                    </div>
                    `;
					}

					item.innerHTML = `
                    <div class="post-item-title">${post.title}</div>
                    ${categoriesHtml}
                    <div class="post-item-meta">
                        <span>作者: ${post.author}</span>
                        <span>评论: ${commentCount}</span>
                    </div>
                    <button class="forum-post-delete-btn" title="删除帖子">×</button>
                `;

					// 使用 prepend() 将新帖子添加到列表的【最前面】
					listEl.prepend(item);
				}

				/**
				 * 处理用户点击"发布"按钮，创建新帖子的逻辑
				 */
				async function handleCreateForumPost() {
					const title = document.getElementById("forum-post-title-input").value.trim();
					const content = document.getElementById("post-public-text").value.trim();
					if (!title || !content) {
						alert("帖子标题和内容都不能为空哦！");
						return;
					}

					const categoryInput = document.getElementById("forum-post-category-input").value.trim();
					const categories = categoryInput ? categoryInput.match(/#(\S+)/g)?.map((tag) => tag.substring(1)) || [] : [];

					const newPost = {
						groupId: activeGroupId,
						title: title,
						content: content,
						author: state.qzoneSettings.nickname || "我",
						timestamp: Date.now(),
						categories: categories,
					};

					// 将数据库 add() 操作返回的【ID】捕获到一个变量中。
					const postId = await db.forumPosts.add(newPost);
					// 将这个ID赋值回我们的 newPost 对象，现在它是一个完整的、包含ID的对象了。
					newPost.id = postId;

					// 关闭发帖弹窗。
					document.getElementById("create-post-modal").classList.remove("visible");

					// 不再调用可能出错的 renderGroupPosts，而是调用我们新的、可靠的 prependNewPostElement 函数。
					prependNewPostElement(newPost);

					// 给出成功提示。
					alert("帖子发布成功！");
				}

				let activeGroupId = null; // 记录当前打开的小组ID

				/**
				 * 渲染小组内的帖子列表及其分类（已支持筛选）
				 */
				async function renderGroupPosts(groupId) {
					const listEl = document.getElementById("group-post-list");
					const allPosts = await db.forumPosts.where("groupId").equals(groupId).reverse().sortBy("timestamp");
					listEl.innerHTML = "";

					const groupFilters = activeForumFilters.group[groupId];
					let postsToRender = allPosts;

					if (groupFilters && groupFilters.length > 0) {
						postsToRender = allPosts.filter((post) => post.categories && post.categories.some((cat) => groupFilters.includes(cat)));
					}

					if (postsToRender.length === 0) {
						const message = groupFilters && groupFilters.length > 0 ? "没有找到符合筛选条件的帖子哦" : "这个小组还没有帖子哦";
						listEl.innerHTML = `<p style="text-align:center; color: #8a8a8a; padding: 50px 0;">${message}</p>`;
						return;
					}

					for (const post of postsToRender) {
						// 在使用 post.id 查询前，先用 parseInt() 确保它一定是数字类型。
						const commentCount = await db.forumComments.where("postId").equals(parseInt(post.id)).count();

						const item = document.createElement("div");
						item.className = "forum-post-item";
						item.dataset.postId = post.id;

						let categoriesHtml = "";
						if (post.categories && post.categories.length > 0) {
							categoriesHtml = `
                                <div class="category-tag-container">
                                    ${post.categories.map((cat) => `<span class="category-tag">#${cat}</span>`).join("")}
                                </div>
                            `;
						}

						item.innerHTML = `
                            <div class="post-item-title">${post.title}</div>
                            ${categoriesHtml}
                            <div class="post-item-meta">
                                <span>作者: ${post.author}</span>
                                <span>评论: ${commentCount}</span>
                            </div>
                            <button class="forum-post-delete-btn" title="删除帖子">×</button>
                        `;
						listEl.appendChild(item);
					}

					// 更新筛选按钮状态
					const filterBtn = document.getElementById("group-filter-btn");
					if (filterBtn) {
						filterBtn.classList.toggle("active", groupFilters && groupFilters.length > 0);
					}
				}

				// 亲密关系徽章阈值配置
				const SYMBOL_THRESHOLDS = [
					{ id: "first_heartbeat", level: 100, symbol: "https://i.postimg.cc/DZSsNzMB/5BF06FFB38AAF2B394F89F6270D328D5.png", name: "初识心动", description: "心跳是故事的开始。" },
					{ id: "shining_star", level: 300, symbol: "https://i.postimg.cc/L47gJRb3/7227080E4BF5950D1B182043D1F734DB.png", name: "星光闪烁", description: "你们的关系像星光一样开始闪耀。" },
					{ id: "burning_passion", level: 700, symbol: "https://i.postimg.cc/yNQcnRvT/BD0C0CC3C6692D736014BACE73C07F8E.png", name: "热情如火", description: "每一次互动都让感情升温。" },
					{ id: "only_crown", level: 1500, symbol: "https://i.postimg.cc/B6jDzvVh/92DD1E30EFEEC589E3BE0FFB630F8B4E.png", name: "唯一王冠", description: "在彼此的世界里，对方是独一无二的存在。" },
					{ id: "eternal_diamond", level: 5000, symbol: "https://i.postimg.cc/C1RD2KQc/B0E2B3034728540DA4198357D5B8131C.png", name: "永恒之钻", description: "你们的关系如钻石般坚固而璀璨。" },
				];

				/**
				 * 计算用户与角色的亲密值
				 * @param {object} chat - 聊天对象
				 * @returns {number} - 计算出的亲密值分数
				 */
				function calculateIntimacy(chat) {
					if (!chat || !chat.settings.streak) return 0;

					// 基础分：连续聊天天数
					const streakDays = chat.settings.streak.currentDays || 0;
					const streakScore = streakDays * 15;

					// 互动分：累计消息总数
					const stats = chat.interactionStats || {};
					const totalMessages = Object.values(stats).reduce((sum, count) => sum + count, 0);
					const messageScore = totalMessages * 0.2;

					const intimacy = streakScore + messageScore;
					return Math.floor(intimacy);
				}

				/**
				 * 检查并解锁新的亲密徽章
				 * @param {object} chat - 聊天对象
				 * @param {number} intimacyValue - 当前的亲密值
				 * @returns {Promise<boolean>} - 如果有新徽章解锁，返回true
				 */
				async function checkAndUnlockSymbols(chat, intimacyValue) {
					let newUnlock = false;
					if (!chat.unlockedSymbols) chat.unlockedSymbols = [];

					SYMBOL_THRESHOLDS.forEach((threshold) => {
						// 检查亲密值是否达到解锁条件且徽章未被解锁过
						if (intimacyValue >= threshold.level && !chat.unlockedSymbols.some((s) => s.symbol === threshold.symbol)) {
							chat.unlockedSymbols.push({
								symbol: threshold.symbol,
								name: threshold.name,
								unlockedAt: Date.now(),
							});
							newUnlock = true;
							console.log(`徽章解锁！角色: ${chat.name}, 徽章: ${threshold.name}`);
						}
					});

					// 如果有新解锁的徽章，更新数据库并显示通知
					if (newUnlock) {
						await db.chats.put(chat);
						const latestUnlock = chat.unlockedSymbols[chat.unlockedSymbols.length - 1];
						await showCustomAlert("新徽章已解锁！", `恭喜你和“${chat.name}”解锁了新的亲密徽章：${latestUnlock.name}`);
					}
					return newUnlock;
				}

				/**
				 * 打开亲密关系面板
				 * @param {string} chatId - 聊天ID
				 */
				async function openIntimacyPanel(chatId) {
					const chat = state.chats[chatId];
					if (!chat) return;

					// 计算亲密值并检查解锁徽章
					const intimacyValue = calculateIntimacy(chat);
					await checkAndUnlockSymbols(chat, intimacyValue);

					// 更新UI显示数据
					document.getElementById("intimacy-score-display").textContent = intimacyValue;
					const today = new Date().toISOString().split("T")[0];
					const todayMsgs = chat.interactionStats?.[today] || 0;
					const totalMsgs = Object.values(chat.interactionStats || {}).reduce((sum, count) => sum + count, 0);
					document.getElementById("intimacy-streak-days").textContent = `${chat.settings.streak?.currentDays || 0} 天`;
					document.getElementById("intimacy-today-msgs").textContent = `${todayMsgs} 条`;
					document.getElementById("intimacy-total-msgs").textContent = `${totalMsgs} 条`;

					// 渲染可佩戴的徽章列表
					const symbolListContainer = document.getElementById("symbol-list-container");
					symbolListContainer.innerHTML = "";

					// 添加"不佩戴"选项
					const noneItem = document.createElement("div");
					noneItem.className = "symbol-item unlocked";
					if (!chat.settings.selectedIntimacyBadge) {
						noneItem.classList.add("selected");
					}
					noneItem.innerHTML = `<div class="symbol-icon no-badge">🚫</div><div class="symbol-name">不佩戴</div>`;
					noneItem.onclick = () => selectIntimacyBadge(chatId, "");
					symbolListContainer.appendChild(noneItem);

					// 渲染所有徽章
					SYMBOL_THRESHOLDS.forEach((threshold) => {
						const isUnlocked = intimacyValue >= threshold.level;
						const isSelected = chat.settings.selectedIntimacyBadge === threshold.symbol;

						const item = document.createElement("div");
						item.className = `symbol-item ${isUnlocked ? "unlocked" : ""} ${isSelected ? "selected" : ""}`;

						item.innerHTML = `
                            <div class="symbol-icon ${!isUnlocked ? "not-unlocked" : ""}">
                                <img src="${threshold.symbol}" alt="${threshold.name}">
                            </div>
                            <div class="symbol-name">${threshold.name}</div>
                            <div class="symbol-level">${isUnlocked ? "已解锁" : `${threshold.level}分解锁`}</div>
                        `;

						if (isUnlocked) {
							item.onclick = () => selectIntimacyBadge(chatId, threshold.symbol);
						}

						symbolListContainer.appendChild(item);
					});

					// 渲染解锁记录
					const recordsContainer = document.getElementById("unlocked-symbols-record");
					recordsContainer.innerHTML = "";
					if (chat.unlockedSymbols && chat.unlockedSymbols.length > 0) {
						const sortedRecords = [...chat.unlockedSymbols].sort((a, b) => b.unlockedAt - a.unlockedAt);
						sortedRecords.forEach((record) => {
							const recordItem = document.createElement("div");
							recordItem.className = "record-item";
							recordItem.innerHTML = `<span class="symbol"><img src="${record.symbol}" style="height:1em; vertical-align:middle;"></span><span>${record.name}</span><span class="date">${new Date(record.unlockedAt).toLocaleDateString()}</span>`;
							recordsContainer.appendChild(recordItem);
						});
					} else {
						recordsContainer.innerHTML = '<p style="text-align:center; color:#999; font-size:13px;">暂无已解锁的徽章</p>';
					}

					// 显示面板
					document.getElementById("intimacy-panel").classList.add("visible");
				}

				/**
				 * 选择并佩戴亲密徽章
				 * @param {string} chatId - 角色ID
				 * @param {string} symbol - 要佩戴的徽章符号，或''表示不佩戴
				 */
				async function selectIntimacyBadge(chatId, symbol) {
					const chat = state.chats[chatId];
					if (!chat) return;

					// 更新选择并保存到数据库
					chat.settings.selectedIntimacyBadge = symbol;
					await db.chats.put(chat);

					// 重新渲染面板和聊天列表
					await openIntimacyPanel(chatId);
					await renderChatList();
				}

				/**
				 * 为指定聊天的今日消息数加1
				 * @param {string} chatId - 聊天ID
				 */
				async function incrementMessageCount(chatId) {
					const chat = state.chats[chatId];
					if (!chat || chat.isGroup) return;

					const today = new Date().toISOString().split("T")[0];

					if (!chat.interactionStats) {
						chat.interactionStats = {};
					}

					chat.interactionStats[today] = (chat.interactionStats[today] || 0) + 1;

					// 保存更新到数据库
					await db.chats.put(chat);
				}

				/**
				 * 获取设备唯一标识码
				 * @returns {string} - 设备码
				 */
				function getDeviceCode() {
					const deviceIdKey = "ephone-device-code";
					let deviceId = localStorage.getItem(deviceIdKey);
					if (!deviceId) {
						deviceId = crypto.randomUUID();
						localStorage.setItem(deviceIdKey, deviceId);
					}
					return deviceId;
				}

				/**
				 * 根据设备码生成PIN码
				 * @param {string} deviceCode - 设备码
				 * @returns {string} - 6位PIN码
				 */
				function generatePinFromDeviceCode(deviceCode) {
					if (!deviceCode || deviceCode.length < 6) return "INVALID";
					return deviceCode.split("").reverse().join("").substring(0, 6).toUpperCase();
				}

				/**
				 * 清空所有好友动态
				 */
				async function clearAllQzonePosts() {
					const confirmed = await showCustomConfirm("确认清空", "此操作将永久删除所有好友动态（不包括微博和圈子），且无法恢复。确定要继续吗？", { confirmButtonClass: "btn-danger" });

					if (!confirmed) {
						return;
					}

					try {
						// 清空动态数据表
						await db.qzonePosts.clear();
						console.log("`qzonePosts` table has been cleared.");

						// 清理角色历史记录中的动态通知
						const allChats = Object.values(state.chats);
						const chatsToUpdate = [];
						for (const chat of allChats) {
							const originalHistoryLength = chat.history.length;
							chat.history = chat.history.filter((msg) => !(msg.role === "system" && msg.content && msg.content.includes("发布了")));
							if (chat.history.length < originalHistoryLength) {
								chatsToUpdate.push(chat);
							}
						}
						if (chatsToUpdate.length > 0) {
							await db.chats.bulkPut(chatsToUpdate);
							console.log(`已从 ${chatsToUpdate.length} 个角色的历史记录中移除动态通知。`);
						}

						// 重新渲染动态列表
						await renderQzonePosts();

						alert("所有好友动态已清空！");
					} catch (error) {
						console.error("清空好友动态时出错:", error);
						await showCustomAlert("操作失败", `清空动态时发生错误: ${error.message}`);
					}
				}

				/**
				 * 初始化应用
				 */
				async function init() {
					// 设置主题
					const savedTheme = localStorage.getItem("ephone-theme") || "light";
					applyTheme(savedTheme);

					// 创建自定义气泡样式标签
					const customBubbleStyleTag = document.createElement("style");
					customBubbleStyleTag.id = "custom-bubble-style";
					document.head.appendChild(customBubbleStyleTag);

					const previewBubbleStyleTag = document.createElement("style");
					previewBubbleStyleTag.id = "preview-bubble-style";
					document.head.appendChild(previewBubbleStyleTag);

					// 清除自定义气泡样式
					applyScopedCss("", "#chat-messages", "custom-bubble-style");
					applyScopedCss("", "#settings-preview-area", "preview-bubble-style");

					window.showScreen = showScreen;
					window.openLoversSpaceFromCard = openLoversSpaceFromCard;
					window.renderChatListProxy = renderChatList;
					window.renderApiSettingsProxy = renderApiSettings;
					window.renderWallpaperScreenProxy = renderWallpaperScreen;
					window.renderWorldBookScreenProxy = renderWorldBookScreen;

					await loadAllDataFromDB();

					// 应用自定义CSS主题
					if (state.globalSettings.activeCustomCss) {
						applyThemeCss(state.globalSettings.activeCustomCss);
					} else if (state.globalSettings.activeThemeId) {
						const activeTheme = await db.themes.get(state.globalSettings.activeThemeId);
						if (activeTheme) {
							console.log(`正在应用已保存的主题: "${activeTheme.name}"`);
							applyThemeCss(activeTheme.css);
						}
					}

					// 设置默认通知音
					if (typeof state.globalSettings.notificationSoundUrl === "undefined") {
						state.globalSettings.notificationSoundUrl = "https://files.catbox.moe/k369mf.mp3";
					}

					// 初始化主页头像框
					renderHomeScreenProfileFrame();

					// 应用图标和小组件文本颜色
					applyHomeIconWidgetTextColor(state.globalSettings.homeIconWidgetTextColor);

					// 加载字体预设
					await loadAllFontPresetsOnStartup();

					// 迁移默认问题数据
					await migrateDefaultLudoQuestions();

					// 添加默认暗色主题
					await addDefaultDarkModeThemeIfNeeded();

					// 应用小组件数据
					applyWidgetData();

					if (state.globalSettings.homeIconWidgetTextColor) {
						applyHomeIconWidgetTextColor(state.globalSettings.homeIconWidgetTextColor);
					}

					// 应用字体阴影设置
					document.getElementById("phone-screen").classList.toggle("no-home-font-shadow", !!state.globalSettings.removeHomeFontShadow);

					// 初始化未读动态计数
					const storedCount = parseInt(localStorage.getItem("unreadPostsCount")) || 0;
					updateUnreadIndicator(storedCount);

					if (state.globalSettings && state.globalSettings.fontUrl) {
						applyCustomFont(state.globalSettings.fontUrl);
					}

					// 应用已保存的主题
					if (state.globalSettings.activeThemeId) {
						const activeTheme = await db.themes.get(state.globalSettings.activeThemeId);
						if (activeTheme) {
							console.log(`正在应用已保存的主题: "${activeTheme.name}"`);
							applyThemeCss(activeTheme.css);
						}
					}

					// 初始化时钟和电池管理
					updateClock();
					setInterval(updateClock, 1000 * 30);
					applyGlobalWallpaper();
					initBatteryManager();

					// 应用应用图标和标签
					applyAppIcons();
					applyAppLabels();

					// 初始化可拖动歌词栏
					initDraggableLyricsBar();

					// 绑定事件监听器
					document.getElementById("check-phone-btn").addEventListener("click", openCharacterSelectionScreen);

					document.getElementById("character-selection-list").addEventListener("click", (e) => {
						const item = e.target.closest(".character-select-item");
						if (item && item.dataset.chatId) {
							openCharacterPhone(item.dataset.chatId);
						}
					});

					// 角色手机数据生成和清空
					document.getElementById("generate-character-data-btn").addEventListener("click", generateCharacterPhoneData);
					document.getElementById("clear-character-data-btn").addEventListener("click", clearCharacterPhoneData);

					// 角色手机页面事件处理
					document.getElementById("character-phone-container").addEventListener("click", (e) => {
						const backBtn = e.target.closest(".back-btn");
						const actionBtn = e.target.closest(".action-btn");

						// 处理返回按钮
						if (backBtn) {
							if (backBtn.dataset.targetPage) {
								showCharacterPhonePage(backBtn.dataset.targetPage);
							} else if (backBtn.dataset.targetScreen) {
								showScreen(backBtn.dataset.targetScreen);
							}
							return;
						}

						// 处理操作按钮
						if (actionBtn) {
							switch (actionBtn.id) {
								// 生成数据按钮
								case "generate-chat-message-btn":
									generateCharacterPhoneDataSegment("chats");
									break;
								case "generate-cart-item-btn":
									generateCharacterPhoneDataSegment("shoppingCart");
									break;
								case "generate-memo-btn":
									generateCharacterPhoneDataSegment("memos");
									break;
								case "generate-browser-history-btn":
									generateCharacterPhoneDataSegment("browserHistory");
									break;
								case "generate-album-photo-btn":
									generateCharacterPhoneDataSegment("photoAlbum");
									break;
								case "generate-bank-transaction-btn":
									generateCharacterPhoneDataSegment("bank");
									break;
								case "generate-trajectory-btn":
									generateCharacterPhoneDataSegment("trajectory");
									break;
								case "generate-app-usage-btn":
									generateCharacterPhoneDataSegment("appUsage");
									break;
								case "generate-diary-entry-btn":
									generateCharacterPhoneDataSegment("diary");
									break;

								// 清空数据按钮
								case "clear-npc-chats-btn":
									handleClearCharacterDataSegment("chats");
									break;
								case "clear-cart-items-btn":
									handleClearCharacterDataSegment("shoppingCart");
									break;
								case "clear-memos-btn":
									handleClearCharacterDataSegment("memos");
									break;
								case "clear-browser-history-btn":
									handleClearCharacterDataSegment("browserHistory");
									break;
								case "clear-album-photos-btn":
									handleClearCharacterDataSegment("photoAlbum");
									break;
								case "clear-bank-transactions-btn":
									handleClearCharacterDataSegment("bank.transactions");
									break;
								case "clear-trajectory-btn":
									handleClearCharacterDataSegment("trajectory");
									break;
								case "clear-app-usage-btn":
									handleClearCharacterDataSegment("appUsage");
									break;
								case "clear-diary-entries-btn":
									handleClearCharacterDataSegment("diary");
									break;
							}
						}
					});

					// 主屏幕预设功能事件绑定
					document.getElementById("home-preset-selector").addEventListener("change", handleHomePresetSelection);
					document.getElementById("apply-home-preset-btn").addEventListener("click", applySelectedHomeScreenPreset);
					document.getElementById("save-home-preset-btn").addEventListener("click", saveCurrentHomeScreenAsPreset);
					document.getElementById("update-home-preset-btn").addEventListener("click", updateSelectedHomeScreenPreset);
					document.getElementById("rename-home-preset-btn").addEventListener("click", renameSelectedHomeScreenPreset);
					document.getElementById("delete-home-preset-btn").addEventListener("click", deleteSelectedHomeScreenPreset);
					document.getElementById("export-home-preset-btn").addEventListener("click", exportHomeScreenPreset);
					document.getElementById("import-home-preset-btn").addEventListener("click", () => document.getElementById("import-home-preset-input").click());
					document.getElementById("import-home-preset-input").addEventListener("change", (e) => {
						importHomeScreenPreset(e.target.files[0]);
						e.target.value = null;
					});

					document.getElementById("theme-toggle-switch").addEventListener("change", toggleTheme);

					// 聊天记录搜索功能
					document.getElementById("search-chat-btn").addEventListener("click", openChatSearchScreen);

					document.getElementById("search-back-btn").addEventListener("click", () => {
						showScreen("chat-interface-screen");
						document.getElementById("chat-settings-btn").click();
					});

					document.getElementById("perform-search-btn").addEventListener("click", performChatSearch);

					// 搜索结果点击处理
					document.getElementById("chat-search-results-list").addEventListener("click", (e) => {
						const item = e.target.closest(".search-result-item");
						if (item && item.dataset.timestamp) {
							jumpToMessage(parseInt(item.dataset.timestamp));
						}
					});

					// 为删除过期搜索歌曲按钮绑定事件
					document.getElementById("delete-expired-songs-btn").addEventListener("click", deleteExpiredSearchedSongs);

					// 为聊天设置模态框中的管理角色表情包按钮绑定事件
					document.getElementById("chat-settings-modal").addEventListener("click", (e) => {
						if (e.target.id === "manage-char-stickers-btn") {
							document.getElementById("chat-settings-modal").classList.remove("visible");
							openCharStickerManager();
						}
					});

					// 为返回表情包管理页面按钮绑定事件
					document.getElementById("back-from-sticker-manager").addEventListener("click", () => {
						showScreen("chat-interface-screen");
						document.getElementById("chat-settings-btn").click();
					});

					// 获取表情包页签元素
					const stickerTabExclusive = document.getElementById("sticker-tab-exclusive");
					const stickerTabCommon = document.getElementById("sticker-tab-common");
					const stickerContentExclusive = document.getElementById("sticker-content-exclusive");
					const stickerContentCommon = document.getElementById("sticker-content-common");

					// 为专属表情包页签绑定点击事件
					stickerTabExclusive.addEventListener("click", () => {
						stickerTabExclusive.classList.add("active");
						stickerTabCommon.classList.remove("active");
						stickerContentExclusive.classList.add("active");
						stickerContentCommon.classList.remove("active");
						// 切换时如果处于选择模式，需要重新渲染
						if (isCharStickerSelectionMode) renderCharStickers("exclusive");
					});

					// 为通用表情包页签绑定点击事件
					stickerTabCommon.addEventListener("click", () => {
						stickerTabCommon.classList.add("active");
						stickerTabExclusive.classList.remove("active");
						stickerContentCommon.classList.add("active");
						stickerContentExclusive.classList.remove("active");
						// 切换时如果处于选择模式，需要重新渲染
						if (isCharStickerSelectionMode) renderCharStickers("common");
					});

					// 为添加/上传表情包按钮绑定事件
					document.getElementById("add-exclusive-sticker-btn").addEventListener("click", () => bulkAddCharStickers("exclusive"));
					document.getElementById("upload-exclusive-sticker-btn").addEventListener("click", () => uploadCharStickersLocal("exclusive"));
					document.getElementById("add-common-sticker-btn").addEventListener("click", () => bulkAddCharStickers("common"));
					document.getElementById("upload-common-sticker-btn").addEventListener("click", () => uploadCharStickersLocal("common"));

					// 为清空所有心声历史记录按钮绑定事件
					document.getElementById("clear-all-history-btn").addEventListener("click", clearAllInnerVoiceHistory);

					// 使用事件委托处理单条心声历史记录删除
					document.getElementById("inner-voice-history-list").addEventListener("click", (e) => {
						if (e.target.classList.contains("history-item-delete-btn")) {
							const timestamp = parseInt(e.target.dataset.timestamp);
							if (!isNaN(timestamp)) {
								deleteSingleInnerVoice(timestamp);
							}
						}
					});

					// 为导入角色卡按钮绑定事件
					document.getElementById("import-character-card-btn").addEventListener("click", async () => {
						const unlockKey = "isCharacterImportUnlocked";

						// 检查是否已经解锁
						if (localStorage.getItem(unlockKey) === "true") {
							document.getElementById("character-card-input").click();
							return;
						}

						// 如果未解锁，获取设备码
						const deviceCode = getDeviceCode();

						// 构建包含设备码和输入框的HTML内容
						const modalHtmlContent = `
                            <p style="margin-bottom: 15px;">请前往取PIN网站，使用下面的设备码获取PIN。</p>
                            <div style="background: #eee; padding: 10px; border-radius: 6px; margin-bottom: 15px; user-select: all; cursor: copy;" title="点击复制设备码">
                                <strong>设备码:</strong> <span id="device-code-to-copy">${deviceCode}</span>
                            </div>
                            <p id="copy-device-code-feedback" style="height: 15px; font-size: 12px; color: green;"></p>
                        `;

						// 使用自定义提示框弹出增强版模态框
						const userPin = await window.showCustomPrompt("功能解锁", "请在此输入获取到的PIN码...", "", "text", modalHtmlContent);

						// 如果用户点击了取消，则直接返回
						if (userPin === null) return;

						// 验证PIN码
						const correctPin = generatePinFromDeviceCode(deviceCode);
						if (userPin.trim().toUpperCase() === correctPin) {
							localStorage.setItem(unlockKey, "true");
							await showCustomAlert("解锁成功！", "导入功能已解锁，此设备无需再次输入PIN码。");
							document.getElementById("character-card-input").click();
						} else {
							await showCustomAlert("解锁失败", "PIN码错误，请重新获取或输入。");
						}
					});

					// 为自定义模态框添加点击复制设备码的功能
					document.getElementById("custom-modal-body").addEventListener("click", (e) => {
						const codeElement = e.target.closest("#device-code-to-copy");
						if (codeElement) {
							const deviceCode = codeElement.textContent;
							const feedbackEl = document.getElementById("copy-device-code-feedback");
							navigator.clipboard
								.writeText(deviceCode)
								.then(() => {
									if (feedbackEl) feedbackEl.textContent = "设备码已复制！";
									setTimeout(() => {
										if (feedbackEl) feedbackEl.textContent = "";
									}, 2000);
								})
								.catch((err) => {
									if (feedbackEl) feedbackEl.textContent = "复制失败，请手动复制。";
								});
						}
					});

					// 为角色卡文件输入绑定事件
					document.getElementById("character-card-input").addEventListener("change", (event) => {
						const file = event.target.files[0];
						if (file) {
							// 当用户选择了文件后，调用处理函数
							handleCharacterImport(file);
						}
						// 清空选择，这样用户下次还能选择同一个文件
						event.target.value = null;
					});

					// 为手机屏幕绑定一次性音频上下文解锁事件
					document.getElementById("phone-screen").addEventListener("click", unlockAudioContext, { once: true });

					// 为自定义模态框取消按钮绑定事件
					document.getElementById("custom-modal-cancel").addEventListener("click", hideCustomModal);

					// 为自定义模态框遮罩层绑定点击事件
					document.getElementById("custom-modal-overlay").addEventListener("click", (e) => {
						if (e.target === modalOverlay) hideCustomModal();
					});

					// 为清理孤立数据按钮绑定事件
					document.getElementById("clear-orphaned-data-btn").addEventListener("click", clearOrphanedData);

					// 为导出数据按钮绑定事件
					document.getElementById("export-data-btn").addEventListener("click", exportBackup);

					// 为导入按钮绑定事件
					document.getElementById("import-btn").addEventListener("click", () => document.getElementById("import-data-input").click());

					// 为导入数据文件输入绑定事件
					document.getElementById("import-data-input").addEventListener("change", (e) => importBackup(e.target.files[0]));

					// 为返回聊天列表按钮绑定事件
					document.getElementById("back-to-list-btn").addEventListener("click", () => {
						stopPetDecayTimer();
						// 清除自定义气泡样式
						applyScopedCss("", "#chat-messages", "custom-bubble-style");
						applyScopedCss("", "#settings-preview-area", "preview-bubble-style");

						exitSelectionMode();
						state.activeChatId = null;
						// 隐藏心形按钮
						document.getElementById("char-heart-btn").style.display = "none";
						showScreen("chat-list-screen");
					});

					// 为音乐显示区域绑定点击切换事件
					document.getElementById("music-display-area").addEventListener("click", () => {
						const displayArea = document.getElementById("music-display-area");
						// 切换显示歌词的类
						displayArea.classList.toggle("show-lyrics");
					});

					// 为添加聊天按钮绑定事件
					document.getElementById("add-chat-btn").addEventListener("click", async () => {
						const name = await showCustomPrompt("创建新聊天", "请输入Ta的名字");
						if (name && name.trim()) {
							const newChatId = "chat_" + Date.now();

							// 创建新聊天对象
							const newChat = {
								id: newChatId,
								name: name.trim(),
								isGroup: false,
								isPinned: false,
								npcLibrary: [],
								relationship: { status: "friend", blockedTimestamp: null, applicationReason: "" },
								status: { text: "在线", lastUpdate: Date.now(), isBusy: false },
								settings: {
									aiPersona: "你是谁呀。",
									myPersona: "我是谁呀。",
									maxMemory: 10,
									aiAvatar: defaultAvatar,
									myAvatar: defaultAvatar,
									background: "",
									theme: "default",
									fontSize: 13,
									customCss: "",
									linkedWorldBookIds: [],
									aiAvatarLibrary: [],
									stickerLibrary: [],
									// 初始化记忆互通数组
									linkedMemories: [],
									// 初始化线下模式
									offlineMode: { enabled: false, prompt: "", style: "", wordCount: 300, presets: [] },
									// 初始化时间感知
									timePerceptionEnabled: true,
									// 初始化自定义时间
									customTime: "",
									// 初始化情侣头像开关
									isCoupleAvatar: false,
									// 初始化情侣头像描述
									coupleAvatarDescription: "",
									// 初始化微博职业
									weiboProfession: "",
									// 初始化微博指令
									weiboInstruction: "",
								},
								history: [],
								musicData: { totalTime: 0 },
								// 初始化手机数据
								characterPhoneData: {
									lastGenerated: null,
									chats: {},
									shoppingCart: [],
									memos: [],
									browserHistory: [],
									photoAlbum: [],
									bank: { balance: 0, transactions: [] },
									trajectory: [],
									appUsage: [],
									diary: [],
								},
							};

							state.chats[newChatId] = newChat;
							await db.chats.put(newChat);
							renderChatList();
						}
					});

					// 为创建群聊按钮绑定事件
					document.getElementById("add-group-chat-btn").addEventListener("click", openContactPickerForGroupCreate);

					// 为转账取消按钮绑定事件
					document.getElementById("transfer-cancel-btn").addEventListener("click", () => document.getElementById("transfer-modal").classList.remove("visible"));

					// 为确认转账按钮绑定事件
					document.getElementById("transfer-confirm-btn").addEventListener("click", sendUserTransfer);

					// 为一起听按钮绑定事件
					document.getElementById("listen-together-btn").addEventListener("click", handleListenTogetherClick);

					// 为音乐退出按钮绑定事件
					document.getElementById("music-exit-btn").addEventListener("click", () => endListenTogetherSession(true));

					// 为音乐返回按钮绑定事件
					document.getElementById("music-return-btn").addEventListener("click", returnToChat);

					// 为音乐播放/暂停按钮绑定事件
					document.getElementById("music-play-pause-btn").addEventListener("click", togglePlayPause);

					// 为音乐下一首按钮绑定事件
					document.getElementById("music-next-btn").addEventListener("click", playNext);

					// 为音乐上一首按钮绑定事件
					document.getElementById("music-prev-btn").addEventListener("click", playPrev);

					// 为音乐播放模式按钮绑定事件
					document.getElementById("music-mode-btn").addEventListener("click", changePlayMode);

					// 为音乐播放列表按钮绑定事件
					document.getElementById("music-playlist-btn").addEventListener("click", () => {
						updatePlaylistUI();
						document.getElementById("music-playlist-panel").classList.add("visible");
					});

					// 为关闭播放列表按钮绑定事件
					document.getElementById("close-playlist-btn").addEventListener("click", () => document.getElementById("music-playlist-panel").classList.remove("visible"));

					// 为添加歌曲URL按钮绑定事件
					document.getElementById("add-song-url-btn").addEventListener("click", addSongFromURL);

					// 为添加本地歌曲按钮绑定事件
					document.getElementById("add-song-local-btn").addEventListener("click", () => document.getElementById("local-song-upload-input").click());

					// 为本地歌曲上传输入绑定事件
					document.getElementById("local-song-upload-input").addEventListener("change", addSongFromLocal);

					// 为歌曲搜索按钮绑定事件
					document.getElementById("add-song-search-btn").addEventListener("click", addSongFromSearch);

					// 为取消音乐搜索按钮绑定事件
					document.getElementById("cancel-music-search-btn").addEventListener("click", () => {
						document.getElementById("music-search-results-modal").classList.remove("visible");
					});

					// 为搜索结果列表绑定点击事件
					document.getElementById("search-results-list").addEventListener("click", (e) => {
						const item = e.target.closest(".search-result-item");
						if (item && item.dataset.songJson) {
							const songData = JSON.parse(item.dataset.songJson);
							handleSearchResultClick(songData);
						}
					});

					// 为音频播放器绑定播放结束事件
					audioPlayer.addEventListener("ended", playNext);

					const chatInput = document.getElementById("chat-input");

					// 为发送按钮绑定点击事件
					document.getElementById("send-btn").addEventListener("click", async () => {
						const content = chatInput.value.trim();
						if (!content || !state.activeChatId) return;

						// 尝试解析特殊指令
						try {
							const command = JSON.parse(content);
							// 检查是否为微博发布指令
							if (command && command.type === "weibo_post") {
								const chat = state.chats[state.activeChatId];
								if (chat.isGroup) {
									alert("不能在群聊中为单个角色发布微博。");
									return;
								}

								// 创建微博帖子对象
								const newPost = {
									authorId: chat.id,
									authorType: "char",
									authorNickname: chat.name,
									authorAvatar: chat.settings.aiAvatar || defaultAvatar,
									content: command.content || "",
									timestamp: Date.now(),
									likes: [],
									comments: [],
									baseLikesCount: command.baseLikesCount || 0,
									baseCommentsCount: command.baseCommentsCount || 0,
								};

								// 解析并添加评论
								if (command.comments && typeof command.comments === "string") {
									newPost.comments = command.comments
										.split("\n")
										.map((c) => {
											const parts = c.split(/[:：]/);
											const commenter = parts.shift() || "路人";
											const commentText = parts.join(":").trim();
											return { commentId: "comment_" + Date.now() + Math.random(), authorNickname: commenter, commentText: commentText };
										})
										.filter((c) => c.commentText);
								}

								await db.weiboPosts.add(newPost);

								// 刷新关注列表
								await renderFollowingWeiboFeed();

								await showCustomAlert("操作成功", `已为 “${chat.name}” 发布了一条新微博！`);

								chatInput.value = "";
								return;
							}
						} catch (e) {
							// 解析失败则作为普通文本处理
						}

						const chat = state.chats[state.activeChatId];
						// 检查群聊禁言状态
						if (chat && chat.isGroup && chat.settings.isUserMuted) {
							alert("你已被禁言，无法发言！");
							return;
						}

						// 创建消息对象
						const msg = {
							role: "user",
							content,
							timestamp: Date.now(),
						};

						// 检查是否处于引用回复模式
						if (currentReplyContext) {
							msg.quote = currentReplyContext;
						}

						chat.history.push(msg);
						await incrementMessageCount(state.activeChatId);
						await db.chats.put(chat);
						appendMessage(msg, chat);
						renderChatList();
						chatInput.value = "";
						chatInput.style.height = "auto";
						chatInput.focus();

						// 取消引用模式
						cancelReplyMode();
					});

					// 为等待回复按钮绑定点击事件
					document.getElementById("wait-reply-btn").addEventListener("click", triggerAiResponse);

					// 为聊天输入框绑定回车发送事件
					chatInput.addEventListener("keypress", (e) => {
						if (e.key === "Enter" && !e.shiftKey) {
							e.preventDefault();
							document.getElementById("send-btn").click();
						}
					});

					// 为聊天输入框绑定自动调整高度事件
					chatInput.addEventListener("input", () => {
						chatInput.style.height = "auto";
						chatInput.style.height = chatInput.scrollHeight + "px";
					});

					// 为壁纸上传输入绑定事件
					document.getElementById("wallpaper-upload-input").addEventListener("change", async (event) => {
						const file = event.target.files[0];
						if (file) {
							const dataUrl = await new Promise((res, rej) => {
								const reader = new FileReader();
								reader.onload = () => res(reader.result);
								reader.onerror = () => rej(reader.error);
								reader.readAsDataURL(file);
							});
							newWallpaperBase64 = dataUrl;
							renderWallpaperScreen();
						}
					});

					// 为保存壁纸按钮绑定点击事件
					document.getElementById("save-wallpaper-btn").addEventListener("click", async () => {
						let changesMade = false;

						// 保存壁纸
						if (newWallpaperBase64) {
							state.globalSettings.wallpaper = newWallpaperBase64;
							changesMade = true;
						}

						// 保存锁屏壁纸
						if (newLockscreenWallpaperBase64) {
							state.globalSettings.lockscreenWallpaper = newLockscreenWallpaperBase64;
							changesMade = true;
						}

						// 保存全局聊天背景
						if (newGlobalBgBase64 === "REMOVED") {
							state.globalSettings.globalChatBackground = "";
							changesMade = true;
						} else if (newGlobalBgBase64) {
							state.globalSettings.globalChatBackground = newGlobalBgBase64;
							changesMade = true;
						}

						// 保存CSS样式和主题ID
						state.globalSettings.activeCustomCss = document.getElementById("theme-css-editor").value;
						const activeThemeSelector = document.getElementById("theme-selector");
						state.globalSettings.activeThemeId = activeThemeSelector.value ? parseInt(activeThemeSelector.value) : null;
						changesMade = true;

						// 保存密码
						const newPassword = document.getElementById("password-set-input").value;
						state.globalSettings.password = newPassword;

						// 保存铃声和提示音
						state.globalSettings.ringtoneUrl = document.getElementById("ringtone-url-input").value.trim();
						state.globalSettings.notificationSoundUrl = document.getElementById("notification-sound-url-input").value.trim();

						// 保存锁屏和状态栏开关状态
						const isLockEnabled = document.getElementById("enable-lock-screen-toggle").checked;
						state.globalSettings.enableLockScreen = isLockEnabled;
						localStorage.setItem("lockScreenEnabled", isLockEnabled);

						// 保存主屏幕字体颜色和阴影设置
						state.globalSettings.homeIconWidgetTextColor = document.getElementById("home-icon-widget-text-color-picker").value;
						state.globalSettings.removeHomeFontShadow = document.getElementById("remove-home-font-shadow-toggle").checked;

						// 保存App名称
						saveAppLabels();

						// 将所有设置写入数据库
						await db.globalSettings.put(state.globalSettings);

						// 应用所有更改
						if (changesMade) {
							applyGlobalWallpaper();
							applyLockscreenWallpaper();
							applyThemeCss(state.globalSettings.activeCustomCss);
							newWallpaperBase64 = null;
							newLockscreenWallpaperBase64 = null;
							newGlobalBgBase64 = null;
						}
						applyAppIcons();
						applyAppLabels();

						alert("所有外观设置已保存并应用！");
						showScreen("home-screen");
					});

					// 为保存API设置按钮绑定点击事件
					document.getElementById("save-api-settings-btn").addEventListener("click", async () => {
						const proxyUrl = document.getElementById("proxy-url").value.trim();
						const apiKey = document.getElementById("api-key").value.trim();
						const isBlocked = BLOCKED_API_SITES.some((blockedDomain) => proxyUrl.includes(blockedDomain));

						// 检查API站点是否被禁用
						if (isBlocked) {
							alert("错误：该 API 站点已被禁用，无法使用。");
							return;
						}

						// 保存API配置
						state.apiConfig.proxyUrl = document.getElementById("proxy-url").value.trim();
						state.apiConfig.apiKey = document.getElementById("api-key").value.trim();
						state.apiConfig.model = document.getElementById("model-select").value;
						state.apiConfig.temperature = parseFloat(document.getElementById("temperature-slider").value);
						// 保存Minimax设置
						state.apiConfig.minimaxGroupId = document.getElementById("minimax-group-id").value.trim();
						state.apiConfig.minimaxApiKey = document.getElementById("minimax-api-key").value.trim();
						state.apiConfig.minimaxSpeechModel = document.getElementById("minimax-speech-model-select").value;
						await db.apiConfig.put(state.apiConfig);

						// 保存图片压缩质量
						state.globalSettings.imageCompressionQuality = parseFloat(document.getElementById("image-quality-slider").value);

						// 保存后台活动设置
						const backgroundSwitch = document.getElementById("background-activity-switch");
						const intervalInput = document.getElementById("background-interval-input");
						const newEnableState = backgroundSwitch.checked;
						const oldEnableState = state.globalSettings.enableBackgroundActivity || false;

						// 后台活动开启时显示警告
						if (newEnableState && !oldEnableState) {
							const userConfirmed = confirm("【高费用警告】\n\n" + "您正在启用“后台角色活动”功能。\n\n" + "这会使您的AI角色们在您不和他们聊天时，也能“独立思考”并主动给您发消息或进行社交互动，极大地增强沉浸感。\n\n" + "但请注意：\n" + "这会【在后台自动、定期地调用API】，即使您不进行任何操作。根据您的角色数量和检测间隔，这可能会导致您的API费用显著增加。\n\n" + "您确定要开启吗？");

							if (!userConfirmed) {
								backgroundSwitch.checked = false;
								return;
							}
						}

						state.globalSettings.enableBackgroundActivity = newEnableState;
						state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
						state.globalSettings.blockCooldownHours = parseFloat(document.getElementById("block-cooldown-input").value) || 1;
						await db.globalSettings.put(state.globalSettings);

						// 动态启动或停止模拟器
						stopBackgroundSimulation();
						if (state.globalSettings.enableBackgroundActivity) {
							startBackgroundSimulation();
							console.log(`后台活动模拟已启动，间隔: ${state.globalSettings.backgroundActivityInterval}秒`);
						} else {
							console.log("后台活动模拟已停止。");
						}

						alert("API设置已保存!");
					});

					// 为API密钥输入框绑定聚焦/失焦事件
					const ApiKeyInput = document.getElementById("api-key");
					ApiKeyInput.addEventListener("focus", (e) => {
						e.target.setAttribute("type", "text");
					});
					ApiKeyInput.addEventListener("blur", (e) => {
						e.target.setAttribute("type", "password");
					});

					// 为拉取模型按钮绑定点击事件
					document.getElementById("fetch-models-btn").addEventListener("click", async () => {
						const url = document.getElementById("proxy-url").value.trim();
						const key = document.getElementById("api-key").value.trim();
						if (!url || !key) return alert("请先填写反代地址和密钥");
						try {
							let isGemini = url === GEMINI_API_URL;
							const response = await fetch(isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(key)}` : `${url}/v1/models`, isGemini ? undefined : { headers: { Authorization: `Bearer ${key}` } });
							if (!response.ok) throw new Error("无法获取模型列表");
							const data = await response.json();
							let models = isGemini ? data.models : data.data;
							if (isGemini) {
								models = models.map((model) => {
									const parts = model.name.split("/");
									return {
										id: parts.length > 1 ? parts[1] : model.name,
									};
								});
							}
							const modelSelect = document.getElementById("model-select");
							modelSelect.innerHTML = "";
							models.forEach((model) => {
								const option = document.createElement("option");
								option.value = model.id;
								option.textContent = model.id;
								if (model.id === state.apiConfig.model) option.selected = true;
								modelSelect.appendChild(option);
							});
							alert("模型列表已更新");
						} catch (error) {
							alert(`拉取模型失败: ${error.message}`);
						}
					});

					// 为拉取语音模型按钮绑定点击事件
					document.getElementById("fetch-minimax-speech-models-btn").addEventListener("click", fetchMinimaxSpeechModels);

					// 为NovelAI开关绑定变更事件
					document.getElementById("novelai-switch").addEventListener("change", (e) => {
						const detailsDiv = document.getElementById("novelai-details");
						detailsDiv.style.display = e.target.checked ? "block" : "none";
					});

					// 为NovelAI密钥切换按钮绑定点击事件
					document.getElementById("novelai-key-toggle").addEventListener("click", function () {
						const input = document.getElementById("novelai-api-key");
						if (input.type === "password") {
							input.type = "text";
							this.textContent = "😌";
						} else {
							input.type = "password";
							this.textContent = "🧐";
						}
					});

					// 为NovelAI设置按钮绑定点击事件
					document.getElementById("novelai-settings-btn").addEventListener("click", () => {
						loadNovelAISettings();
						document.getElementById("novelai-settings-modal").style.display = "flex";
					});

					// 为CORS代理选择器绑定变更事件
					document.getElementById("nai-cors-proxy").addEventListener("change", (e) => {
						const customProxyGroup = document.getElementById("nai-custom-proxy-group");
						if (e.target.value === "custom") {
							customProxyGroup.style.display = "block";
						} else {
							customProxyGroup.style.display = "none";
						}
					});

					// 为关闭NovelAI设置按钮绑定点击事件
					document.getElementById("close-novelai-settings").addEventListener("click", () => {
						document.getElementById("novelai-settings-modal").style.display = "none";
					});

					// 为保存NAI设置按钮绑定点击事件
					document.getElementById("save-nai-settings-btn").addEventListener("click", () => {
						saveNovelAISettings();
						document.getElementById("novelai-settings-modal").style.display = "none";
						alert("NovelAI设置已保存！");
					});

					// 为重置NAI设置按钮绑定点击事件
					document.getElementById("reset-nai-settings-btn").addEventListener("click", () => {
						if (confirm("确定要恢复默认设置吗？")) {
							resetNovelAISettings();
						}
					});

					// 为NovelAI测试按钮绑定点击事件
					document.getElementById("novelai-test-btn").addEventListener("click", () => {
						const apiKey = document.getElementById("novelai-api-key").value.trim();
						if (!apiKey) {
							alert("请先填写NovelAI API Key！");
							return;
						}
						document.getElementById("novelai-test-modal").style.display = "flex";
						document.getElementById("nai-test-result").style.display = "none";
						document.getElementById("nai-test-error").style.display = "none";
					});

					// 为关闭NovelAI测试按钮绑定点击事件
					document.getElementById("close-novelai-test").addEventListener("click", () => {
						document.getElementById("novelai-test-modal").style.display = "none";
					});

					document.getElementById("close-nai-test-btn").addEventListener("click", () => {
						document.getElementById("novelai-test-modal").style.display = "none";
					});

					// 为NAI生成按钮绑定点击事件
					document.getElementById("nai-generate-btn").addEventListener("click", async () => {
						await generateNovelAIImage();
					});

					// 为NAI下载按钮绑定点击事件
					document.getElementById("nai-download-btn").addEventListener("click", () => {
						const img = document.getElementById("nai-result-image");
						const link = document.createElement("a");
						link.href = img.src;
						link.download = "novelai-generated-" + Date.now() + ".png";
						link.click();
					});

					// 为角色NAI提示词按钮绑定点击事件
					document.getElementById("character-nai-prompts-btn").addEventListener("click", () => {
						if (!state.activeChatId) return;
						const chat = state.chats[state.activeChatId];

						// 加载当前角色的NAI提示词配置
						const naiSettings = chat.settings.naiSettings || {
							promptSource: "system",
							characterPositivePrompt: "",
							characterNegativePrompt: "",
						};

						// 填充角色配置，不与系统配置混淆
						document.getElementById("character-nai-positive").value = naiSettings.characterPositivePrompt || "";
						document.getElementById("character-nai-negative").value = naiSettings.characterNegativePrompt || "";

						document.getElementById("character-nai-prompts-modal").style.display = "flex";
					});

					// 为关闭角色NAI提示词按钮绑定点击事件
					document.getElementById("close-character-nai-prompts").addEventListener("click", () => {
						document.getElementById("character-nai-prompts-modal").style.display = "none";
					});

					// 为保存角色NAI提示词按钮绑定点击事件
					document.getElementById("save-character-nai-prompts-btn").addEventListener("click", async () => {
						if (!state.activeChatId) return;
						const chat = state.chats[state.activeChatId];

						if (!chat.settings.naiSettings) {
							chat.settings.naiSettings = {
								promptSource: "system",
							};
						}

						chat.settings.naiSettings.characterPositivePrompt = document.getElementById("character-nai-positive").value.trim();
						chat.settings.naiSettings.characterNegativePrompt = document.getElementById("character-nai-negative").value.trim();

						console.log("💾 [专属弹窗] 保存角色NAI提示词");
						console.log("   characterPositivePrompt:", chat.settings.naiSettings.characterPositivePrompt);
						console.log("   characterNegativePrompt:", chat.settings.naiSettings.characterNegativePrompt);
						console.log("   promptSource:", chat.settings.naiSettings.promptSource);

						// 保存到数据库
						await db.chats.put(chat);

						document.getElementById("character-nai-prompts-modal").style.display = "none";
						alert("角色专属NAI提示词已保存！");
					});

					// 为重置角色NAI提示词按钮绑定点击事件
					document.getElementById("reset-character-nai-prompts-btn").addEventListener("click", () => {
						if (confirm("确定要清空当前角色的NAI提示词配置吗？")) {
							document.getElementById("character-nai-positive").value = "";
							document.getElementById("character-nai-negative").value = "";
						}
					});

					// 为群聊角色NAI提示词按钮绑定点击事件
					document.getElementById("group-character-nai-prompts-btn").addEventListener("click", () => {
						if (!state.activeChatId) return;
						const chat = state.chats[state.activeChatId];

						// 加载当前角色的NAI提示词配置
						const naiSettings = chat.settings.naiSettings || {
							promptSource: "system",
							characterPositivePrompt: "",
							characterNegativePrompt: "",
						};

						// 填充角色配置，不与系统配置混淆
						document.getElementById("character-nai-positive").value = naiSettings.characterPositivePrompt || "";
						document.getElementById("character-nai-negative").value = naiSettings.characterNegativePrompt || "";

						document.getElementById("character-nai-prompts-modal").style.display = "flex";
					});

					// 为导入世界书按钮绑定点击事件
					document.getElementById("import-world-book-btn").addEventListener("click", async () => {
						const unlockKey = "isCharacterImportUnlocked";

						// 检查是否已经解锁
						if (localStorage.getItem(unlockKey) === "true") {
							document.getElementById("world-book-import-input").click();
							return;
						}

						// 获取设备码
						const deviceCode = getDeviceCode();

						// 构建包含设备码的HTML内容
						const modalHtmlContent = `
                            <p style="margin-bottom: 15px;">请前往取PIN网站，使用下面的设备码获取PIN。</p>
                            <div style="background: #eee; padding: 10px; border-radius: 6px; margin-bottom: 15px; user-select: all; cursor: copy;" title="点击复制设备码">
                                <strong>设备码:</strong> <span id="device-code-to-copy">${deviceCode}</span>
                            </div>
                            <p id="copy-device-code-feedback" style="height: 15px; font-size: 12px; color: green;"></p>
                        `;

						// 弹出增强版模态框，让用户输入PIN
						const userPin = await window.showCustomPrompt("功能解锁", "请在此输入获取到的PIN码...", "", "text", modalHtmlContent);

						// 如果用户点击了取消，则直接返回
						if (userPin === null) return;

						// 验证PIN码
						const correctPin = generatePinFromDeviceCode(deviceCode);
						if (userPin.trim().toUpperCase() === correctPin) {
							localStorage.setItem(unlockKey, "true");
							await showCustomAlert("解锁成功！", "导入功能已解锁，此设备无需再次输入PIN码。");
							// 触发世界书的文件选择器
							document.getElementById("world-book-import-input").click();
						} else {
							await showCustomAlert("解锁失败", "PIN码错误，请重新获取或输入。");
						}
					});

					// 为世界书导入输入绑定变更事件
					document.getElementById("world-book-import-input").addEventListener("change", (e) => {
						const file = e.target.files[0];
						if (file) {
							// 调用核心处理函数
							handleImportSillyTavernWorldBook(file);
						}
						// 每次用完后清空，这样用户下次还能选择同一个文件
						e.target.value = null;
					});

					// 为添加世界书按钮绑定点击事件
					document.getElementById("add-world-book-btn").addEventListener("click", async () => {
						const name = await showCustomPrompt("创建世界书", "请输入书名");
						if (name && name.trim()) {
							const newBook = { id: "wb_" + Date.now(), name: name.trim(), content: "" };
							await db.worldBooks.add(newBook);
							state.worldBooks.push(newBook);
							renderWorldBookScreen();
							openWorldBookEditor(newBook.id);
						}
					});

					// 为保存世界书按钮绑定点击事件
					document.getElementById("save-world-book-btn").addEventListener("click", async () => {
						if (!editingWorldBookId) return;
						const book = state.worldBooks.find((wb) => wb.id === editingWorldBookId);
						if (book) {
							const newName = document.getElementById("world-book-name-input").value.trim();
							if (!newName) {
								alert("书名不能为空！");
								return;
							}
							book.name = newName;
							book.content = document.getElementById("world-book-content-input").value;

							// 保存分类ID
							const categoryId = document.getElementById("world-book-category-select").value;
							// 如果选择了"未分类"，存入 null；否则存入数字ID
							book.categoryId = categoryId ? parseInt(categoryId) : null;

							await db.worldBooks.put(book);
							document.getElementById("world-book-editor-title").textContent = newName;
							editingWorldBookId = null;
							renderWorldBookScreen();
							showScreen("world-book-screen");
						}
					});

					// 为聊天消息区域绑定点击事件
					document.getElementById("chat-messages").addEventListener("click", async (e) => {
						const voiceBody = e.target.closest(".voice-message-body");
						if (voiceBody) {
							const bubble = voiceBody.closest(".message-bubble");
							if (!bubble) return;

							// 如果是用户自己的语音，只切换文字显示，不播放
							if (bubble.classList.contains("user")) {
								toggleVoiceTranscript(bubble);
								return;
							}

							// 如果是AI的语音消息
							const chat = state.chats[state.activeChatId];
							if (!chat) return;

							// 检查是否点击了正在播放的语音条
							if (isTtsPlaying && currentTtsAudioBubble === bubble) {
								// 停止播放并收起所有关联的文字
								stopMinimaxAudio();
							}
							// 检查点击的是否是已经展开了文字但没有播放的语音条
							else if (bubble.dataset.state === "expanded") {
								// 只收起文字，不影响其他
								toggleVoiceTranscript(bubble);
							}
							// 如果以上都不是，说明是想开始播放或只展开文字
							else {
								const clickedTimestamp = parseInt(bubble.dataset.timestamp);
								const startIndex = chat.history.findIndex((m) => m.timestamp === clickedTimestamp);
								if (startIndex === -1) return;

								// 查找连续的语音消息
								const messagesToPlay = findConsecutiveAiVoiceMessages(chat.history, startIndex);
								if (messagesToPlay.length > 0) {
									const bubblesToAnimate = messagesToPlay.map((m) => document.querySelector(`.message-bubble[data-timestamp="${m.timestamp}"]`)).filter(Boolean);

									// 检查配置，决定是播放还是只显示文字
									const groupId = state.apiConfig.minimaxGroupId;
									const apiKey = state.apiConfig.minimaxApiKey;
									const voiceId = chat.settings.minimaxVoiceId;

									if (groupId && apiKey && voiceId) {
										// 播放分支：先展开所有文字，然后调用播放器
										bubblesToAnimate.forEach((b) => {
											if (b.dataset.state !== "expanded") {
												toggleVoiceTranscript(b);
											}
										});
										const combinedText = messagesToPlay.map((m) => m.content.trim()).join("，");
										playMinimaxAudio(combinedText, voiceId, bubblesToAnimate);
									} else {
										// 只显示文字分支：只展开当前点击的这一个语音条的文字
										toggleVoiceTranscript(bubble);
									}
								}
							}

							return;
						}

						// 处理AI生成图片的点击事件
						const aiImage = e.target.closest(".ai-generated-image");
						if (aiImage) {
							const description = aiImage.dataset.description;
							if (description) showCustomAlert("照片描述", description);
							return;
						}

						// 处理链接分享卡片的点击事件
						const linkCard = e.target.closest(".link-share-card");
						if (linkCard && linkCard.closest(".message-bubble.is-link-share")) {
							const timestamp = parseInt(linkCard.dataset.timestamp);
							if (!isNaN(timestamp)) {
								openBrowser(timestamp);
							}
						}

						// 处理红包卡片的点击事件
						const packetCard = e.target.closest(".red-packet-card");
						if (packetCard) {
							const messageBubble = packetCard.closest(".message-bubble");
							if (messageBubble && messageBubble.dataset.timestamp) {
								const timestamp = parseInt(messageBubble.dataset.timestamp);
								handlePacketClick(timestamp);
							}
						}

						// 处理投票卡片的点击事件
						const pollCard = e.target.closest(".poll-card");
						if (pollCard) {
							const timestamp = parseInt(pollCard.dataset.pollTimestamp);
							if (isNaN(timestamp)) return;

							// 处理投票选项点击
							const optionItem = e.target.closest(".poll-option-item");
							if (optionItem && !pollCard.classList.contains("closed")) {
								handleUserVote(timestamp, optionItem.dataset.option);
								return;
							}

							// 处理投票操作按钮点击
							const actionBtn = e.target.closest(".poll-action-btn");
							if (actionBtn) {
								if (pollCard.classList.contains("closed")) {
									showPollResults(timestamp);
								} else {
									endPoll(timestamp);
								}
								return;
							}

							// 显示投票结果
							if (pollCard.classList.contains("closed")) {
								showPollResults(timestamp);
							}
						}

						// 处理外卖卡片点击事件
						const card = e.target.closest(".waimai-card");
						if (card) {
							const messageBubble = card.closest(".message-bubble");
							const invitationMsg = state.chats[state.activeChatId].history.find((m) => m.timestamp === parseInt(messageBubble.dataset.timestamp));
							if (invitationMsg && invitationMsg.type === "lovers_space_invitation" && invitationMsg.status === "pending") {
								const choice = e.target.dataset.choice;
								if (choice) {
									handleLoversSpaceResponse(invitationMsg.timestamp, choice);
								}
							}
						}

						// 处理转发卡片点击事件
						const repostCard = e.target.closest(".link-share-card[data-post-id]");
						if (repostCard) {
							const postId = parseInt(repostCard.dataset.postId);
							if (!isNaN(postId)) {
								openPost(postId);
							}
						}

						// 处理分享卡片的点击事件
						const shareCard = e.target.closest(".link-share-card[data-timestamp]");
						if (shareCard && shareCard.closest(".message-bubble.is-link-share")) {
							const timestamp = parseInt(shareCard.dataset.timestamp);
							if (!isNaN(timestamp)) {
								const msg = state.chats[state.activeChatId].history.find((m) => m.timestamp === timestamp);
								if (msg && msg.type === "share_card") openSharedHistoryViewer(timestamp);
								else if (msg && msg.type === "share_link") openBrowser(timestamp);
							}
						}

						// 处理已撤回消息的点击事件
						const placeholder = e.target.closest(".recalled-message-placeholder");
						if (placeholder) {
							const wrapper = placeholder.closest(".message-wrapper");
							const chat = state.chats[state.activeChatId];
							if (chat && wrapper) {
								const timestamp = parseInt(wrapper.dataset.timestamp);
								const recalledMsg = chat.history.find((m) => m.timestamp === timestamp);
								if (recalledMsg && recalledMsg.recalledData) {
									let originalContentText = "";
									const recalled = recalledMsg.recalledData;
									if (recalled.originalType === "text") {
										originalContentText = `原文: "${recalled.originalContent}"`;
									} else {
										originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
									}
									showCustomAlert("已撤回的消息", originalContentText);
								}
							}
						}

						// 处理约会总结聊天卡片点击事件
						const chatCard = e.target.closest(".dating-summary-chat-card");
						if (chatCard && chatCard.dataset.summaryPayload) {
							try {
								// 读取并解析存储在 data-* 属性中的卡片数据
								const payloadString = chatCard.dataset.summaryPayload.replace(/&apos;/g, "'").replace(/"/g, "&quot;");
								const payload = JSON.parse(payloadString);
								// 调用函数打开详情卡片
								reopenDatingSummary(payload);
							} catch (error) {
								console.error("解析分享的约会记录失败:", error);
								alert("无法打开这个约会记录。");
							}
						}
					});

					const chatSettingsModal = document.getElementById("chat-settings-modal");
					const worldBookSelectBox = document.querySelector(".custom-multiselect .select-box");
					const worldBookCheckboxesContainer = document.getElementById("world-book-checkboxes-container");

					// 更新世界书选择显示文本
					function updateWorldBookSelectionDisplay() {
						const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll("input:checked");
						const displayText = document.querySelector(".selected-options-text");
						if (checkedBoxes.length === 0) {
							displayText.textContent = "-- 点击选择 --";
						} else if (checkedBoxes.length > 2) {
							displayText.textContent = `已选择 ${checkedBoxes.length} 项`;
						} else {
							displayText.textContent = Array.from(checkedBoxes)
								.map((cb) => cb.parentElement.textContent.trim())
								.join(", ");
						}
					}

					// 世界书选择框点击事件
					worldBookSelectBox.addEventListener("click", (e) => {
						e.stopPropagation();
						worldBookCheckboxesContainer.classList.toggle("visible");
						worldBookSelectBox.classList.toggle("expanded");
					});

					// 世界书复选框变化事件
					document.getElementById("world-book-checkboxes-container").addEventListener("change", updateWorldBookSelectionDisplay);

					// 点击外部区域关闭世界书选择框
					window.addEventListener("click", (e) => {
						if (!document.querySelector(".custom-multiselect").contains(e.target)) {
							worldBookCheckboxesContainer.classList.remove("visible");
							worldBookSelectBox.classList.remove("expanded");
						}
					});

					// 聊天设置按钮点击事件
					document.getElementById("chat-settings-btn").addEventListener("click", async () => {
						if (!state.activeChatId) return;
						const chat = state.chats[state.activeChatId];
						const isGroup = chat.isGroup;

						// 控制各设置区域显示/隐藏
						document.getElementById("offline-mode-section").style.display = isGroup ? "none" : "block";
						document.getElementById("couple-avatar-group").style.display = isGroup ? "none" : "block";
						document.getElementById("streak-settings-section").style.display = isGroup ? "none" : "block";

						// 计算并显示总消息条数
						const totalMessages = chat.history.length;
						const countDisplay = document.getElementById("total-message-count-display");
						if (countDisplay) {
							countDisplay.textContent = `${totalMessages} 条`;
						}

						// 计算并显示上下文Token数
						const contextTextForToken = await getContextForTokenCalculation(state.activeChatId);
						const tokenCount = calculateTokenCount(contextTextForToken);
						const tokenDisplay = document.getElementById("context-token-count-display");
						if (tokenDisplay) {
							tokenDisplay.textContent = tokenCount.toLocaleString();
						}

						// 视频通话设置
						const videoCallSettingsGroup = document.getElementById("video-call-settings-group");
						const visualCallSwitch = document.getElementById("visual-video-call-switch");
						const imageUploadsDiv = document.getElementById("video-call-image-uploads");

						// 聊天总结设置
						const summarySettings = chat.settings.summary || {};
						const summaryToggle = document.getElementById("summary-toggle");
						const summaryDetails = document.getElementById("summary-details-container");

						summaryToggle.checked = summarySettings.enabled || false;
						summaryDetails.style.display = summaryToggle.checked ? "block" : "none";

						document.querySelector(`input[name="summary-mode"][value="${summarySettings.mode || "auto"}"]`).checked = true;
						document.getElementById("summary-count-input").value = summarySettings.count || 20;
						document.getElementById("summary-prompt-input").value = summarySettings.prompt || "请你以第三人称的视角，客观、冷静、不带任何感情色彩地总结以下对话的核心事件和信息。禁止进行任何角色扮演或添加主观评论。";

						// 聊天总结开关事件
						summaryToggle.onchange = () => {
							summaryDetails.style.display = summaryToggle.checked ? "block" : "none";
						};

						if (isGroup) {
							videoCallSettingsGroup.style.display = "none";
						} else {
							videoCallSettingsGroup.style.display = "block";

							// 加载视频通话设置
							visualCallSwitch.checked = chat.settings.visualVideoCallEnabled || false;
							imageUploadsDiv.style.display = visualCallSwitch.checked ? "block" : "none";
							document.getElementById("char-video-image-preview").src = chat.settings.charVideoImage || "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png";
							document.getElementById("user-video-image-preview").src = chat.settings.userVideoImage || "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png";

							// 视频通话开关事件
							visualCallSwitch.onchange = () => {
								imageUploadsDiv.style.display = visualCallSwitch.checked ? "block" : "none";
							};
						}

						// 线下模式设置
						const offlineModeSettings = chat.settings.offlineMode || { enabled: false, presets: [] };
						const offlineToggle = document.getElementById("offline-mode-toggle");
						const offlineDetails = document.getElementById("offline-mode-details");

						offlineToggle.checked = offlineModeSettings.enabled;
						offlineDetails.style.display = offlineToggle.checked ? "block" : "none";
						offlineToggle.onchange = () => {
							offlineDetails.style.display = offlineToggle.checked ? "block" : "none";
						};

						document.getElementById("offline-prompt-input").value = offlineModeSettings.prompt || "";
						document.getElementById("offline-style-input").value = offlineModeSettings.style || "";
						document.getElementById("offline-word-count-input").value = offlineModeSettings.wordCount || 300;

						// 渲染线下模式预设选择器
						renderOfflinePresetsSelector();

						// 气泡预设导入/导出事件绑定
						document.getElementById("export-bubble-preset-btn").addEventListener("click", exportSelectedBubblePreset);

						document.getElementById("import-bubble-preset-btn").addEventListener("click", () => {
							document.getElementById("import-bubble-preset-input").click();
						});

						document.getElementById("import-bubble-preset-input").addEventListener("change", (e) => {
							importBubblePreset(e.target.files[0]);
							e.target.value = null;
						});

						// 控制各组设置显示/隐藏
						document.getElementById("chat-name-group").style.display = "block";
						document.getElementById("minimax-voice-id-group").style.display = isGroup ? "none" : "block";
						document.getElementById("my-persona-group").style.display = "block";
						document.getElementById("my-avatar-group").style.display = "block";
						document.getElementById("my-group-nickname-group").style.display = isGroup ? "block" : "none";
						document.getElementById("group-avatar-group").style.display = isGroup ? "block" : "none";
						document.getElementById("group-members-group").style.display = isGroup ? "block" : "none";
						document.getElementById("ai-persona-group").style.display = isGroup ? "none" : "block";
						document.getElementById("ai-avatar-group").style.display = isGroup ? "none" : "block";
						document.getElementById("npc-library-group").style.display = isGroup ? "none" : "block";

						// NovelAI角色设置
						const naiCharacterSettingsGroup = document.getElementById("nai-character-settings-group");
						const novelaiEnabled = localStorage.getItem("novelai-enabled") === "true";
						if (!isGroup && novelaiEnabled) {
							naiCharacterSettingsGroup.style.display = "block";

							const naiSettings = chat.settings.naiSettings || {
								promptSource: "system",
								characterPositivePrompt: "",
								characterNegativePrompt: "",
							};

							const promptSourceRadios = document.querySelectorAll('input[name="nai-prompt-source"]');
							promptSourceRadios.forEach((radio) => {
								radio.checked = radio.value === naiSettings.promptSource;
							});
						} else {
							naiCharacterSettingsGroup.style.display = "none";
						}

						// 群聊NovelAI设置
						const groupNaiSettingsGroup = document.getElementById("group-nai-settings-group");
						if (isGroup && novelaiEnabled) {
							groupNaiSettingsGroup.style.display = "block";

							const groupNaiSettings = chat.settings.naiSettings || {
								promptSource: "system",
								characterPositivePrompt: "",
								characterNegativePrompt: "",
							};

							const groupPromptSourceRadios = document.querySelectorAll('input[name="group-nai-prompt-source"]');
							groupPromptSourceRadios.forEach((radio) => {
								radio.checked = radio.value === groupNaiSettings.promptSource;
							});
						} else {
							groupNaiSettingsGroup.style.display = "none";
						}

						// 表情管理设置
						const charStickerGroup = document.getElementById("char-sticker-group");
						if (charStickerGroup) {
							charStickerGroup.style.display = "block";
						}

						// 微博设置显示控制
						document.getElementById("weibo-profession-group").style.display = isGroup ? "none" : "block";
						document.getElementById("weibo-instruction-group").style.display = isGroup ? "none" : "block";
						document.getElementById("assign-group-section").style.display = isGroup ? "none" : "block";

						// 加载表单数据
						document.getElementById("chat-name-input").value = chat.name;
						document.getElementById("my-persona").value = chat.settings.myPersona;
						document.getElementById("my-avatar-preview").src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
						document.getElementById("max-memory").value = chat.settings.maxMemory;

						// 记忆互通功能UI渲染
						const memoryLinkSelectBox = document.querySelector("#memory-link-multiselect .select-box");
						const memoryLinkCheckboxesContainer = document.getElementById("memory-link-checkboxes-container");
						memoryLinkCheckboxesContainer.innerHTML = "";

						const otherChats = Object.values(state.chats).filter((c) => c.id !== chat.id);

						otherChats.forEach((otherChat) => {
							const existingLink = chat.settings.linkedMemories.find((link) => link.chatId === otherChat.id);
							const isChecked = existingLink ? "checked" : "";

							const avatarUrl = otherChat.isGroup ? otherChat.settings.groupAvatar || defaultGroupAvatar : otherChat.settings.aiAvatar || defaultAvatar;

							const label = document.createElement("label");
							label.innerHTML = `
                            <input type="checkbox" value="${otherChat.id}" ${isChecked}>
                            <img src="${avatarUrl}" class="avatar-preview">
                            <span>${otherChat.name} ${otherChat.isGroup ? "(群聊)" : ""}</span>
                        `;
							memoryLinkCheckboxesContainer.appendChild(label);
						});

						// 更新记忆链接显示
						function updateMemoryLinkDisplay() {
							const checkedBoxes = memoryLinkCheckboxesContainer.querySelectorAll("input:checked");
							const displayText = memoryLinkSelectBox.querySelector(".selected-options-text");
							if (checkedBoxes.length === 0) {
								displayText.textContent = "-- 点击选择 --";
							} else {
								displayText.textContent = `已链接 ${checkedBoxes.length} 个聊天`;
							}
						}

						document.getElementById("link-memory-depth-input").value = chat.settings.linkMemoryDepth || 5;

						updateMemoryLinkDisplay();
						memoryLinkCheckboxesContainer.addEventListener("change", updateMemoryLinkDisplay);

						const newSelectBox = memoryLinkSelectBox.cloneNode(true);
						memoryLinkSelectBox.parentNode.replaceChild(newSelectBox, memoryLinkSelectBox);
						newSelectBox.addEventListener("click", (e) => {
							e.stopPropagation();
							memoryLinkCheckboxesContainer.classList.toggle("visible");
							newSelectBox.classList.toggle("expanded");
						});

						// 时间感知设置
						const timeToggle = document.getElementById("time-perception-toggle");
						const customTimeContainer = document.getElementById("custom-time-container");
						const customTimeInput = document.getElementById("custom-time-input");

						const isTimeEnabled = chat.settings.timePerceptionEnabled ?? true;
						timeToggle.checked = isTimeEnabled;
						customTimeInput.value = chat.settings.customTime || "";

						customTimeContainer.style.display = isTimeEnabled ? "none" : "block";

						// 背景图片设置
						const bgPreview = document.getElementById("bg-preview");
						const removeBgBtn = document.getElementById("remove-bg-btn");
						if (chat.settings.background) {
							bgPreview.src = chat.settings.background;
							bgPreview.style.display = "block";
							removeBgBtn.style.display = "inline-block";
						} else {
							bgPreview.style.display = "none";
							removeBgBtn.style.display = "none";
						}

						if (isGroup) {
							document.getElementById("my-group-nickname-input").value = chat.settings.myNickname || "";
							document.getElementById("group-avatar-preview").src = chat.settings.groupAvatar || defaultGroupAvatar;
							renderGroupMemberSettings(chat.members);

							// 群聊后台活动设置
							const groupActivityGroup = document.getElementById("group-background-activity-group");
							const groupActivitySwitch = document.getElementById("group-background-activity-switch");
							const groupIntervalSettings = document.getElementById("group-background-interval-settings");
							const groupIntervalInput = document.getElementById("group-background-interval-input");

							groupActivityGroup.style.display = "block";
							const bgSettings = chat.settings.backgroundActivity || { enabled: false, interval: 120 };
							groupActivitySwitch.checked = bgSettings.enabled;
							groupIntervalInput.value = bgSettings.interval;
							groupIntervalSettings.style.display = bgSettings.enabled ? "block" : "none";

							groupActivitySwitch.onchange = () => {
								groupIntervalSettings.style.display = groupActivitySwitch.checked ? "block" : "none";
							};
						} else {
							document.getElementById("ai-persona").value = chat.settings.aiPersona;
							document.getElementById("weibo-profession-input").value = chat.settings.weiboProfession || "";
							document.getElementById("weibo-instruction-input").value = chat.settings.weiboInstruction || "";
							document.getElementById("ai-avatar-preview").src = chat.settings.aiAvatar || defaultAvatar;
							document.getElementById("minimax-voice-id-input").value = chat.settings.minimaxVoiceId || "";

							// 情侣头像设置
							const coupleAvatarToggle = document.getElementById("couple-avatar-toggle");
							const coupleAvatarDescContainer = document.getElementById("couple-avatar-desc-container");
							const coupleAvatarDescInput = document.getElementById("couple-avatar-description");

							coupleAvatarToggle.checked = chat.settings.isCoupleAvatar || false;
							coupleAvatarDescInput.value = chat.settings.coupleAvatarDescription || "";

							coupleAvatarDescContainer.style.display = coupleAvatarToggle.checked ? "block" : "none";

							coupleAvatarToggle.onchange = () => {
								coupleAvatarDescContainer.style.display = coupleAvatarToggle.checked ? "block" : "none";
							};

							document.getElementById("group-background-activity-group").style.display = "none";

							// 好友分组设置
							const select = document.getElementById("assign-group-select");
							select.innerHTML = '<option value="">未分组</option>';
							const groups = await db.qzoneGroups.toArray();
							groups.forEach((group) => {
								const option = document.createElement("option");
								option.value = group.id;
								option.textContent = group.name;
								if (chat.groupId === group.id) {
									option.selected = true;
								}
								select.appendChild(option);
							});
						}

						// 世界书分类和书籍渲染
						const worldBookCheckboxesContainer = document.getElementById("world-book-checkboxes-container");
						worldBookCheckboxesContainer.innerHTML = "";
						const linkedIds = new Set(chat.settings.linkedWorldBookIds || []);

						const categories = await db.worldBookCategories.toArray();
						const books = state.worldBooks;

						const hasUncategorized = books.some((book) => !book.categoryId);
						if (hasUncategorized) {
							categories.push({ id: "uncategorized", name: "未分类" });
						}

						const booksByCategoryId = books.reduce((acc, book) => {
							const categoryId = book.categoryId || "uncategorized";
							if (!acc[categoryId]) {
								acc[categoryId] = [];
							}
							acc[categoryId].push(book);
							return acc;
						}, {});

						categories.forEach((category) => {
							const booksInCategory = booksByCategoryId[category.id] || [];
							if (booksInCategory.length > 0) {
								const allInCategoryChecked = booksInCategory.every((book) => linkedIds.has(book.id));

								const header = document.createElement("div");
								header.className = "wb-category-header";
								header.innerHTML = `
                                <span class="arrow">▼</span>
                                <input type="checkbox" class="wb-category-checkbox" data-category-id="${category.id}" ${allInCategoryChecked ? "checked" : ""}>
                                <span>${category.name}</span>
                            `;

								const bookContainer = document.createElement("div");
								bookContainer.className = "wb-book-container";
								bookContainer.dataset.containerFor = category.id;

								booksInCategory.forEach((book) => {
									const isChecked = linkedIds.has(book.id);
									const label = document.createElement("label");
									label.innerHTML = `<input type="checkbox" class="wb-book-checkbox" value="${book.id}" data-parent-category="${category.id}" ${isChecked ? "checked" : ""}> <span class="wb-book-name">${book.name}</span>`;
									bookContainer.appendChild(label);
								});

								header.classList.add("collapsed");
								bookContainer.classList.add("collapsed");

								worldBookCheckboxesContainer.appendChild(header);
								worldBookCheckboxesContainer.appendChild(bookContainer);
							}
						});

						updateWorldBookSelectionDisplay();

						// 主题和字体设置
						const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || "default"}"]`);
						if (themeRadio) themeRadio.checked = true;
						const fontSizeSlider = document.getElementById("font-size-slider");
						fontSizeSlider.value = chat.settings.fontSize || 13;
						document.getElementById("font-size-value").textContent = `${fontSizeSlider.value}px`;
						const customCssInput = document.getElementById("custom-css-input");

						// 火花设置
						const streakSettings = chat.settings.streak || { enabled: false, initialDays: 0, extinguishThreshold: 1 };

						// 自定义火花图标和颜色设置
						document.getElementById("streak-lit-icon-url").value = streakSettings.litIconUrl || "";
						document.getElementById("streak-extinguished-icon-url").value = streakSettings.extinguishedIconUrl || "";
						document.getElementById("streak-font-color-picker").value = streakSettings.fontColor || "#ff6f00";

						const streakToggle = document.getElementById("streak-enabled-toggle");
						const streakDetails = document.getElementById("streak-details-container");
						const initialDaysInput = document.getElementById("streak-initial-days-input");
						const thresholdSelect = document.getElementById("streak-extinguish-threshold-select");

						streakToggle.checked = streakSettings.enabled;
						streakDetails.style.display = streakSettings.enabled ? "block" : "none";

						const intimacyBtn = document.getElementById("open-intimacy-panel-btn");
						if (intimacyBtn) {
							intimacyBtn.style.display = streakSettings.enabled ? "block" : "none";
						}

						initialDaysInput.value = streakSettings.initialDays || 0;
						thresholdSelect.value = streakSettings.extinguishThreshold || 1;

						streakToggle.onchange = () => {
							streakDetails.style.display = streakToggle.checked ? "block" : "none";
						};

						customCssInput.value = chat.settings.customCss || "";

						updateSettingsPreview();

						// 气泡预设相关设置
						renderBubblePresetSelector();
						document.getElementById("bubble-style-preset-select").addEventListener("change", handlePresetSelectChange);
						document.getElementById("manage-bubble-presets-btn").addEventListener("click", openBubblePresetManager);
						document.getElementById("chat-settings-modal").classList.add("visible");
					});

					// 渲染群成员设置
					function renderGroupMemberSettings(members) {
						const container = document.getElementById("group-members-settings");
						container.innerHTML = "";
						members.forEach((member) => {
							const div = document.createElement("div");
							div.className = "member-editor";
							div.dataset.memberId = member.id;
							div.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`;
							div.addEventListener("click", () => openMemberEditor(member.id));
							container.appendChild(div);
						});
					}

					// 打开成员编辑器
					function openMemberEditor(memberId) {
						editingMemberId = memberId;
						const chat = state.chats[state.activeChatId];
						const member = chat.members.find((m) => m.id === memberId);
						if (!member) return;

						if (typeof member.isMuted === "undefined") {
							member.isMuted = false;
						}

						document.getElementById("member-name-input").value = member.groupNickname;
						document.getElementById("member-persona-input").value = member.persona;
						document.getElementById("member-avatar-preview").src = member.avatar;

						const changeFrameBtn = document.getElementById("member-editor-change-frame-btn");
						const newChangeFrameBtn = changeFrameBtn.cloneNode(true);
						changeFrameBtn.parentNode.replaceChild(newChangeFrameBtn, changeFrameBtn);

						newChangeFrameBtn.addEventListener("click", () => {
							openFrameSelectorModal("member", memberId);
						});

						document.getElementById("member-settings-modal").classList.add("visible");
					}

					// 成员设置取消按钮事件：关闭成员设置模态框并重置编辑状态
					document.getElementById("cancel-member-settings-btn").addEventListener("click", () => {
						document.getElementById("member-settings-modal").classList.remove("visible");
						editingMemberId = null;
					});

					// 成员设置保存按钮事件：验证并保存成员信息
					document.getElementById("save-member-settings-btn").addEventListener("click", () => {
						if (!editingMemberId) return;
						const chat = state.chats[state.activeChatId];
						const member = chat.members.find((m) => m.id === editingMemberId);

						// 获取并验证群昵称
						const newNickname = document.getElementById("member-name-input").value.trim();
						if (!newNickname) {
							alert("群昵称不能为空！");
							return;
						}

						// 更新成员信息
						member.groupNickname = newNickname; // 只修改群昵称
						member.persona = document.getElementById("member-persona-input").value;
						member.avatar = document.getElementById("member-avatar-preview").src;

						// 重新渲染群成员设置界面并关闭模态框
						renderGroupMemberSettings(chat.members);
						document.getElementById("member-settings-modal").classList.remove("visible");
					});

					// 主题重置按钮事件：选中默认主题
					document.getElementById("reset-theme-btn").addEventListener("click", () => {
						document.getElementById("theme-default").checked = true;
					});

					// 聊天设置取消按钮事件：关闭聊天设置模态框
					document.getElementById("cancel-chat-settings-btn").addEventListener("click", () => {
						chatSettingsModal.classList.remove("visible");
					});

					// 聊天设置保存按钮事件：保存所有聊天设置
					document.getElementById("save-chat-settings-btn").addEventListener("click", async () => {
						if (!state.activeChatId) return;
						const chat = state.chats[state.activeChatId];

						// 验证并保存聊天名称
						const newName = document.getElementById("chat-name-input").value.trim();
						if (!newName) return alert("备注名/群名不能为空！");
						chat.name = newName;

						// 记忆互通功能设置
						const linkedMemoryCheckboxes = document.querySelectorAll("#memory-link-checkboxes-container input:checked");
						const memoryDepth = parseInt(document.getElementById("link-memory-depth-input").value) || 5;

						// 保存记忆深度设置
						chat.settings.linkMemoryDepth = memoryDepth;

						// 保存链接的记忆设置
						chat.settings.linkedMemories = Array.from(linkedMemoryCheckboxes).map((checkbox) => ({
							chatId: checkbox.value,
							depth: memoryDepth,
						}));

						// 保存主题和字体设置
						const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
						chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : "default";
						chat.settings.fontSize = parseInt(document.getElementById("font-size-slider").value);
						chat.settings.customCss = document.getElementById("custom-css-input").value.trim();

						// 保存用户和AI角色设置
						chat.settings.myPersona = document.getElementById("my-persona").value;
						chat.settings.myAvatar = document.getElementById("my-avatar-preview").src;
						const checkedBooks = document.querySelectorAll("#world-book-checkboxes-container input.wb-book-checkbox:checked");
						chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map((cb) => cb.value);

						if (chat.isGroup) {
							// 群聊设置
							chat.settings.myNickname = document.getElementById("my-group-nickname-input").value.trim();
							chat.settings.groupAvatar = document.getElementById("group-avatar-preview").src;

							// 保存群聊后台活动设置
							const groupActivityEnabled = document.getElementById("group-background-activity-switch").checked;
							const groupActivityInterval = parseInt(document.getElementById("group-background-interval-input").value) || 120;
							const lastTimestamp = chat.settings.backgroundActivity ? chat.settings.backgroundActivity.lastActivityTimestamp : 0;

							chat.settings.backgroundActivity = {
								enabled: groupActivityEnabled,
								interval: groupActivityInterval,
								lastActivityTimestamp: lastTimestamp,
							};
						} else {
							// 私聊设置
							chat.settings.aiPersona = document.getElementById("ai-persona").value;
							chat.settings.aiAvatar = document.getElementById("ai-avatar-preview").src;
							chat.settings.minimaxVoiceId = document.getElementById("minimax-voice-id-input").value.trim();

							// 情侣头像设置
							chat.settings.isCoupleAvatar = document.getElementById("couple-avatar-toggle").checked;
							chat.settings.coupleAvatarDescription = document.getElementById("couple-avatar-description").value.trim();

							// 微博相关设置
							chat.settings.weiboProfession = document.getElementById("weibo-profession-input").value.trim();
							chat.settings.weiboInstruction = document.getElementById("weibo-instruction-input").value.trim();

							// 视频通话设置
							chat.settings.visualVideoCallEnabled = document.getElementById("visual-video-call-switch").checked;
							chat.settings.charVideoImage = document.getElementById("char-video-image-preview").src;
							chat.settings.userVideoImage = document.getElementById("user-video-image-preview").src;

							// NAI出图设置
							const novelaiEnabled = localStorage.getItem("novelai-enabled") === "true";
							if (novelaiEnabled) {
								if (!chat.settings.naiSettings) {
									chat.settings.naiSettings = {};
								}

								const isGroup = chat.isGroup;
								const promptSourceRadio = document.querySelector(isGroup ? 'input[name="group-nai-prompt-source"]:checked' : 'input[name="nai-prompt-source"]:checked');

								chat.settings.naiSettings.promptSource = promptSourceRadio ? promptSourceRadio.value : "system";
								console.log("💾 保存NAI设置 - promptSource:", chat.settings.naiSettings.promptSource);
								console.log("💾 保存NAI设置 - characterPositivePrompt:", chat.settings.naiSettings.characterPositivePrompt);
								console.log("💾 保存NAI设置 - characterNegativePrompt:", chat.settings.naiSettings.characterNegativePrompt);
							}

							// 分组设置
							const selectedGroupId = document.getElementById("assign-group-select").value;
							chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
						}

						// 记忆相关设置
						chat.settings.maxMemory = parseInt(document.getElementById("max-memory").value) || 10;
						chat.settings.timePerceptionEnabled = document.getElementById("time-perception-toggle").checked;
						chat.settings.customTime = document.getElementById("custom-time-input").value;

						// 线下模式设置
						if (!chat.settings.offlineMode) chat.settings.offlineMode = {};
						chat.settings.offlineMode.enabled = document.getElementById("offline-mode-toggle").checked;
						chat.settings.offlineMode.prompt = document.getElementById("offline-prompt-input").value.trim();
						chat.settings.offlineMode.style = document.getElementById("offline-style-input").value.trim();
						chat.settings.offlineMode.wordCount = parseInt(document.getElementById("offline-word-count-input").value) || 300;

						// 聊天总结设置
						if (!chat.settings.summary) chat.settings.summary = {};
						chat.settings.summary.enabled = document.getElementById("summary-toggle").checked;
						chat.settings.summary.mode = document.querySelector('input[name="summary-mode"]:checked').value;
						chat.settings.summary.count = parseInt(document.getElementById("summary-count-input").value) || 20;
						chat.settings.summary.prompt = document.getElementById("summary-prompt-input").value.trim();

						// 连续对话天数(火花)设置
						const isStreakEnabled = document.getElementById("streak-enabled-toggle").checked;
						const newInitialDays = parseInt(document.getElementById("streak-initial-days-input").value) || 0;
						const newThreshold = parseInt(document.getElementById("streak-extinguish-threshold-select").value);
						const oldStreak = chat.settings.streak || {};

						if (isStreakEnabled) {
							const isFirstTimeEnabled = !oldStreak.enabled;
							chat.settings.streak = {
								enabled: true,
								currentDays: isFirstTimeEnabled ? newInitialDays : oldStreak.currentDays,
								lastInteractionDate: isFirstTimeEnabled ? null : oldStreak.lastInteractionDate,
								initialDays: newInitialDays,
								extinguishThreshold: newThreshold,
								litIconUrl: document.getElementById("streak-lit-icon-url").value.trim(),
								extinguishedIconUrl: document.getElementById("streak-extinguished-icon-url").value.trim(),
								fontColor: document.getElementById("streak-font-color-picker").value,
							};
						} else {
							chat.settings.streak = {
								enabled: false,
								initialDays: 0,
								currentDays: 0,
								extinguishThreshold: 1,
								lastInteractionDate: null,
								litIconUrl: "",
								extinguishedIconUrl: "",
								fontColor: "#ff6f00",
							};
						}

						// 保存聊天数据到数据库
						await db.chats.put(chat);

						// 应用自定义CSS样式
						applyScopedCss(chat.settings.customCss, "#chat-messages", "custom-bubble-style");

						// 关闭设置模态框并重新渲染聊天界面
						chatSettingsModal.classList.remove("visible");
						renderChatInterface(state.activeChatId);
						renderChatList();
					});

					// 清空聊天记录按钮事件：清除消息和心声记录
					document.getElementById("clear-chat-btn").addEventListener("click", async () => {
						if (!state.activeChatId) return;
						const chat = state.chats[state.activeChatId];
						const confirmed = await showCustomConfirm("清空记录", "确定要清空此聊天的【消息和心声】吗？\n（聊天总结将被保留）", { confirmButtonClass: "btn-danger" });
						if (confirmed) {
							// 只保留类型为 'summary' 的消息
							chat.history = chat.history.filter((msg) => msg.type === "summary");

							// 清空心声记录
							if (chat.innerVoiceHistory) {
								chat.innerVoiceHistory = [];
							}
							chat.latestInnerVoice = null;

							await db.chats.put(chat);
							renderChatInterface(state.activeChatId);
							renderChatList();
							chatSettingsModal.classList.remove("visible");

							alert("聊天消息和心声已清空！");
						}
					});

					// 导出聊天记录按钮事件：调用导出函数
					document.getElementById("export-chat-history-btn").addEventListener("click", exportChatHistory);

					// 导入聊天记录按钮事件：触发隐藏的文件选择框
					document.getElementById("import-chat-history-btn").addEventListener("click", () => {
						document.getElementById("import-chat-history-input").click();
					});

					// 隐藏的文件选择框事件：处理导入的聊天记录文件
					document.getElementById("import-chat-history-input").addEventListener("change", (event) => {
						const file = event.target.files[0];
						if (file) {
							importChatHistory(file);
						}
						event.target.value = null;
					});

					// 图片上传处理函数：设置文件上传回调
					const setupFileUpload = (inputId, callback) => {
						document.getElementById(inputId).addEventListener("change", async (event) => {
							const file = event.target.files[0];
							if (file) {
								try {
									// 调用通用压缩函数处理图片
									const compressedDataUrl = await handleImageUploadAndCompress(file);
									callback(compressedDataUrl);
								} catch (error) {
									console.error(`处理文件 ${file.name} 失败:`, error);
									alert(`处理图片失败: ${error.message}`);
								} finally {
									event.target.value = null;
								}
							}
						});
					};

					// 为各个头像和背景图片设置上传处理
					setupFileUpload("ai-avatar-input", (base64) => (document.getElementById("ai-avatar-preview").src = base64));
					setupFileUpload("my-avatar-input", (base64) => (document.getElementById("my-avatar-preview").src = base64));
					setupFileUpload("group-avatar-input", (base64) => (document.getElementById("group-avatar-preview").src = base64));
					setupFileUpload("member-avatar-input", (base64) => (document.getElementById("member-avatar-preview").src = base64));
					setupFileUpload("bg-input", (base64) => {
						if (state.activeChatId) {
							state.chats[state.activeChatId].settings.background = base64;
							const bgPreview = document.getElementById("bg-preview");
							bgPreview.src = base64;
							bgPreview.style.display = "block";
							document.getElementById("remove-bg-btn").style.display = "inline-block";
						}
					});
					setupFileUpload("preset-avatar-input", (base64) => (document.getElementById("preset-avatar-preview").src = base64));
					setupFileUpload("char-video-image-input", (base64) => (document.getElementById("char-video-image-preview").src = base64));
					setupFileUpload("user-video-image-input", (base64) => (document.getElementById("user-video-image-preview").src = base64));

					// 移除背景按钮事件：清除聊天背景设置
					document.getElementById("remove-bg-btn").addEventListener("click", () => {
						if (state.activeChatId) {
							state.chats[state.activeChatId].settings.background = "";
							const bgPreview = document.getElementById("bg-preview");
							bgPreview.src = "";
							bgPreview.style.display = "none";
							document.getElementById("remove-bg-btn").style.display = "none";
						}
					});

					// 表情包面板相关事件处理
					const stickerPanel = document.getElementById("sticker-panel");
					document.getElementById("open-sticker-panel-btn").addEventListener("click", () => {
						renderStickerPanel();
						stickerPanel.classList.add("visible");
					});
					document.getElementById("close-sticker-panel-btn").addEventListener("click", () => stickerPanel.classList.remove("visible"));

					// 添加表情按钮事件：打开批量添加表情模态框
					document.getElementById("add-sticker-btn").addEventListener("click", openBulkAddStickersModal);

					// 上传表情按钮事件：触发隐藏的表情上传输入框
					document.getElementById("upload-sticker-btn").addEventListener("click", () => document.getElementById("sticker-upload-input").click());

					// 表情上传输入框事件：处理多选表情文件上传
					document.getElementById("sticker-upload-input").addEventListener("change", async (event) => {
						const files = event.target.files;
						if (!files.length) return;

						const newStickers = [];
						let canceled = false;

						// 逐个处理选中的文件
						for (const file of files) {
							if (canceled) break;

							// 生成临时预览URL
							const previewUrl = URL.createObjectURL(file);

							// 显示命名对话框（带预览图）
							const name = await showCustomPrompt(`为表情命名 (${newStickers.length + 1}/${files.length})`, "请输入表情名称", file.name.replace(/\.[^/.]+$/, ""), "text", `<img src="${previewUrl}" style="max-width: 100px; max-height: 100px; margin-bottom: 10px; border-radius: 8px;">`);

							// 释放临时URL
							URL.revokeObjectURL(previewUrl);

							if (name && name.trim()) {
								// 读取文件并准备保存
								const base64Url = await new Promise((resolve) => {
									const reader = new FileReader();
									reader.onload = (e) => resolve(e.target.result);
									reader.readAsDataURL(file);
								});

								newStickers.push({
									id: "sticker_" + (Date.now() + newStickers.length),
									url: base64Url,
									name: name.trim(),
								});
							} else if (name === null) {
								// 用户取消操作确认
								const confirmCancel = await showCustomConfirm("确认取消", "确定要取消剩余表情的上传吗？");
								if (confirmCancel) {
									canceled = true;
								}
							} else {
								alert("表情名不能为空！");
							}
						}

						// 批量添加新表情到数据库
						if (newStickers.length > 0) {
							await db.userStickers.bulkAdd(newStickers);
							state.userStickers.push(...newStickers);
							renderStickerPanel();
							await showCustomAlert("上传成功", `已成功添加 ${newStickers.length} 个新表情！`);
						}

						// 清空文件选择器
						event.target.value = null;
					});

					// 上传图片按钮事件：触发隐藏的图片上传输入框
					document.getElementById("upload-image-btn").addEventListener("click", () => document.getElementById("image-upload-input").click());

					// 图片上传处理事件：读取并保存用户上传的图片
					document.getElementById("image-upload-input").addEventListener("change", async (event) => {
						const file = event.target.files[0];
						if (!file || !state.activeChatId) return;
						const reader = new FileReader();
						reader.onload = async (e) => {
							const base64Url = e.target.result;
							const chat = state.chats[state.activeChatId];
							// 创建包含图片的消息对象
							const msg = { role: "user", content: [{ type: "image_url", image_url: { url: base64Url } }], timestamp: Date.now() };
							chat.history.push(msg);
							await db.chats.put(chat);
							appendMessage(msg, chat);
							renderChatList();
						};
						reader.readAsDataURL(file);
						event.target.value = null;
					});

					// 发送语音消息按钮事件：显示输入框并创建语音消息
					document.getElementById("voice-message-btn").addEventListener("click", async () => {
						if (!state.activeChatId) return;
						const text = await showCustomPrompt("发送语音", "请输入你想说的内容：");
						if (text && text.trim()) {
							const chat = state.chats[state.activeChatId];
							// 创建语音消息对象
							const msg = { role: "user", type: "voice_message", content: text.trim(), timestamp: Date.now() };
							chat.history.push(msg);
							await db.chats.put(chat);
							appendMessage(msg, chat);
							renderChatList();
						}
					});

					// 发送照片按钮事件：显示描述输入框并创建照片消息
					document.getElementById("send-photo-btn").addEventListener("click", async () => {
						if (!state.activeChatId) return;
						const description = await showCustomPrompt("发送照片", "请用文字描述您要发送的照片：");
						if (description && description.trim()) {
							const chat = state.chats[state.activeChatId];
							// 创建用户照片消息对象
							const msg = { role: "user", type: "user_photo", content: description.trim(), timestamp: Date.now() };
							chat.history.push(msg);
							await db.chats.put(chat);
							appendMessage(msg, chat);
							renderChatList();
						}
					});

					// 外卖请求功能相关事件处理
					const waimaiModal = document.getElementById("waimai-request-modal");

					// 发起外卖请求按钮事件：显示外卖请求模态框
					document.getElementById("send-waimai-request-btn").addEventListener("click", () => {
						waimaiModal.classList.add("visible");
					});

					// 外卖请求取消按钮事件：隐藏外卖请求模态框
					document.getElementById("waimai-cancel-btn").addEventListener("click", () => {
						waimaiModal.classList.remove("visible");
					});

					// 外卖请求确认按钮事件：验证输入并创建外卖请求消息
					document.getElementById("waimai-confirm-btn").addEventListener("click", async () => {
						if (!state.activeChatId) return;

						const productInfoInput = document.getElementById("waimai-product-info");
						const amountInput = document.getElementById("waimai-amount");

						const productInfo = productInfoInput.value.trim();
						const amount = parseFloat(amountInput.value);

						// 验证商品信息输入
						if (!productInfo) {
							alert("请输入商品信息！");
							return;
						}
						// 验证金额输入
						if (isNaN(amount) || amount <= 0) {
							alert("请输入有效的代付金额！");
							return;
						}

						const chat = state.chats[state.activeChatId];
						const now = Date.now();

						const myNickname = chat.isGroup ? chat.settings.myNickname || "我" : "我";

						// 创建外卖请求消息对象
						const msg = {
							role: "user",
							senderName: myNickname,
							type: "waimai_request",
							productInfo: productInfo,
							amount: amount,
							status: "pending",
							countdownEndTime: now + 15 * 60 * 1000, // 15分钟倒计时
							timestamp: now,
						};

						chat.history.push(msg);

						await db.chats.put(chat);
						appendMessage(msg, chat);
						renderChatList();

						// 清空输入框并隐藏模态框
						productInfoInput.value = "";
						amountInput.value = "";
						waimaiModal.classList.remove("visible");
					});

					// 人设库相关按钮事件
					document.getElementById("open-persona-library-btn").addEventListener("click", openPersonaLibrary);
					document.getElementById("close-persona-library-btn").addEventListener("click", closePersonaLibrary);
					document.getElementById("add-persona-preset-btn").addEventListener("click", openPersonaEditorForCreate);
					document.getElementById("cancel-persona-editor-btn").addEventListener("click", closePersonaEditor);

					// 预设操作按钮事件
					document.getElementById("preset-action-edit").addEventListener("click", openPersonaEditorForEdit);
					document.getElementById("preset-action-delete").addEventListener("click", deletePersonaPreset);
					document.getElementById("preset-action-cancel").addEventListener("click", hidePresetActions);

					// 消息选择取消按钮事件：退出选择模式
					document.getElementById("selection-cancel-btn").addEventListener("click", exitSelectionMode);

					// 批量删除消息按钮事件：删除选中的消息并添加系统提示
					document.getElementById("selection-delete-btn").addEventListener("click", async () => {
						if (selectedMessages.size === 0) return;
						const confirmed = await showCustomConfirm("删除消息", `确定要删除选中的 ${selectedMessages.size} 条消息吗？这将改变AI的记忆。`, { confirmButtonClass: "btn-danger" });
						if (confirmed) {
							const chat = state.chats[state.activeChatId];

							// 检查被删除的消息中是否包含投票
							let deletedPollsInfo = [];
							for (const timestamp of selectedMessages) {
								const msg = chat.history.find((m) => m.timestamp === timestamp);
								if (msg && msg.type === "poll") {
									deletedPollsInfo.push(`关于“${msg.question}”的投票(时间戳: ${msg.timestamp})`);
								}
							}

							// 从历史记录中移除选中的消息
							chat.history = chat.history.filter((msg) => !selectedMessages.has(msg.timestamp));

							// 构建遗忘指令，通知AI这些消息已被删除
							let forgetReason = "一些之前的消息已被用户删除。";
							if (deletedPollsInfo.length > 0) {
								forgetReason += ` 其中包括以下投票：${deletedPollsInfo.join("；")}。`;
							}
							forgetReason += " 你应该像它们从未存在过一样继续对话，并相应地调整你的记忆和行为，不要再提及这些被删除的内容。";

							const forgetInstruction = {
								role: "system",
								content: `[系统提示：${forgetReason}]`,
								timestamp: Date.now(),
								isHidden: true,
							};
							chat.history.push(forgetInstruction);

							// 保存更新后的聊天记录
							await db.chats.put(chat);

							// 更新UI显示
							renderChatInterface(state.activeChatId);
							renderChatList();
						}
					});

					// 重置字体按钮事件：恢复默认字体设置
					document.getElementById("reset-font-btn").addEventListener("click", resetToDefaultFont);

					// 聊天列表底部导航项点击事件：切换不同的视图
					document.querySelectorAll("#chat-list-bottom-nav .nav-item").forEach((item) => {
						item.addEventListener("click", () => switchToChatListView(item.dataset.view));
					});

					// Qzone返回按钮事件：返回消息视图
					document.getElementById("qzone-back-btn").addEventListener("click", () => switchToChatListView("messages-view"));

					// Qzone昵称点击事件：修改用户昵称
					document.getElementById("qzone-nickname").addEventListener("click", async () => {
						const newNickname = await showCustomPrompt("修改昵称", "请输入新的昵称", state.qzoneSettings.nickname);
						if (newNickname && newNickname.trim()) {
							state.qzoneSettings.nickname = newNickname.trim();
							await saveQzoneSettings();
							renderQzoneScreen();
						}
					});

					// Qzone头像容器点击事件：触发头像上传
					document.getElementById("qzone-avatar-container").addEventListener("click", () => document.getElementById("qzone-avatar-input").click());

					// Qzone背景图容器点击事件：触发背景图上传
					document.getElementById("qzone-banner-container").addEventListener("click", () => document.getElementById("qzone-banner-input").click());

					// Qzone头像上传处理事件：读取并保存新头像
					document.getElementById("qzone-avatar-input").addEventListener("change", async (event) => {
						const file = event.target.files[0];
						if (file) {
							const dataUrl = await new Promise((res) => {
								const reader = new FileReader();
								reader.onload = () => res(reader.result);
								reader.readAsDataURL(file);
							});
							state.qzoneSettings.avatar = dataUrl;
							await saveQzoneSettings();
							renderQzoneScreen();
						}
						event.target.value = null;
					});

					// Qzone背景图上传处理事件：读取并保存新背景图
					document.getElementById("qzone-banner-input").addEventListener("change", async (event) => {
						const file = event.target.files[0];
						if (file) {
							const dataUrl = await new Promise((res) => {
								const reader = new FileReader();
								reader.onload = () => res(reader.result);
								reader.readAsDataURL(file);
							});
							state.qzoneSettings.banner = dataUrl;
							await saveQzoneSettings();
							renderQzoneScreen();
						}
						event.target.value = null;
					});

					// 创建说说按钮事件：打开说说发布界面
					document.getElementById("create-shuoshuo-btn").addEventListener("click", () => openQZonePublisher("shuoshuo"));

					// 创建动态按钮事件：打开复杂动态发布界面
					document.getElementById("create-post-btn").addEventListener("click", () => openQZonePublisher("complex"));

					// 打开相册按钮事件：渲染并显示相册列表
					document.getElementById("open-album-btn").addEventListener("click", async () => {
						await renderAlbumList();
						showScreen("album-screen");
					});

					// 相册返回按钮事件：返回Qzone界面
					document.getElementById("album-back-btn").addEventListener("click", () => {
						showScreen("chat-list-screen");
						switchToChatListView("qzone-screen");
					});

					// 相册照片返回按钮事件：返回相册列表
					document.getElementById("album-photos-back-btn").addEventListener("click", () => {
						state.activeAlbumId = null;
						showScreen("album-screen");
					});

					// 上传照片按钮事件：触发照片上传输入框
					document.getElementById("album-upload-photo-btn").addEventListener("click", () => document.getElementById("album-photo-input").click());

					// 相册照片上传处理事件：读取并保存上传的照片
					document.getElementById("album-photo-input").addEventListener("change", async (event) => {
						if (!state.activeAlbumId) return;
						const files = event.target.files;
						if (!files.length) return;

						const album = await db.qzoneAlbums.get(state.activeAlbumId);

						// 处理每一张上传的照片
						for (const file of files) {
							const dataUrl = await new Promise((resolve) => {
								const reader = new FileReader();
								reader.onload = () => resolve(reader.result);
								reader.readAsDataURL(file);
							});
							await db.qzonePhotos.add({ albumId: state.activeAlbumId, url: dataUrl, createdAt: Date.now() });
						}

						// 更新相册照片数量和封面
						const photoCount = await db.qzonePhotos.where("albumId").equals(state.activeAlbumId).count();
						const updateData = { photoCount };

						if (!album.photoCount || album.coverUrl.includes("placeholder")) {
							const firstPhoto = await db.qzonePhotos.where("albumId").equals(state.activeAlbumId).first();
							if (firstPhoto) updateData.coverUrl = firstPhoto.url;
						}

						await db.qzoneAlbums.update(state.activeAlbumId, updateData);
						await renderAlbumPhotosScreen();
						await renderAlbumList();

						event.target.value = null;
						alert("照片上传成功！");
					});

					// 相册照片网格点击事件：处理照片删除或查看
					document.getElementById("photos-grid-page").addEventListener("click", async (e) => {
						const deleteBtn = e.target.closest(".photo-delete-btn");
						const photoThumb = e.target.closest(".photo-thumb");

						if (deleteBtn) {
							// 处理照片删除
							e.stopPropagation();
							const photoId = parseInt(deleteBtn.dataset.photoId);
							const confirmed = await showCustomConfirm("删除照片", "确定要删除这张照片吗？此操作不可恢复。", { confirmButtonClass: "btn-danger" });

							if (confirmed) {
								const deletedPhoto = await db.qzonePhotos.get(photoId);
								if (!deletedPhoto) return;

								await db.qzonePhotos.delete(photoId);

								const album = await db.qzoneAlbums.get(state.activeAlbumId);
								const photoCount = (album.photoCount || 1) - 1;
								const updateData = { photoCount };

								// 如果删除的是封面照片，更新为下一张照片或默认封面
								if (album.coverUrl === deletedPhoto.url) {
									const nextPhoto = await db.qzonePhotos.where("albumId").equals(state.activeAlbumId).first();
									updateData.coverUrl = nextPhoto ? nextPhoto.url : "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png";
								}

								await db.qzoneAlbums.update(state.activeAlbumId, updateData);
								await renderAlbumPhotosScreen();
								await renderAlbumList();
								alert("照片已删除。");
							}
						} else if (photoThumb) {
							// 处理照片查看
							openPhotoViewer(photoThumb.src);
						}
					});

					// 照片查看器关闭按钮事件
					document.getElementById("photo-viewer-close-btn").addEventListener("click", closePhotoViewer);

					// 下一张照片按钮事件
					document.getElementById("photo-viewer-next-btn").addEventListener("click", showNextPhoto);

					// 上一张照片按钮事件
					document.getElementById("photo-viewer-prev-btn").addEventListener("click", showPrevPhoto);

					// 键盘事件处理：支持箭头键和ESC键操作照片查看器
					document.addEventListener("keydown", (e) => {
						if (!photoViewerState.isOpen) return;

						if (e.key === "ArrowRight") {
							showNextPhoto();
						} else if (e.key === "ArrowLeft") {
							showPrevPhoto();
						} else if (e.key === "Escape") {
							closePhotoViewer();
						}
					});

					// 创建相册按钮事件：显示输入框并创建新相册
					document.getElementById("create-album-btn-page").addEventListener("click", async () => {
						const albumName = await showCustomPrompt("创建新相册", "请输入相册名称");
						if (albumName && albumName.trim()) {
							const newAlbum = { name: albumName.trim(), coverUrl: "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png", photoCount: 0, createdAt: Date.now() };
							await db.qzoneAlbums.add(newAlbum);
							await renderAlbumList();
							alert(`相册 "${albumName}" 创建成功！`);
						} else if (albumName !== null) {
							alert("相册名称不能为空！");
						}
					});

					// 取消创建动态按钮事件：隐藏创建动态模态框
					document.getElementById("cancel-create-post-btn").addEventListener("click", () => document.getElementById("create-post-modal").classList.remove("visible"));

					// 动态上传本地图片按钮事件：触发本地图片上传
					document.getElementById("post-upload-local-btn").addEventListener("click", () => document.getElementById("post-local-image-input").click());

					// 动态本地图片上传处理事件：读取并显示图片预览
					document.getElementById("post-local-image-input").addEventListener("change", (event) => {
						const file = event.target.files[0];
						if (file) {
							const reader = new FileReader();
							reader.onload = (e) => {
								document.getElementById("post-image-preview").src = e.target.result;
								document.getElementById("post-image-preview-container").classList.add("visible");
								document.getElementById("post-image-desc-group").style.display = "block";
							};
							reader.readAsDataURL(file);
						}
					});

					// 动态使用URL图片按钮事件：显示URL输入框并加载图片
					document.getElementById("post-use-url-btn").addEventListener("click", async () => {
						const url = await showCustomPrompt("输入图片URL", "请输入网络图片的链接", "", "url");
						if (url) {
							document.getElementById("post-image-preview").src = url;
							document.getElementById("post-image-preview-container").classList.add("visible");
							document.getElementById("post-image-desc-group").style.display = "block";
						}
					});

					// 动态移除图片按钮事件：重置创建动态模态框
					document.getElementById("post-remove-image-btn").addEventListener("click", () => resetCreatePostModal());

					// 图片模式切换按钮事件处理
					const imageModeBtn = document.getElementById("switch-to-image-mode");
					const textImageModeBtn = document.getElementById("switch-to-text-image-mode");
					const imageModeContent = document.getElementById("image-mode-content");
					const textImageModeContent = document.getElementById("text-image-mode-content");

					// 切换到图片模式
					imageModeBtn.addEventListener("click", () => {
						imageModeBtn.classList.add("active");
						textImageModeBtn.classList.remove("active");
						imageModeContent.classList.add("active");
						textImageModeContent.classList.remove("active");
					});

					// 切换到文字图模式
					textImageModeBtn.addEventListener("click", () => {
						textImageModeBtn.classList.add("active");
						imageModeBtn.classList.remove("active");
						textImageModeContent.classList.add("active");
						imageModeContent.classList.remove("active");
					});

					// 确认创建动态按钮事件：根据模式处理不同类型的发布
					document.getElementById("confirm-create-post-btn").addEventListener("click", async () => {
						const modal = document.getElementById("create-post-modal");
						const mode = modal.dataset.mode;

						// 处理小组发帖模式
						if (mode === "forum") {
							await handleCreateForumPost();
							return;
						}

						// 处理微博发布模式
						if (mode === "weibo") {
							await handlePublishWeibo();
							return;
						}

						// 处理Qzone动态发布和编辑
						const editingId = parseInt(modal.dataset.editingPostId);
						const areCommentsVisible = document.getElementById("post-comments-toggle").checked;

						const visibility = document.querySelector('input[name="visibility"]:checked').value;
						let visibleGroupIds = null;
						if (visibility === "groups") {
							visibleGroupIds = Array.from(document.querySelectorAll("#post-visibility-groups input:checked")).map((cb) => parseInt(cb.value));
							if (visibleGroupIds.length === 0) {
								alert("请至少选择一个可见的分组！");
								return;
							}
						}

						let postData = {};

						if (mode === "edit") {
							// 编辑现有动态
							const existingPost = await db.qzonePosts.get(editingId);
							if (!existingPost) {
								alert("错误：找不到要编辑的动态！");
								return;
							}
							postData = {
								...existingPost,
								areCommentsVisible: areCommentsVisible,
								visibleGroupIds: visibleGroupIds,
							};

							if (postData.type === "shuoshuo") {
								postData.content = document.getElementById("post-public-text").value.trim();
							} else {
								postData.publicText = document.getElementById("post-public-text").value.trim();
								if (postData.type === "image_post") {
									postData.imageUrl = document.getElementById("post-image-preview").src;
									postData.imageDescription = document.getElementById("post-image-description").value.trim();
								} else if (postData.type === "text_image") {
									postData.hiddenContent = document.getElementById("post-hidden-text").value.trim();
								}
							}
							await db.qzonePosts.put(postData);
						} else {
							// 创建新动态
							const basePostData = {
								timestamp: Date.now(),
								authorId: "user",
								areCommentsVisible: areCommentsVisible,
								visibleGroupIds: visibleGroupIds,
							};

							if (mode === "shuoshuo") {
								const content = document.getElementById("post-public-text").value.trim();
								if (!content) return alert("说说内容不能为空哦！");
								postData = { ...basePostData, type: "shuoshuo", content: content };
							} else {
								const publicText = document.getElementById("post-public-text").value.trim();
								const isImageModeActive = document.getElementById("image-mode-content").classList.contains("active");
								if (isImageModeActive) {
									const imageUrl = document.getElementById("post-image-preview").src;
									const imageDescription = document.getElementById("post-image-description").value.trim();
									if (!imageUrl || !(imageUrl.startsWith("http") || imageUrl.startsWith("data:"))) return alert("请先添加一张图片再发布动态哦！");
									if (!imageDescription) return alert("请为你的图片添加一个简单的描述（必填，给AI看的）！");
									postData = { ...basePostData, type: "image_post", publicText, imageUrl, imageDescription };
								} else {
									const hiddenText = document.getElementById("post-hidden-text").value.trim();
									if (!hiddenText) return alert("请输入文字图描述！");
									postData = { ...basePostData, type: "text_image", publicText, hiddenContent: hiddenText };
								}
							}
							const newPostId = await db.qzonePosts.add(postData);
							postData.id = newPostId;
						}

						// 创建动态摘要并通知所有聊天
						let postSummary = postData.content || postData.publicText || postData.imageDescription || postData.hiddenContent || "（无文字内容）";
						postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? "..." : "");
						for (const chatId in state.chats) {
							const chat = state.chats[chatId];
							if (chat.isGroup) continue;
							const historyMessage = { role: "system", content: `[系统提示：用户${editingId ? "编辑了" : "发布了"}一条动态(ID: ${editingId || postData.id})，内容摘要是：“${postSummary}”。]`, timestamp: Date.now(), isHidden: true };
							chat.history.push(historyMessage);
							await db.chats.put(chat);
						}

						// 更新UI并显示成功消息
						await renderQzonePosts();
						modal.classList.remove("visible");
						delete modal.dataset.editingPostId;
						delete modal.dataset.mode;
						alert(`动态${editingId ? "编辑" : "发布"}成功！`);
					});

					// 全局聊天背景上传事件处理：读取并预览上传的背景图片
					document.getElementById("global-bg-upload-input").addEventListener("change", async (event) => {
						const file = event.target.files[0];
						if (file) {
							const dataUrl = await new Promise((res) => {
								const reader = new FileReader();
								reader.onload = () => res(reader.result);
								reader.readAsDataURL(file);
							});
							newGlobalBgBase64 = dataUrl; // 将新背景存入临时变量
							// 实时更新预览
							const preview = document.getElementById("global-bg-preview");
							preview.style.backgroundImage = `url(${dataUrl})`;
							preview.textContent = "";
						}
					});

					// 移除全局聊天背景事件处理：设置特殊标记并更新预览
					document.getElementById("remove-global-bg-btn").addEventListener("click", () => {
						newGlobalBgBase64 = "REMOVED"; // 用一个特殊标记表示"移除"
						const preview = document.getElementById("global-bg-preview");
						preview.style.backgroundImage = "none";
						preview.textContent = "已移除";
						alert("全局背景将在点击'保存'后被移除。");
					});

					// 一键清空所有单人聊天背景事件处理
					document.getElementById("clear-all-single-bgs-btn").addEventListener("click", clearAllSingleChatBackgrounds);

					// 滑动状态管理对象
					const postsList = document.getElementById("qzone-posts-list");
					let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };

					// 重置所有滑动状态（除了指定的容器）
					function resetAllSwipes(exceptThisOne = null) {
						document.querySelectorAll(".qzone-post-container").forEach((container) => {
							if (container !== exceptThisOne) {
								container.querySelector(".qzone-post-item").classList.remove("swiped");
							}
						});
					}

					// 处理滑动开始事件
					const handleSwipeStart = (e) => {
						const targetContainer = e.target.closest(".qzone-post-container");
						if (!targetContainer) return;

						resetAllSwipes(targetContainer);
						swipeState.activeContainer = targetContainer;
						swipeState.isDragging = true;
						swipeState.isClick = true;
						swipeState.swipeDirection = null;
						swipeState.startX = e.type.includes("mouse") ? e.pageX : e.touches[0].pageX;
						swipeState.startY = e.type.includes("mouse") ? e.pageY : e.touches[0].pageY;
						swipeState.activeContainer.querySelector(".qzone-post-item").style.transition = "none";
					};

					// 处理滑动移动事件
					const handleSwipeMove = (e) => {
						if (!swipeState.isDragging || !swipeState.activeContainer) return;

						const currentX = e.type.includes("mouse") ? e.pageX : e.touches[0].pageX;
						const currentY = e.type.includes("mouse") ? e.pageY : e.touches[0].pageY;
						const diffX = currentX - swipeState.startX;
						const diffY = currentY - swipeState.startY;
						const absDiffX = Math.abs(diffX);
						const absDiffY = Math.abs(diffY);
						const clickThreshold = 5;

						// 判断是否为点击操作
						if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
							swipeState.isClick = false;
						}

						// 确定滑动方向
						if (swipeState.swipeDirection === null) {
							if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
								if (absDiffX > absDiffY) {
									swipeState.swipeDirection = "horizontal";
								} else {
									swipeState.swipeDirection = "vertical";
								}
							}
						}

						// 垂直滑动时结束处理
						if (swipeState.swipeDirection === "vertical") {
							handleSwipeEnd(e);
							return;
						}

						// 水平滑动处理
						if (swipeState.swipeDirection === "horizontal") {
							e.preventDefault();
							swipeState.currentX = currentX;
							let translation = diffX;
							if (translation > 0) translation = 0;
							if (translation < -90) translation = -90;
							swipeState.activeContainer.querySelector(".qzone-post-item").style.transform = `translateX(${translation}px)`;
						}
					};

					// 处理滑动结束事件
					const handleSwipeEnd = (e) => {
						if (swipeState.isClick) {
							swipeState.isDragging = false;
							swipeState.activeContainer = null;
							return;
						}
						if (!swipeState.isDragging || !swipeState.activeContainer) return;

						const postItem = swipeState.activeContainer.querySelector(".qzone-post-item");
						postItem.style.transition = "transform 0.3s ease";

						const finalX = e.type.includes("touchend") ? e.changedTouches[0].pageX : e.pageX;
						const diffX = finalX - swipeState.startX;
						const swipeThreshold = -40;

						// 根据滑动距离决定是否保持滑动状态
						if (swipeState.swipeDirection === "horizontal" && diffX < swipeThreshold) {
							postItem.classList.add("swiped");
							postItem.style.transform = "";
						} else {
							postItem.classList.remove("swiped");
							postItem.style.transform = "";
						}

						// 重置滑动状态
						swipeState.isDragging = false;
						swipeState.startX = 0;
						swipeState.startY = 0;
						swipeState.currentX = 0;
						swipeState.activeContainer = null;
						swipeState.swipeDirection = null;
						swipeState.isClick = true;
					};

					// 绑定所有滑动事件
					postsList.addEventListener("mousedown", handleSwipeStart);
					document.addEventListener("mousemove", handleSwipeMove);
					document.addEventListener("mouseup", handleSwipeEnd);
					postsList.addEventListener("touchstart", handleSwipeStart, { passive: false });
					postsList.addEventListener("touchmove", handleSwipeMove, { passive: false });
					postsList.addEventListener("touchend", handleSwipeEnd);

					// 动态列表点击事件处理：处理各种交互操作
					postsList.addEventListener("click", async (e) => {
						e.stopPropagation();
						const target = e.target;

						// 处理NPC召唤按钮点击
						const summonBtn = target.closest(".action-icon.summon-npc");
						if (summonBtn) {
							const postId = parseInt(summonBtn.dataset.postId);
							const authorId = summonBtn.dataset.authorId;
							if (!isNaN(postId) && authorId) {
								handleNpcSummonClick(postId, authorId);
							}
							return; // 处理完召唤逻辑后，直接结束，不执行后续的点赞等判断
						}

						// 处理评论项点击（用于回复）
						const commentItem = target.closest(".comment-item");
						// 确保点击的不是删除按钮或评论里的名字链接
						if (commentItem && !target.classList.contains("comment-delete-btn") && !target.classList.contains("commenter-name") && !target.classList.contains("reply-target-name")) {
							const postContainer = commentItem.closest(".qzone-post-container");
							if (postContainer) {
								const commenterName = commentItem.dataset.commenterName;
								const myNickname = state.qzoneSettings.nickname;

								// 如果点击的是自己的评论，则不进入回复模式
								if (commenterName !== myNickname) {
									const commentInput = postContainer.querySelector(".comment-input");
									commentInput.placeholder = `回复 ${commenterName}:`;
									commentInput.dataset.replyTo = commenterName; // 把要回复的人的名字，临时存起来
									commentInput.focus(); // 自动聚焦到输入框
								}
							}
							return; // 处理完点击评论后，就不用往下执行了
						}

						// 处理评论删除按钮点击
						if (target.classList.contains("comment-delete-btn")) {
							const postContainer = target.closest(".qzone-post-container");
							if (!postContainer) return;
							const postId = parseInt(postContainer.dataset.postId);
							const commentIndex = parseInt(target.dataset.commentIndex);
							if (isNaN(postId) || isNaN(commentIndex)) return;
							const post = await db.qzonePosts.get(postId);
							if (!post || !post.comments || !post.comments[commentIndex]) return;
							const commentText = post.comments[commentIndex].text;
							const confirmed = await showCustomConfirm("删除评论", `确定要删除这条评论吗？\n\n"${commentText.substring(0, 50)}..."`, { confirmButtonClass: "btn-danger" });
							if (confirmed) {
								post.comments.splice(commentIndex, 1);
								await db.qzonePosts.update(postId, { comments: post.comments });
								await renderQzonePosts();
								alert("评论已删除。");
							}
							return;
						}

						// 处理动态操作按钮点击
						if (target.classList.contains("post-actions-btn")) {
							const container = target.closest(".qzone-post-container");
							if (container && container.dataset.postId) showPostActions(parseInt(container.dataset.postId));
							return;
						}

						// 处理动态删除操作
						if (target.closest(".qzone-post-delete-action")) {
							const container = target.closest(".qzone-post-delete-action").parentElement;
							if (!container) return;
							const postIdToDelete = parseInt(container.dataset.postId);
							if (isNaN(postIdToDelete)) return;
							const confirmed = await showCustomConfirm("删除动态", "确定要永久删除这条动态吗？", { confirmButtonClass: "btn-danger" });
							if (confirmed) {
								container.style.transition = "all 0.3s ease";
								container.style.transform = "scale(0.8)";
								container.style.opacity = "0";
								setTimeout(async () => {
									await db.qzonePosts.delete(postIdToDelete);
									const notificationIdentifier = `(ID: ${postIdToDelete})`;
									for (const chatId in state.chats) {
										const chat = state.chats[chatId];
										const originalHistoryLength = chat.history.length;
										chat.history = chat.history.filter((msg) => !(msg.role === "system" && msg.content.includes(notificationIdentifier)));
										if (chat.history.length < originalHistoryLength) await db.chats.put(chat);
									}
									await renderQzonePosts();
									alert("动态已删除。");
								}, 300);
							}
							return;
						}

						// 处理隐藏文字图片点击
						if (target.tagName === "IMG" && target.dataset.hiddenText) {
							showCustomAlert("图片内容", target.dataset.hiddenText.replace(/<br>/g, "\n"));
							return;
						}

						// 处理点赞和收藏操作
						const icon = target.closest(".action-icon");
						if (icon) {
							const postContainer = icon.closest(".qzone-post-container");
							if (!postContainer) return;
							const postId = parseInt(postContainer.dataset.postId);
							if (isNaN(postId)) return;
							if (icon.classList.contains("like")) {
								const post = await db.qzonePosts.get(postId);
								if (!post) return;
								if (!post.likes) post.likes = [];
								const userNickname = state.qzoneSettings.nickname;
								const userLikeIndex = post.likes.indexOf(userNickname);
								if (userLikeIndex > -1) {
									post.likes.splice(userLikeIndex, 1);
								} else {
									post.likes.push(userNickname);
									icon.classList.add("animate-like");
									icon.addEventListener("animationend", () => icon.classList.remove("animate-like"), { once: true });
								}
								await db.qzonePosts.update(postId, { likes: post.likes });
							}
							if (icon.classList.contains("favorite")) {
								const existingFavorite = await db.favorites.where({ type: "qzone_post", "content.id": postId }).first();
								if (existingFavorite) {
									await db.favorites.delete(existingFavorite.id);
									await showCustomAlert("提示", "已取消收藏");
								} else {
									const postToSave = await db.qzonePosts.get(postId);
									if (postToSave) {
										await db.favorites.add({ type: "qzone_post", content: postToSave, timestamp: Date.now() });
										await showCustomAlert("提示", "收藏成功！");
									}
								}
							}
							await renderQzonePosts();
							return;
						}

						// 处理评论发送按钮点击
						const sendBtn = target.closest(".comment-send-btn");
						if (sendBtn) {
							const postContainer = sendBtn.closest(".qzone-post-container");
							if (!postContainer) return;
							const postId = parseInt(postContainer.dataset.postId);
							const commentInput = postContainer.querySelector(".comment-input");
							const commentText = commentInput.value.trim();
							if (!commentText) return alert("评论内容不能为空哦！");
							const post = await db.qzonePosts.get(postId);
							if (!post) return;
							if (!post.comments) post.comments = [];

							// 创建新的评论对象
							const newComment = {
								commenterName: state.qzoneSettings.nickname,
								text: commentText,
								timestamp: Date.now(),
							};

							// 检查是不是在回复模式
							if (commentInput.dataset.replyTo) {
								newComment.replyTo = commentInput.dataset.replyTo; // 如果是，就把回复对象的名字加上
							}

							post.comments.push(newComment);
							await db.qzonePosts.update(postId, { comments: post.comments });
							for (const chatId in state.chats) {
								const chat = state.chats[chatId];
								if (!chat.isGroup) {
									let aiNotification = `[系统提示：'${state.qzoneSettings.nickname}' 在ID为${postId}的动态下发表了评论："${commentText}"`;
									if (newComment.replyTo) {
										aiNotification += ` (这是对'${newComment.replyTo}'的回复)`;
									}
									aiNotification += `]`;
									chat.history.push({ role: "system", content: aiNotification, timestamp: Date.now(), isHidden: true });
									await db.chats.put(chat);
								}
							}

							// 发送后，重置输入框状态
							commentInput.value = "";
							commentInput.placeholder = "友善的评论是交流的起点";
							delete commentInput.dataset.replyTo; // 清除回复状态

							await renderQzonePosts();
							return;
						}
					});

					// 绑定动态页和收藏页的返回按钮事件
					document.getElementById("qzone-back-btn").addEventListener("click", () => switchToChatListView("messages-view"));
					document.getElementById("favorites-back-btn").addEventListener("click", () => switchToChatListView("messages-view"));

					// 收藏页搜索功能相关元素
					const searchInput = document.getElementById("favorites-search-input");
					const searchClearBtn = document.getElementById("favorites-search-clear-btn");

					// 搜索输入事件处理：根据输入内容筛选收藏项
					searchInput.addEventListener("input", () => {
						const searchTerm = searchInput.value.trim().toLowerCase();

						// 控制清除按钮的显示/隐藏
						searchClearBtn.style.display = searchTerm ? "block" : "none";

						if (!searchTerm) {
							displayFilteredFavorites(allFavoriteItems); // 如果搜索框为空，显示所有
							return;
						}

						// 筛选逻辑
						const filteredItems = allFavoriteItems.filter((item) => {
							let contentToSearch = "";
							let authorToSearch = "";

							if (item.type === "qzone_post") {
								const post = item.content;
								contentToSearch += (post.publicText || "") + " " + (post.content || "");
								if (post.authorId === "user") {
									authorToSearch = state.qzoneSettings.nickname;
								} else if (state.chats[post.authorId]) {
									authorToSearch = state.chats[post.authorId].name;
								}
							} else if (item.type === "chat_message") {
								const msg = item.content;
								if (typeof msg.content === "string") {
									contentToSearch = msg.content;
								}
								const chat = state.chats[item.chatId];
								if (chat) {
									if (msg.role === "user") {
										authorToSearch = chat.isGroup ? chat.settings.myNickname || "我" : "我";
									} else {
										authorToSearch = chat.isGroup ? msg.senderName : chat.name;
									}
								}
							}

							// 同时搜索内容和作者，并且不区分大小写
							return contentToSearch.toLowerCase().includes(searchTerm) || authorToSearch.toLowerCase().includes(searchTerm);
						});

						displayFilteredFavorites(filteredItems);
					});

					// 搜索清除按钮事件处理：清空搜索并重置显示
					searchClearBtn.addEventListener("click", () => {
						searchInput.value = "";
						searchClearBtn.style.display = "none";
						displayFilteredFavorites(allFavoriteItems);
						searchInput.focus();
					});

					// 聊天界面批量收藏按钮事件处理
					document.getElementById("selection-favorite-btn").addEventListener("click", async () => {
						if (selectedMessages.size === 0) return;
						const chat = state.chats[state.activeChatId];
						if (!chat) return;

						const favoritesToAdd = [];
						const timestampsToFavorite = [...selectedMessages];

						for (const timestamp of timestampsToFavorite) {
							// 使用新的、高效的索引进行查询
							const existing = await db.favorites.where("originalTimestamp").equals(timestamp).first();

							if (!existing) {
								const messageToSave = chat.history.find((msg) => msg.timestamp === timestamp);
								if (messageToSave) {
									favoritesToAdd.push({
										type: "chat_message",
										content: messageToSave,
										chatId: state.activeChatId,
										timestamp: Date.now(), // 这是收藏操作发生的时间
										originalTimestamp: messageToSave.timestamp, // 保存原始消息的时间戳到新字段
									});
								}
							}
						}

						if (favoritesToAdd.length > 0) {
							await db.favorites.bulkAdd(favoritesToAdd);
							allFavoriteItems = await db.favorites.orderBy("timestamp").reverse().toArray(); // 更新全局收藏缓存
							await showCustomAlert("收藏成功", `已成功收藏 ${favoritesToAdd.length} 条消息。`);
						} else {
							await showCustomAlert("提示", "选中的消息均已收藏过。");
						}

						exitSelectionMode();
					});

					// 收藏页面编辑按钮相关元素
					const favoritesEditBtn = document.getElementById("favorites-edit-btn");
					const favoritesView = document.getElementById("favorites-view");
					const favoritesActionBar = document.getElementById("favorites-action-bar");
					const mainBottomNav = document.getElementById("chat-list-bottom-nav"); // 获取主导航栏
					const favoritesList = document.getElementById("favorites-list"); // 获取收藏列表

					// 收藏页面编辑按钮事件处理：切换编辑模式
					favoritesEditBtn.addEventListener("click", () => {
						isFavoritesSelectionMode = !isFavoritesSelectionMode;
						favoritesView.classList.toggle("selection-mode", isFavoritesSelectionMode);

						if (isFavoritesSelectionMode) {
							// 进入编辑模式
							favoritesEditBtn.textContent = "完成";
							favoritesActionBar.style.display = "block"; // 显示删除操作栏
							mainBottomNav.style.display = "none"; // 隐藏主导航栏
							favoritesList.style.paddingBottom = "80px"; // 给列表底部增加空间
						} else {
							// 退出编辑模式
							favoritesEditBtn.textContent = "编辑";
							favoritesActionBar.style.display = "none"; // 隐藏删除操作栏
							mainBottomNav.style.display = "flex"; // 恢复主导航栏
							favoritesList.style.paddingBottom = ""; // 恢复列表默认padding

							// 退出时清空所有选择
							selectedFavorites.clear();
							document.querySelectorAll(".favorite-item-card.selected").forEach((card) => card.classList.remove("selected"));
							document.getElementById("favorites-delete-selected-btn").textContent = `删除 (0)`;
						}
					});

					// 收藏列表点击事件处理：处理选择和文字图查看
					document.getElementById("favorites-list").addEventListener("click", (e) => {
						const target = e.target;
						const card = target.closest(".favorite-item-card");

						// 处理文字图点击，这段逻辑要放在最前面，保证任何模式下都生效
						if (target.tagName === "IMG" && target.dataset.hiddenText) {
							const hiddenText = target.dataset.hiddenText;
							showCustomAlert("图片内容", hiddenText.replace(/<br>/g, "\n"));
							return; // 处理完就退出，不继续执行选择逻辑
						}

						// 如果不在选择模式，则不执行后续的选择操作
						if (!isFavoritesSelectionMode) return;

						// 处理选择逻辑
						if (!card) return;

						const favId = parseInt(card.dataset.favid);
						if (isNaN(favId)) return;

						// 切换选择状态
						if (selectedFavorites.has(favId)) {
							selectedFavorites.delete(favId);
							card.classList.remove("selected");
						} else {
							selectedFavorites.add(favId);
							card.classList.add("selected");
						}

						// 更新底部删除按钮的计数
						document.getElementById("favorites-delete-selected-btn").textContent = `删除 (${selectedFavorites.size})`;
					});

					// 收藏页面批量删除按钮事件处理
					document.getElementById("favorites-delete-selected-btn").addEventListener("click", async () => {
						if (selectedFavorites.size === 0) return;

						const confirmed = await showCustomConfirm("确认删除", `确定要从收藏夹中移除这 ${selectedFavorites.size} 条内容吗？`, { confirmButtonClass: "btn-danger" });

						if (confirmed) {
							const idsToDelete = [...selectedFavorites];
							await db.favorites.bulkDelete(idsToDelete);
							await showCustomAlert("删除成功", "选中的收藏已被移除。");

							// 从前端缓存中也移除被删除的项
							allFavoriteItems = allFavoriteItems.filter((item) => !idsToDelete.includes(item.id));

							// 使用更新后的缓存，立即重新渲染列表
							displayFilteredFavorites(allFavoriteItems);

							// 最后，再退出编辑模式
							favoritesEditBtn.click(); // 模拟点击"完成"按钮来退出编辑模式
						}
					});

					// 根据全局设置启动后台活动模拟
					if (state.globalSettings.enableBackgroundActivity) {
						startBackgroundSimulation();
						console.log("后台活动模拟已自动启动。");
					}

					// 监听主题选择变化，更新设置预览
					document.querySelectorAll('input[name="theme-select"]').forEach((radio) => {
						radio.addEventListener("change", updateSettingsPreview);
					});

					// 监听字体大小滑块变化，实时更新数值显示和预览
					const fontSizeSlider = document.getElementById("font-size-slider");
					fontSizeSlider.addEventListener("input", () => {
						// 实时更新数值显示
						document.getElementById("font-size-value").textContent = `${fontSizeSlider.value}px`;
						// 更新预览
						updateSettingsPreview();
					});

					// 监听自定义CSS输入框变化，更新预览
					const customCssInputForPreview = document.getElementById("custom-css-input");
					customCssInputForPreview.addEventListener("input", updateSettingsPreview);

					// 监听重置主题按钮点击，恢复默认主题并更新预览
					document.getElementById("reset-theme-btn").addEventListener("click", () => {
						document.getElementById("theme-default").checked = true;
						updateSettingsPreview();
					});

					// 监听重置自定义CSS按钮点击，清空输入并更新预览
					document.getElementById("reset-custom-css-btn").addEventListener("click", () => {
						document.getElementById("custom-css-input").value = "";
						updateSettingsPreview();
					});

					// 监听可见性选项变化，控制分组容器显示/隐藏
					document.querySelectorAll('input[name="visibility"]').forEach((radio) => {
						radio.addEventListener("change", function () {
							const groupsContainer = document.getElementById("post-visibility-groups");
							if (this.value === "include" || this.value === "exclude") {
								groupsContainer.style.display = "block";
							} else {
								groupsContainer.style.display = "none";
							}
						});
					});

					// 绑定管理分组按钮点击事件，打开分组管理器
					document.getElementById("manage-groups-btn").addEventListener("click", openGroupManager);

					// 绑定关闭分组管理器按钮点击事件
					document.getElementById("close-group-manager-btn").addEventListener("click", () => {
						document.getElementById("group-management-modal").classList.remove("visible");
						// 刷新聊天设置里的分组列表
						const chatSettingsBtn = document.getElementById("chat-settings-btn");
						if (document.getElementById("chat-settings-modal").classList.contains("visible")) {
							chatSettingsBtn.click(); // 再次点击以重新打开
						}
					});

					// 绑定添加新分组按钮点击事件
					document.getElementById("add-new-group-btn").addEventListener("click", addNewGroup);

					// 绑定分组列表点击事件，处理分组删除
					document.getElementById("existing-groups-list").addEventListener("click", (e) => {
						if (e.target.classList.contains("delete-group-btn")) {
							const groupId = parseInt(e.target.dataset.id);
							deleteGroup(groupId);
						}
					});

					// 消息操作菜单的取消按钮事件
					document.getElementById("cancel-message-action-btn").addEventListener("click", hideMessageActions);

					// 消息操作菜单的编辑按钮事件，打开高级消息编辑器
					document.getElementById("edit-message-btn").addEventListener("click", openAdvancedMessageEditor);

					// 消息操作菜单的复制按钮事件
					document.getElementById("copy-message-btn").addEventListener("click", copyMessageContent);

					// 消息操作菜单的撤回按钮事件
					document.getElementById("recall-message-btn").addEventListener("click", handleRecallClick);

					// 消息操作菜单的选择按钮事件
					document.getElementById("select-message-btn").addEventListener("click", () => {
						// 在关闭菜单前，先捕获时间戳
						const timestampToSelect = activeMessageTimestamp;
						hideMessageActions();
						// 使用捕获到的值
						if (timestampToSelect) {
							enterSelectionMode(timestampToSelect);
						}
					});

					// 动态操作菜单的编辑按钮事件
					document.getElementById("edit-post-btn").addEventListener("click", openPostEditor);

					// 动态操作菜单的复制按钮事件
					document.getElementById("copy-post-btn").addEventListener("click", copyPostContent);

					// 动态操作菜单的取消按钮事件
					document.getElementById("cancel-post-action-btn").addEventListener("click", hidePostActions);

					// 联系人选择器取消按钮事件
					document.getElementById("cancel-contact-picker-btn").addEventListener("click", () => {
						showScreen("chat-list-screen");
					});

					// 联系人选择器列表点击事件，处理联系人选择
					document.getElementById("contact-picker-list").addEventListener("click", (e) => {
						const item = e.target.closest(".contact-picker-item");
						if (!item) return;

						const contactId = item.dataset.contactId;
						item.classList.toggle("selected");

						if (selectedContacts.has(contactId)) {
							selectedContacts.delete(contactId);
						} else {
							selectedContacts.add(contactId);
						}
						updateContactPickerConfirmButton();
					});

					// 管理群成员按钮事件
					document.getElementById("manage-members-btn").addEventListener("click", () => {
						// 在切换屏幕前，先隐藏当前的聊天设置弹窗
						document.getElementById("chat-settings-modal").classList.remove("visible");
						// 然后再打开成员管理屏幕
						openMemberManagementScreen();
					});

					// 群成员管理返回按钮事件
					document.getElementById("back-from-member-management").addEventListener("click", () => {
						showScreen("chat-interface-screen");
						document.getElementById("chat-settings-btn").click();
					});

					// 添加现有联系人按钮事件
					document.getElementById("add-existing-contact-btn").addEventListener("click", async () => {
						// 为"完成"按钮绑定"拉人入群"的逻辑
						const confirmBtn = document.getElementById("confirm-contact-picker-btn");
						// 使用克隆节点方法清除旧的事件监听器，防止重复绑定
						const newConfirmBtn = confirmBtn.cloneNode(true);
						confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
						newConfirmBtn.addEventListener("click", handleAddMembersToGroup);

						await openContactPickerForAddMember();
					});

					// 创建新成员按钮事件
					document.getElementById("create-new-member-btn").addEventListener("click", createNewMemberInGroup);

					// 视频通话按钮事件
					document.getElementById("video-call-btn").addEventListener("click", handleInitiateCall);

					// 群视频通话按钮事件
					document.getElementById("group-video-call-btn").addEventListener("click", handleInitiateCall);

					// 挂断按钮事件
					document.getElementById("hang-up-btn").addEventListener("click", endVideoCall);

					// 取消呼叫按钮事件
					document.getElementById("cancel-call-btn").addEventListener("click", () => {
						videoCallState.isAwaitingResponse = false;
						showScreen("chat-interface-screen");
					});

					// 加入通话按钮事件
					document.getElementById("join-call-btn").addEventListener("click", handleUserJoinCall);

					// 拒绝来电按钮事件
					document.getElementById("decline-call-btn").addEventListener("click", async () => {
						stopRingtone();
						hideIncomingCallModal();
						const callerChatId = videoCallState.activeChatId; // 从专用信道获取来电者ID
						if (!callerChatId) return;

						const chat = state.chats[callerChatId];
						if (!chat) return;

						// 根据是否群聊，执行不同的拒绝逻辑
						if (videoCallState.isGroupCall) {
							// 对于群聊，拒绝=旁观
							videoCallState.isUserParticipating = false;
							const systemNote = {
								role: "system",
								content: `[系统提示：用户拒绝了通话邀请，但你们可以自己开始。请你们各自决策是否加入。]`,
								timestamp: Date.now(),
								isHidden: true,
							};
							chat.history.push(systemNote);
							await db.chats.put(chat);
							await triggerAiResponse();
						} else {
							// 对于单聊，静默处理拒绝
							const declineMessage = { role: "user", content: "我拒绝了你的视频通话请求。", timestamp: Date.now(), isHidden: true };
							chat.history.push(declineMessage);
							await db.chats.put(chat);

							// 通知但不切换屏幕
							showNotification(callerChatId, "你已拒绝通话邀请。");
							// 在后台为对方触发响应
							const originalActiveChatId = state.activeChatId;
							state.activeChatId = callerChatId;
							await triggerAiResponse();
							state.activeChatId = originalActiveChatId;
						}

						// 清理状态
						videoCallState.isAwaitingResponse = false;
						videoCallState.activeChatId = null;
					});

					// 接听来电按钮事件
					document.getElementById("accept-call-btn").addEventListener("click", async () => {
						stopRingtone();
						hideIncomingCallModal();
						const callerChatId = videoCallState.activeChatId; // 从专用信道获取ID
						if (!callerChatId) return;

						// 在接听时，才真正改变全局状态，并打开通话界面
						state.activeChatId = callerChatId; // 授权修改全局状态

						videoCallState.initiator = "ai";
						videoCallState.isUserParticipating = true;

						if (videoCallState.isGroupCall) {
							const chat = state.chats[videoCallState.activeChatId];
							const requester = chat.members.find((m) => m.name === videoCallState.callRequester);
							if (requester) {
								videoCallState.participants = [requester];
							} else {
								videoCallState.participants = [];
							}
						}

						startVideoCall(); // 启动通话界面
					});

					// 用户在通话中发言按钮事件
					document.getElementById("user-speak-btn").addEventListener("click", async () => {
						if (!videoCallState.isActive) return;

						// 在弹出输入框前，先找到并高亮用户头像
						const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
						if (userAvatar) {
							userAvatar.classList.add("speaking");
						}

						const userInput = await showCustomPrompt("你说", "请输入你想说的话...");

						// 无论用户是否输入，只要关闭输入框就移除高亮
						if (userAvatar) {
							userAvatar.classList.remove("speaking");
						}

						if (userInput && userInput.trim()) {
							triggerAiInCallAction(userInput.trim());
						}
					});

					// 回忆录页面导航事件
					document.querySelector('.nav-item[data-view="memories-view"]').addEventListener("click", () => {
						// 在切换前，确保"收藏"页面的编辑模式已关闭
						if (isFavoritesSelectionMode) {
							document.getElementById("favorites-edit-btn").click();
						}
						switchToChatListView("memories-view");
						renderMemoriesScreen(); // 点击时渲染
					});

					// 回忆录返回按钮事件
					document.getElementById("memories-back-btn").addEventListener("click", () => switchToChatListView("messages-view"));

					// 添加倒计时按钮事件
					document.getElementById("add-countdown-btn").addEventListener("click", () => {
						document.getElementById("create-countdown-modal").classList.add("visible");
					});

					// 取消创建倒计时按钮事件
					document.getElementById("cancel-create-countdown-btn").addEventListener("click", () => {
						document.getElementById("create-countdown-modal").classList.remove("visible");
					});

					// 确认创建倒计时按钮事件
					document.getElementById("confirm-create-countdown-btn").addEventListener("click", async () => {
						const title = document.getElementById("countdown-title-input").value.trim();
						const dateValue = document.getElementById("countdown-date-input").value;

						if (!title || !dateValue) {
							alert("请填写完整的约定标题和日期！");
							return;
						}

						const targetDate = new Date(dateValue);
						if (isNaN(targetDate) || targetDate <= new Date()) {
							alert("请输入一个有效的、未来的日期！");
							return;
						}

						const newCountdown = {
							chatId: null, // 用户创建的，不属于任何特定AI
							authorName: "我",
							description: title,
							timestamp: Date.now(),
							type: "countdown",
							targetDate: targetDate.getTime(),
						};

						await db.memories.add(newCountdown);
						document.getElementById("create-countdown-modal").classList.remove("visible");
						renderMemoriesScreen();
					});

					// 拉黑聊天按钮事件
					document.getElementById("block-chat-btn").addEventListener("click", async () => {
						if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;

						const chat = state.chats[state.activeChatId];
						const confirmed = await showCustomConfirm("确认拉黑", `确定要拉黑"${chat.name}"吗？拉黑后您将无法向其发送消息，直到您将Ta移出黑名单，或等待Ta重新申请好友。`, { confirmButtonClass: "btn-danger" });

						if (confirmed) {
							chat.relationship.status = "blocked_by_user";
							chat.relationship.blockedTimestamp = Date.now();

							const hiddenMessage = {
								role: "system",
								content: `[系统提示：你刚刚被用户拉黑了。在对方解除拉黑之前，你无法再主动发起对话，也无法回应。]`,
								timestamp: Date.now() + 1,
								isHidden: true,
							};
							chat.history.push(hiddenMessage);

							await db.chats.put(chat);

							// 关闭设置弹窗，并刷新聊天界面
							document.getElementById("chat-settings-modal").classList.remove("visible");
							renderChatInterface(state.activeChatId);
							// 刷新聊天列表，可能会有UI变化
							renderChatList();
						}
					});

					// 聊天锁定覆盖层点击事件
					document.getElementById("chat-lock-overlay").addEventListener("click", async (e) => {
						const chat = state.chats[state.activeChatId];
						if (!chat) return;

						if (e.target.id === "force-apply-check-btn") {
							alert("正在手动触发好友申请流程，请稍后...\n如果API调用成功，将弹出提示。如果失败，也会有错误提示。如果长时间无反应，说明AI可能决定暂时不申请。");
							await triggerAiFriendApplication(chat.id);
							renderChatInterface(chat.id);
							return;
						}

						if (e.target.id === "unblock-btn") {
							chat.relationship.status = "friend";
							chat.relationship.blockedTimestamp = null;

							const hiddenMessage = {
								role: "system",
								content: `[系统提示：用户刚刚解除了对你的拉黑。现在你们可以重新开始对话了。]`,
								timestamp: Date.now(),
								isHidden: true,
							};
							chat.history.push(hiddenMessage);

							await db.chats.put(chat);
							renderChatInterface(chat.id);
							renderChatList();
							triggerAiResponse(); // 解除后让AI主动说点什么
						} else if (e.target.id === "accept-friend-btn") {
							chat.relationship.status = "friend";
							chat.relationship.applicationReason = "";

							const hiddenMessage = {
								role: "system",
								content: `[系统提示：用户刚刚通过了你的好友申请。你们现在又可以正常聊天了。]`,
								timestamp: Date.now(),
								isHidden: true,
							};
							chat.history.push(hiddenMessage);

							await db.chats.put(chat);
							renderChatInterface(chat.id);
							renderChatList();
							const msg = { role: "user", content: "我通过了你的好友请求", timestamp: Date.now() };
							chat.history.push(msg);
							await db.chats.put(chat);
							appendMessage(msg, chat);
							triggerAiResponse();
						} else if (e.target.id === "reject-friend-btn") {
							chat.relationship.status = "blocked_by_user";
							chat.relationship.blockedTimestamp = Date.now();
							chat.relationship.applicationReason = "";
							await db.chats.put(chat);
							renderChatInterface(chat.id);
						}
						// 处理申请好友按钮的点击事件
						else if (e.target.id === "apply-friend-btn") {
							const reason = await showCustomPrompt("发送好友申请", `请输入你想对"${chat.name}"说的申请理由：`, "我们和好吧！");
							// 只有当用户输入了内容并点击"确定"后才继续
							if (reason !== null) {
								// 更新关系状态为"等待AI批准"
								chat.relationship.status = "pending_ai_approval";
								chat.relationship.applicationReason = reason;
								await db.chats.put(chat);

								// 刷新UI，显示"等待通过"的界面
								renderChatInterface(chat.id);
								renderChatList();

								// 触发AI响应，让它去处理这个好友申请
								triggerAiResponse();
							}
						}
					});

					// 红包功能事件绑定
					// 将原有的转账按钮(￥)的点击事件，重定向到新的总入口函数
					document.getElementById("transfer-btn").addEventListener("click", handlePaymentButtonClick);

					// 红包模态框取消按钮事件
					document.getElementById("cancel-red-packet-btn").addEventListener("click", () => {
						document.getElementById("red-packet-modal").classList.remove("visible");
					});

					// 发送群红包按钮事件
					document.getElementById("send-group-packet-btn").addEventListener("click", sendGroupRedPacket);

					// 发送个人红包按钮事件
					document.getElementById("send-direct-packet-btn").addEventListener("click", sendDirectRedPacket);

					// 红包模态框群红包标签事件
					const rpTabGroup = document.getElementById("rp-tab-group");
					const rpTabDirect = document.getElementById("rp-tab-direct");
					const rpContentGroup = document.getElementById("rp-content-group");
					const rpContentDirect = document.getElementById("rp-content-direct");

					rpTabGroup.addEventListener("click", () => {
						rpTabGroup.classList.add("active");
						rpTabDirect.classList.remove("active");
						rpContentGroup.style.display = "block";
						rpContentDirect.style.display = "none";
					});

					// 红包模态框个人红包标签事件
					rpTabDirect.addEventListener("click", () => {
						rpTabDirect.classList.add("active");
						rpTabGroup.classList.remove("active");
						rpContentDirect.style.display = "block";
						rpContentGroup.style.display = "none";
					});

					// 群红包金额输入事件，实时更新显示
					document.getElementById("rp-group-amount").addEventListener("input", (e) => {
						const amount = parseFloat(e.target.value) || 0;
						document.getElementById("rp-group-total").textContent = `¥ ${amount.toFixed(2)}`;
					});

					// 个人红包金额输入事件，实时更新显示
					document.getElementById("rp-direct-amount").addEventListener("input", (e) => {
						const amount = parseFloat(e.target.value) || 0;
						document.getElementById("rp-direct-total").textContent = `¥ ${amount.toFixed(2)}`;
					});

					// 使用事件委托处理红包点击
					document.getElementById("chat-messages").addEventListener("click", (e) => {
						// 找到被点击的红包卡片
						const packetCard = e.target.closest(".red-packet-card");
						if (!packetCard) return; // 如果点击的不是红包，就什么也不做

						// 从红包卡片的父级.message-bubble获取时间戳
						const messageBubble = packetCard.closest(".message-bubble");
						if (!messageBubble || !messageBubble.dataset.timestamp) return;

						// 调用处理函数
						const timestamp = parseInt(messageBubble.dataset.timestamp);
						handlePacketClick(timestamp);
					});

					// 投票功能事件监听器
					// 输入框工具栏添加投票按钮事件
					document.getElementById("send-poll-btn").addEventListener("click", openCreatePollModal);

					// 添加投票选项按钮事件
					document.getElementById("add-poll-option-btn").addEventListener("click", addPollOptionInput);

					// 取消创建投票按钮事件
					document.getElementById("cancel-create-poll-btn").addEventListener("click", () => {
						document.getElementById("create-poll-modal").classList.remove("visible");
					});

					// 确认创建投票按钮事件
					document.getElementById("confirm-create-poll-btn").addEventListener("click", sendPoll);

					// 使用事件委托处理投票卡片内的所有点击事件
					document.getElementById("chat-messages").addEventListener("click", (e) => {
						const pollCard = e.target.closest(".poll-card");
						if (!pollCard) return;

						const timestamp = parseInt(pollCard.dataset.pollTimestamp);
						if (isNaN(timestamp)) return;

						// 点击了选项
						const optionItem = e.target.closest(".poll-option-item");
						if (optionItem && !pollCard.classList.contains("closed")) {
							handleUserVote(timestamp, optionItem.dataset.option);
							return;
						}

						// 点击了动作按钮（结束投票/查看结果）
						const actionBtn = e.target.closest(".poll-action-btn");
						if (actionBtn) {
							if (pollCard.classList.contains("closed")) {
								showPollResults(timestamp);
							} else {
								endPoll(timestamp);
							}
							return;
						}

						// 如果是已结束的投票，点击卡片任何地方都可以查看结果
						if (pollCard.classList.contains("closed")) {
							showPollResults(timestamp);
						}
					});

					// AI头像库功能事件绑定
					// 管理AI头像库按钮事件
					document.getElementById("manage-ai-avatar-library-btn").addEventListener("click", openAiAvatarLibraryModal);

					// 添加AI头像按钮事件
					document.getElementById("add-ai-avatar-btn").addEventListener("click", addAvatarToLibrary);

					// 关闭AI头像库按钮事件
					document.getElementById("close-ai-avatar-library-btn").addEventListener("click", closeAiAvatarLibraryModal);

					// App图标上传功能升级
					document.getElementById("icon-settings-grid").addEventListener("click", async (e) => {
						if (e.target.classList.contains("change-icon-btn")) {
							const item = e.target.closest(".icon-setting-item");
							const iconId = item.dataset.iconId;
							if (!iconId) return;

							// 弹出选择模态框
							const choice = await showChoiceModal("更换图标", [
								{ text: "📁 从本地上传", value: "local" },
								{ text: "🌐 使用网络URL", value: "url" },
							]);

							let newUrl = null;

							// 根据用户的选择执行不同操作
							if (choice === "local") {
								newUrl = await uploadImageLocally(); // 调用本地上传辅助函数
							} else if (choice === "url") {
								const currentUrl = state.globalSettings.appIcons[iconId];
								newUrl = await showCustomPrompt(`更换"${item.querySelector(".icon-preview").alt}"图标`, "请输入新的图片URL", currentUrl, "url");
							}

							// 处理最终结果
							if (newUrl && newUrl.trim()) {
								const trimmedUrl = newUrl.trim();
								// 仅在内存中更新，等待用户点击"保存"
								state.globalSettings.appIcons[iconId] = trimmedUrl;
								// 实时更新设置页面的预览图
								item.querySelector(".icon-preview").src = trimmedUrl;
							} else if (newUrl !== null) {
								alert("请输入一个有效的URL或选择一个文件！");
							}
						}
					});

					// 链接分享卡片点击事件
					document.getElementById("chat-messages").addEventListener("click", (e) => {
						// 使用 .closest() 向上查找被点击的卡片
						const linkCard = e.target.closest(".link-share-card");
						if (linkCard) {
							const timestamp = parseInt(linkCard.dataset.timestamp);
							if (!isNaN(timestamp)) {
								openBrowser(timestamp); // 调用函数
							}
						}
					});

					// 浏览器返回按钮事件
					document.getElementById("browser-back-btn").addEventListener("click", () => {
						showScreen("chat-interface-screen");
					});

					// 输入框上方"分享链接"按钮点击事件
					document.getElementById("share-link-btn").addEventListener("click", openShareLinkModal);

					// 模态框中"取消"按钮点击事件
					document.getElementById("cancel-share-link-btn").addEventListener("click", () => {
						document.getElementById("share-link-modal").classList.remove("visible");
					});

					// 模态框中"分享"按钮点击事件
					document.getElementById("confirm-share-link-btn").addEventListener("click", sendUserLinkShare);

					// 主题切换开关事件
					document.getElementById("theme-toggle-switch").addEventListener("change", toggleTheme);

					// 消息操作菜单中的"引用"按钮事件
					document.getElementById("quote-message-btn").addEventListener("click", startReplyToMessage);

					// 回复预览栏中的"取消"按钮事件
					document.getElementById("cancel-reply-btn").addEventListener("click", cancelReplyMode);

					// 转账卡片点击事件
					document.getElementById("chat-messages").addEventListener("click", (e) => {
						// 向上查找被点击的元素是否在一个消息气泡内
						const bubble = e.target.closest(".message-bubble");
						if (!bubble) return; // 如果不在，就退出

						// 核心修正：添加严格的筛选条件
						// 必须是 AI 的消息 (.ai)
						// 必须是转账类型 (.is-transfer)
						// 必须是我们标记为"待处理"的 (data-status="pending")
						if (bubble.classList.contains("ai") && bubble.classList.contains("is-transfer") && bubble.dataset.status === "pending") {
							// 只有满足所有条件，才执行后续逻辑
							const timestamp = parseInt(bubble.dataset.timestamp);
							if (!isNaN(timestamp)) {
								showTransferActionModal(timestamp);
							}
						}
					});

					// 转账操作接受按钮事件
					document.getElementById("transfer-action-accept").addEventListener("click", () => handleUserTransferResponse("accepted"));

					// 转账操作拒绝按钮事件
					document.getElementById("transfer-action-decline").addEventListener("click", () => handleUserTransferResponse("declined"));

					// 转账操作取消按钮事件
					document.getElementById("transfer-action-cancel").addEventListener("click", hideTransferActionModal);

					// 通话记录标题点击事件
					document.getElementById("chat-list-title").addEventListener("click", renderCallHistoryScreen);

					// 通话记录页面返回按钮事件
					document.getElementById("call-history-back-btn").addEventListener("click", () => {
						// 返回到聊天列表页面，而不是聊天界面
						showScreen("chat-list-screen");
					});

					// 通话记录列表点击事件
					document.getElementById("call-history-list").addEventListener("click", (e) => {
						const card = e.target.closest(".call-record-card");
						if (card && card.dataset.recordId) {
							showCallTranscript(parseInt(card.dataset.recordId));
						}
					});

					// 关闭通话记录详情弹窗按钮事件
					document.getElementById("close-transcript-modal-btn").addEventListener("click", () => {
						document.getElementById("call-transcript-modal").classList.remove("visible");
					});

					// 语音消息点击事件处理
					document.getElementById("chat-messages").addEventListener("click", (e) => {
						// 检查点击的是否是语音条
						const voiceBody = e.target.closest(".voice-message-body");
						if (!voiceBody) return;

						// 找到相关的DOM元素
						const bubble = voiceBody.closest(".message-bubble");
						if (!bubble) return;

						const spinner = voiceBody.querySelector(".loading-spinner");
						const transcriptEl = bubble.querySelector(".voice-transcript");

						// 如果正在加载中，则不响应点击
						if (bubble.dataset.state === "loading") {
							return;
						}

						// 如果文字已经展开，则收起
						if (bubble.dataset.state === "expanded") {
							transcriptEl.style.display = "none";
							bubble.dataset.state = "collapsed";
						}
						// 如果是收起状态，则开始"转录"流程
						else {
							bubble.dataset.state = "loading"; // 进入加载状态
							spinner.style.display = "block"; // 显示加载动画

							// 模拟语音识别过程
							setTimeout(() => {
								// 检查此时元素是否还存在（可能用户已经切换了聊天）
								if (document.body.contains(bubble)) {
									const voiceText = bubble.dataset.voiceText || "(无法识别)";
									transcriptEl.textContent = voiceText; // 填充文字

									spinner.style.display = "none"; // 隐藏加载动画
									transcriptEl.style.display = "block"; // 显示文字
									bubble.dataset.state = "expanded"; // 进入展开状态
								}
							}, 500);
						}
					});

					// 状态编辑点击事件处理
					document.getElementById("chat-header-status").addEventListener("click", handleEditStatusClick);

					// 分享按钮点击事件处理
					document.getElementById("selection-share-btn").addEventListener("click", () => {
						if (selectedMessages.size > 0) {
							openShareTargetPicker(); // 打开目标选择器
						}
					});

					// 确认分享目标按钮点击事件处理
					document.getElementById("confirm-share-target-btn").addEventListener("click", async () => {
						const sourceChat = state.chats[state.activeChatId];
						const selectedTargetIds = Array.from(document.querySelectorAll(".share-target-checkbox:checked")).map((cb) => cb.dataset.chatId);

						if (selectedTargetIds.length === 0) {
							alert("请至少选择一个要分享的聊天。");
							return;
						}

						// 打包聊天记录
						const sharedHistory = [];
						const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
						for (const timestamp of sortedTimestamps) {
							const msg = sourceChat.history.find((m) => m.timestamp === timestamp);
							if (msg) {
								sharedHistory.push(msg);
							}
						}

						// 创建分享卡片消息对象
						const shareCardMessage = {
							role: "user",
							senderName: sourceChat.isGroup ? sourceChat.settings.myNickname || "我" : "我",
							type: "share_card",
							timestamp: Date.now(),
							payload: {
								sourceChatName: sourceChat.name,
								title: `来自"${sourceChat.name}"的聊天记录`,
								sharedHistory: sharedHistory,
							},
						};

						// 循环发送到所有目标聊天
						for (const targetId of selectedTargetIds) {
							const targetChat = state.chats[targetId];
							if (targetChat) {
								targetChat.history.push(shareCardMessage);
								await db.chats.put(targetChat);
							}
						}

						// 收尾工作
						document.getElementById("share-target-modal").classList.remove("visible");
						exitSelectionMode(); // 退出多选模式
						await showCustomAlert("分享成功", `聊天记录已成功分享到 ${selectedTargetIds.length} 个会话中。`);
						renderChatList(); // 刷新列表，可能会有新消息提示
					});

					// 取消分享按钮点击事件处理
					document.getElementById("cancel-share-target-btn").addEventListener("click", () => {
						document.getElementById("share-target-modal").classList.remove("visible");
					});

					// 分享卡片点击事件处理
					document.getElementById("chat-messages").addEventListener("click", (e) => {
						// 新增逻辑：处理分享卡片的点击
						const shareCard = e.target.closest(".link-share-card[data-timestamp]");
						if (shareCard && shareCard.closest(".message-bubble.is-link-share")) {
							const timestamp = parseInt(shareCard.dataset.timestamp);
							openSharedHistoryViewer(timestamp);
						}
					});

					// 关闭共享历史查看器按钮点击事件处理
					document.getElementById("close-shared-history-viewer-btn").addEventListener("click", () => {
						document.getElementById("shared-history-viewer-modal").classList.remove("visible");
					});

					// 音频播放器时间更新事件处理
					audioPlayer.addEventListener("timeupdate", updateMusicProgressBar);

					// 音频播放器暂停事件处理
					audioPlayer.addEventListener("pause", () => {
						if (musicState.isActive) {
							musicState.isPlaying = false;
							updatePlayerUI();
						}
					});

					// 音频播放器播放事件处理
					audioPlayer.addEventListener("play", () => {
						if (musicState.isActive) {
							musicState.isPlaying = true;
							updatePlayerUI();
						}
					});

					// 播放列表点击事件处理
					document.getElementById("playlist-body").addEventListener("click", async (e) => {
						const target = e.target;
						if (target.classList.contains("delete-track-btn")) {
							const index = parseInt(target.dataset.index);
							const track = musicState.playlist[index];
							const confirmed = await showCustomConfirm("删除歌曲", `确定要从播放列表中删除《${track.name}》吗？`);
							if (confirmed) {
								deleteTrack(index);
							}
							return;
						}

						// 处理封面上传按钮点击
						if (target.classList.contains("cover-btn")) {
							const index = parseInt(target.dataset.index);
							if (!isNaN(index)) {
								handleCoverUpload(index);
							}
							return; // 处理完就退出，避免触发其他逻辑
						}

						// 处理歌词按钮点击
						if (target.classList.contains("lyrics-btn")) {
							const index = parseInt(target.dataset.index);
							if (isNaN(index)) return;

							// 弹窗询问用户选择歌词来源
							const choice = await showChoiceModal("选择歌词来源", [
								{ text: "使用网络URL", value: "url" },
								{ text: "从本地上传", value: "local" },
							]);

							let lrcContent = null;

							// 根据选择执行不同操作
							if (choice === "url") {
								const url = await showCustomPrompt("歌词URL", "请输入.lrc歌词文件的网络链接");
								if (url && url.trim()) {
									try {
										const response = await fetch(url.trim());
										if (response.ok) {
											lrcContent = await response.text();
										} else {
											alert("无法获取歌词文件，请检查URL是否正确。");
										}
									} catch (error) {
										alert("获取歌词失败: " + error.message);
									}
								}
							} else if (choice === "local") {
								lrcContent = await new Promise((resolve) => {
									const lrcInput = document.getElementById("lrc-upload-input");
									const handler = (event) => {
										const file = event.target.files[0];
										if (file) {
											const reader = new FileReader();
											reader.onload = (re) => resolve(re.target.result);
											reader.readAsText(file);
										} else {
											resolve(null);
										}
										lrcInput.removeEventListener("change", handler);
										lrcInput.value = "";
									};
									lrcInput.addEventListener("change", handler);
									lrcInput.click();
								});
							}

							// 如果成功获取到歌词，就保存并更新
							if (lrcContent !== null) {
								musicState.playlist[index].lrcContent = lrcContent;
								await saveGlobalPlaylist();
								alert("歌词导入成功！");
								if (musicState.currentIndex === index) {
									musicState.parsedLyrics = parseLRC(lrcContent);
									renderLyrics();
								}
							}
						}
					});

					// 进度条点击事件处理
					document.querySelector(".progress-bar").addEventListener("click", (e) => {
						if (!audioPlayer.duration) return;
						const progressBar = e.currentTarget;
						const barWidth = progressBar.clientWidth;
						const clickX = e.offsetX;
						audioPlayer.currentTime = (clickX / barWidth) * audioPlayer.duration;
					});

					// 已撤回消息点击事件处理
					document.getElementById("chat-messages").addEventListener("click", (e) => {
						// 检查被点击的元素或其父元素是否是"已撤回"提示
						const placeholder = e.target.closest(".recalled-message-placeholder");
						if (!placeholder) return; // 如果不是，就退出

						// 如果是，就从聊天记录中找到对应的数据并显示
						const chat = state.chats[state.activeChatId];
						const wrapper = placeholder.closest(".message-wrapper"); // 找到它的父容器
						if (chat && wrapper) {
							// 从父容器上找到时间戳
							const timestamp = parseInt(wrapper.dataset.timestamp);
							const recalledMsg = chat.history.find((m) => m.timestamp === timestamp);

							if (recalledMsg && recalledMsg.recalledData) {
								let originalContentText = "";
								const recalled = recalledMsg.recalledData;

								if (recalled.originalType === "text") {
									originalContentText = `原文: "${recalled.originalContent}"`;
								} else {
									originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
								}
								showCustomAlert("已撤回的消息", originalContentText);
							}
						}
					});

					// 管理世界书分类按钮点击事件处理
					document.getElementById("manage-world-book-categories-btn").addEventListener("click", openCategoryManager);

					// 关闭分类管理器按钮点击事件处理
					document.getElementById("close-category-manager-btn").addEventListener("click", () => {
						document.getElementById("world-book-category-manager-modal").classList.remove("visible");
						renderWorldBookScreen(); // 关闭后刷新主列表
					});

					// 添加新分类按钮点击事件处理
					document.getElementById("add-new-category-btn").addEventListener("click", addNewCategory);

					// 现有分类列表点击事件处理
					document.getElementById("existing-categories-list").addEventListener("click", (e) => {
						if (e.target.classList.contains("delete-group-btn")) {
							const categoryId = parseInt(e.target.dataset.id);
							deleteCategory(categoryId);
						}
					});

					// 自定义头像框功能事件绑定
					// 打开"选择"弹窗的按钮
					document.getElementById("chat-settings-modal").addEventListener("click", (e) => {
						if (e.target.classList.contains("change-frame-btn")) {
							openFrameSelectorModal(e.target.dataset.type);
						}
					});

					// 成员设置模态框中的头像框更改按钮点击事件处理
					document.getElementById("member-settings-modal").addEventListener("click", (e) => {
						if (e.target.classList.contains("change-frame-btn")) {
							openFrameSelectorModal("member", editingMemberId);
						}
					});

					// 管理自定义头像框按钮点击事件处理
					document.getElementById("manage-custom-frames-btn").addEventListener("click", () => {
						// 先关闭当前的选择弹窗
						document.getElementById("avatar-frame-modal").classList.remove("visible");

						// 然后再打开管理弹窗
						openFrameManager();
					});

					// 取消头像框设置按钮点击事件处理
					document.getElementById("cancel-frame-settings-btn").addEventListener("click", () => document.getElementById("avatar-frame-modal").classList.remove("visible"));

					// 保存头像框设置按钮点击事件处理
					document.getElementById("save-frame-settings-btn").addEventListener("click", saveSelectedFrames);

					// 上传自定义头像框按钮点击事件处理
					document.getElementById("upload-custom-frame-btn").addEventListener("click", handleUploadCustomFrame);

					// 关闭头像框管理器按钮点击事件处理
					document.getElementById("close-frame-manager-btn").addEventListener("click", () => {
						document.getElementById("custom-frame-manager-modal").classList.remove("visible");
						// 关闭管理后，刷新选择界面，因为列表可能变了
						openFrameSelectorModal(currentFrameSelection.type, currentFrameSelection.target);
					});

					// 聊天列表左滑功能JS逻辑
					const chatListEl = document.getElementById("chat-list");
					let chatSwipeState = { isDragging: false, startX: 0, activeContent: null };

					// 关闭所有已滑开的项
					function resetAllChatSwipes(exceptThisOne = null) {
						document.querySelectorAll(".chat-list-item-content.swiped").forEach((content) => {
							if (content !== exceptThisOne) {
								content.classList.remove("swiped");
							}
						});
					}

					// 鼠标按下事件处理
					chatListEl.addEventListener("mousedown", (e) => {
						const content = e.target.closest(".chat-list-item-content");
						if (content) {
							resetAllChatSwipes(content);
							chatSwipeState.isDragging = true;
							chatSwipeState.startX = e.pageX;
							chatSwipeState.activeContent = content;
							// 阻止拖动时选中文本
							e.preventDefault();
						}
					});

					// 鼠标移动事件处理
					document.addEventListener("mousemove", (e) => {
						if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
						const diffX = e.pageX - chatSwipeState.startX;
						if (diffX < 0 && diffX > -170) {
							// 只允许向左滑, 限制最大距离
							chatSwipeState.activeContent.style.transition = "none"; // 滑动时禁用动画
							chatSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
						}
					});

					// 鼠标释放事件处理
					document.addEventListener("mouseup", (e) => {
						if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;

						chatSwipeState.activeContent.style.transition = "transform 0.3s ease";
						const transformStyle = window.getComputedStyle(chatSwipeState.activeContent).transform;
						const currentTranslateX = new DOMMatrix(transformStyle).m41;

						if (currentTranslateX < -60) {
							// 滑动超过阈值
							chatSwipeState.activeContent.classList.add("swiped");
						} else {
							chatSwipeState.activeContent.classList.remove("swiped");
						}
						chatSwipeState.activeContent.style.transform = ""; // 清除内联样式，交由CSS class控制

						// 重置状态
						chatSwipeState.isDragging = false;
						chatSwipeState.activeContent = null;
					});

					// 移动端触摸开始事件处理
					chatListEl.addEventListener(
						"touchstart",
						(e) => {
							const content = e.target.closest(".chat-list-item-content");
							if (content) {
								resetAllChatSwipes(content);
								chatSwipeState.isDragging = true;
								chatSwipeState.startX = e.touches[0].pageX;
								chatSwipeState.activeContent = content;
							}
						},
						{ passive: true }
					);

					// 移动端触摸移动事件处理
					chatListEl.addEventListener(
						"touchmove",
						(e) => {
							if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
							const diffX = e.touches[0].pageX - chatSwipeState.startX;
							if (diffX < 0 && diffX > -170) {
								chatSwipeState.activeContent.style.transition = "none";
								chatSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
							}
						},
						{ passive: true }
					);

					// 移动端触摸结束事件处理
					chatListEl.addEventListener("touchend", (e) => {
						if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;

						chatSwipeState.activeContent.style.transition = "transform 0.3s ease";
						const transformStyle = window.getComputedStyle(chatSwipeState.activeContent).transform;
						const currentTranslateX = new DOMMatrix(transformStyle).m41;

						if (currentTranslateX < -60) {
							chatSwipeState.activeContent.classList.add("swiped");
						} else {
							chatSwipeState.activeContent.classList.remove("swiped");
						}
						chatSwipeState.activeContent.style.transform = "";

						chatSwipeState.isDragging = false;
						chatSwipeState.activeContent = null;
					});

					// 聊天列表操作按钮点击事件处理
					chatListEl.addEventListener("click", async (e) => {
						const target = e.target;
						if (target.classList.contains("swipe-action-btn")) {
							const container = target.closest(".chat-list-item-swipe-container");
							if (!container) return;

							const chatId = container.dataset.chatId;
							const chat = state.chats[chatId];
							if (!chat) return;

							if (target.classList.contains("pin") || target.classList.contains("unpin")) {
								// 置顶或取消置顶
								chat.isPinned = !chat.isPinned;
								await db.chats.put(chat);
								await renderChatList(); // 重新渲染列表以更新排序
							} else if (target.classList.contains("delete")) {
								// 删除
								const confirmed = await showCustomConfirm("删除对话", `确定要删除与 "${chat.name}" 的整个对话吗？此操作不可撤销。`, { confirmButtonClass: "btn-danger" });
								if (confirmed) {
									if (musicState.isActive && musicState.activeChatId === chat.id) await endListenTogetherSession(false);
									delete state.chats[chat.id];
									if (state.activeChatId === chat.id) state.activeChatId = null;
									await db.chats.delete(chat.id);
									await renderChatList();
								} else {
									// 如果取消删除，则把滑块收回去
									const content = container.querySelector(".chat-list-item-content");
									if (content) content.classList.remove("swiped");
								}
							}
						}
					});

					// 使用事件委托来处理所有点击和勾选事件，效率更高
					worldBookCheckboxesContainer.addEventListener("click", (e) => {
						const header = e.target.closest(".wb-category-header");
						// 如果点击的是文件夹头部，并且不是点在复选框上
						if (header && !e.target.matches('input[type="checkbox"]')) {
							const categoryId = header.querySelector(".wb-category-checkbox")?.dataset.categoryId;
							if (categoryId) {
								const bookContainer = worldBookCheckboxesContainer.querySelector(`.wb-book-container[data-container-for="${categoryId}"]`);
								if (bookContainer) {
									header.classList.toggle("collapsed");
									bookContainer.classList.toggle("collapsed");
								}
							}
						}
					});

					// 处理复选框状态变化事件
					worldBookCheckboxesContainer.addEventListener("change", (e) => {
						const target = e.target;

						// 如果点击的是分类的"全选"复选框
						if (target.classList.contains("wb-category-checkbox")) {
							const categoryId = target.dataset.categoryId;
							const isChecked = target.checked;
							// 找到这个分类下的所有书籍复选框，并将它们的状态设置为与分类复选框一致
							const bookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
							bookCheckboxes.forEach((cb) => (cb.checked = isChecked));
						}

						// 如果点击的是单个书籍的复选框
						if (target.classList.contains("wb-book-checkbox")) {
							const categoryId = target.dataset.parentCategory;
							if (categoryId) {
								// 检查它是否属于一个分类
								const categoryCheckbox = worldBookCheckboxesContainer.querySelector(`input.wb-category-checkbox[data-category-id="${categoryId}"]`);
								const allBookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
								// 检查该分类下是否所有书籍都被选中了
								const allChecked = Array.from(allBookCheckboxes).every((cb) => cb.checked);
								// 同步分类"全选"复选框的状态
								if (categoryCheckbox) categoryCheckbox.checked = allChecked;
							}
						}

						// 每次变更后都更新顶部的已选数量显示
						updateWorldBookSelectionDisplay();
					});

					// 美化功能事件绑定
					const themeEditor = document.getElementById("theme-css-editor");

					// 页面加载时，加载主题列表并显示模板
					await loadThemesToDropdown();
					themeEditor.value = THEME_CSS_TEMPLATE;

					// 绑定下拉框选择事件
					document.getElementById("theme-selector").addEventListener("change", handleThemeSelection);

					// 绑定所有操作按钮
					document.getElementById("apply-theme-btn").addEventListener("click", () => applyThemeCss(themeEditor.value));
					document.getElementById("save-theme-btn").addEventListener("click", saveCurrentTheme);
					document.getElementById("save-as-new-theme-btn").addEventListener("click", saveAsNewTheme);
					document.getElementById("rename-theme-btn").addEventListener("click", renameSelectedTheme);
					document.getElementById("delete-theme-btn").addEventListener("click", deleteSelectedTheme);
					document.getElementById("export-theme-btn").addEventListener("click", exportTheme);

					// 绑定导入按钮和隐藏的文件选择器
					document.getElementById("import-theme-btn").addEventListener("click", () => {
						document.getElementById("import-theme-input").click();
					});
					document.getElementById("import-theme-input").addEventListener("change", (e) => {
						importTheme(e.target.files[0]);
						e.target.value = null; // 清空，以便下次能选择同一个文件
					});

					// API预设选择事件处理
					document.getElementById("api-preset-select").addEventListener("change", handleApiPresetSelectChange);

					// 打开API预设管理器事件处理
					document.getElementById("manage-api-presets-btn").addEventListener("click", openApiPresetManager);

					// 锁屏壁纸上传事件处理
					document.getElementById("lockscreen-wallpaper-upload-input").addEventListener("change", async (event) => {
						const file = event.target.files[0];
						if (file) {
							const dataUrl = await new Promise((res, rej) => {
								const reader = new FileReader();
								reader.onload = () => res(reader.result);
								reader.onerror = () => rej(reader.error);
								reader.readAsDataURL(file);
							});
							newLockscreenWallpaperBase64 = dataUrl;
							renderWallpaperScreen(); // 上传后实时预览
						}
					});

					// 密码确认和取消按钮事件处理
					document.getElementById("password-confirm-btn").addEventListener("click", checkPassword);
					document.getElementById("password-cancel-btn").addEventListener("click", hidePasswordModal);

					// 密码输入框回车键事件处理
					document.getElementById("password-input-field").addEventListener("keypress", (e) => {
						if (e.key === "Enter") {
							checkPassword();
						}
					});

					// 锁屏解锁手势处理函数
					const lockScreen = document.getElementById("lock-screen");
					const unlockHint = document.getElementById("unlock-hint");
					let touchStartY = 0;
					let isSwiping = false;

					// 统一的开始处理函数
					const handleUnlockStart = (e) => {
						if (document.getElementById("password-modal-overlay").classList.contains("visible")) return;

						// 其他逻辑保持不变
						const blurBg = document.getElementById("lock-screen-background-blur");
						if (state.globalSettings.password) {
							blurBg.style.backgroundImage = lockScreen.style.backgroundImage;
							blurBg.style.display = "block";
						} else {
							document.getElementById("home-screen").classList.add("active");
						}

						touchStartY = getEventCoords(e).y; // 使用辅助函数获取Y坐标
						isSwiping = true;
						lockScreen.style.transition = "none";
						unlockHint.style.transition = "none";
					};

					// 统一的移动处理函数
					const handleUnlockMove = (e) => {
						if (!isSwiping) return;
						const currentY = getEventCoords(e).y; // 使用辅助函数
						let diffY = currentY - touchStartY;
						// 其他逻辑保持不变
						if (diffY > 0) diffY = 0;
						lockScreen.style.transform = `translateY(${diffY}px)`;
						unlockHint.style.opacity = Math.max(0, 1 - Math.abs(diffY) / 100);
						if (state.globalSettings.password) {
							const blurBg = document.getElementById("lock-screen-background-blur");
							blurBg.style.opacity = Math.min(1, Math.abs(diffY) / 80);
						}
					};

					// 统一的结束处理函数
					const handleUnlockEnd = (e) => {
						if (!isSwiping) return;
						isSwiping = false;

						// 其他逻辑保持不变
						lockScreen.style.transition = "transform 0.3s ease-out";
						unlockHint.style.transition = "opacity 0.3s ease-out";
						const blurBg = document.getElementById("lock-screen-background-blur");

						// 注意：touchend事件的坐标在 e.changedTouches[0]
						const touchEndY = e.changedTouches ? e.changedTouches[0].clientY : e.pageY;
						const swipeDistance = touchStartY - touchEndY;

						if (swipeDistance > 80) {
							lockScreen.style.transform = "translateY(-100%)";
							setTimeout(() => {
								if (state.globalSettings.password) {
									showPasswordModal();
								} else {
									unlockPhone();
								}
							}, 300);
						} else {
							lockScreen.style.transform = "translateY(0)";
							unlockHint.style.opacity = "1";
							if (state.globalSettings.password) {
								blurBg.style.opacity = "0";
								setTimeout(() => {
									blurBg.style.display = "none";
								}, 300);
							} else {
								document.getElementById("home-screen").classList.remove("active");
							}
						}
					};

					// 绑定触摸和鼠标事件到同一套处理逻辑上
					lockScreen.addEventListener("touchstart", handleUnlockStart, { passive: true });
					lockScreen.addEventListener("touchmove", handleUnlockMove, { passive: true });
					lockScreen.addEventListener("touchend", handleUnlockEnd, { passive: true });

					lockScreen.addEventListener("mousedown", handleUnlockStart);
					// 注意：mousemove和mouseup最好绑定在document上，防止鼠标拖出范围后失效
					document.addEventListener("mousemove", handleUnlockMove);
					document.addEventListener("mouseup", handleUnlockEnd);

					// 为聊天底部工具栏添加鼠标拖动滚动功能
					const actionsTopBar = document.getElementById("chat-input-actions-top");
					let isDown = false;
					let startX;
					let scrollLeft;

					// 鼠标按下事件处理
					actionsTopBar.addEventListener("mousedown", (e) => {
						isDown = true;
						actionsTopBar.classList.add("grabbing"); // 添加一个class来改变鼠标样式
						startX = e.pageX - actionsTopBar.offsetLeft;
						scrollLeft = actionsTopBar.scrollLeft;
					});

					// 鼠标离开事件处理
					actionsTopBar.addEventListener("mouseleave", () => {
						isDown = false;
						actionsTopBar.classList.remove("grabbing");
					});

					// 鼠标释放事件处理
					actionsTopBar.addEventListener("mouseup", () => {
						isDown = false;
						actionsTopBar.classList.remove("grabbing");
					});

					// 鼠标移动事件处理
					actionsTopBar.addEventListener("mousemove", (e) => {
						if (!isDown) return;
						e.preventDefault();
						const x = e.pageX - actionsTopBar.offsetLeft;
						const walk = (x - startX) * 2; // 乘以2可以增加拖动速度，感觉更灵敏
						actionsTopBar.scrollLeft = scrollLeft - walk;
					});

					// 定位模态框取消按钮事件处理
					document.getElementById("location-cancel-btn").addEventListener("click", () => {
						document.getElementById("send-location-modal").classList.remove("visible");
					});

					// 定位模态框确认按钮事件处理
					document.getElementById("location-confirm-btn").addEventListener("click", sendUserLocation);

					// 定位模态框添加途经点按钮事件处理
					document.getElementById("add-trajectory-point-btn").addEventListener("click", () => {
						// 限制最多添加3个途经点，防止UI过于拥挤
						if (document.querySelectorAll(".trajectory-point-input").length < 3) {
							addTrajectoryPointInput();
						} else {
							alert("最多只能添加3个途经点哦！");
						}
					});

					// 发送定位按钮点击事件处理
					document.getElementById("send-location-btn").addEventListener("click", () => {
						document.getElementById("trajectory-points-container").innerHTML = "";
						document.getElementById("send-location-modal").classList.add("visible");
					});

					// 重新生成回复按钮事件处理
					document.getElementById("reroll-btn").addEventListener("click", handleRerollClick);

					// 悬浮歌词栏设置功能事件处理
					document.getElementById("lyrics-settings-btn").addEventListener("click", (e) => {
						e.stopPropagation(); // 阻止事件冒泡触发拖动或打开播放器
						document.getElementById("lyrics-settings-modal").classList.add("visible");
					});

					// 关闭歌词设置模态框并保存设置
					document.getElementById("close-lyrics-settings-btn").addEventListener("click", async () => {
						// 保存设置到全局状态并写入数据库
						state.globalSettings.lyricsBarSettings = lyricsBarSettings;
						await db.globalSettings.put(state.globalSettings);
						document.getElementById("lyrics-settings-modal").classList.remove("visible");
						alert("设置已保存！");
					});

					// 重置歌词设置按钮事件处理
					document.getElementById("reset-lyrics-settings-btn").addEventListener("click", () => {
						// 恢复到默认值
						lyricsBarSettings = { fontSize: 14, bgOpacity: 0, fontColor: "#FFFFFF", showOnClose: true };
						applyLyricsSettings(); // 应用默认设置
					});

					// 实时更新歌词字体大小
					document.getElementById("lyrics-font-size-slider").addEventListener("input", (e) => {
						lyricsBarSettings.fontSize = e.target.value;
						applyLyricsSettings();
					});

					// 实时更新歌词背景透明度
					document.getElementById("lyrics-bg-opacity-slider").addEventListener("input", (e) => {
						lyricsBarSettings.bgOpacity = e.target.value;
						applyLyricsSettings();
					});

					// 实时更新歌词字体颜色
					document.getElementById("lyrics-font-color-picker").addEventListener("input", (e) => {
						lyricsBarSettings.fontColor = e.target.value;
						applyLyricsSettings();
					});

					// 歌词栏上的关闭按钮事件处理
					document.querySelector("#floating-lyrics-bar .close-btn").addEventListener("click", (e) => {
						e.stopPropagation();
						document.getElementById("floating-lyrics-bar").style.display = "none";
					});

					// 播放器里的"悬浮/隐藏"开关事件处理
					document.getElementById("toggle-lyrics-bar-btn").addEventListener("click", async (e) => {
						lyricsBarSettings.showOnClose = !lyricsBarSettings.showOnClose;
						e.target.textContent = lyricsBarSettings.showOnClose ? "悬浮" : "隐藏";
						e.target.style.opacity = lyricsBarSettings.showOnClose ? "1" : "0.5";
						// 立即保存这个设置
						state.globalSettings.lyricsBarSettings = lyricsBarSettings;
						await db.globalSettings.put(state.globalSettings);
					});

					// 在页面加载时，就应用一次已保存的设置
					applyLyricsSettings();

					// "查角色手机"功能事件监听器
					// 绑定主屏幕上的"查手机"APP图标
					const checkPhoneAppIcon = document.querySelector('.app-icon[data-app-id="check-phone"]');
					if (checkPhoneAppIcon) {
						checkPhoneAppIcon.onclick = openCharacterSelectionScreen; // 修改onclick事件
					}

					// 角色选择列表的点击事件 (事件委托)
					document.getElementById("character-selection-list").addEventListener("click", (e) => {
						const item = e.target.closest(".character-select-item");
						if (item && item.dataset.chatId) {
							openCharacterPhone(item.dataset.chatId);
						}
					});

					// 角色手机聊天列表的点击事件 (事件委托)
					document.getElementById("character-chat-list").addEventListener("click", (e) => {
						const item = e.target.closest(".chat-list-item");
						if (item && item.dataset.contactName) {
							// 处理微信消息删除
							const isUserChat = item.dataset.isUserChat === "true";
							console.log("【诊断日志 2】: 点击了聊天列表项", {
								contactName: item.dataset.contactName,
								isUserChat: isUserChat,
							});

							// 将联系人名字和"身份证"一起传递给渲染函数
							renderCharacterChatHistory(item.dataset.contactName, isUserChat);
							showCharacterPhonePage("character-chat-history-screen");
						}
					});

					// 角色手机顶部的"刷新"和"清空"按钮事件处理
					document.getElementById("generate-character-data-btn").addEventListener("click", generateCharacterPhoneData);
					document.getElementById("clear-character-data-btn").addEventListener("click", clearCharacterPhoneData);

					// 角色手机内部统一返回事件监听器
					document.getElementById("character-phone-container").addEventListener("click", (e) => {
						const backBtn = e.target.closest(".back-btn");
						if (!backBtn) return;

						// 检查是返回到角色手机内部页面，还是返回到主屏幕
						if (backBtn.dataset.targetPage) {
							showCharacterPhonePage(backBtn.dataset.targetPage);
						} else if (backBtn.dataset.targetScreen) {
							showScreen(backBtn.dataset.targetScreen);
						}
					});

					// 角色手机日记APP事件监听器
					document.getElementById("character-app-grid").addEventListener("click", (e) => {
						const icon = e.target.closest(".app-icon");
						if (icon && icon.querySelector(".label").textContent === "日记") {
							renderCharacterDiary();
						}
					});

					// 生成新日记条目按钮事件处理
					document.getElementById("generate-diary-entry-btn").addEventListener("click", generateNewDiaryEntry);

					// "查手机"内容单条删除功能事件绑定
					document.getElementById("character-phone-container").addEventListener("click", (e) => {
						const deleteBtn = e.target.closest(".item-delete-btn");
						if (deleteBtn) {
							// 处理微信消息删除
							if (deleteBtn.classList.contains("message-delete-btn")) {
								const contactName = deleteBtn.dataset.contactName;
								const index = parseInt(deleteBtn.dataset.index);
								if (contactName && !isNaN(index)) {
									handleCharacterChatMessageDeletion(contactName, index);
								}
							}
							// 处理其他列表删除
							else {
								const dataType = deleteBtn.dataset.type;
								const index = parseInt(deleteBtn.dataset.index);
								if (dataType && !isNaN(index)) {
									handleCharacterDataDeletion(dataType, index);
								}
							}
						}
					});

					// NPC库管理功能事件绑定
					// 聊天设置里的"管理NPC库"按钮
					document.getElementById("chat-settings-modal").addEventListener("click", (e) => {
						if (e.target.id === "manage-npcs-btn") {
							// 先关闭聊天设置，再打开NPC管理
							document.getElementById("chat-settings-modal").classList.remove("visible");
							openNpcManager();
						}
					});

					// NPC管理界面的返回按钮
					document.getElementById("back-from-npc-management").addEventListener("click", () => {
						// 返回时，重新打开聊天设置
						showScreen("chat-interface-screen");
						document.getElementById("chat-settings-btn").click();
					});

					// NPC管理界面的"+"按钮
					document.getElementById("add-new-npc-btn").addEventListener("click", () => openNpcEditor(null));

					// 后台活动设置界面的事件绑定
					// 总开关的事件
					document.getElementById("background-activity-switch").addEventListener("change", () => {
						// 每次点击总开关，都重新渲染一次详细设置区（它会根据开关状态自动显示或隐藏）
						renderBackgroundFrequencySelector();
					});

					// 全选按钮
					document.getElementById("bg-select-all-chars").addEventListener("click", () => {
						document.querySelectorAll(".bg-char-checkbox").forEach((checkbox) => {
							checkbox.checked = true;
						});
					});

					// 全不选按钮
					document.getElementById("bg-deselect-all-chars").addEventListener("click", () => {
						document.querySelectorAll(".bg-char-checkbox").forEach((checkbox) => {
							checkbox.checked = false;
						});
					});

					// 后台活动频率设置按钮事件处理
					document.querySelector("#background-activity-details").addEventListener("click", async (e) => {
						// 注意这里加了 async
						if (e.target.classList.contains("bg-freq-btn")) {
							const freq = e.target.dataset.freq;
							const selectedCheckboxes = document.querySelectorAll(".bg-char-checkbox:checked");

							if (selectedCheckboxes.length === 0) {
								alert("请先选择至少一个角色！");
								return;
							}

							const config = state.globalSettings.backgroundActivityConfig || {};
							selectedCheckboxes.forEach((checkbox) => {
								const chatId = checkbox.dataset.chatId;
								if (freq === "none") {
									delete config[chatId];
								} else {
									config[chatId] = freq;
								}
							});

							state.globalSettings.backgroundActivityConfig = config;

							// 这就是我们新加的关键代码！
							await db.globalSettings.put(state.globalSettings);
							// 添加结束

							renderBackgroundFrequencySelector();

							const freqTextMap = { low: "低", medium: "中", high: "高", none: "关闭" };
							const freqText = freqTextMap[freq];
							alert(`已为 ${selectedCheckboxes.length} 个角色将后台活动频率设为 "${freqText}"`);
						}
					});

					// 使用事件委托，为所有可编辑元素统一绑定点击事件
					document.getElementById("home-screen").addEventListener("click", async (e) => {
						// <-- 把这行也改成 async
						// 核心修正：使用 .closest() 来确保即使点击到子元素也能正确触发
						const editableText = e.target.closest(".editable-text");
						if (editableText) {
							handleEditText(editableText);
							return; // 处理完就退出，避免重复触发
						}

						const editableImage = e.target.closest(".editable-image");
						if (editableImage) {
							// 这就是我们本次修改的核心代码
							// 1. 判断被点击的图片是不是主屏幕的那个大头像
							if (editableImage.id === "profile-avatar-img") {
								// 2. 如果是，就弹出一个选择菜单
								const choice = await showChoiceModal("编辑头像", [
									{ text: "更换头像图片", value: "avatar" },
									{ text: "更换头像框", value: "frame" },
								]);

								// 3. 根据用户的选择，执行不同的操作
								if (choice === "avatar") {
									handleEditImage(editableImage); // 调用原来的更换图片函数
								} else if (choice === "frame") {
									openFrameSelectorModal("home_profile"); // 调用我们新增的更换头像框函数
								}
							} else {
								// 4. 如果点击的不是主头像（比如是其他小组件的图片），就还执行原来的逻辑
								handleEditImage(editableImage);
							}
							// 核心代码修改结束
							return;
						}
					});

					/**
					 * 处理角色手机内数据删除的通用函数
					 * @param {string} dataType - 要删除的数据类型, 比如 'memos', 'shoppingCart'
					 * @param {number} index - 要删除的数据在数组中的索引
					 */
					async function handleCharacterDataDeletion(dataType, index) {
						if (!activeCharacterPhoneId) return;
						const chat = state.chats[activeCharacterPhoneId];

						let dataArray;
						// 核心修改：处理像 bank.transactions 这样的嵌套数据
						if (dataType.includes(".")) {
							const keys = dataType.split(".");
							dataArray = chat.characterPhoneData[keys[0]][keys[1]];
						} else {
							dataArray = chat.characterPhoneData[dataType];
						}

						if (!chat || !dataArray) return;

						const itemToDelete = dataArray[index];
						if (!itemToDelete) return;

						const confirmed = await showCustomConfirm("确认删除", "确定要删除这条记录吗？", { confirmButtonClass: "btn-danger" });

						if (confirmed) {
							dataArray.splice(index, 1);
							await db.chats.put(chat);

							// 根据删除的类型，重新渲染对应的APP界面
							switch (dataType) {
								case "memos":
									renderCharacterMemos();
									break;
								case "shoppingCart":
									renderCharacterShoppingCart();
									break;
								case "browserHistory":
									renderCharacterBrowser();
									break;
								case "diary":
									renderCharacterDiary();
									break;
								case "bank.transactions":
									renderCharacterBank();
									break; // 新增
								case "trajectory":
									renderCharacterTrajectory();
									break; // 新增
								case "appUsage":
									renderCharacterAppUsage();
									break; // 新增
								case "photoAlbum":
									renderCharacterPhotoAlbum();
									break; // 新增
							}
							alert("记录已删除。");
						}
					}

					// 启动群聊专属的后台时钟
					startGroupSimulation();

					// 使用事件委托，监听整个动态列表的"焦点移出"事件
					document.getElementById("qzone-posts-list").addEventListener("focusout", (e) => {
						// 如果是评论输入框失去了焦点
						if (e.target.classList.contains("comment-input")) {
							const commentInput = e.target;
							// 并且输入框是空的
							if (commentInput.value.trim() === "") {
								// 就重置它的状态，取消回复
								commentInput.placeholder = "友善的评论是交流的起点";
								delete commentInput.dataset.replyTo;
							}
						}
					});

					// 为时间感知开关添加实时交互事件
					document.getElementById("time-perception-toggle").addEventListener("change", (e) => {
						const customTimeContainer = document.getElementById("custom-time-container");
						customTimeContainer.style.display = e.target.checked ? "none" : "block";
					});

					// 心声功能事件监听器
					document.getElementById("char-heart-btn").addEventListener("click", openInnerVoiceModal);

					// 关闭内心独白模态框
					document.getElementById("close-inner-voice-modal").addEventListener("click", () => {
						document.getElementById("inner-voice-modal").classList.remove("visible");
					});

					// 内心独白历史按钮事件处理
					document.getElementById("inner-voice-history-btn").addEventListener("click", toggleInnerVoiceHistory);

					// 返回内心独白历史按钮事件处理
					document.getElementById("back-from-history-btn").addEventListener("click", toggleInnerVoiceHistory);

					/**
					 * 【全新】导出当前角色的聊天记录
					 */
					async function exportChatHistory() {
						if (!state.activeChatId) return;
						const chat = state.chats[state.activeChatId];
						if (!chat) return;

						// 1. 创建一个只包含聊天记录和角色名的对象
						const exportData = {
							characterName: chat.name,
							exportedAt: new Date().toISOString(),
							history: chat.history,
						};

						// 2. 将这个对象转换为格式化的JSON字符串
						const jsonString = JSON.stringify(exportData, null, 2);

						// 3. 创建一个Blob对象
						const blob = new Blob([jsonString], { type: "application/json" });

						// 4. 创建一个临时的下载链接
						const url = URL.createObjectURL(blob);
						const link = document.createElement("a");

						// 5. 设置下载链接的属性，包括文件名
						const dateStr = new Date().toISOString().split("T")[0];
						link.href = url;
						link.download = `[${chat.name}]-聊天记录-${dateStr}.json`;

						// 6. 模拟点击链接来触发下载
						document.body.appendChild(link);
						link.click();

						// 7. 清理临时创建的元素和URL
						document.body.removeChild(link);
						URL.revokeObjectURL(url);

						await showCustomAlert("导出成功", `与"${chat.name}"的聊天记录已开始下载！`);
					}

					/**
					 * 【全新】导入聊天记录到当前角色
					 */
					async function importChatHistory(file) {
						if (!file) return;
						if (!state.activeChatId) return;

						const reader = new FileReader();
						reader.onload = async (e) => {
							try {
								const data = JSON.parse(e.target.result);

								// 关键验证：检查导入的文件是否包含一个名为 'history' 的数组
								if (!data.history || !Array.isArray(data.history)) {
									throw new Error("文件格式不正确，缺少有效的'history'数据。");
								}

								const chat = state.chats[state.activeChatId];

								// 安全警告：提醒用户这将覆盖现有记录
								const confirmed = await showCustomConfirm("确认导入", `这将会【覆盖】你与"${chat.name}"的当前所有聊天记录。此操作无法撤销，确定要继续吗？`, { confirmButtonClass: "btn-danger" });

								if (confirmed) {
									// 替换历史记录
									chat.history = data.history;
									// 保存到数据库
									await db.chats.put(chat);
									// 刷新界面
									renderChatInterface(state.activeChatId);
									renderChatList(); // 刷新列表以更新最后一条消息
									await showCustomAlert("导入成功", "聊天记录已成功导入并覆盖！");
								}
							} catch (error) {
								console.error("导入聊天记录失败:", error);
								await showCustomAlert("导入失败", `无法导入文件，请检查文件是否为正确的聊天记录备份文件。\n\n错误: ${error.message}`);
							}
						};
						reader.readAsText(file, "UTF-8");
					}

					/**
					 * 导出当前选中的气泡样式预设
					 */
					async function exportSelectedBubblePreset() {
						const selectEl = document.getElementById("bubble-style-preset-select");
						const selectedId = parseInt(selectEl.value);

						if (!selectedId) {
							alert("请先从下拉框中选择一个要导出的预设。");
							return;
						}

						const preset = await db.bubbleStylePresets.get(selectedId);
						if (!preset) {
							alert("找不到选中的预设。");
							return;
						}

						// 准备要导出的数据
						const exportData = {
							presetName: preset.name,
							presetCss: preset.css,
						};

						// 创建并触发下载
						const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
						const url = URL.createObjectURL(blob);
						const a = document.createElement("a");
						a.href = url;
						a.download = `[EPhone气泡]${preset.name}.json`;
						document.body.appendChild(a);
						a.click();
						document.body.removeChild(a);
						URL.revokeObjectURL(url);
					}

					/**
					 * 处理导入的气泡样式预设文件
					 * @param {File} file - 用户选择的.json文件
					 */
					function importBubblePreset(file) {
						if (!file) return;
						const reader = new FileReader();
						reader.onload = async (e) => {
							try {
								const data = JSON.parse(e.target.result);
								// 验证文件内容是否正确
								if (data.presetName && typeof data.presetCss !== "undefined") {
									const newPreset = {
										name: `${data.presetName} (导入)`,
										css: data.presetCss,
									};
									const newId = await db.bubbleStylePresets.add(newPreset);

									if (!state.bubbleStylePresets) state.bubbleStylePresets = [];
									state.bubbleStylePresets.push({ id: newId, ...newPreset });

									// 刷新下拉框并自动选中新导入的预设
									renderBubblePresetSelector();
									document.getElementById("bubble-style-preset-select").value = newId;
									handlePresetSelectChange();
									await showCustomAlert("导入成功", `气泡预设 "${newPreset.name}" 已成功导入！`);
								} else {
									alert("导入失败：文件格式不正确。");
								}
							} catch (error) {
								alert(`导入失败：文件解析错误。 ${error.message}`);
							}
						};
						reader.readAsText(file);
					}

					// 塔罗牌占卜功能事件绑定
					document.getElementById("open-tarot-btn").addEventListener("click", openTarotModal);
					document.getElementById("close-tarot-modal-btn").addEventListener("click", () => {
						document.getElementById("tarot-divination-modal").classList.remove("visible");
					});
					document.getElementById("draw-tarot-cards-btn").addEventListener("click", handleDrawCards);
					document.getElementById("back-to-tarot-setup-btn").addEventListener("click", () => {
						document.getElementById("tarot-result-view").style.display = "none";
						document.getElementById("tarot-setup-view").style.display = "block";
					});
					document.getElementById("send-tarot-result-btn").addEventListener("click", sendTarotReadingToChat);
					document.getElementById("tarot-history-btn").addEventListener("click", openTarotHistory);
					document.getElementById("back-to-tarot-main-btn").addEventListener("click", () => {
						document.getElementById("tarot-history-view").style.display = "none";
						document.getElementById("tarot-setup-view").style.display = "block";
					});

					// 使用事件委托处理历史记录的删除按钮
					document.getElementById("tarot-history-list").addEventListener("click", (e) => {
						if (e.target.classList.contains("tarot-history-delete-btn")) {
							const readingId = parseInt(e.target.dataset.id);
							if (!isNaN(readingId)) {
								deleteTarotReading(readingId);
							}
						}
					});

					// 初始化时创建默认小组
					await initializeDefaultGroups();

					// 主屏幕滑动分页的JS逻辑
					function initHomeScreenSlider() {
						const slider = document.querySelector(".home-screen-slider");
						const dots = document.querySelectorAll(".pagination-dots .dot");

						if (!slider || dots.length === 0) return;

						// 监听滑动事件
						slider.addEventListener("scroll", () => {
							// 计算当前滑到了第几页
							const pageIndex = Math.round(slider.scrollLeft / slider.clientWidth);

							// 更新小圆点的状态
							dots.forEach((dot, index) => {
								dot.classList.toggle("active", index === pageIndex);
							});
						});
					}

					// 初始化主屏幕滑动功能
					initHomeScreenSlider();

					// 监听主屏幕图标和小组件颜色选择器的实时变化
					document.getElementById("home-icon-widget-text-color-picker").addEventListener("input", (e) => {
						applyHomeIconWidgetTextColor(e.target.value);
					});

					// 主屏幕字体阴影开关的实时预览事件
					document.getElementById("remove-home-font-shadow-toggle").addEventListener("change", (e) => {
						document.getElementById("phone-screen").classList.toggle("no-home-font-shadow", e.target.checked);
					});

					// 宠物功能事件监听器
					// 绑定输入框上方的宠物图标按钮
					document.getElementById("pet-action-btn").addEventListener("click", openPetModal);

					// 绑定宠物弹窗内的各种按钮
					document.getElementById("pet-modal-cancel-btn").addEventListener("click", () => {
						document.getElementById("pet-modal").classList.remove("visible");
						currentPetData = null; // 取消时也要清理
					});
					document.getElementById("pet-modal-save-btn").addEventListener("click", savePetSettings);

					// 实时更新预览
					document.getElementById("pet-type-input").addEventListener("input", updatePetPreview);
					document.getElementById("pet-name-input").addEventListener("input", updatePetPreview);
					document.getElementById("pet-image-input").addEventListener("input", updatePetPreview);

					// "在聊天界面显示"开关的交互
					document.getElementById("pet-display-toggle").addEventListener("change", (e) => {
						document.getElementById("pet-position-controls").style.display = e.target.checked ? "block" : "none";
					});

					// 尺寸滑块的交互
					const sizeSlider = document.getElementById("pet-size-slider");
					sizeSlider.addEventListener("input", () => {
						document.getElementById("pet-size-value").textContent = `${sizeSlider.value}px`;
					});

					// 绑定更换自定义图片的点击事件
					document.getElementById("pet-preview-display").addEventListener("click", () => {
						document.getElementById("pet-custom-image-input").click();
					});
					document.getElementById("pet-custom-image-input").addEventListener("change", (e) => {
						const file = e.target.files[0];
						if (file) {
							const reader = new FileReader();
							reader.onload = (event) => {
								// 将图片的Base64链接直接填入输入框
								document.getElementById("pet-image-input").value = event.target.result;
								updatePetPreview(); // 并更新预览
							};
							reader.readAsDataURL(file);
						}
					});

					// 绑定互动按钮 (使用事件委托)
					document.getElementById("pet-interaction-area").addEventListener("click", (e) => {
						if (e.target.tagName === "BUTTON" && e.target.dataset.action) {
							handlePetInteraction(e.target.dataset.action);
						}
					});

					// 初始化宠物的拖动功能
					initPetDragging();

					// 宠物聊天功能事件绑定
					document.getElementById("send-to-pet-btn").addEventListener("click", handleSendToPet);
					document.getElementById("pet-chat-input").addEventListener("keypress", (e) => {
						if (e.key === "Enter" && !e.shiftKey) {
							e.preventDefault();
							document.getElementById("send-to-pet-btn").click();
						}
					});

					// 为宠物聊天窗口的"外部"点击添加关闭功能
					const petChatModal = document.getElementById("pet-chat-modal");
					petChatModal.addEventListener("click", (e) => {
						if (e.target === petChatModal) {
							// 只有点击灰色遮罩层才关闭
							petChatModal.classList.remove("visible");
						}
					});

					// 为"放生宠物"按钮绑定事件
					document.getElementById("pet-abandon-btn").addEventListener("click", async () => {
						if (!state.activeChatId) return;

						const confirmed = await showCustomConfirm("确认放生", "确定要关闭宠物系统吗？这将会重置所有宠物数据（数值、聊天记录等），但不会删除你的设置。你可以随时重新领养。", { confirmButtonClass: "btn-danger" });

						if (confirmed) {
							const chat = state.chats[state.activeChatId];
							chat.settings.petAdopted = false; // 关闭领养状态
							delete chat.settings.pet; // 删除宠物数据对象

							await db.chats.put(chat);

							renderChatPet(); // 从聊天界面移除宠物
							document.getElementById("pet-modal").classList.remove("visible"); // 关闭弹窗
							alert("宠物已放生，江湖再见！");
						}
					});

					// 绑定线下模式预设的下拉框和管理按钮
					document.getElementById("offline-preset-select").addEventListener("change", handleOfflinePresetSelection);
					document.getElementById("manage-offline-presets-btn").addEventListener("click", openOfflinePresetManager);

					// 打开聊天总结查看器
					document.getElementById("view-summaries-btn").addEventListener("click", openSummaryViewer);

					// 关闭总结查看器并返回聊天设置
					document.getElementById("close-summary-viewer-btn").addEventListener("click", () => {
						document.getElementById("summary-viewer-modal").classList.remove("visible");
						document.getElementById("chat-settings-btn").click();
					});

					// 使用事件委托处理总结列表中的编辑、删除和精简操作
					document.getElementById("summary-list").addEventListener("click", (e) => {
						const editBtn = e.target.closest(".edit-summary-btn");
						if (editBtn) {
							const timestamp = parseInt(editBtn.dataset.timestamp);
							editSummary(timestamp);
							return;
						}

						const deleteBtn = e.target.closest(".delete-summary-btn");
						if (deleteBtn) {
							const timestamp = parseInt(deleteBtn.dataset.timestamp);
							deleteSummary(timestamp);
							return;
						}

						const conciseBtn = e.target.closest(".concise-summary-btn");
						if (conciseBtn) {
							const timestamp = parseInt(conciseBtn.dataset.timestamp);
							handleConciseSummary(timestamp);
							return;
						}
					});

					// 为“全部精简”按钮绑定事件
					document.getElementById("concise-all-summaries-btn").addEventListener("click", handleConciseAllSummaries);

					// 打开手动总结选项
					document.getElementById("chat-settings-modal").addEventListener("click", (e) => {
						if (e.target.id === "manual-summary-btn") {
							document.getElementById("chat-settings-modal").classList.remove("visible");
							openManualSummaryOptions();
						}
					});

					// 角色手机外观设置事件监听器
					document.getElementById("character-phone-container").addEventListener("click", (e) => {
						if (e.target.id === "upload-char-phone-wallpaper-btn") {
							document.getElementById("char-phone-wallpaper-upload-input").click();
						} else if (e.target.id === "remove-char-phone-wallpaper-btn") {
							handleCharPhoneWallpaperChange("");
						} else {
							const changeIconButton = e.target.closest(".change-icon-btn");
							if (changeIconButton) {
								const iconId = changeIconButton.dataset.iconId;
								handleChangeCharPhoneIcon(iconId);
							}
						}
					});

					// 监听壁纸文件选择
					document.getElementById("char-phone-wallpaper-upload-input").addEventListener("change", async (event) => {
						const file = event.target.files[0];
						if (file) {
							const dataUrl = await new Promise((res) => {
								const reader = new FileReader();
								reader.onload = () => res(reader.result);
								reader.readAsDataURL(file);
							});
							handleCharPhoneWallpaperChange(dataUrl);
						}
						event.target.value = null;
					});

					// 角色手机小组件上传功能
					const handleWidgetUpload = async (widgetKey, inputFileId) => {
						const fileInput = document.getElementById(inputFileId);
						const file = fileInput.files[0];
						if (!file) return;

						const dataUrl = await new Promise((res) => {
							const reader = new FileReader();
							reader.onload = () => res(reader.result);
							reader.readAsDataURL(file);
						});

						const chat = state.chats[activeCharacterPhoneId];
						if (!chat.characterPhoneData.widgets) {
							chat.characterPhoneData.widgets = {};
						}
						chat.characterPhoneData.widgets[widgetKey] = dataUrl;

						await db.chats.put(chat);
						renderCharPhoneAppearanceScreen();
						openCharacterPhone(activeCharacterPhoneId);
						alert("小组件图片已更新！");
						fileInput.value = null;
					};

					const handleWidgetRemove = async (widgetKey) => {
						const chat = state.chats[activeCharacterPhoneId];
						if (chat.characterPhoneData.widgets && chat.characterPhoneData.widgets[widgetKey]) {
							delete chat.characterPhoneData.widgets[widgetKey];
							await db.chats.put(chat);
							renderCharPhoneAppearanceScreen();
							openCharacterPhone(activeCharacterPhoneId);
							alert("小组件图片已移除！");
						}
					};

					// 小组件按钮事件绑定
					document.getElementById("upload-widget-1-btn").addEventListener("click", () => {
						document.getElementById("char-phone-widget-1-upload-input").click();
					});
					document.getElementById("remove-widget-1-btn").addEventListener("click", () => {
						handleWidgetRemove("widget1_url");
					});
					document.getElementById("char-phone-widget-1-upload-input").addEventListener("change", () => {
						handleWidgetUpload("widget1_url", "char-phone-widget-1-upload-input");
					});

					document.getElementById("upload-widget-2-btn").addEventListener("click", () => {
						document.getElementById("char-phone-widget-2-upload-input").click();
					});
					document.getElementById("remove-widget-2-btn").addEventListener("click", () => {
						handleWidgetRemove("widget2_url");
					});
					document.getElementById("char-phone-widget-2-upload-input").addEventListener("change", () => {
						handleWidgetUpload("widget2_url", "char-phone-widget-2-upload-input");
					});

					// 角色手机外观预设功能事件绑定
					document.getElementById("char-phone-preset-selector").addEventListener("change", handleCharPhonePresetSelection);
					document.getElementById("apply-char-phone-preset-btn").addEventListener("click", applySelectedCharPhonePreset);
					document.getElementById("save-char-phone-preset-btn").addEventListener("click", saveCurrentCharPhonePreset);
					document.getElementById("update-char-phone-preset-btn").addEventListener("click", updateSelectedCharPhonePreset);
					document.getElementById("rename-char-phone-preset-btn").addEventListener("click", renameSelectedCharPhonePreset);
					document.getElementById("delete-char-phone-preset-btn").addEventListener("click", deleteSelectedCharPhonePreset);
					document.getElementById("export-char-phone-preset-btn").addEventListener("click", exportCharPhonePreset);
					document.getElementById("import-char-phone-preset-btn").addEventListener("click", () => {
						document.getElementById("import-char-phone-preset-input").click();
					});
					document.getElementById("import-char-phone-preset-input").addEventListener("change", (e) => {
						importCharPhonePreset(e.target.files[0]);
						e.target.value = null;
					});

					// 角色手机App内壁纸功能事件绑定
					document.getElementById("upload-char-phone-app-wallpaper-btn").addEventListener("click", () => {
						document.getElementById("char-phone-app-wallpaper-upload-input").click();
					});

					document.getElementById("char-phone-app-wallpaper-upload-input").addEventListener("change", async (event) => {
						const file = event.target.files[0];
						if (file) {
							const dataUrl = await new Promise((res) => {
								const reader = new FileReader();
								reader.onload = () => res(reader.result);
								reader.readAsDataURL(file);
							});
							handleCharPhoneAppWallpaperChange(dataUrl);
						}
						event.target.value = null;
					});

					document.getElementById("remove-char-phone-app-wallpaper-btn").addEventListener("click", () => {
						handleCharPhoneAppWallpaperChange("");
					});

					// 心声背景更换功能
					document.getElementById("change-inner-voice-bg-btn").addEventListener("click", handleInnerVoiceBgChange);

					document.getElementById("inner-voice-bg-input").addEventListener("change", async (event) => {
						const file = event.target.files[0];
						if (!file) return;

						const dataUrl = await new Promise((resolve) => {
							const reader = new FileReader();
							reader.onload = (e) => resolve(e.target.result);
							reader.readAsDataURL(file);
						});

						await saveInnerVoiceBackground(dataUrl);
						event.target.value = null;
					});

					// 情侣空间取消和解除绑定
					document.getElementById("ls-cancel-space-btn").addEventListener("click", handleCancelLoversSpace);
					document.getElementById("ls-disconnect-space-btn").addEventListener("click", handleDisconnectLoversSpace);

					// 监听删除按钮的点击
					userDmListEl.addEventListener("click", (e) => {
						if (e.target.classList.contains("swipe-action-btn") && e.target.classList.contains("delete")) {
							const fanIndex = parseInt(e.target.dataset.fanIndex);
							if (!isNaN(fanIndex)) {
								handleDeleteUserDmConversation(fanIndex);
							}
						}
					});

					// 群成员管理功能增强
					document.getElementById("member-management-list").addEventListener("click", (e) => {
						const button = e.target.closest(".action-btn");
						if (!button) return;

						const action = button.dataset.action;
						const memberId = button.dataset.memberId;

						if (!action || !memberId) return;

						if (memberId === "user") {
							if (action === "set-nickname") handleSetUserNickname();
							if (action === "set-title") handleSetUserTitle();
							if (action === "unmute-self") {
								handleUserUnmute();
							}
							return;
						}

						switch (action) {
							case "toggle-admin":
								handleToggleAdmin(memberId);
								break;
							case "set-title":
								handleSetMemberTitle(memberId);
								break;
							case "transfer-owner":
								handleTransferOwnership(memberId);
								break;
							case "remove-member":
								removeMemberFromGroup(memberId);
								break;
							case "mute-member":
								handleMuteMember(memberId);
								break;
						}
					});

					// 绑定群公告按钮，点击时打开群公告模态框
					document.getElementById("group-announcement-btn").addEventListener("click", openGroupAnnouncementModal);

					// 绑定用户表情面板的批量删除相关按钮事件
					document.getElementById("edit-user-stickers-btn").addEventListener("click", toggleUserStickerSelectionMode);
					document.getElementById("done-user-stickers-btn").addEventListener("click", toggleUserStickerSelectionMode);
					document.getElementById("delete-selected-user-stickers-btn").addEventListener("click", handleBulkDeleteUserStickers);

					// 关闭表情面板时退出选择模式
					document.getElementById("close-sticker-panel-btn").addEventListener("click", () => {
						exitUserStickerSelectionMode();
						stickerPanel.classList.remove("visible");
					});

					// 处理删除表情分类按钮的点击事件
					function onStickerCategoryDelete(deleteButtonElement) {
						const categoryId = parseInt(deleteButtonElement.dataset.categoryId);
						const categoryName = deleteButtonElement.dataset.categoryName;

						// 调试输出分类ID和名称
						console.log(`[调试] 准备删除分类: ID=${categoryId}, 名称='${categoryName}'`);

						if (!isNaN(categoryId) && categoryName) {
							handleDeleteStickerCategory(categoryId, categoryName);
						} else {
							console.error("[错误] 无法从按钮获取有效的分类ID或名称。", deleteButtonElement.dataset);
							alert("删除失败：无法获取分类信息，请检查代码或刷新页面。");
						}
					}

					// 处理切换表情分类按钮的点击事件
					function onStickerCategorySelect(categoryButtonElement) {
						const categoryIdStr = categoryButtonElement.dataset.categoryId;
						activeStickerCategoryId = categoryIdStr === "uncategorized" ? "uncategorized" : parseInt(categoryIdStr);
						renderStickerPanel(); // 切换分类并重新渲染表情列表
					}

					// 绑定角色表情管理页的批量删除按钮事件
					document.getElementById("edit-char-stickers-btn").addEventListener("click", toggleCharStickerSelectionMode);
					document.getElementById("done-char-stickers-btn").addEventListener("click", toggleCharStickerSelectionMode);
					document.getElementById("delete-selected-char-stickers-btn").addEventListener("click", handleBulkDeleteCharStickers);

					// 返回聊天设置时退出选择模式
					document.getElementById("back-from-sticker-manager").addEventListener("click", () => {
						exitCharStickerSelectionMode();
						showScreen("chat-interface-screen");
						document.getElementById("chat-settings-btn").click();
					});

					// 为心声面板编辑按钮绑定事件
					document.getElementById("inner-voice-modal").addEventListener("click", (e) => {
						if (e.target.closest("#inner-voice-edit-btn")) {
							showInnerVoiceEditOptions();
						}
					});

					// 心声样式编辑器事件绑定
					const ivEditorModal = document.getElementById("inner-voice-editor-modal");
					const ivPanel = document.getElementById("inner-voice-main-panel");

					// 实时预览功能
					ivEditorModal.addEventListener("input", (e) => {
						const targetId = e.target.id;
						const value = e.target.value;

						switch (targetId) {
							case "iv-color-clothing":
								ivPanel.style.setProperty("--iv-color-clothing", value);
								break;
							case "iv-color-behavior":
								ivPanel.style.setProperty("--iv-color-behavior", value);
								break;
							case "iv-color-thoughts":
								ivPanel.style.setProperty("--iv-color-thoughts", value);
								break;
							case "iv-color-naughty":
								ivPanel.style.setProperty("--iv-color-naughty", value);
								break;
							case "iv-card-bg-color":
								ivPanel.style.setProperty("--iv-card-rgb", hexToRgb(value));
								break;
							case "iv-opacity-slider":
								document.getElementById("iv-opacity-value").textContent = `${Math.round(value * 100)}%`;
								ivPanel.style.setProperty("--iv-card-opacity", value);
								break;
							case "iv-icon-color":
								ivPanel.style.setProperty("--iv-icon-color", value);
								break;
						}
					});

					// 保存心声样式设置
					document.getElementById("iv-editor-save-btn").addEventListener("click", saveInnerVoiceStyles);

					// 取消心声样式编辑
					document.getElementById("iv-editor-cancel-btn").addEventListener("click", () => {
						ivEditorModal.classList.remove("visible");
						// 取消时重新应用保存好的样式
						applySavedInnerVoiceStyles();
					});

					// AI生成群成员功能事件绑定
					document.getElementById("ai-generate-members-btn").addEventListener("click", openAiGenerateMembersModal);
					document.getElementById("cancel-ai-generate-members-btn").addEventListener("click", () => {
						document.getElementById("ai-generate-members-modal").classList.remove("visible");
					});
					document.getElementById("confirm-ai-generate-members-btn").addEventListener("click", handleGenerateMembers);

					// 约会大作战功能事件监听器
					document.getElementById("date-a-live-app-icon").addEventListener("click", openDatingApp);
					document.getElementById("refresh-dating-scene-btn").addEventListener("click", refreshDatingScenes);
					document.getElementById("end-date-btn").addEventListener("click", endDate);

					// 使用事件委托处理约会场景卡片的删除和点击事件
					document.getElementById("dating-scene-content").addEventListener("click", (e) => {
						const card = e.target.closest(".dating-scene-card");
						if (!card) return;

						const sceneUid = card.dataset.uid;
						const scene = currentDatingScenes.find((s) => s.uid === sceneUid);
						if (!scene) return;

						// 如果点击的是删除按钮
						if (e.target.classList.contains("dating-scene-delete-btn")) {
							deleteDatingScene(sceneUid);
						} else {
							// 否则点击卡片本身，打开角色选择器
							openDatingCharacterSelector(scene);
						}
					});

					// 为文游文本框绑定点击切换下一句的事件
					document.querySelector(".dating-game-textbox").addEventListener("click", () => {
						if (
							datingGameState.isActive &&
							!datingGameState.isSwitchingSentence && // 检查是否正在切换中
							datingGameState.currentSentenceIndex < datingGameState.sentences.length - 1
						) {
							showNextSentence();
						}
					});

					// 约会大作战-文游模式UI事件绑定
					document.getElementById("dating-game-settings-btn").addEventListener("click", openDatingSettingsModal);
					document.getElementById("dating-game-reroll-btn").addEventListener("click", handleDatingReroll);

					// 设置弹窗内的按钮事件
					document.getElementById("cancel-dating-settings-btn").addEventListener("click", () => {
						document.getElementById("dating-game-settings-modal").classList.remove("visible");
						// 取消时恢复到角色已保存的设置
						const chat = state.chats[datingGameState.characterId];
						currentDatingUISettings = JSON.parse(JSON.stringify(chat.settings.datingUISettings || {}));
						applyDatingUISettings();
					});
					document.getElementById("save-dating-settings-btn").addEventListener("click", saveDatingSettings);

					// 图片上传按钮事件
					document.querySelector("#dating-game-settings-modal .bg-upload-container button").addEventListener("click", () => handleDatingImageUpload("bg"));
					document.querySelector("#dating-game-settings-modal .form-group:nth-of-type(5) .bg-upload-container button").addEventListener("click", () => handleDatingImageUpload("sprite"));

					// 图片URL输入实时更新
					document.getElementById("dating-bg-url-input").addEventListener("input", (e) => {
						currentDatingUISettings.backgroundUrl = e.target.value.trim();
						applyDatingUISettings();
					});

					// 约会立绘功能事件监听器
					document.getElementById("manage-sprite-groups-btn").addEventListener("click", openSpriteGroupManager);
					document.getElementById("close-sprite-group-manager-btn").addEventListener("click", () => {
						document.getElementById("sprite-group-manager-modal").classList.remove("visible");
					});

					document.getElementById("sprite-group-list-container").addEventListener("click", (e) => {
						const target = e.target;
						if (target.tagName === "BUTTON" && target.dataset.id) {
							const action = target.dataset.action;
							const groupId = parseInt(target.dataset.id);
							if (action === "edit") {
								openSpriteEditor(groupId);
							} else if (action === "delete") {
								deleteSpriteGroup(groupId);
							}
						}
					});

					document.getElementById("create-new-sprite-group-btn").addEventListener("click", () => openSpriteEditor());

					document.getElementById("cancel-sprite-editor-btn").addEventListener("click", () => {
						document.getElementById("sprite-editor-modal").classList.remove("visible");
					});

					document.getElementById("save-sprite-editor-btn").addEventListener("click", saveSpriteGroup);

					document.getElementById("add-new-sprite-btn").addEventListener("click", () => {
						document.getElementById("sprite-list-editor").appendChild(createSpriteEditCard());
					});

					// 约会预设功能按钮事件
					document.getElementById("dating-preset-select").addEventListener("change", handleDatingPresetSelect);
					document.getElementById("manage-dating-presets-btn").addEventListener("click", openDatingPresetManager);

					// 约会结算卡片事件绑定
					const summaryCard = document.querySelector(".dating-summary-card");
					const summaryCardBackBtn = document.getElementById("summary-flip-back-btn");

					// 点击卡片正面或背面的返回按钮触发翻转
					summaryCard.addEventListener("click", (e) => {
						// 确保点击的不是分享或关闭按钮
						if (!e.target.closest("button")) {
							summaryCard.classList.toggle("is-flipped");
						}
					});
					summaryCardBackBtn.addEventListener("click", (e) => {
						e.stopPropagation(); // 阻止事件冒泡到父元素
						summaryCard.classList.remove("is-flipped");
					});

					// 分享按钮事件
					document.getElementById("summary-share-btn").addEventListener("click", shareDatingSummary);

					// 关闭按钮事件（支持不同场景）
					document.getElementById("summary-close-btn").addEventListener("click", async () => {
						if (datingGameState.isActive) {
							// 如果在约会中，确认并结束约会
							const confirmed = await showCustomConfirm("确认关闭", "确定要关闭结算卡片吗？关闭后约会即告结束。", { confirmButtonClass: "btn-danger" });
							if (confirmed) {
								finalizeAndExitDate();
							}
						} else {
							// 如果只是在单聊里查看分享，直接关闭弹窗
							document.getElementById("dating-summary-overlay").classList.remove("visible");
							// 重置卡片翻转状态
							const card = document.querySelector(".dating-summary-card");
							if (card) {
								card.classList.remove("is-flipped");
							}
						}
					});

					// 聊天记录中的卡片点击事件（事件委托）
					document.getElementById("chat-messages").addEventListener("click", (e) => {
						const chatCard = e.target.closest(".dating-summary-chat-card");
						// 检查 data-timestamp
						if (chatCard && chatCard.dataset.timestamp) {
							try {
								const timestamp = parseInt(chatCard.dataset.timestamp);
								const chat = state.chats[state.activeChatId];

								// 用时间戳从聊天记录里找到那条原始消息
								const message = chat.history.find((m) => m.timestamp === timestamp);

								// 如果找到了，直接用它的 payload
								if (message && message.payload) {
									reopenDatingSummary(message.payload);
								} else {
									// 如果因为某种原因没找到，给提示
									alert("无法找到对应的约会记录数据。");
								}
							} catch (error) {
								console.error("打开分享的约会记录失败:", error);
								alert("打开约会记录时发生未知错误。");
							}
						}
					});

					// 约会历史记录功能事件绑定
					document.getElementById("dating-history-btn").addEventListener("click", openDatingHistory);
					document.getElementById("dating-history-back-btn").addEventListener("click", () => showScreen("date-a-live-screen"));

					// 使用事件委托为历史列表中的所有卡片绑定翻转事件
					document.getElementById("dating-history-list").addEventListener("click", (e) => {
						// 找到被点击的卡片
						const card = e.target.closest(".dating-summary-card");
						if (card) {
							// 切换 is-flipped 类触发CSS动画
							card.classList.toggle("is-flipped");
						}
					});

					// 约会大作战-创建场景功能事件绑定
					document.getElementById("create-dating-scene-btn").addEventListener("click", () => {
						// 打开创建弹窗并清空输入框
						document.getElementById("scene-name-input").value = "";
						document.getElementById("scene-image-url-input").value = "";
						document.getElementById("scene-cost-input").value = "";
						document.getElementById("create-dating-scene-modal").classList.add("visible");
					});

					document.getElementById("cancel-create-scene-btn").addEventListener("click", () => {
						document.getElementById("create-dating-scene-modal").classList.remove("visible");
					});

					document.getElementById("save-custom-scene-btn").addEventListener("click", handleSaveCustomDatingScene);

					// 表情分类功能事件绑定
					document.getElementById("move-selected-stickers-btn").addEventListener("click", openStickerCategoryModal);
					document.getElementById("cancel-sticker-category-btn").addEventListener("click", () => {
						document.getElementById("sticker-category-modal").classList.remove("visible");
					});
					document.getElementById("confirm-sticker-category-btn").addEventListener("click", handleMoveStickers);

					// 高级导入/导出功能事件监听器 v2.0
					document.getElementById("advanced-transfer-btn").addEventListener("click", openAdvancedTransferModal);

					document.getElementById("close-advanced-transfer-btn").addEventListener("click", () => {
						document.getElementById("advanced-transfer-modal").classList.remove("visible");
					});

					document.getElementById("export-selected-data-btn").addEventListener("click", exportChunkedData);

					document.getElementById("import-chunked-data-btn").addEventListener("click", () => {
						document.getElementById("import-chunked-data-input").click();
					});

					document.getElementById("import-chunked-data-input").addEventListener("change", (e) => {
						const file = e.target.files[0];
						if (file) {
							importChunkedData(file);
						}
						e.target.value = null; // 清空以便下次选择
					});
					document.getElementById("export-for-330-btn").addEventListener("click", exportDataFor330);

					// 兼容330格式导入按钮事件
					document.getElementById("import-from-330-btn").addEventListener("click", () => {
						// 触发隐藏的文件选择器
						document.getElementById("import-from-330-input").click();
					});

					// 隐藏的文件选择器change事件
					document.getElementById("import-from-330-input").addEventListener("change", (e) => {
						const file = e.target.files[0];
						if (file) {
							// 调用核心导入函数
							importFrom330Format(file);
						}
						// 每次用完后清空
						e.target.value = null;
					});

					document.getElementById("compress-all-images-btn").addEventListener("click", compressAllImagesInDB);
					document.getElementById("export-data-stream-btn").addEventListener("click", exportDataStream);

					// 重置应用名称按钮事件
					document.getElementById("reset-app-names-btn").addEventListener("click", resetAppNamesToDefault);

					// 夜间模式切换功能
					document.addEventListener("DOMContentLoaded", function () {
						const toggleCheckbox = document.getElementById("dark-mode-toggle");
						const storageKey = "darkModeManualPref";
						const darkReaderOptions = {
							brightness: 100,
							contrast: 90,
							sepia: 10,
						};
						const manualPref = localStorage.getItem(storageKey);
						if (manualPref === "true") {
							DarkReader.enable(darkReaderOptions);
							toggleCheckbox.checked = true;
						} else if (manualPref === "false") {
							DarkReader.disable();
							toggleCheckbox.checked = false;
						} else {
							DarkReader.auto(darkReaderOptions);
							setTimeout(() => {
								toggleCheckbox.checked = DarkReader.isEnabled();
							}, 100);
						}
						toggleCheckbox.addEventListener("change", function () {
							if (this.checked) {
								DarkReader.enable(darkReaderOptions);
								localStorage.setItem(storageKey, "true");
							} else {
								DarkReader.disable();
								localStorage.setItem(storageKey, "false");
							}
						});
					});

					// 表情分类标签点击事件（事件委托）
					document.getElementById("sticker-category-tabs").addEventListener("click", (event) => {
						const target = event.target;

						// 委托处理删除按钮的点击
						if (target.classList.contains("sticker-category-delete-btn")) {
							event.stopPropagation();

							const parentBtn = target.closest(".sticker-category-btn");
							if (parentBtn) {
								const categoryId = parseInt(parentBtn.dataset.categoryId);
								const categoryName = parentBtn.dataset.categoryName;

								if (!isNaN(categoryId) && categoryName) {
									handleDeleteStickerCategory(categoryId, categoryName);
								}
							}
							return;
						}

						// 委托处理切换分类按钮的点击
						const categoryBtn = target.closest(".sticker-category-btn");
						if (categoryBtn) {
							const categoryIdStr = categoryBtn.dataset.categoryId;
							activeStickerCategoryId = categoryIdStr === "uncategorized" ? "uncategorized" : parseInt(categoryIdStr);
							renderStickerPanel(); // 切换分类并重新渲染表情列表
						}
					});

					// 亲密值面板事件绑定
					document.getElementById("chat-list").addEventListener("click", (e) => {
						// 检查被点击的是否是亲密值按钮
						const intimacyBtn = e.target.closest(".intimacy-btn");
						if (intimacyBtn) {
							const chatId = intimacyBtn.dataset.chatId;
							if (chatId) {
								openIntimacyPanel(chatId);
							}
						}
					});

					// 面板关闭按钮事件
					document.getElementById("close-intimacy-panel").addEventListener("click", () => {
						document.getElementById("intimacy-panel").classList.remove("visible");
					});

					// 打开亲密值面板按钮事件
					document.getElementById("open-intimacy-panel-btn").addEventListener("click", () => openIntimacyPanel(state.activeChatId));

					// 动态页面头部按钮事件委托
					document.getElementById("qzone-screen").addEventListener("click", (e) => {
						// 检查点击的是否是清空按钮
						const clearBtn = e.target.closest("#clear-qzone-posts-btn");
						if (clearBtn) {
							clearAllQzonePosts(); // 调用清空函数
							return;
						}
					});

					initLoversSpace();
					initTaobao();
					initWeiboEventListeners();

					// ===================================================================
					// 5. 启动！

					// 应用锁屏壁纸并更新锁屏时钟
					applyLockscreenWallpaper();
					updateLockClock();

					// 读取并设置锁屏启用状态
					const enableLockScreenToggle = document.getElementById("enable-lock-screen-toggle");
					const lockScreenEnabled = localStorage.getItem("lockScreenEnabled") !== "false";
					enableLockScreenToggle.checked = lockScreenEnabled;

					// 读取并设置状态栏显示状态
					const showStatusBarToggle = document.getElementById("show-status-bar-toggle");
					const statusBar = document.getElementById("status-bar");
					const showStatusBar = localStorage.getItem("showStatusBar") !== "false";
					showStatusBarToggle.checked = showStatusBar;

					// 根据保存的状态设置状态栏初始显示/隐藏
					if (showStatusBar) {
						statusBar.style.display = "flex";
					} else {
						statusBar.style.display = "none";
					}

					// 监听状态栏开关变化事件，保存设置并更新显示状态
					showStatusBarToggle.addEventListener("change", (e) => {
						const isEnabled = e.target.checked;
						// 保存新的状态栏显示设置
						localStorage.setItem("showStatusBar", isEnabled);
						// 根据新设置显示或隐藏状态栏
						statusBar.style.display = isEnabled ? "flex" : "none";
					});

					// 根据锁屏设置决定启动时显示的初始屏幕
					if (lockScreenEnabled) {
						lockPhone(); // 显示锁屏界面
					} else {
						showScreen("home-screen"); // 直接进入主屏幕
					}
				}

				init();

				/*
				 * ===================================================================
				 * === 全局接口 (Public API for other scripts) ===
				 * ===================================================================
				 * 将主应用的核心功能暴露给其他脚本文件（如 game-hall.js）使用
				 */
				window.openChat = openChat;
				window.triggerAiResponse = triggerAiResponse;
				window.openLoversSpaceFromCard = openLoversSpaceFromCard;

				const avatarFrames = [
					{ id: "none", url: "", name: "无" },
					{ id: "frame_cat_ear", url: "https://i.postimg.cc/fLDnz5Pn/IMG-5574.gif", name: "1" },
					{ id: "frame_ribbon", url: "https://i.postimg.cc/HxH3cNHz/IMG-6871.gif", name: "2" },
					{ id: "frame_flower", url: "https://i.postimg.cc/jCVK0fGL/IMG-6890.gif", name: "3" },
					{ id: "frame_tech", url: "https://i.postimg.cc/85Zsyjwn/IMG-6895.gif", name: "4" },
					{ id: "frame_5", url: "https://i.postimg.cc/cJtpZCB3/IMG-6894.gif", name: "5" },
					{ id: "frame_6", url: "https://i.postimg.cc/63sDQKMm/IMG-6893.gif", name: "6" },
					{ id: "frame_7", url: "https://i.postimg.cc/cHQPgzj4/IMG-6888.gif", name: "7" },
					{ id: "frame_8", url: "https://i.postimg.cc/dVLXm3Xf/IMG-6885.gif", name: "8" },
					{ id: "frame_9", url: "https://i.postimg.cc/kGsZwbq0/IMG-6886.gif", name: "9" },
					{ id: "frame_10", url: "https://i.postimg.cc/63NmX03s/IMG-4366.gif", name: "10" },
					{ id: "frame_11", url: "https://i.postimg.cc/zvz2LGK0/IMG-4367.gif", name: "11" },
					{ id: "frame_12", url: "https://i.postimg.cc/prsGKMBx/IMG-4370.gif", name: "12" },
					{ id: "frame_13", url: "https://i.postimg.cc/gk0BmrY0/IMG-4371.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/fRt2SFSn/IMG-4368.gif", name: "14" },
					{ id: "frame_cat_ear", url: "https://i.postimg.cc/kGgwJhPH/IMG-4374.gif", name: "1" },
					{ id: "frame_ribbon", url: "https://i.postimg.cc/PrcKH436/IMG-4376.gif", name: "2" },
					{ id: "frame_flower", url: "https://i.postimg.cc/fRV86FMq/IMG-4381.gif", name: "3" },
					{ id: "frame_tech", url: "https://i.postimg.cc/HsyqMVyk/IMG-4385.gif", name: "4" },
					{ id: "frame_5", url: "https://i.postimg.cc/qBbKK7dS/IMG-4386.gif", name: "5" },
					{ id: "frame_6", url: "https://i.postimg.cc/05wnd389/IMG-4388.gif", name: "6" },
					{ id: "frame_7", url: "https://i.postimg.cc/RZNLhbbr/IMG-4389.gif", name: "7" },
					{ id: "frame_8", url: "https://i.postimg.cc/fLTc42dg/IMG-4391.gif", name: "8" },
					{ id: "frame_9", url: "https://i.postimg.cc/FzbGNdRT/IMG-4392.gif", name: "9" },
					{ id: "frame_10", url: "https://i.postimg.cc/XY63sTS3/IMG-4393.gif", name: "10" },
					{ id: "frame_11", url: "https://i.postimg.cc/Cx9vCVWH/IMG-4395.gif", name: "11" },
					{ id: "frame_12", url: "https://i.postimg.cc/kMfPQBwQ/IMG-4396.gif", name: "12" },
					{ id: "frame_13", url: "https://i.postimg.cc/CLrZQMMD/IMG-4398.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/L4zwDhTC/IMG-4399.gif", name: "14" },
					{ id: "frame_cat_ear", url: "https://i.postimg.cc/yN3s8szM/IMG-4400.gif", name: "1" },
					{ id: "frame_ribbon", url: "https://i.postimg.cc/59Cn1tkB/IMG-4401.gif", name: "2" },
					{ id: "frame_flower", url: "https://i.postimg.cc/g0s1V0PX/IMG-4402.gif", name: "3" },
					{ id: "frame_tech", url: "https://i.postimg.cc/Jn1DFPgY/IMG-4403.gif", name: "4" },
					{ id: "frame_5", url: "https://i.postimg.cc/q7cQnDy1/IMG-4404.gif", name: "5" },
					{ id: "frame_6", url: "https://i.postimg.cc/RFK3q2t0/IMG-4407.gif", name: "6" },
					{ id: "frame_7", url: "https://i.postimg.cc/gcV0VR2t/IMG-4408.gif", name: "7" },
					{ id: "frame_8", url: "https://i.postimg.cc/W1CjLb4J/IMG-4409.gif", name: "8" },
					{ id: "frame_9", url: "https://i.postimg.cc/Ss7pM6fW/IMG-4410.gif", name: "9" },
					{ id: "frame_10", url: "https://i.postimg.cc/nrFfYX3N/IMG-4412.gif", name: "10" },
					{ id: "frame_11", url: "https://i.postimg.cc/cHWp0KG6/IMG-4413.gif", name: "11" },
					{ id: "frame_12", url: "https://i.postimg.cc/4yNjHrdg/IMG-4414.gif", name: "12" },
					{ id: "frame_13", url: "https://i.postimg.cc/hPX5F8Qp/IMG-4415.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/vHCSG1WM/IMG-4416.gif", name: "14" },
					{ id: "frame_cat_ear", url: "https://i.postimg.cc/x1Hp80Rm/IMG-4417.gif", name: "1" },
					{ id: "frame_ribbon", url: "https://i.postimg.cc/FHRcCGfH/IMG-4418.gif", name: "2" },
					{ id: "frame_flower", url: "https://i.postimg.cc/13hhJ77p/IMG-4419.gif", name: "3" },
					{ id: "frame_tech", url: "https://i.postimg.cc/J4WCQd2j/IMG-4420.gif", name: "4" },
					{ id: "frame_5", url: "https://i.postimg.cc/Dydkpd9H/IMG-4421.gif", name: "5" },
					{ id: "frame_6", url: "https://i.postimg.cc/mrkvDxPW/IMG-4422.gif", name: "6" },
					{ id: "frame_7", url: "https://i.postimg.cc/76Tj3g1B/IMG-4425.gif", name: "7" },
					{ id: "frame_8", url: "https://i.postimg.cc/3N5Vndn3/IMG-4426.gif", name: "8" },
					{ id: "frame_9", url: "https://i.postimg.cc/05DLr0yj/IMG-4427.gif", name: "9" },
					{ id: "frame_10", url: "https://i.postimg.cc/GhR6DT4Q/IMG-4428.gif", name: "10" },
					{ id: "frame_11", url: "https://i.postimg.cc/fRTF24jS/IMG-4430.gif", name: "11" },
					{ id: "frame_12", url: "https://i.postimg.cc/R0WYmcYM/IMG-4431.gif", name: "12" },
					{ id: "frame_13", url: "https://i.postimg.cc/nrJSqNhz/IMG-4432.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/tC9mJ0cv/IMG-4438.gif", name: "14" },
					{ id: "frame_cat_ear", url: "https://i.postimg.cc/XNkQTHvf/IMG-5561.gif", name: "1" },
					{ id: "frame_ribbon", url: "https://i.postimg.cc/Mpv5fzm5/IMG-4439.gif", name: "2" },
					{ id: "frame_flower", url: "https://i.postimg.cc/T1tjhsyB/IMG-4720.gif", name: "3" },
					{ id: "frame_tech", url: "https://i.postimg.cc/c4JMPd2W/IMG-4724.gif", name: "4" },
					{ id: "frame_5", url: "https://i.postimg.cc/g2XykNGB/IMG-4727.gif", name: "5" },
					{ id: "frame_6", url: "https://i.postimg.cc/y8MmJcd6/IMG-4728.gif", name: "6" },
					{ id: "frame_7", url: "https://i.postimg.cc/Lsjzj5Yt/IMG-4729.gif", name: "7" },
					{ id: "frame_8", url: "https://i.postimg.cc/bNdk33SN/IMG-4893.gif", name: "8" },
					{ id: "frame_9", url: "https://i.postimg.cc/4x9tTy1D/IMG-5563.gif", name: "9" },
					{ id: "frame_10", url: "https://i.postimg.cc/DZshzKv6/IMG-5576.gif", name: "10" },
					{ id: "frame_11", url: "https://i.postimg.cc/Fsvr71JL/IMG-5573.gif", name: "11" },
					{ id: "frame_12", url: "https://i.postimg.cc/Fz3HwLk9/IMG-5569.gif", name: "12" },
					{ id: "frame_13", url: "https://i.postimg.cc/wjH180kn/IMG-5566.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/MG6qtLYK/IMG-5565.gif", name: "14" },
					{ id: "frame_cat_ear", url: "https://i.postimg.cc/CKgDNYVb/IMG-5577.gif", name: "1" },
					{ id: "frame_ribbon", url: "https://i.postimg.cc/hj4dkrvj/IMG-5578.gif", name: "2" },
					{ id: "frame_flower", url: "https://i.postimg.cc/hj4dkrvj/IMG-5578.gif", name: "3" },
					{ id: "frame_tech", url: "https://i.postimg.cc/C5XnfpNB/IMG-5579.gif", name: "4" },
					{ id: "frame_5", url: "https://i.postimg.cc/4y7mGFgJ/IMG-5716.gif", name: "5" },
					{ id: "frame_6", url: "https://i.postimg.cc/FzM1Hgr0/IMG-5717.gif", name: "6" },
					{ id: "frame_7", url: "https://i.postimg.cc/rF4KYbjj/IMG-5720.gif", name: "7" },
					{ id: "frame_8", url: "https://i.postimg.cc/6pLTBvDG/IMG-5721.gif", name: "8" },
					{ id: "frame_9", url: "https://i.postimg.cc/VNK6Ccsf/IMG-5722.gif", name: "9" },
					{ id: "frame_10", url: "https://i.postimg.cc/wx72fhr2/IMG-5968.gif", name: "10" },
					{ id: "frame_11", url: "https://i.postimg.cc/QdrqdvdY/IMG-5969.gif", name: "11" },
					{ id: "frame_12", url: "https://i.postimg.cc/0yd0MZ6k/IMG-5971.gif", name: "12" },
					{ id: "frame_13", url: "https://i.postimg.cc/1zmcp66p/IMG-5973.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/wBw5Fvcn/IMG-5974.gif", name: "14" },
					{ id: "frame_cat_ear", url: "https://i.postimg.cc/R0pfKYvB/IMG-5976.gif", name: "1" },
					{ id: "frame_ribbon", url: "https://i.postimg.cc/9fQZ425b/IMG-5975.gif", name: "2" },
					{ id: "frame_flower", url: "https://i.postimg.cc/v8V9xXjJ/IMG-6137.gif", name: "3" },
					{ id: "frame_tech", url: "https://i.postimg.cc/WbmkXzsS/IMG-6138.gif", name: "4" },
					{ id: "frame_5", url: "https://i.postimg.cc/Dw2bDhZh/IMG-6140.gif", name: "5" },
					{ id: "frame_6", url: "https://i.postimg.cc/ZqQBCyLY/IMG-6144.gif", name: "6" },
					{ id: "frame_7", url: "https://i.postimg.cc/qRCtnMms/IMG-6145.gif", name: "7" },
					{ id: "frame_8", url: "https://i.postimg.cc/1Rwn3XVP/IMG-6146.gif", name: "8" },
					{ id: "frame_9", url: "https://i.postimg.cc/Kv51tW5H/IMG-6147.gif", name: "9" },
					{ id: "frame_10", url: "https://i.postimg.cc/nhcC21Rc/IMG-6148.gif", name: "10" },
					{ id: "frame_11", url: "https://i.postimg.cc/fTWzQRx8/IMG-6149.gif", name: "11" },
					{ id: "frame_12", url: "https://i.postimg.cc/LXyyqDbY/IMG-6294.gif", name: "12" },
					{ id: "frame_13", url: "https://i.postimg.cc/7Zgm1wRy/IMG-6295.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/5tbpnDcQ/IMG-6296.gif", name: "14" },
					{ id: "frame_cat_ear", url: "https://i.postimg.cc/YSRRV8kn/IMG-6297.gif", name: "1" },
					{ id: "frame_ribbon", url: "https://i.postimg.cc/k45sd8gn/IMG-6375.gif", name: "2" },
					{ id: "frame_flower", url: "https://i.postimg.cc/50k390X8/IMG-6376.gif", name: "3" },
					{ id: "frame_tech", url: "https://i.postimg.cc/90RBDh9K/IMG-6377.gif", name: "4" },
					{ id: "frame_5", url: "https://i.postimg.cc/cCpBYbMH/IMG-6552.gif", name: "5" },
					{ id: "frame_6", url: "https://i.postimg.cc/Pf9g2fSL/IMG-6554.gif", name: "6" },
					{ id: "frame_7", url: "https://i.postimg.cc/gkhf597g/IMG-6555.gif", name: "7" },
					{ id: "frame_8", url: "https://i.postimg.cc/g2PfbSFm/IMG-6556.gif", name: "8" },
					{ id: "frame_9", url: "https://i.postimg.cc/pLY3WfR8/IMG-6557.gif", name: "9" },
					{ id: "frame_10", url: "https://i.postimg.cc/65Cmcr7S/IMG-6559.gif", name: "10" },
					{ id: "frame_11", url: "https://i.postimg.cc/Y94XWYKd/IMG-6560.gif", name: "11" },
					{ id: "frame_12", url: "https://i.postimg.cc/ydwLXx7s/IMG-6562.gif", name: "12" },
					{ id: "frame_13", url: "https://i.postimg.cc/G3y73Fj2/IMG-6563.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/TYvkKKkc/IMG-6565.gif", name: "14" },
					{ id: "frame_cat_ear", url: "https://i.postimg.cc/GmcqjZn8/IMG-6566.gif", name: "1" },
					{ id: "frame_ribbon", url: "https://i.postimg.cc/k5Gs0K47/IMG-6567.gif", name: "2" },
					{ id: "frame_flower", url: "https://i.postimg.cc/XJy8JWdh/IMG-6568.gif", name: "3" },
					{ id: "frame_tech", url: "https://i.postimg.cc/fycfcvHf/IMG-6569.gif", name: "4" },
					{ id: "frame_5", url: "https://i.postimg.cc/J7ZxC11H/IMG-6570.gif", name: "5" },
					{ id: "frame_6", url: "https://i.postimg.cc/hPnrSHjy/IMG-4434.gif", name: "6" },
					{ id: "frame_7", url: "https://i.postimg.cc/YqxxjbLp/IMG-6572.gif", name: "7" },
					{ id: "frame_8", url: "https://i.postimg.cc/wjfcQMkZ/IMG-6573.gif", name: "8" },
					{ id: "frame_9", url: "https://i.postimg.cc/Vv8jkCYr/IMG-6574.gif", name: "9" },
					{ id: "frame_10", url: "https://i.postimg.cc/MZ77rdDy/IMG-6850.gif", name: "10" },
					{ id: "frame_11", url: "https://i.postimg.cc/T3NvqJCZ/IMG-6851.gif", name: "11" },
					{ id: "frame_12", url: "https://i.postimg.cc/28TsrxRV/IMG-6852.gif", name: "12" },
					{ id: "frame_13", url: "https://i.postimg.cc/VkV2bLNw/IMG-6853.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/gJ95NSRB/IMG-6854.gif", name: "14" },
					{ id: "frame_cat_ear", url: "https://i.postimg.cc/d1qsQsbQ/IMG-6855.gif", name: "1" },
					{ id: "frame_ribbon", url: "https://i.postimg.cc/gJNYx9pV/IMG-6856.gif", name: "2" },
					{ id: "frame_flower", url: "https://i.postimg.cc/fyPDvxJk/IMG-6860.gif", name: "3" },
					{ id: "frame_tech", url: "https://i.postimg.cc/QMDsSNxg/IMG-6861.gif", name: "4" },
					{ id: "frame_5", url: "https://i.postimg.cc/vBqsQW7X/IMG-6858.gif", name: "5" },
					{ id: "frame_6", url: "https://i.postimg.cc/Y0vwjhb7/IMG-6857.gif", name: "6" },
					{ id: "frame_7", url: "https://i.postimg.cc/90sH9Cn7/IMG-6868.gif", name: "7" },
					{ id: "frame_8", url: "https://i.postimg.cc/Y2PHZzCC/IMG-6866.gif", name: "8" },
					{ id: "frame_9", url: "https://i.postimg.cc/7Z8yYP7v/IMG-6889.gif", name: "9" },
					{ id: "frame_10", url: "https://i.postimg.cc/nryNzTXK/IMG-6915.gif", name: "10" },
					{ id: "frame_11", url: "https://i.postimg.cc/Qx5dqyJ3/IMG-6917.gif", name: "11" },
					{ id: "frame_12", url: "https://i.postimg.cc/Wbr0JSDD/IMG-5316.gif", name: "12" },
					{ id: "frame_13", url: "https://i.postimg.cc/tgR6wjBP/IMG-5570.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/d0WCKxff/IMG-6932.gif", name: "14" },
					{ id: "frame_11", url: "https://i.postimg.cc/Ss3znzk7/IMG-6934.gif", name: "11" },
					{ id: "frame_12", url: "https://i.postimg.cc/nrm9BcL8/IMG-6941.gif", name: "12" },
					{ id: "frame_13", url: "https://i.postimg.cc/ZYvd1jxf/IMG-6937.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/sDFhySn3/IMG-6936.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/43PhvxRq/IMG-6922.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/3Rb46fRZ/IMG-6923.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/PJppkbvn/IMG-6918.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/XqRZNZ9G/IMG-6916.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/RVt6sRzc/IMG-6939.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/mgGc0HbK/IMG-6926.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/P5zLh5JJ/IMG-6942.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/xCqqKGRN/IMG-6929.gif", name: "14" },
					{ id: "frame_12", url: "https://i.postimg.cc/7LSRp4hx/e7fa949b9pc84cff0dabe57defceb54c.gif", name: "12" },
					{ id: "frame_13", url: "https://i.postimg.cc/DZgMwc1H/817178fdbpf2ff7740dc98e26ab78759.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/3NffgJSZ/e09c07034ld7e62266c0a5de6a36ae62.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/vHDNGfT2/35ac7f372v588bf48d4f659077196b85.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/KvVsjjgG/3c3aa5219s18b90187ef1f54b3db7ba8.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/k5P1NHcL/55f3e31d8qbc8a02d152b07b99d31567.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/FFCTCzpy/641bad3b3udc599fdb63ca75fde427e5.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/8k7YSLjK/1689aa46aqc4b9ffc0f970e668f56537.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/J0CZSwyW/IMG-6938.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/Df1qLzDf/IMG-6927.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/CLNkrQSW/IMG-6925.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/y8p9s3Jj/IMG-6919.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/Lsr1Zd3Z/IMG-6928.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/Ssgbv41n/IMG-6876.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/SNByPrf9/IMG-7005.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/Z5nrCyS5/IMG-7006.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/mDfMXXFP/IMG-7007.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/DZrGtrqB/IMG-7008.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/ZnJNZWHZ/IMG-7009.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/RhGH0vpt/IMG-7010.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/tRzPkzRg/IMG-7012.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/wTTNGs3Q/IMG-7013.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/3JSG5Jv5/IMG-7014.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/rwDr8X1d/IMG-7015.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/DzDy2vS7/IMG-7017.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/QMVdG9x6/IMG-7016.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/mZ9hgH3J/IMG-7019.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/t4ksHGdg/IMG-7020.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/hP9JpdfT/IMG-7023.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/wTKyXVT9/IMG-7024.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/ZqjKXPSv/IMG-7025.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/gj3Tmqz5/mmexport1751030241029.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/4yCXW52F/mmexport1751030908335.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/VkXngG72/mmexport1751031208329.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/LscBkxZb/mmexport1751017556565.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/1XqzGKwJ/mmexport1751018282681.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/8kHCQwbQ/mmexport1751020645824.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/HWynLK7f/mmexport1751021724230.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/JnwFp3Kx/mmexport1751031208329.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/HLZNWkQw/mmexport1751031767634.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/vH2X6N1y/mmexport1751032231179.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/NFS4ZyvM/mmexport1751032686953.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/3RpmWc8c/mmexport1751033102811.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/L5RLr3tg/mmexport1751035976943.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/4NCPsp5d/mmexport1751034427637.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/CMv02LHm/mmexport1751034842120.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/rFnSzWGx/mmexport1751035618517.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/7YRbzN51/mmexport1751036276038.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/cJpbtPWq/mmexport1751036607799.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/HxLV5v92/mmexport1751036977582.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/D01rYy86/mmexport1751037965259.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/J4fwkTLW/mmexport1751038167142.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/xjpN4swz/IMG-7240.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/ZnzbGdxX/IMG-7239.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/DyYDmKtw/IMG-7238.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/W40f9qtd/IMG-7098.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/8PsK20jQ/IMG-7236.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/cHsTXDVz/IMG-7235.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/sXwm8Yzg/IMG-7234.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/xTk5xN49/IMG-7233.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/k5yv6QBv/IMG-7232.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/yx2m4nbs/IMG-7231.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/vZt0fFKn/IMB-r-HMBXY.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/pddJj9zN/IMG-7094.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/rmB17Qbc/IMB-f-VDf-Fc.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/VkKjzYTK/IMB-f4kk-CT.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/B6KD52vz/IMG-7096.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/9XPwWmwy/IMB-Kf7um-P.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/mrFhKBGz/IMB-e-QWBpa.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/bw4wxW2z/IMB-16r-COL.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/3x0Kx1fz/IMB-K1u-Jp-P.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/CLz0cJ0d/IMG-7116.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/fyyGgW61/IMG-7115.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/gkk7s0vD/IMG-6984.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/0NpZPgYj/IMG-6985.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/tTWKKmTN/IMG-7073.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/jS8tc9wW/IMG-7083.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/rmRVKJpD/IMG-7087.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/zvWGPjms/IMG-7090.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/YSkqDg8V/IMG-7092.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/FzqHTBng/IMG-7093.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/tTpZ6wLs/IMG-7095.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/8P5vt8sW/IMG-7097.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/wMxmCZVC/IMG-7099.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/2jxd0FGp/IMG-7100.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/B6T59xGK/IMG-7101.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/kXfcgFRN/IMG-7106.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/htZppbS4/IMG-7107.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/hPgyjtyn/IMG-7108.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/HLKvs0Kv/IMG-7109.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/wjwbnYkp/IMG-7111.gif", name: "14" },
					{ id: "frame_13", url: "https://i.postimg.cc/bJDMQVkj/IMG-7112.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/SNWBTP5S/IMG-7113.gif", name: "14" },
					{ id: "frame_14", url: "https://i.postimg.cc/jCVMQsKH/IMG-7114.gif", name: "14" },
					{ id: "frame_1", url: "https://i.postimg.cc/50W2jZGN/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mj-E4SURh-Uz-J2ZVFv-IQUAc-XVu-Z3o.gif", name: "1" },
					{ id: "frame_2", url: "https://i.postimg.cc/85gzsq3h/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mj-I4SURh-WTRLYk-Fv-IQUAc-XVu-Z3o.gif", name: "2" },
					{ id: "frame_3", url: "https://i.postimg.cc/tTG47LfS/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mj-Jj-SURh-Vmd2ZUFv-IQUAc-XVu-Z3o.gif", name: "3" },
					{ id: "frame_4", url: "https://i.postimg.cc/sXPDWTd4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mj-JNSURh-Vj-Iw-ZWdv-IQUAc-XVu-Z3o.gif", name: "4" },
					{ id: "frame_5", url: "https://i.postimg.cc/SsLN9gFG/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mj-Jz-SURh-Yj-Ru-Ymdv-IQUAc-XVu-Z3o.gif", name: "5" },
					{ id: "frame_6", url: "https://i.postimg.cc/SsLN9gb4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mj-NNSURh-Yz-FZYmdv-IQUAc-XVu-Z3o.gif", name: "6" },
					{ id: "frame_7", url: "https://i.postimg.cc/cJnJxsDg/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mjc4RURh-WDl1R3pn-IQUAc-XVu-Z3o.gif", name: "7" },
					{ id: "frame_8", url: "https://i.postimg.cc/tTG47Lfq/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mjdz-RURh-Un-Vm-SERn-IQUAc-XVu-Z3o.gif", name: "8" },
					{ id: "frame_9", url: "https://i.postimg.cc/DZ3wmtDb/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mjh-NRURh-UW9VRURn-IQUAc-XVu-Z3o.gif", name: "9" },
					{ id: "frame_10", url: "https://i.postimg.cc/76rZbpcG/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mjhj-RURh-Yml-QRHpn-IQUAc-XVu-Z3o.gif", name: "10" },
					{ id: "frame_11", url: "https://i.postimg.cc/Pxn5NBcw/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mjhz-RURh-WWgq-RHpn-IQUAc-XVu-Z3o.gif", name: "11" },
					{ id: "frame_12", url: "https://i.postimg.cc/bJ0Nnmc4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mjl-NQURh-YVVm-Rk-Nr-IQUAc-XVu-Z3o.gif", name: "12" },
					{ id: "frame_13", url: "https://i.postimg.cc/Ghg3vBVL/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk-U4RURh-Vmlv-SFNz-IQUAc-XVu-Z3o.gif", name: "13" },
					{ id: "frame_14", url: "https://i.postimg.cc/YC4rRrBS/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk-Y4RURh-Zm-Jn-RHlz-IQUAc-XVu-Z3o.gif", name: "14" },
					{ id: "frame_15", url: "https://i.postimg.cc/SxXSdSbc/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk-Y4TURh-ZDY3ZGc0IQUAc-XVu-Z3o.gif", name: "15" },
					{ id: "frame_16", url: "https://i.postimg.cc/rwdVjV2f/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk-ZNRURh-Vl-VNSFNz-IQUAc-XVu-Z3o.gif", name: "16" },
					{ id: "frame_17", url: "https://i.postimg.cc/MHWZm1zv/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk84VURh-Yk-Fjcnp-BIQUAc-XVu-Z3o.gif", name: "17" },
					{ id: "frame_18", url: "https://i.postimg.cc/pr2VJKPP/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk9j-VURh-Zkh-Dd-Wp-BIQUAc-XVu-Z3o.gif", name: "18" },
					{ id: "frame_19", url: "https://i.postimg.cc/C5FMsbwh/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk9NVURh-WW4ud-Wp-BIQUAc-XVu-Z3o.gif", name: "19" },
					{ id: "frame_20", url: "https://i.postimg.cc/QCXNJcjx/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk9z-VURh-Wmxncnp-BIQUAc-XVu-Z3o.gif", name: "20" },
					{ id: "frame_21", url: "https://i.postimg.cc/HnpW9bTb/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkc4TURh-YTBv-YVE0IQUAc-XVu-Z3o.gif", name: "21" },
					{ id: "frame_22", url: "https://i.postimg.cc/HnBYZjLX/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkd-NRURh-UXV5RHlz-IQUAc-XVu-Z3o.gif", name: "22" },
					{ id: "frame_23", url: "https://i.postimg.cc/NFpsJL02/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkd-NTURh-ZW9FZGc0IQUAc-XVu-Z3o.gif", name: "23" },
					{ id: "frame_24", url: "https://i.postimg.cc/BbMSYtvX/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkdj-TURh-VGdn-YWc0IQUAc-XVu-Z3o.gif", name: "24" },
					{ id: "frame_25", url: "https://i.postimg.cc/nr0FRMLY/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkdz-TURh-ZFBj-YUE0IQUAc-XVu-Z3o.gif", name: "25" },
					{ id: "frame_26", url: "https://i.postimg.cc/zv0zt3f6/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkh-NTURh-USpm-WFE0IQUAc-XVu-Z3o.gif", name: "26" },
					{ id: "frame_27", url: "https://i.postimg.cc/2y2kc35H/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkhj-TURh-Vm-ZNWEE0IQUAc-XVu-Z3o.gif", name: "27" },
					{ id: "frame_28", url: "https://i.postimg.cc/jqXSd3hx/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkhz-TURh-Zlh-JWFE0IQUAc-XVu-Z3o.gif", name: "28" },
					{ id: "frame_29", url: "https://i.postimg.cc/CMNxLr4b/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mklz-UURh-ZEQ3Tk-I0IQUAc-XVu-Z3o.gif", name: "29" },
					{ id: "frame_30", url: "https://i.postimg.cc/65p57VHv/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mko4QURh-ZEQ3e-EJ3IQUAc-XVu-Z3o.gif", name: "30" },
					{ id: "frame_31", url: "https://i.postimg.cc/bNwNG06T/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mko4UURh-ZDl-SS1I0IQUAc-XVu-Z3o.gif", name: "31" },
					{ id: "frame_32", url: "https://i.postimg.cc/8PzPFdKQ/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkpj-UURh-VFl-GS1I0IQUAc-XVu-Z3o.gif", name: "32" },
					{ id: "frame_33", url: "https://i.postimg.cc/tCvRF1wj/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkpz-UURh-U1Jq-S1I0IQUAc-XVu-Z3o.gif", name: "33" },
					{ id: "frame_34", url: "https://i.postimg.cc/Jz91dfR5/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-A4SURh-U0R3a-Hd-FIQUAc-XVu-Z3o.gif", name: "34" },
					{ id: "frame_35", url: "https://i.postimg.cc/cLVs5pdF/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-A4VURh-Zi5Eb1RBIQUAc-XVu-Z3o.gif", name: "35" },
					{ id: "frame_36", url: "https://i.postimg.cc/htHS3kKY/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Bj-VURh-Vl-Fxb3p-BIQUAc-XVu-Z3o.gif", name: "36" },
					{ id: "frame_37", url: "https://i.postimg.cc/YSYpcdSJ/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Bz-VURh-WXZPb2p-BIQUAc-XVu-Z3o.gif", name: "37" },
					{ id: "frame_38", url: "https://i.postimg.cc/5tLxcs0H/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-E4SURh-Wmx-SYmd-FIQUAc-XVu-Z3o.gif", name: "38" },
					{ id: "frame_39", url: "https://i.postimg.cc/1zw9xvt4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-E4VURh-Vj-Y0b-VRBIQUAc-XVu-Z3o.gif", name: "39" },
					{ id: "frame_40", url: "https://i.postimg.cc/R0KMrgFc/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Fj-SURh-VG9v-ZWd-FIQUAc-XVu-Z3o.gif", name: "40" },
					{ id: "frame_41", url: "https://i.postimg.cc/PxHdd1pP/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Fj-VURh-VWh-Sb-Gp-BIQUAc-XVu-Z3o.gif", name: "41" },
					{ id: "frame_42", url: "https://i.postimg.cc/sXz335Q4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-FNSURh-Vm-Nx-ZXd-FIQUAc-XVu-Z3o.gif", name: "42" },
					{ id: "frame_43", url: "https://i.postimg.cc/764qqSGc/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-FNVURh-VE1ub-Gp-BIQUAc-XVu-Z3o.gif", name: "43" },
					{ id: "frame_44", url: "https://i.postimg.cc/bJRprdkW/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Fz-SURh-UVB2ZVFFIQUAc-XVu-Z3o.gif", name: "44" },
					{ id: "frame_45", url: "https://i.postimg.cc/LXV25hjF/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-I4RURh-Vkw3Nl-Mw-IQUAc-XVu-Z3o.gif", name: "45" },
					{ id: "frame_46", url: "https://i.postimg.cc/ZRL4n06R/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-I4TURh-WDVFKnh-BIQUAc-XVu-Z3o.gif", name: "46" },
					{ id: "frame_47", url: "https://i.postimg.cc/Gthryrj1/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-I4VURh-Zm1u-Z1RBIQUAc-XVu-Z3o.gif", name: "47" },
					{ id: "frame_48", url: "https://i.postimg.cc/4yNZ9Z14/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Jj-RURh-UWx1OWkw-IQUAc-XVu-Z3o.gif", name: "48" },
					{ id: "frame_49", url: "https://i.postimg.cc/zvX5g5kX/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Jj-SURh-Ynd-WYmd-FIQUAc-XVu-Z3o.gif", name: "49" },
					{ id: "frame_50", url: "https://i.postimg.cc/2y8mZmxv/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Jj-TURh-U3JSKmh-BIQUAc-XVu-Z3o.gif", name: "50" },
					{ id: "frame_51", url: "https://i.postimg.cc/J04mkmQj/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Jj-VURh-ZS5sa-FRBIQUAc-XVu-Z3o.gif", name: "51" },
					{ id: "frame_52", url: "https://i.postimg.cc/vTqy7jP9/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-JNRURh-VVVs-OWkw-IQUAc-XVu-Z3o.gif", name: "52" },
					{ id: "frame_53", url: "https://i.postimg.cc/sx6zP8n9/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-JNSURh-ZFc1Yl-FFIQUAc-XVu-Z3o.gif", name: "53" },
					{ id: "frame_54", url: "https://i.postimg.cc/VvGw9T7D/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-JNTURh-VEd-QQ1JFIQUAc-XVu-Z3o.gif", name: "54" },
					{ id: "frame_55", url: "https://i.postimg.cc/yxQKh5fb/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-JNVURh-UTl2a-Wp-BIQUAc-XVu-Z3o.gif", name: "55" },
					{ id: "frame_56", url: "https://i.postimg.cc/J7PRWD1z/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Jz-VURh-YXdta-Xp-BIQUAc-XVu-Z3o.gif", name: "56" },
					{ id: "frame_57", url: "https://i.postimg.cc/J7PRWD1z/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-M4VURh-ZTZx-ZERBIQUAc-XVu-Z3o.gif", name: "57" },
					{ id: "frame_58", url: "https://i.postimg.cc/SQDmp2yn/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Nj-TURh-YWNVOHh-BIQUAc-XVu-Z3o.gif", name: "58" },
					{ id: "frame_59", url: "https://i.postimg.cc/h4pKqzS8/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-NNRURh-WWJ1Nl-Mw-IQUAc-XVu-Z3o.gif", name: "59" },
					{ id: "frame_60", url: "https://i.postimg.cc/vHTb8YBt/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-NNVURh-Zko2Z0RBIQUAc-XVu-Z3o.gif", name: "60" },
					{ id: "frame_61", url: "https://i.postimg.cc/4Nys4fdF/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Nz-TURh-ZXo4OFJBIQUAc-XVu-Z3o.gif", name: "61" },
					{ id: "frame_62", url: "https://i.postimg.cc/CL5SMh5M/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Nz-VURh-Zld-DZGp-BIQUAc-XVu-Z3o.gif", name: "62" },
					{ id: "frame_63", url: "https://i.postimg.cc/SNPqJBYS/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Q4VURh-Y2Fa-WFRBIQUAc-XVu-Z3o.gif", name: "63" },
					{ id: "frame_64", url: "https://i.postimg.cc/DyNF894W/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-U4VURh-Uk8y-VURBIQUAc-XVu-Z3o.gif", name: "64" },
					{ id: "frame_65", url: "https://i.postimg.cc/JzB8JpjD/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Vj-VURh-YS5NWERBIQUAc-XVu-Z3o.gif", name: "65" },
					{ id: "frame_66", url: "https://i.postimg.cc/dVTFd5GC/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-VNVURh-Wl-Bi-WERBIQUAc-XVu-Z3o.gif", name: "66" },
					{ id: "frame_67", url: "https://i.postimg.cc/t4VbPBFS/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Y4VURh-ZWdl-Ul-RBIQUAc-XVu-Z3o.gif", name: "67" },
					{ id: "frame_68", url: "https://i.postimg.cc/k53myWyT/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-ZNVURh-Wjg3VURBIQUAc-XVu-Z3o.gif", name: "68" },
					{ id: "frame_69", url: "https://i.postimg.cc/zfZrkTk2/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Zz-VURh-Zm5GUk-RBIQUAc-XVu-Z3o.gif", name: "69" },
					{ id: "frame_70", url: "https://i.postimg.cc/xdM0r6Cn/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mlc4QURh-Vm-ZCNFI4IQUAc-XVu-Z3o.gif", name: "70" },
					{ id: "frame_71", url: "https://i.postimg.cc/9fZW3LMW/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mldz-QURh-VDUq-NGg4IQUAc-XVu-Z3o.gif", name: "71" },
					{ id: "frame_72", url: "https://i.postimg.cc/3wXHfWSw/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm-I4SURh-Y09JSWd-RIQUAc-XVu-Z3o.gif", name: "72" },
					{ id: "frame_73", url: "https://i.postimg.cc/LstMQhC5/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm-Jj-SURh-VU9VSXd-RIQUAc-XVu-Z3o.gif", name: "73" },
					{ id: "frame_74", url: "https://i.postimg.cc/7L3ytbs5/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm-JNSURh-Y2Fu-TFFRIQUAc-XVu-Z3o.gif", name: "74" },
					{ id: "frame_75", url: "https://i.postimg.cc/8CRVXsKr/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm-Jz-SURh-YWVi-SWd-RIQUAc-XVu-Z3o.gif", name: "75" },
					{ id: "frame_76", url: "https://i.postimg.cc/63Bxkwgr/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm-Nj-SURh-U2h-XRmd-RIQUAc-XVu-Z3o.gif", name: "76" },
					{ id: "frame_77", url: "https://i.postimg.cc/C1wp3YX4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm-Nz-SURh-VGYy-Rmd-RIQUAc-XVu-Z3o.gif", name: "77" },
					{ id: "frame_78", url: "https://i.postimg.cc/MG2SY1D2/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm04UURh-VVht-Vk-NZIQUAc-XVu-Z3o.gif", name: "78" },
					{ id: "frame_79", url: "https://i.postimg.cc/Bv90C2Cy/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm1NUURh-WHI1WUNZIQUAc-XVu-Z3o.gif", name: "79" },
					{ id: "frame_80", url: "https://i.postimg.cc/k53myWyL/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm1z-UURh-VWI1V0NZIQUAc-XVu-Z3o.gif", name: "80" },
					{ id: "frame_81", url: "https://i.postimg.cc/CKTg4bNV/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm5j-UURh-YXBl-VGl-ZIQUAc-XVu-Z3o.gif", name: "81" },
					{ id: "frame_82", url: "https://i.postimg.cc/QMG3qcb8/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm5NUURh-VDd-FVUNZIQUAc-XVu-Z3o.gif", name: "82" },
					{ id: "frame_83", url: "https://i.postimg.cc/JhVLQjqn/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm5z-UURh-VUpz-Uml-ZIQUAc-XVu-Z3o.gif", name: "83" },
					{ id: "frame_84", url: "https://i.postimg.cc/JhNWYt68/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm84UURh-Vm1XTFNZIQUAc-XVu-Z3o.gif", name: "84" },
					{ id: "frame_85", url: "https://i.postimg.cc/GpwCjvQ9/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm9j-UURh-Um-JJT0NZIQUAc-XVu-Z3o.gif", name: "85" },
					{ id: "frame_86", url: "https://i.postimg.cc/zfC123tr/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm9z-UURh-Ylh0Tl-NZIQUAc-XVu-Z3o.gif", name: "86" },
					{ id: "frame_87", url: "https://i.postimg.cc/HLwCvjZp/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmg4TURh-Y2s1NUJRIQUAc-XVu-Z3o.gif", name: "87" },
					{ id: "frame_88", url: "https://i.postimg.cc/R07zpqsc/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmk4TURh-VENz-Ml-JRIQUAc-XVu-Z3o.gif", name: "88" },
					{ id: "frame_89", url: "https://i.postimg.cc/jjHr3Cgh/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mml-NTURh-Wk-Q0NGh-RIQUAc-XVu-Z3o.gif", name: "89" },
					{ id: "frame_90", url: "https://i.postimg.cc/q7sdDgbX/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmlj-TURh-Zjh-MMl-JRIQUAc-XVu-Z3o.gif", name: "90" },
					{ id: "frame_91", url: "https://i.postimg.cc/1ty1kP2D/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmlz-RURh-VFhzd3p-JIQUAc-XVu-Z3o.gif", name: "91" },
					{ id: "frame_92", url: "https://i.postimg.cc/wv9YCHZ4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmo4UURh-WVVya0NZIQUAc-XVu-Z3o.gif", name: "92" },
					{ id: "frame_93", url: "https://i.postimg.cc/C1wp3Y9V/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmp-NRURh-Ulkud-Gp-JIQUAc-XVu-Z3o.gif", name: "93" },
					{ id: "frame_94", url: "https://i.postimg.cc/xC9VwYh4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmpj-RURh-Y3Fpdnp-JIQUAc-XVu-Z3o.gif", name: "94" },
					{ id: "frame_95", url: "https://i.postimg.cc/4dXRDZjC/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmpj-UURh-WVZJbl-NZIQUAc-XVu-Z3o.gif", name: "95" },
					{ id: "frame_96", url: "https://i.postimg.cc/LXvFRwFb/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmpz-RURh-WTZ6c3p-JIQUAc-XVu-Z3o.gif", name: "96" },
					{ id: "frame_97", url: "https://i.postimg.cc/MTtJxNJN/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmpz-UURh-Uyoqb-Wl-ZIQUAc-XVu-Z3o.gif", name: "97" },
					{ id: "frame_98", url: "https://i.postimg.cc/MTtJxN88/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mms4RURh-WGl-FYnp-RIQUAc-XVu-Z3o.gif", name: "98" },
					{ id: "frame_99", url: "https://i.postimg.cc/V64P1pcz/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mms4UURh-ZGFYZ3l-ZIQUAc-XVu-Z3o.gif", name: "99" },
					{ id: "frame_100", url: "https://i.postimg.cc/fL5QZpht/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmt-NUURh-Uzkyanl-ZIQUAc-XVu-Z3o.gif", name: "100" },
					{ id: "frame_101", url: "https://i.postimg.cc/9M1HVKjW/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmtj-RURh-Wn-Nab-Xp-JIQUAc-XVu-Z3o.gif", name: "101" },
					{ id: "frame_102", url: "https://i.postimg.cc/Y98BkZw9/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmtj-UURh-V21oak-NZIQUAc-XVu-Z3o.gif", name: "102" },
					{ id: "frame_103", url: "https://i.postimg.cc/G2znrV1s/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmw4UURh-U1da-ZENZIQUAc-XVu-Z3o.gif", name: "103" },
					{ id: "frame_104", url: "https://i.postimg.cc/tJTQgkXs/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmx-NUURh-Vj-NBZ0NZIQUAc-XVu-Z3o.gif", name: "104" },
					{ id: "frame_105", url: "https://i.postimg.cc/MHT2G5WT/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmxj-UURh-Zl-NYZFNZIQUAc-XVu-Z3o.gif", name: "105" },
					{ id: "frame_106", url: "https://i.postimg.cc/RhF50dMJ/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmxz-UURh-Zk-NIZFNZIQUAc-XVu-Z3o.gif", name: "106" },
					{ id: "frame_107", url: "https://i.postimg.cc/2y6R5GzZ/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-A4UURh-U3JYTml-ZIQUAc-XVu-Z3o.gif", name: "107" },
					{ id: "frame_108", url: "https://i.postimg.cc/SRsFKdyC/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-Bj-UURh-VDcq-S1NZIQUAc-XVu-Z3o.gif", name: "108" },
					{ id: "frame_109", url: "https://i.postimg.cc/D0Zkz62q/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-Bz-UURh-Ynha-SVNZIQUAc-XVu-Z3o.gif", name: "109" },
					{ id: "frame_110", url: "https://i.postimg.cc/5y0dtgxp/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-Fj-UURh-Um-FBSHl-ZIQUAc-XVu-Z3o.gif", name: "110" },
					{ id: "frame_111", url: "https://i.postimg.cc/yxd4NjVf/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-FNUURh-ZEV5SUNZIQUAc-XVu-Z3o.gif", name: "111" },
					{ id: "frame_112", url: "https://i.postimg.cc/zvBZf7J2/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-Fz-UURh-Ym-Zq-RXl-ZIQUAc-XVu-Z3o.gif", name: "112" },
					{ id: "frame_113", url: "https://i.postimg.cc/rsP6R4mS/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-I4SURh-WXNMSGdn-IQUAc-XVu-Z3o.gif", name: "113" },
					{ id: "frame_114", url: "https://i.postimg.cc/x84rNmC3/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-Jj-SURh-ZWps-UHdn-IQUAc-XVu-Z3o.gif", name: "114" },
					{ id: "frame_115", url: "https://i.postimg.cc/1XjxVFtj/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-JNSURh-ZVU3U3dn-IQUAc-XVu-Z3o.gif", name: "115" },
					{ id: "frame_116", url: "https://i.postimg.cc/nrP89mzW/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-JNUURh-WElp-RXl-ZIQUAc-XVu-Z3o.gif", name: "116" },
					{ id: "frame_117", url: "https://i.postimg.cc/5tCt4xPt/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-M4SURh-VUt-UM3dr-IQUAc-XVu-Z3o.gif", name: "117" },
					{ id: "frame_118", url: "https://i.postimg.cc/6QvQW9H7/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-Nj-SURh-ZTZPTk-Fn-IQUAc-XVu-Z3o.gif", name: "118" },
				];

				// ▲▲▲ 粘贴结束 ▲▲▲
			});

			// ▼▼▼ 第十四部分：三次点击下载NAI图片功能（完整代码） ▼▼▼
			// ========================================
			// 🖼️ NAI图片三击下载功能（非入侵式）
			// ========================================
			// 功能：为所有NAI图片（realimag-image、naiimag-image）添加三击下载功能
			// 适用场景：群聊、私聊、动态、测试弹窗等所有显示NAI图片的地方
			// 实现方式：事件委托，不修改任何现有代码
			// 触发方式：在图片上快速点击三次
			// ========================================

			(function () {
				"use strict";

				// 下载图片的核心函数
				function downloadImage(imageSrc, filename) {
					try {
						// 创建一个隐藏的下载链接
						const link = document.createElement("a");
						link.href = imageSrc;
						link.download = filename;
						link.style.display = "none";

						document.body.appendChild(link);
						link.click(); // 触发下载

						// 短暂延迟后移除链接
						setTimeout(() => {
							document.body.removeChild(link);
						}, 100);

						console.log("✅ [NAI下载] 开始下载图片:", filename);

						// 显示下载提示
						showDownloadToast();
					} catch (error) {
						console.error("❌ [NAI下载] 下载失败:", error);
						showDownloadToast("下载失败，请重试", "error");
					}
				}

				// 显示下载提示（临时Toast）
				function showDownloadToast(message = "📥 图片下载中...", type = "success") {
					const toast = document.createElement("div");
					toast.textContent = message;
					toast.style.cssText = `
                        position: fixed;
                        bottom: 20px;
                        right: 20px;
                        background: ${type === "success" ? "#4CAF50" : "#f44336"};
                        color: white;
                        padding: 12px 24px;
                        border-radius: 8px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                        z-index: 10000;
                        font-size: 14px;
                        pointer-events: none;
                        opacity: 0;
                        transform: translateY(20px);
                        transition: all 0.3s ease;
                    `;

					document.body.appendChild(toast);

					// 动画进入
					setTimeout(() => {
						toast.style.opacity = "1";
						toast.style.transform = "translateY(0)";
					}, 10);

					// 2秒后淡出并移除
					setTimeout(() => {
						toast.style.opacity = "0";
						toast.style.transform = "translateY(-20px)";
						setTimeout(() => {
							toast.remove();
						}, 300);
					}, 2000);
				}

				// 生成智能文件名
				function generateFilename(imgElement) {
					// 尝试从title属性获取prompt（用于文件名）
					const title = imgElement.getAttribute("title") || imgElement.getAttribute("alt") || "";

					// 清理title，提取前30个有效字符
					let cleanTitle = title
						.replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g, "_") // 保留中英文字母数字和空格
						.replace(/\s+/g, "_") // 空格转下划线
						.substring(0, 30);

					if (!cleanTitle) {
						cleanTitle = "NAI_Image";
					}

					// 添加时间戳（精确到秒）
					const timestamp = new Date().toISOString().replace(/[-:]/g, "").replace("T", "_").split(".")[0]; // 格式：20250124_123045

					// 生成文件名
					return `${cleanTitle}_${timestamp}.png`;
				}

				// 为图片添加双击时的视觉反馈
				function addVisualFeedback(imgElement) {
					const originalTransform = imgElement.style.transform || "";
					const originalTransition = imgElement.style.transition || "";

					// 添加缩放动画
					imgElement.style.transition = "transform 0.15s ease";
					imgElement.style.transform = "scale(0.95)";

					setTimeout(() => {
						imgElement.style.transform = originalTransform;
						setTimeout(() => {
							imgElement.style.transition = originalTransition;
						}, 150);
					}, 150);
				}

				// 三击检测相关变量
				let clickCount = 0;
				let clickTimer = null;
				let lastClickedElement = null;

				// 全局事件监听器（事件委托 - 三击触发）
				document.addEventListener(
					"click",
					function (e) {
						const target = e.target;

						// 检查是否是NAI图片（realimag-image 或 naiimag-image）
						if (target.tagName === "IMG" && (target.classList.contains("realimag-image") || target.classList.contains("naiimag-image"))) {
							// 如果点击的是同一个元素，增加计数
							if (target === lastClickedElement) {
								clickCount++;
							} else {
								// 点击了不同的元素，重置计数
								clickCount = 1;
								lastClickedElement = target;
							}

							// 清除之前的定时器
							if (clickTimer) {
								clearTimeout(clickTimer);
							}

							// 如果达到三击
							if (clickCount === 3) {
								// 重置计数
								clickCount = 0;
								lastClickedElement = null;

								// 阻止默认行为和事件冒泡
								e.preventDefault();
								e.stopPropagation();

								console.log("🖼️ [NAI下载] 检测到三击NAI图片");

								// 添加视觉反馈
								addVisualFeedback(target);

								// 获取图片源（可能是base64或URL）
								const imageSrc = target.src;

								if (!imageSrc || imageSrc === "about:blank") {
									console.warn("⚠️ [NAI下载] 图片源为空，无法下载");
									showDownloadToast("图片加载中，请稍后重试", "error");
									return;
								}

								// 生成文件名
								const filename = generateFilename(target);

								// 触发下载
								downloadImage(imageSrc, filename);
							} else {
								// 设置定时器，500ms后重置计数（如果用户停止点击）
								clickTimer = setTimeout(() => {
									clickCount = 0;
									lastClickedElement = null;
								}, 500);
							}
						}
					},
					true
				); // 使用捕获阶段，确保优先处理

				console.log("✅ [NAI下载] 三击下载功能已初始化");
				console.log("💡 [NAI下载] 提示：三击任意NAI图片即可下载");
			})();
		</script>

		<input type="file" id="character-card-input" accept=".png, .json" style="display: none" />
		<input type="file" id="world-book-import-input" accept=".json, .jsonl" style="display: none" />
		<input type="file" id="ludo-qbank-import-input" accept=".json" hidden />
		<input type="file" id="inner-voice-bg-input" accept="image/*" hidden />
	</body>
</html>
